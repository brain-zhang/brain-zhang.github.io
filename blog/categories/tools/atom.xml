<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2020-11-19T16:04:44+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Sort by Length of String Followed by Alphabetical Order]]></title>
    <link href="https://happy123.me/blog/2020/08/17/how-to-sort-by-length-of-string-followed-by-alphabetical-order/"/>
    <updated>2020-08-17T08:34:52+08:00</updated>
    <id>https://happy123.me/blog/2020/08/17/how-to-sort-by-length-of-string-followed-by-alphabetical-order</id>
    <content type="html"><![CDATA[<p>shell中，多行文本，先按照字母长度排序，相同长度再按照字母序排列；</p>

<p>做了很多次，隔几天就忘，让人绝望：</p>

<p><code>
cat /tmp/xxx.txt|sort -u | awk '{print length($0), $0}'  | sort -k2,2n -k1,1n -k3,3 |cut -d" " -f2-|less
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xargs Sh -c Skipping the First Argument]]></title>
    <link href="https://happy123.me/blog/2020/08/12/xargs-sh-c-skipping-the-first-argument/"/>
    <updated>2020-08-12T16:46:27+08:00</updated>
    <id>https://happy123.me/blog/2020/08/12/xargs-sh-c-skipping-the-first-argument</id>
    <content type="html"><![CDATA[<p>其实这个问题已经见过很多次了，但是知其然不知其所以然；今天偶尔在stackoverflow上看到了，记录一下；</p>

<h4 id="shellarg1-arg2">shell中的arg1, arg2…</h4>

<p>在bash shell中，<code>$1</code>, <code>$2</code>代表arg1, arg2，比如</p>

<p>```
# echo hello world|xargs echo $1 $2</p>

<p>hello world
```</p>

<!-- more -->

<p><code>$0</code> 代表执行环境，如果是一个执行脚本的话，<code>$0</code> 代表其脚本名；比如下面这个脚本hello.sh:</p>

<p>```
#!/bin/bash</p>

<p>echo $0
echo $1
echo $2
```</p>

<p>执行:</p>

<p>```
# ./hello.sh arg1 arg2</p>

<p>```
会输出</p>

<p><code>
./hello.sh
arg1
arg2
</code></p>

<h4 id="xargs-sh--c-arg">xargs 调用sh -c 中的arg</h4>

<p>但是使用<code>xargs sh -c</code>时会出现一个比较疑惑的情况，比如执行:</p>

<p>```
# echo hello world|xargs sh -c ‘echo $1 $2’</p>

<p>world
```</p>

<p>此时<code>$1</code>代表world，<code>$2</code>已经没有值了；而执行</p>

<p>```
# echo hello world|xargs sh -c ‘echo $0 $1’</p>

<p>hello world
```</p>

<p>反而得到了正确结果；</p>

<h4 id="why">why</h4>

<p>之前我一直认为<code>xargs sh -c</code>调用的时候吃掉了<code>$0</code>，不求甚解；偶尔读了一下sh的手册才发现玄机:</p>

<blockquote>
  <p>From the documentation for the -c option:</p>
</blockquote>

<blockquote>
  <p>Read commands from the command_string operand. Set the value of special parameter 0 (see Special Parameters) from the value of the command_name operand and the positional parameters ($1, $2, and so on) in sequence from the remaining argument operands.</p>
</blockquote>

<p>就是说在上面这条命令中，其实是没有找到要执行的命令，或者说要执行的命令为空，而hello world作为<code>$1</code>, <code>$2</code>传给一个空命令了；</p>

<p>后面追加一个dummy的命令会看的更清楚:</p>

<p>```
# echo hello world|xargs sh -c ‘echo $1 $2’ _</p>

<p>hello world
```</p>

<p>后面我加了一条下划线作为xargs的dummy command，这样<code>$1</code>, <code>$2</code>就恢复正常了；</p>

<h4 id="section">总结</h4>

<p>虽然这是一个啥用也没有的Magic Topic，但是搞明白之后还是挺有意思的，娱乐用；</p>

<p>另外隐隐约约觉得这里面隐含着一些安全方面的问题，暂时只是一种感觉，将来需要留意有没有这方面的hack手段;</p>

<h4 id="section-1">引用</h4>

<p>https://stackoverflow.com/questions/41043163/xargs-sh-c-skipping-the-first-argument</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSL环境备份恢复]]></title>
    <link href="https://happy123.me/blog/2019/11/18/wslhuan-jing-bei-fen-hui-fu/"/>
    <updated>2019-11-18T11:04:27+08:00</updated>
    <id>https://happy123.me/blog/2019/11/18/wslhuan-jing-bei-fen-hui-fu</id>
    <content type="html"><![CDATA[<p>WSL环境是可以单独备份还原的，有个工具名为LxRunOffline:</p>

<p>https://github.com/DDoSolitary/LxRunOffline</p>

<p>release版本下载下来之后直接使用就可以；记录一下操作命令:</p>

<!-- more -->

<h4 id="wsl">备份wsl</h4>

<p><code>
LxRunOffline.exe export -n Ubuntu-18.04 -f ubuntu18.04.backup.tar.gz
</code></p>

<p>-n ：wsl的别名，就是之前用list查看的其中一个</p>

<p>-f ：备份的路径，我这直接备份到当前路径backup.tar.gz</p>

<h4 id="wsl-1">还原wsl</h4>

<p><code>
LxRunOffline.exe install -n Ubuntu-18.04 -d C:\wsl -f D:\temp\ubuntu18.04.backup.tar.gz
</code></p>

<p>-n ：起个名字</p>

<p>-d ：wsl安装目录</p>

<p>-f ：备份文件目录</p>

<h4 id="wsl-2">删除WSL环境</h4>

<p>可以直接用wsl原生的命令：wslconfig</p>

<p><code>
wslconfig /u Ubuntu-18.04
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSL权限管理]]></title>
    <link href="https://happy123.me/blog/2019/11/18/wslquan-xian-guan-li/"/>
    <updated>2019-11-18T10:45:54+08:00</updated>
    <id>https://happy123.me/blog/2019/11/18/wslquan-xian-guan-li</id>
    <content type="html"><![CDATA[<p>重装系统，又折腾了一遍WSL环境，记录一下:</p>

<p>WSL (Win­dows Sub­sys­tem for Linux) 通过 /mnt 目录下的 c、d、e 等目录可分别访问本地的 C、D、E 等盘，虽然可以直接访问 Win­dows 下的文件内容，但输入 ls -al 查看文件你会发现文件权限全都是 777。这会导致一些问题出现，比如 Git会保留这些文件的执行权限，如果你之前在 Win­dows 下使用过 Git Bash ，那么在 WSL 中使用 <code>git status</code>查看本地仓库的文件状态时你会发现它们全部被标记成了 modified。</p>

<!-- more -->

<h3 id="section">分析问题</h3>

<p>首先要了解 WSL 中的两种文件系统：</p>

<h4 id="volfs">VolFs</h4>
<p>着力于在 Win­dows 文件系统上提供完整的 Linux 文件系统特性，通过各种手段实现了对 In­odes、Di­rec­tory en­tries、File ob­jects、File de­scrip­tors、Spe­cial file types 的支持。比如为了支持 Win­dows 上没有的 In­odes，VolFs 会把文件权限等信息保存在文件的 NTFS Ex­tended At­trib­utes 中。</p>

<p>WSL 中的 / 使用的就是 VolFs 文件系统。</p>

<h4 id="drvfs">DrvFs</h4>
<p>着力于提供与 Win­dows 文件系统的互操作性。与 VolFs 不同，为了提供最大的互操作性，DrvFs 不会在文件的 NTFS Ex­tended At­trib­utes 中储存附加信息，而是从 Win­dows 的文件权限（Ac­cess Con­trol Lists，就是你右键文件 &gt; 属性 &gt; 安全选项卡中的那些权限配置）推断出该文件对应的的 Linux 文件权限。</p>

<p>所有 Win­dows 盘符挂载至 WSL 下的 /mnt 时都是使用的 DrvFs 文件系统。</p>

<p>简单来说就是 WSL 对 / 目录下的文件拥有完整的控制权，而 /mnt 目录中的文件无法被 WSL 完全控制（可修改数据，无法真实的修改权限）。WSL 对 /mnt 目录中权限的修改不会直接记录到文件本身，而在 Win­dows 下对文件权限的修改直接可作用到 WSL 。关于权限在<a href="https://p3terx.com/go/aHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL2NvbW1hbmRsaW5lL2NobW9kLWNob3duLXdzbC1pbXByb3ZlbWVudHMv">微软开发者博客中</a>有更详细的说明。</p>

<h3 id="section-1">解决方案</h3>

<p>这只是让文件在 WSL 中的权限看起来正常（目录 755，文件 644），实际并不会作用到 Win­dows 文件系统下的文件本身。</p>

<p>在 /etc/wsl.conf 中添加以下配置：</p>

<p><code>
[automount]
enabled = true
root = /mnt/
options = "metadata,umask=22,fmask=111"
mountFsTab = true
</code></p>

<p>上面的方法对所有盘符都有效，如果你想在 WSL 中调用 Win­dows 下的应用程序（比如 explorer.exe . 调用资源管理器打开当前路径）就需要对 C 盘进行单独设置，否则会提示没有权限。首先确认 wsl.conf 中的 mountFsTab 没有被设置为 false，然后编辑 /etc/fstab，添加如下内容：</p>

<p><code>
C:\ /mnt/c drvfs rw,noatime,uid=1000,gid=1000,metadata,umask=22,fmask=11 0 0
</code></p>

<p>此时执行<code>mkdir</code>等命令的时候，会发现新建的目录权限依然是 777。</p>

<p>目前民间解决方案是在.profile、.bashrc、.zshrc 或者其他 shell 配置文件中添加如下命令，重新设置 umask</p>

<p><code>
[filesystem]
umask = 022
</code></p>

<p>全部设置完成之后，最好重启一遍Windows系统。</p>

<h4 id="section-2">参考:</h4>

<p>https://segmentfault.com/a/1190000016677670</p>

<p>https://p3terx.com/archives/problems-and-solutions-encountered-in-wsl-use-2.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Should You Do if Windows 10 Freezes Randomly]]></title>
    <link href="https://happy123.me/blog/2019/11/13/what-should-you-do-if-windows-10-freezes-randomly/"/>
    <updated>2019-11-13T11:45:32+08:00</updated>
    <id>https://happy123.me/blog/2019/11/13/what-should-you-do-if-windows-10-freezes-randomly</id>
    <content type="html"><![CDATA[<p>是的，作为一名码农，日常最主要的工作就是修电脑；</p>

<p>有一台装Win10的Thinkpad T440 笔记本会随机冻结，表现就是所有操作没有反应，鼠标键盘没有响应，画面不动，然后等待1分钟后自我恢复； 每天随机发生&gt;5次；</p>

<!-- more -->

<p>在Google了N多<code>What Should You Do If Windows 10 Freezes Randomly</code>的帖子之后，发现有这个问题的人可以组成一个军团，可谓是苦大仇深；</p>

<p>至少这下面所有的方法我都试了一遍：</p>

<p>https://www.partitionwizard.com/partitionmagic/win10-freezes-randomly.html</p>

<p>最后无奈之下挂载winGDB，是的，就是这么无聊，追到了Chrome里面；</p>

<p>我发现，只要关闭Chrome的 “设置-&gt;高级-&gt;使用硬件加速模式”，问题概率就会大大降低；</p>

<p>这是什么原理，一番探究后，我发现这台笔记本是自动切换核显和独立显卡的；而Intel核显有个选项： “Intel Graphics Control Panel -&gt; Energy management -&gt; Panel Self Refresh”关闭之后就OK了；</p>

<p>好吧，归根到底还是驱动的问题；Intel的这个显卡其实官方没有支持Win10的驱动，这是Win10自己瞎支持的，出现问题再所难免；</p>

<p>以后遇到Win10冻结的情况，你的检查清单上还需要多加两项：</p>

<ol>
  <li>
    <p>Chrome的硬件加速关闭试一试</p>
  </li>
  <li>
    <p>如果有Intel的核显，关闭<code>Panel Self Refresh</code>试一试</p>
  </li>
</ol>

<blockquote>
  <p>Apparently, disabling Panel Self Refresh (PSR) in the Intel HD Graphics Control Panel application fixed the issue.
On Lenovo notebook right click on desktop -&gt; Intel Graphics Control Panel -&gt; Energy management -&gt; Panel Self Refresh -&gt; set to Disabled.
I also set the display to max performance, but I don’t think this is relevant.
Once disabled, I’ve no more experienced any freeze for several days.</p>
</blockquote>

<p>参考：</p>

<p>https://forums.lenovo.com/t5/ThinkPad-X-Series-Laptops/X270-generic-freeze/td-p/3927475/page/5</p>
]]></content>
  </entry>
  
</feed>
