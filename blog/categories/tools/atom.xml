<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2020-04-25T19:40:03+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WSL环境备份恢复]]></title>
    <link href="https://happy123.me/blog/2019/11/18/wslhuan-jing-bei-fen-hui-fu/"/>
    <updated>2019-11-18T11:04:27+08:00</updated>
    <id>https://happy123.me/blog/2019/11/18/wslhuan-jing-bei-fen-hui-fu</id>
    <content type="html"><![CDATA[<p>WSL环境是可以单独备份还原的，有个工具名为LxRunOffline:</p>

<p>https://github.com/DDoSolitary/LxRunOffline</p>

<p>release版本下载下来之后直接使用就可以；记录一下操作命令:</p>

<!-- more -->

<h4 id="wsl">备份wsl</h4>

<p><code>
LxRunOffline.exe export -n Ubuntu-18.04 -f ubuntu18.04.backup.tar.gz
</code></p>

<p>-n ：wsl的别名，就是之前用list查看的其中一个</p>

<p>-f ：备份的路径，我这直接备份到当前路径backup.tar.gz</p>

<h4 id="wsl-1">还原wsl</h4>

<p><code>
LxRunOffline.exe install -n Ubuntu-18.04 -d C:\wsl -f D:\temp\ubuntu18.04.backup.tar.gz
</code></p>

<p>-n ：起个名字</p>

<p>-d ：wsl安装目录</p>

<p>-f ：备份文件目录</p>

<h4 id="wsl-2">删除WSL环境</h4>

<p>可以直接用wsl原生的命令：wslconfig</p>

<p><code>
wslconfig /u Ubuntu-18.04
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSL权限管理]]></title>
    <link href="https://happy123.me/blog/2019/11/18/wslquan-xian-guan-li/"/>
    <updated>2019-11-18T10:45:54+08:00</updated>
    <id>https://happy123.me/blog/2019/11/18/wslquan-xian-guan-li</id>
    <content type="html"><![CDATA[<p>重装系统，又折腾了一遍WSL环境，记录一下:</p>

<p>WSL (Win­dows Sub­sys­tem for Linux) 通过 /mnt 目录下的 c、d、e 等目录可分别访问本地的 C、D、E 等盘，虽然可以直接访问 Win­dows 下的文件内容，但输入 ls -al 查看文件你会发现文件权限全都是 777。这会导致一些问题出现，比如 Git会保留这些文件的执行权限，如果你之前在 Win­dows 下使用过 Git Bash ，那么在 WSL 中使用 <code>git status</code>查看本地仓库的文件状态时你会发现它们全部被标记成了 modified。</p>

<!-- more -->

<h3 id="section">分析问题</h3>

<p>首先要了解 WSL 中的两种文件系统：</p>

<h4 id="volfs">VolFs</h4>
<p>着力于在 Win­dows 文件系统上提供完整的 Linux 文件系统特性，通过各种手段实现了对 In­odes、Di­rec­tory en­tries、File ob­jects、File de­scrip­tors、Spe­cial file types 的支持。比如为了支持 Win­dows 上没有的 In­odes，VolFs 会把文件权限等信息保存在文件的 NTFS Ex­tended At­trib­utes 中。</p>

<p>WSL 中的 / 使用的就是 VolFs 文件系统。</p>

<h4 id="drvfs">DrvFs</h4>
<p>着力于提供与 Win­dows 文件系统的互操作性。与 VolFs 不同，为了提供最大的互操作性，DrvFs 不会在文件的 NTFS Ex­tended At­trib­utes 中储存附加信息，而是从 Win­dows 的文件权限（Ac­cess Con­trol Lists，就是你右键文件 &gt; 属性 &gt; 安全选项卡中的那些权限配置）推断出该文件对应的的 Linux 文件权限。</p>

<p>所有 Win­dows 盘符挂载至 WSL 下的 /mnt 时都是使用的 DrvFs 文件系统。</p>

<p>简单来说就是 WSL 对 / 目录下的文件拥有完整的控制权，而 /mnt 目录中的文件无法被 WSL 完全控制（可修改数据，无法真实的修改权限）。WSL 对 /mnt 目录中权限的修改不会直接记录到文件本身，而在 Win­dows 下对文件权限的修改直接可作用到 WSL 。关于权限在<a href="https://p3terx.com/go/aHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL2NvbW1hbmRsaW5lL2NobW9kLWNob3duLXdzbC1pbXByb3ZlbWVudHMv">微软开发者博客中</a>有更详细的说明。</p>

<h3 id="section-1">解决方案</h3>

<p>这只是让文件在 WSL 中的权限看起来正常（目录 755，文件 644），实际并不会作用到 Win­dows 文件系统下的文件本身。</p>

<p>在 /etc/wsl.conf 中添加以下配置：</p>

<p><code>
[automount]
enabled = true
root = /mnt/
options = "metadata,umask=22,fmask=111"
mountFsTab = true
</code></p>

<p>上面的方法对所有盘符都有效，如果你想在 WSL 中调用 Win­dows 下的应用程序（比如 explorer.exe . 调用资源管理器打开当前路径）就需要对 C 盘进行单独设置，否则会提示没有权限。首先确认 wsl.conf 中的 mountFsTab 没有被设置为 false，然后编辑 /etc/fstab，添加如下内容：</p>

<p><code>
C:\ /mnt/c drvfs rw,noatime,uid=1000,gid=1000,metadata,umask=22,fmask=11 0 0
</code></p>

<p>此时执行<code>mkdir</code>等命令的时候，会发现新建的目录权限依然是 777。</p>

<p>目前民间解决方案是在.profile、.bashrc、.zshrc 或者其他 shell 配置文件中添加如下命令，重新设置 umask</p>

<p><code>
[filesystem]
umask = 022
</code></p>

<p>全部设置完成之后，最好重启一遍Windows系统。</p>

<h4 id="section-2">参考:</h4>

<p>https://segmentfault.com/a/1190000016677670</p>

<p>https://p3terx.com/archives/problems-and-solutions-encountered-in-wsl-use-2.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Should You Do if Windows 10 Freezes Randomly]]></title>
    <link href="https://happy123.me/blog/2019/11/13/what-should-you-do-if-windows-10-freezes-randomly/"/>
    <updated>2019-11-13T11:45:32+08:00</updated>
    <id>https://happy123.me/blog/2019/11/13/what-should-you-do-if-windows-10-freezes-randomly</id>
    <content type="html"><![CDATA[<p>是的，作为一名码农，日常最主要的工作就是修电脑；</p>

<p>有一台装Win10的Thinkpad T440 笔记本会随机冻结，表现就是所有操作没有反应，鼠标键盘没有响应，画面不动，然后等待1分钟后自我恢复； 每天随机发生&gt;5次；</p>

<!-- more -->

<p>在Google了N多<code>What Should You Do If Windows 10 Freezes Randomly</code>的帖子之后，发现有这个问题的人可以组成一个军团，可谓是苦大仇深；</p>

<p>至少这下面所有的方法我都试了一遍：</p>

<p>https://www.partitionwizard.com/partitionmagic/win10-freezes-randomly.html</p>

<p>最后无奈之下挂载winGDB，是的，就是这么无聊，追到了Chrome里面；</p>

<p>我发现，只要关闭Chrome的 “设置-&gt;高级-&gt;使用硬件加速模式”，问题概率就会大大降低；</p>

<p>这是什么原理，一番探究后，我发现这台笔记本是自动切换核显和独立显卡的；而Intel核显有个选项： “Intel Graphics Control Panel -&gt; Energy management -&gt; Panel Self Refresh”关闭之后就OK了；</p>

<p>好吧，归根到底还是驱动的问题；Intel的这个显卡其实官方没有支持Win10的驱动，这是Win10自己瞎支持的，出现问题再所难免；</p>

<p>以后遇到Win10冻结的情况，你的检查清单上还需要多加两项：</p>

<ol>
  <li>
    <p>Chrome的硬件加速关闭试一试</p>
  </li>
  <li>
    <p>如果有Intel的核显，关闭<code>Panel Self Refresh</code>试一试</p>
  </li>
</ol>

<blockquote>
  <p>Apparently, disabling Panel Self Refresh (PSR) in the Intel HD Graphics Control Panel application fixed the issue.
On Lenovo notebook right click on desktop -&gt; Intel Graphics Control Panel -&gt; Energy management -&gt; Panel Self Refresh -&gt; set to Disabled.
I also set the display to max performance, but I don’t think this is relevant.
Once disabled, I’ve no more experienced any freeze for several days.</p>
</blockquote>

<p>参考：</p>

<p>https://forums.lenovo.com/t5/ThinkPad-X-Series-Laptops/X270-generic-freeze/td-p/3927475/page/5</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FRP内网穿透]]></title>
    <link href="https://happy123.me/blog/2019/11/11/frpnei-wang-chuan-tou/"/>
    <updated>2019-11-11T10:45:34+08:00</updated>
    <id>https://happy123.me/blog/2019/11/11/frpnei-wang-chuan-tou</id>
    <content type="html"><![CDATA[<p>对于没有公网 IP 的内网用户来说，远程管理或在外网访问内网机器上的服务是一个问题。之前一直用最简单的nc做反代，折腾了几次之后迁移到FRP上面了；记录一下ABC;</p>

<!-- more -->

<p>内网穿透工具 FRP，FRP 全名：Fast Reverse Proxy。</p>

<p>项目地址: https://github.com/fatedier/frp</p>

<h4 id="frp-">FRP 的作用</h4>

<ul>
  <li>
    <p>利用处于内网或防火墙后的机器，对外网环境提供 HTTP 或 HTTPS 服务。</p>
  </li>
  <li>
    <p>对于 HTTP, HTTPS 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口。</p>
  </li>
  <li>
    <p>利用处于内网或防火墙后的机器，对外网环境提供 TCP 和 UDP 服务，例如在家里通过 SSH 访问处于公司内网环境内的主机。</p>
  </li>
</ul>

<h4 id="frp--1">FRP 安装</h4>
<p>FRP 采用 Go 语言开发，支持 Windows、Linux、MacOS、ARM等多平台部署。FRP 安装非常容易，只需下载对应系统平台的软件包，并解压就可用。</p>

<p>这里以 Linux 为例，为了方便管理我们把解压后的目录重命名为 frp ：</p>

<p><code>
 wget https://github.com/fatedier/frp/releases/download/v0.29.1/frp_0.29.1_linux_amd64.tar.gz
 tar xzvf frp_0.29.1_linux_amd64.tar.gz
 mv frp_0.29.1_linux_amd64 frp
 cp frp/frpc frp/frps /usr/bin/
</code></p>

<h4 id="frp">FRP服务端配置</h4>

<ul>
  <li>首先建立配置文件</li>
</ul>

<p><code>
mkdir /etc/frp
vim /etc/frp/frps.ini
</code></p>

<p>下面是模板，根据修改一下token，dashboard_user, dashboard_pwd，默认开了6000端口作为对外ssh端口， 7000作为frpc和frps通讯端口，7500端口作为web管理界面端口；</p>

<p>```
# [common] is integral section
[common]
# A literal address or host name for IPv6 must be enclosed
# in square brackets, as in “[::1]:80”, “[ipv6-host]:http” or “[ipv6-host%zone]:80”
bind_addr = 0.0.0.0
bind_port = 7000</p>

<h1 id="udp-port-to-help-make-udp-hole-to-penetrate-nat">udp port to help make udp hole to penetrate nat</h1>
<p>bind_udp_port = 7001</p>

<h1 id="udp-port-used-for-kcp-protocol-it-can-be-same-with-bindport">udp port used for kcp protocol, it can be same with ‘bind_port’</h1>
<p># if not set, kcp is disabled in frps
kcp_bind_port = 7000</p>

<h1 id="specify-which-address-proxy-will-listen-for-default-value-is-same-with-bindaddr">specify which address proxy will listen for, default value is same with bind_addr</h1>
<p># proxy_bind_addr = 127.0.0.1</p>

<h1 id="if-you-want-to-support-virtual-host-you-must-set-the-http-port-for-listening-optional">if you want to support virtual host, you must set the http port for listening (optional)</h1>
<p># Note: http port and https port can be same with bind_port
vhost_http_port = 80
vhost_https_port = 443</p>

<h1 id="response-header-timeoutseconds-for-vhost-http-server-default-is-60s">response header timeout(seconds) for vhost http server, default is 60s</h1>
<p># vhost_http_timeout = 60</p>

<h1 id="set-dashboardaddr-and-dashboardport-to-view-dashboard-of-frps">set dashboard_addr and dashboard_port to view dashboard of frps</h1>
<p># dashboard_addr’s default value is same with bind_addr
# dashboard is available only if dashboard_port is set
dashboard_addr = 0.0.0.0
dashboard_port = 7500</p>

<h1 id="dashboard-user-and-passwd-for-basic-auth-protect-if-not-set-both-default-value-is-admin">dashboard user and passwd for basic auth protect, if not set, both default value is admin</h1>
<p>dashboard_user = user
dashboard_pwd = user</p>

<h1 id="dashboard-assets-directoryonly-for-debug-mode">dashboard assets directory(only for debug mode)</h1>
<p># assets_dir = ./static
# console or real logFile path like ./frps.log
log_file = /var/log/frps.log</p>

<h1 id="trace-debug-info-warn-error">trace, debug, info, warn, error</h1>
<p>log_level = info</p>

<p>log_max_days = 3</p>

<h1 id="disable-log-colors-when-logfile-is-console-default-is-false">disable log colors when log_file is console, default is false</h1>
<p>disable_log_color = false</p>

<h1 id="auth-token">auth token</h1>
<p>token = 123456frp</p>

<h1 id="heartbeat-configure-its-not-recommended-to-modify-the-default-value">heartbeat configure, it’s not recommended to modify the default value</h1>
<p># the default value of heartbeat_timeout is 90
# heartbeat_timeout = 90</p>

<h1 id="only-allow-frpc-to-bind-ports-you-list-if-you-set-nothing-there-wont-be-any-limit">only allow frpc to bind ports you list, if you set nothing, there won’t be any limit</h1>
<p>#allow_ports = 2000-3000,3001,3003,4000-50000
allow_ports = 80,6000,8080,18332,18333,28332,28333,60000-60010</p>

<h1 id="poolcount-in-each-proxy-will-change-to-maxpoolcount-if-they-exceed-the-maximum-value">pool_count in each proxy will change to max_pool_count if they exceed the maximum value</h1>
<p>max_pool_count = 5</p>

<h1 id="if-subdomainhost-is-not-empty-you-can-set-subdomain-when-type-is-http-or-https-in-frpcs-configure-file">if subdomain_host is not empty, you can set subdomain when type is http or https in frpc’s configure file</h1>
<p># when subdomain is test, the host used by routing is test.frps.com
subdomain_host = frps.com</p>

<h1 id="if-tcp-stream-multiplexing-is-used-default-is-true">if tcp stream multiplexing is used, default is true</h1>
<p>tcp_mux = true</p>

<h1 id="custom-404-page-for-http-requests">custom 404 page for HTTP requests</h1>
<p># custom_404_page = /path/to/404.html</p>

<p>```</p>

<ul>
  <li>再建立systemd 启动脚本</li>
</ul>

<p>```
vim /lib/systemd/system/frps.service</p>

<p>[Unit]
Description=Frp Server Service
After=network.target</p>

<p>[Service]
Type=simple
User=root
Restart=on-failure
RestartSec=5s
ExecStart=/usr/bin/frps -c /etc/frp/frps.ini</p>

<p>[Install]
WantedBy=multi-user.target
```</p>

<ul>
  <li>启动服务，再设置为开机启动</li>
</ul>

<p><code>
systemctl start frps
systemctl enable frps
</code></p>

<h4 id="frp-1">FRP客户端配置</h4>

<ul>
  <li>首先建立配置文件</li>
</ul>

<p><code>
mkdir /etc/frp
vim /etc/frp/frpc.ini
</code></p>

<p>下面是模板，根据修改server_addr、admin_user, admin_pwd字段; token要设置的跟服务端的token相同；</p>

<p>```
# [common] is integral section
[common]
# A literal address or host name for IPv6 must be enclosed
# in square brackets, as in “[::1]:80”, “[ipv6-host]:http” or “[ipv6-host%zone]:80”
server_addr = x.x.x.x
server_port = 7000</p>

<h1 id="if-you-want-to-connect-frps-by-http-proxy-or-socks5-proxy-you-can-set-httpproxy-here-or-in-global-environment-variables">if you want to connect frps by http proxy or socks5 proxy, you can set http_proxy here or in global environment variables</h1>
<p># it only works when protocol is tcp
# http_proxy = http://user:passwd@192.168.1.128:8080
# http_proxy = socks5://user:passwd@192.168.1.128:1080</p>

<h1 id="console-or-real-logfile-path-like-frpclog">console or real logFile path like ./frpc.log</h1>
<p>log_file = /var/log/frpc.log</p>

<h1 id="trace-debug-info-warn-error-1">trace, debug, info, warn, error</h1>
<p>log_level = info</p>

<p>log_max_days = 3</p>

<h1 id="disable-log-colors-when-logfile-is-console-default-is-false-1">disable log colors when log_file is console, default is false</h1>
<p>disable_log_color = false</p>

<h1 id="for-authentication">for authentication</h1>
<p>token = 123456frp</p>

<h1 id="set-admin-address-for-control-frpcs-action-by-http-api-such-as-reload">set admin address for control frpc’s action by http api such as reload</h1>
<p>admin_addr = 127.0.0.1
admin_port = 7400
admin_user = user
admin_pwd = user
# Admin assets directory. By default, these assets are bundled with frpc.
# assets_dir = ./static</p>

<h1 id="connections-will-be-established-in-advance-default-value-is-zero">connections will be established in advance, default value is zero</h1>
<p>pool_count = 5</p>

<h1 id="if-tcp-stream-multiplexing-is-used-default-is-true-it-must-be-same-with-frps">if tcp stream multiplexing is used, default is true, it must be same with frps</h1>
<p>tcp_mux = true</p>

<h1 id="your-proxy-name-will-be-changed-to-userproxy">your proxy name will be changed to {user}.{proxy}</h1>
<p>user = brainzhang.bitcoin.testnet</p>

<h1 id="decide-if-exit-program-when-first-login-failed-otherwise-continuous-relogin-to-frps">decide if exit program when first login failed, otherwise continuous relogin to frps</h1>
<p># default is true
login_fail_exit = true</p>

<h1 id="communication-protocol-used-to-connect-to-server">communication protocol used to connect to server</h1>
<p># now it supports tcp and kcp and websocket, default is tcp
protocol = tcp</p>

<h1 id="if-tlsenable-is-true-frpc-will-connect-frps-by-tls">if tls_enable is true, frpc will connect frps by tls</h1>
<p>tls_enable = true</p>

<h1 id="specify-a-dns-server-so-frpc-will-use-this-instead-of-default-one">specify a dns server, so frpc will use this instead of default one</h1>
<p># dns_server = 8.8.8.8</p>

<h1 id="proxy-names-you-want-to-start-seperated-by-">proxy names you want to start seperated by ‘,’</h1>
<p># default is empty, means all proxies
# start = ssh,dns</p>

<h1 id="heartbeat-configure-its-not-recommended-to-modify-the-default-value-1">heartbeat configure, it’s not recommended to modify the default value</h1>
<p># the default value of heartbeat_interval is 10 and heartbeat_timeout is 90
# heartbeat_interval = 30
# heartbeat_timeout = 90</p>

<h1 id="ssh-is-the-unique-proxy-name">‘ssh’ is the unique proxy name</h1>
<p># if user in [common] section is not empty, it will be changed to {user}.{proxy} such as ‘your_name.ssh’
[ssh]
# tcp | udp | http | https | stcp | xtcp, default is tcp
type = tcp
local_ip = 127.0.0.1
local_port = 22
# true or false, if true, messages between frps and frpc will be encrypted, default is false
use_encryption = false
# if true, message will be compressed
use_compression = true
# remote port listen by frps
remote_port = 6000
# frps will load balancing connections for proxies in same group
#group = test_group
## group should have same group key
#group_key = 123456
## enable health check for the backend service, it support ‘tcp’ and ‘http’ now
## frpc will connect local service’s port to detect it’s healthy status
#health_check_type = tcp
## health check connection timeout
#health_check_timeout_s = 3
## if continuous failed in 3 times, the proxy will be removed from frps
#health_check_max_failed = 3
## every 10 seconds will do a health check
#health_check_interval_s = 10</p>

<h1 id="sshrandom">[ssh_random]</h1>
<p>#type = tcp
#local_ip = 127.0.0.1
#local_port = 22
## if remote_port is 0, frps will assign a random port for you
#remote_port = 0</p>

<h1 id="if-you-want-to-expose-multiple-ports-add-range-prefix-to-the-section-name">if you want to expose multiple ports, add ‘range:’ prefix to the section name</h1>
<p># frpc will generate multiple proxies such as ‘tcp_port<em>6010’, ‘tcp_port</em>6011’ and so on.
[range:tcp_port]
type = tcp
local_ip = 127.0.0.1
#local_port = 6010-6020,6022,6024-6028,
#remote_port = 6010-6020,6022,6024-6028
local_port = 8080,18332,18333,28332,28333,60000-60010
remote_port = 8080,18332,18333,28332,28333,60000-60010
use_encryption = false
use_compression = false</p>

<p>```</p>

<ul>
  <li>再建立systemd 启动脚本</li>
</ul>

<p>```
vim /lib/systemd/system/frpc.service</p>

<p>[Unit]
Description=Frp Client Service
After=network.target</p>

<p>[Service]
Type=simple
User=root
Restart=on-failure
RestartSec=5s
ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini
ExecReload=/usr/bin/frpc reload -c /etc/frp/frpc.ini</p>

<p>[Install]
WantedBy=multi-user.target</p>

<p>```</p>

<ul>
  <li>启动服务，再设置为开机启动</li>
</ul>

<p><code>
systemctl start frpc
systemctl enable frpc
</code></p>

<h4 id="section">测试</h4>

<p>现在可以从外网通过 frps服务端的ip(比如x.x.x.x)中转，访问内网了；比如ssh:</p>

<p><code>
ssh -oPort=6000 root@x.x.x.x
</code></p>

<p>也可以直接用一条scp命令直接通过跳板机拷贝文件到内网机器</p>

<p><code>
scp -P 6000 -r xxx root@xxxxxxx:/opt/
</code></p>

<p>同样的，如果内网开通了某些服务，比如我们的配置模板里面已经映射出了8080,18332,18333,28332,28333,60000-60010这些端口，这些端口同样的映射到服务端了；</p>

<p>比如，我们在内网运行一个简单的web服务:</p>

<p><code>
python -m SimpleHTTPServer 8080
</code></p>

<p>可以通过frps服务端的ip(比如x.x.x.x)访问这个服务：</p>

<p><code>
curl http://x.x.x.x:8080
</code></p>

<p>我们也可以在内网运行一个bitcoin全节点+lnd，然后关闭不必要的服务，再运行一个轻量的vps，在vps上部署Tor服务，这样我们就可以通过多重跳板把闪电网络热钱包隐藏到Tor网络里面了，保证了安全性；</p>

<h4 id="section-1">管理</h4>

<p>可以通过下面的地址进入web管理界面，用户名和密码就是frps.ini中配置的dashboard_user、dashboard_pwd；</p>

<p>http://x.x.x.x:7500</p>

<h4 id="section-2">扩展</h4>

<p>FRP还有非常多的功能，比如虚拟主机、多路复用、负载均衡、点对点内网穿透等等，请参考官方文档：</p>

<p>https://github.com/fatedier/frp/blob/master/README_zh.md</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Run Tmux Service Scripts on Ubuntu Start Up]]></title>
    <link href="https://happy123.me/blog/2019/10/30/how-to-run-tmux-service-scripts-on-ubuntu-start-up/"/>
    <updated>2019-10-30T10:11:38+08:00</updated>
    <id>https://happy123.me/blog/2019/10/30/how-to-run-tmux-service-scripts-on-ubuntu-start-up</id>
    <content type="html"><![CDATA[<p>是的，做了无数遍还是不长记性，昨天又在这上面踩坑了；在ubuntu上写的启动脚本不执行，仅仅是可执行权限和用户权限的问题，又浪费了一上午；</p>

<!-- more -->

<p>在unbuntu启动时自动做一些工作，最佳实践是：</p>

<h4 id="section">你想要执行一个服务</h4>

<ul>
  <li>如果是比较老的ubuntu (version&lt;=14.04LTS);</li>
</ul>

<p>这个时候你需要利用ubuntu的<a href="http://upstart.ubuntu.com/">upstart机制</a></p>

<p>简单说来，就是将一个这样的脚本:</p>

<p><code>
start on startup
task
exec /path/to/command
</code></p>

<p>存为taskxxx.conf文件，放到/etc/init 目录下面(这将会在开机时用root用户权限启动)；</p>

<p>或者存为 ~/.config/upstart(这将会在开机时用当前用户权限启动)</p>

<ul>
  <li>如果你是比较现代的ubuntu (version&gt;=16.04LTS)</li>
</ul>

<p>你需要利用 <a href="https://github.com/systemd/systemd">systemd</a> 服务，这个我们之前写文章科普过：</p>

<p>https://happy123.me/blog/2016/08/22/how-to-write-standard-startup-script/</p>

<h4 id="section-1">仅仅想执行一条简单的命令</h4>

<p><code>
sudo nano /etc/rc.local
</code></p>

<p>加入执行的命令，不要忘了最后加exit</p>

<p><code>
/opt/tmux.sh
exit 0
</code></p>

<p>增加可执行权限</p>

<p><code>
sudo chmod +x /etc/rc.local
</code></p>

<p>注意：</p>

<ul>
  <li>要有可执行权限，这个最容易踩坑，ubuntu安装完毕 /etc/rc.local 是没有可执行权限的</li>
  <li>注意执行命令的ENV变量，不确定的时候要在命令签名设定SHELL ENV Variable</li>
  <li>如果是执行一个脚本，注意脚本命令调用的shell (bash or sh or zsh)，以及ENV Variable</li>
  <li>注意执行脚本、执行命令的用户</li>
</ul>

<h4 id="section-2">如果是修改一个环境变量</h4>

<p>修改当前用户:</p>

<p><code>
nano ~/.bashrc
</code></p>

<p>所有用户生效:</p>

<p><code>
nano ~/etc/profile
</code></p>

<h4 id="section-3">最后，附赠最简单粗暴的开机执行任务方式</h4>

<p>就是在/etc/rc.local 里面启动一个tmux session，在里面执行想要运行的命令；简单粗暴有效</p>

<p>来个模板:</p>

<p>```
#!/bin/bash
# description “Start Tmux”</p>

<h1 id="sleep-for-5-seconds-if-you-are-starting-more-than-one-tmux-session">Sleep for 5 seconds. If you are starting more than one tmux session</h1>
<p>#   “at the same time”, then make sure they all sleep for different periods
#   or you can experience problems
/bin/sleep 5
# Ensure the environment is available
source ~/.bashrc
# Create a new tmux session named newscrawler..
/usr/bin/tmux new-session -d -s bitcoin
# …and control the tmux session (initially ensure the environment
#   is available, then run commands)</p>

<h1 id="usrbintmux-send-keys--t-bitcoincash0-source-bashrc-c-m">/usr/bin/tmux send-keys -t bitcoincash:0 “source ~/.bashrc” C-m</h1>
<p>tmux new-window -n console -t bitcoin
/bin/sleep 3
/usr/bin/tmux send-keys -t bitcoin:0 “cd /opt/bitcoin &amp;&amp; ./startbitcoind.sh” C-m
/bin/sleep 3
/usr/bin/tmux send-keys -t bitcoin:1 “cd /opt/bitcoin &amp;&amp; ./checkwallet start” C-m</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
