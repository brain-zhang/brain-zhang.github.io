<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-05-01T13:16:27+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Parallel All Cmds for Linux]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-parallel-all-cmds-for-linux/"/>
    <updated>2018-05-01T13:07:20+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-parallel-all-cmds-for-linux</id>
    <content type="html"><![CDATA[<p>grep 一个100GB的文件总是很有压力，怎么才能提速呢?</p>

<h3>瞎优化</h3>

<p><code>
LC_ALL=C fgrep -A 5 -B 5 'xxxxx.password' allpassseed.txt
</code></p>

<ul>
<li><p><code>LC_ALL=C</code>比<code>LC_ALL=UTF-8</code>要块</p></li>
<li><p>不需要正则的话，用fgrep可以提速</p></li>
</ul>


<h3>不过这样优化总是治标不治本，下面隆重推出linux 里面parallel all cmds的perl工具</h3>

<p><code>
cat allpassseed.txt |parallel  --pipe  --no-notice grep -f xxxxx.password
</code></p>

<p>使用parallel ，和不使用parallel直接grep。结果显而易见，相差 20 倍。这比用啥 ack，ag优化效果明显多了</p>

<h3>xargs也有一个-n的多核选项，可以作为备用</h3>

<p>```
$ time echo {1..5} |xargs -n 1  sleep</p>

<p>real    0m15.005s
user    0m0.000s
sys 0m0.000s
```</p>

<p>这一条xargs把每个echo的数作为参数传给sleep ，所以一共sleep了 1+2+3+4+5=15秒。</p>

<p>如果使用 -P 参数分给5个核，每个核各sleep 1,2,3,4,5秒，所以执行完之后总共sleep的5秒。</p>

<p>```
$ time echo {1..5} |xargs -n 1 -P 5 sleep</p>

<p>real    0m5.003s
user    0m0.000s
sys 0m0.000s
```</p>

<ul>
<li>引自:</li>
</ul>


<p><a href="https://www.jianshu.com/p/c5a2369fa613">https://www.jianshu.com/p/c5a2369fa613</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Calling Multiple Commands Through Xargs]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-calling-multiple-commands-through-xargs/"/>
    <updated>2018-05-01T09:25:03+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-calling-multiple-commands-through-xargs</id>
    <content type="html"><![CDATA[<p>有时候想在xargs后面接多条命令，这个时候直接加<code>;</code>是不行的，要这样做:</p>

<p><code>
cat a.txt | xargs -I@  sh -c 'command1; command2; ...'
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Compress All Find Files to Single Line Argv]]></title>
    <link href="http://happy123.me/blog/2018/04/30/how-to-compress-all-find-files-to-single-line-argv/"/>
    <updated>2018-04-30T10:39:39+08:00</updated>
    <id>http://happy123.me/blog/2018/04/30/how-to-compress-all-find-files-to-single-line-argv</id>
    <content type="html"><![CDATA[<p>有时候find的所有文件要合并为一个argv管道到一个命令里面:</p>

<p><code>
find /path/to/directory/ -name *.csv -print0 | xargs -0 -I file cat file &gt; merged.file
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Sort Big Files]]></title>
    <link href="http://happy123.me/blog/2018/04/27/how-to-sort-big-files/"/>
    <updated>2018-04-27T17:03:22+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/how-to-sort-big-files</id>
    <content type="html"><![CDATA[<p>在linux要排序一个100G的文件，压力比较大</p>

<p>并行解决之:</p>

<p>```</p>

<pre><code>sort -S 50% --parallel=2 -uo list-sorted.txt list.txt
</code></pre>

<p>```</p>

<p>注意这一招在管道里面行不通，所以要用管道的话一定要先重定向到一个文件里面中转一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Dump Csv From Sqlite3]]></title>
    <link href="http://happy123.me/blog/2018/04/27/how-to-dump-csv-from-sqlite3/"/>
    <updated>2018-04-27T08:57:22+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/how-to-dump-csv-from-sqlite3</id>
    <content type="html"><![CDATA[<p>```</p>

<h1>!/bin/bash</h1>

<p>/usr/bin/sqlite3 test.db &lt;&lt;!
.headers on
.mode csv
.output out.csv
select username,password,email from passhouse order by site;
!
```</p>
]]></content>
  </entry>
  
</feed>
