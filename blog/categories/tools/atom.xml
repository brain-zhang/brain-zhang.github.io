<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-09-16T16:56:55+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Paste Fails When Using Bracketed-paste-magic on zsh5.1.1]]></title>
    <link href="https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1/"/>
    <updated>2019-09-13T10:50:31+08:00</updated>
    <id>https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1</id>
    <content type="html"><![CDATA[<p>突然碰到了zsh5.1.1的一个bug，粘贴中文的时候会把shell freeze；</p>

<p>不知道是不是on-my-zsh升级的时候搞坏的，一通搜索发现了这个:</p>

<p>https://github.com/zsh-users/zsh-autosuggestions/issues/102</p>

<p>没有升级zsh，我直接到配置文件里把那段自动转义的功能注释掉了，嗯，简单粗暴~~~这东西我也不想天天升级；</p>

<p><code>
~/.oh-my-zsh/lib/misc.zsh
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using a GPG Key and Ssh Auth]]></title>
    <link href="https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth/"/>
    <updated>2019-08-16T16:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth</id>
    <content type="html"><![CDATA[<p>在我的一台服务器被数不清的脚本小子暴力尝试登陆N次后，我下定决心将所有的开发环境换成统一的ssh key；并禁止用户登陆；</p>

<p>其中最折腾的部分就是使用我的GPG Key统一所有的ssh 环境；我也很纳闷，为什么自己没有早点搞定这些事情；</p>

<p>众所周知，GPG和Openssl的key是不兼容的，所以统一环境还是花了不少时间，主要是参考了这篇文章：</p>

<p>https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth</p>

<p>常用命令:
<!-- more --></p>

<h3 id="gpg">GPG</h3>

<ul>
  <li>生成证书</li>
</ul>

<p>```
gpg –gen-key</p>

<p>```</p>

<ul>
  <li>生成撤销证书</li>
</ul>

<p>```
gpg –gen-revoke [用户ID]</p>

<p>```</p>

<ul>
  <li>列出所有密钥</li>
</ul>

<p>```
gpg –list-keys</p>

<p>```</p>

<p>输出</p>

<p>```
/home/brain/.gnupg/pubring.gpg
——————————-
pub   4096R/xxxxxxxx 2018-08-16
uid                  brain.zhang (happy123.me) &lt;brain.zhangbin#xxx.com&gt;
sub   4096R/yyyyyyyy 2018-08-16</p>

<p>```</p>

<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示subkey。</p>

<ul>
  <li>输出密钥</li>
</ul>

<p>```
gpg –armor –output public-key.txt –export [用户ID]</p>

<p>```</p>

<ul>
  <li>输出密钥时转换私钥</li>
</ul>

<p>```
gpg –armor –output private-key.txt –export-secret-keys</p>

<p>```</p>

<ul>
  <li>上传公钥</li>
</ul>

<p>```
gpg –keyserver keys.gnupg.net –send-keys [pub key ID] 
…
gpg –keyserver keys.gnupg.net –search-keys brain.zhang</p>

<p>```</p>

<ul>
  <li>生成公钥指纹供别人检查</li>
</ul>

<p>```
gpg –fingerprint [用户ID]</p>

<p>```</p>

<ul>
  <li>加密文件</li>
</ul>

<p>```
gpg –recipient [用户ID] –output demo.en.txt –encrypt demo.txt</p>

<p>```</p>

<ul>
  <li>解密文件</li>
</ul>

<p>```
gpg –decrypt demo.en.txt –output demo.de.txt</p>

<p>```</p>

<ul>
  <li>对文件签名</li>
</ul>

<p>```
gpg –clearsign demo.txt</p>

<p>```</p>

<ul>
  <li>获得单独的签名文件</li>
</ul>

<p>```
gpg –armor –detach-sign demo.txt</p>

<p>```</p>

<ul>
  <li>验证签名</li>
</ul>

<p>```
gpg –verify demo.txt.asc demo.txt</p>

<p>```</p>

<h3 id="section">导入第三方公钥</h3>

<ul>
  <li>获得公钥</li>
</ul>

<p>```
gpg –keyserver keys.gnupg.net –search-keys <user>
...
gpg --keyserver hkp://subkeys.pgp.net --search-keys brain.zhang</user></p>

<p>```</p>

<ul>
  <li>验证公钥</li>
</ul>

<p>```
 gpg –edit-key <key /></p>

<p>```
你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入quit 退出。</p>

<h3 id="githubgpg">在Github中使用GPG</h3>

<ul>
  <li>输出key id</li>
</ul>

<p>```
gpg –list-secret-keys –keyid-format LONG</p>

<p>```</p>

<ul>
  <li>设置提交</li>
</ul>

<p>```
 git config  user.signingkey <key /></p>

<p>```</p>

<ul>
  <li>对单次提交进行签名： </li>
</ul>

<p>```
git commit -S -m “-S选项表示对此次提交使用gpg进行签名”</p>

<p>```</p>

<ul>
  <li>签名标签</li>
</ul>

<p>```
git tag -s <tag /></p>

<p>```</p>

<h3 id="ssh-server-gen">ssh server gen</h3>

<ul>
  <li>制作密钥对</li>
</ul>

<p>```
[root@host ~]$ ssh-keygen </p>

<p>```</p>

<ul>
  <li>把生成的/root/.ssh/id_rsa.pub拷贝到在服务器上，安装公钥</li>
</ul>

<p>```
[root@host ~]$ cd .ssh
[root@host .ssh]$ cat id_rsa.pub » authorized_keys
[root@host .ssh]$ chmod 600 authorized_keys
[root@host .ssh]$ chmod 700 ~/.ssh</p>

<p>```</p>

<ul>
  <li>设置 SSHD，打开密钥登录功能
编辑 /etc/ssh/sshd_config 文件，进行如下设置：</li>
</ul>

<p>```
PubkeyAuthentication yes
PermitRootLogin yes</p>

<p>```</p>

<ul>
  <li>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</li>
</ul>

<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>

<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>

<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>

<ul>
  <li>验证无误，关闭密码登陆</li>
</ul>

<p>```
PasswordAuthentication no
[root@host .ssh]$ service sshd restart</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wsl Best Practice]]></title>
    <link href="https://happy123.me/blog/2019/01/16/wsl-best-practice/"/>
    <updated>2019-01-16T14:13:58+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/wsl-best-practice</id>
    <content type="html"><![CDATA[<p>WSL用了一年，感觉还不错。尤其是在我的机器上pypy3.5版本的<code>SHA512 pbkdf</code>计算性能竟然超越了原生Linux和Windows。成为Python运行效率最高的平台，实在是匪夷所思的事情。</p>

<p>WSL最让我满意的，是命令行里面可以结合Windows和Linux的命令行工具来管道处理，这个实在是太赞了。纯粹计算类的程序，Windows上面有很多现成的命令行工具，现在终于能:</p>

<p>```
ping.exe -t xxx.xxx.xxx.xxx|grep xxxx|echo -I xxx ~~~</p>

<p>```</p>

<p>这样来搞了，事实上，我自己写了很多Python脚本来处理Powershell自带的很多工具输出的内容，还有不少GPU运算程序大多数跑在Windows上面，能直接重定向到Linux上面实在太好了。</p>

<p>另外，WSL网络协议栈和Windows是共享的，倒是直接省了一个事，我直接把http_proxy配置成本地的shadowsock服务就很安逸的翻墙了；方便。</p>

<p>最后，就等着磁盘性能的改善了。</p>

<p>下面记一下常用的坑：</p>

<ul>
  <li>如果开机之后插拔一个移动硬盘，需要手工在WSL中执行重新挂载命令：</li>
</ul>

<p>```
sudo umount /mnt/g &amp;&amp; sudo mount -t drvfs “G:” /mnt/g</p>

<p>```</p>

<ul>
  <li>WSL跟最新2019版本的卡巴斯基冲突，卡巴斯基默认会过滤所有HTTP流量</li>
</ul>

<p>目前无解；要么禁用卡巴斯基的HTTP过滤功能，要么回退2018版本</p>

<p>最后，多个版本实验之后，锁定Win10 1709我也能连续3个月不关机了，稳定性可喜可贺。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alias Rm to Mv]]></title>
    <link href="https://happy123.me/blog/2019/01/16/alias-rm-to-mv/"/>
    <updated>2019-01-16T14:00:18+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/alias-rm-to-mv</id>
    <content type="html"><![CDATA[<p>之前一直简单的用</p>

<p>``` 
alias rm=’mv -f $@ ~/.trash’</p>

<p>``` </p>

<p>取代rm命令。</p>

<p>这样用着有个不便的地方，就是有时候做个脚本命令，带个<code>;</code>的时候会解析有问题。今天突然发现一个用函数来替代的好办法，记一下：</p>

<p>```
alias rm=’move1(){ /bin/mv -f $@ ~/.trash/; };move1 $@’</p>

<p>```</p>

<p>参考资料：</p>

<p>https://www.cnblogs.com/f-ck-need-u/p/7385133.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrate Vm Instances and Snapshots From Different Vps Supporters or Accounts]]></title>
    <link href="https://happy123.me/blog/2018/07/21/migrate-vm-instances-and-snapshots-from-different-vps-supporters-or-accounts/"/>
    <updated>2018-07-21T09:11:55+08:00</updated>
    <id>https://happy123.me/blog/2018/07/21/migrate-vm-instances-and-snapshots-from-different-vps-supporters-or-accounts</id>
    <content type="html"><![CDATA[<p>虽然已经进入X时代了，但电脑城装机习惯性还是用Ghost，无他，习惯方便。</p>

<p>Linux上面系统迁移，网上搜一搜，大批文章还是原始的dd, rsync之类；当然，不是说他不行，而是面向小白实在是有点坑啊。</p>

<p>云时代，不同厂商间基本都提供了<code>快照</code>+<code>在线热迁移</code>的方案了，用起来也很舒服。</p>

<p>那么，作为一个VPS小白用户，怎么在不同的账号，或者说不同的厂商之间，迁移我的Linux系统呢？</p>

<p>比如我在vultr上面有两个账号，vultr的快照功能是很赞的，免费、速度快、生成虚机靠谱；</p>

<p>那么问题来了，怎么把账号A的Linux A迁移到账号B的Linux B虚机上呢？</p>

<p>官方回复是还没有考虑这个功能，然后Linux怎么可能做不到这种简单的事情呢？当然立刻就有人回复了详细的搞法，还贴心的附录了视频:</p>

<p>https://discuss.vultr.com/discussion/104/snapshot-image-downloads/p2</p>

<!-- more -->

<h4 id="section">我们也嘴炮一下整个过程:</h4>

<ol>
  <li>
    <p>对Linux A建立SnapShot A</p>
  </li>
  <li>
    <p>从SnapShot A创立一台虚机 (注意这台虚机的磁盘要比Linux A的磁盘大，比如Linux A是5$的套餐15GB，那么最好建立一个20$的套餐45GB)</p>
  </li>
  <li>
    <p>vultr 有挂载光盘的功能，可以挂载一个linux live CD,用这张Live CD启动新虚机</p>
  </li>
  <li>
    <p>dd 命令完全拷贝原有磁盘</p>

    <table>
      <tbody>
        <tr>
          <td>dd if=/dev/vtbd0 bs=1m</td>
          <td>gzip -c</td>
          <td>ssh -e none myolduser@myoldserverip ‘cat &gt; backupsnapshot.iso.gz’</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>账号B开一台虚机，把backupsnapshot.iso.gz拷贝过去</p>
  </li>
  <li>
    <p>同样挂载Live CD，反向dd，恢复文件系统</p>
  </li>
  <li>
    <p>重启，改配置，赋权限，搞定</p>
  </li>
</ol>

<p>说是嘴炮，是因为我之前硬盘dd对拷过，对于速度和之后的配置兼容深为烦恼，更不用说KVM上面用这个招数去做迁移了，我一个坑都不想踩的。</p>

<p>光是看看上面一波操作，我就没兴趣折腾了。当然也有很多人的乐趣就是折腾，但是年纪大了就老是想偷懒。</p>

<p>之前在不同物理机之间做Linux迁移，用clonezilla居多，虽然有一些Raid方面的支持会有问题，总体来说我对它的稳定性和便利性有巨大信任，但从来没有在KVM上搞过，这次我完整实验了一把，效果MAX。</p>

<h4 id="clonezilla">下面我们说说怎么用clonezilla把上面繁琐的手工操作搞得不那么痛苦一点:</h4>

<ol>
  <li>
    <p>先去clonezilla.org 官网，找到下载地址，好吧，我已经帮你找好了:</p>

    <p>http://onet.dl.osdn.jp/clonezilla/69273/clonezilla-live-2.5.5-38-amd64.iso</p>
  </li>
  <li>
    <p>vultr很贴心的提供了从url上传镜像的功能，我们到下面这个功能项中把iso镜像的url填进去，添加clonezilla镜像文件到vultr:</p>

    <p>https://my.vultr.com/iso/add/</p>
  </li>
  <li>
    <p>点开虚机Linux A，点击<code>Settings</code> -&gt; <code>Custom ISO</code> -&gt; 选择clonezilla -&gt; 点击 <code>Attach ISO and Reboot</code></p>
  </li>
  <li>
    <p>用VNC连接虚机，进入clonezilla的界面</p>
  </li>
  <li>
    <p>进入菜单项，<code>第一菜单800X600分辨率</code> -&gt; <code>简体中文</code> -&gt; <code>使用再生龙</code></p>
  </li>
  <li>
    <p>选择 <code>remote-source 进入远程设备克隆的源端</code></p>
  </li>
  <li>
    <p>选择 <code>初学模式：接受默认的选择</code></p>
  </li>
  <li>
    <p>选择 <code>复制本机硬盘到它机硬盘</code></p>
  </li>
  <li>
    <p>选择 <code>设定固定IP地址</code></p>
  </li>
  <li>
    <p>设定IP,子网掩码，网关,域名服务器，如果机器有多块网卡的话，一般会列出网卡名字和MAC地址供你选择，vultr一般是双网卡(如果你启用了内网地址的话),网络信息在vultr的主机settings中能查到。</p>
  </li>
  <li>
    <p>选择要克隆的硬盘，设定没有问题的话，下面一路YES下去，机器就会进入等待目标端连接的状态</p>
  </li>
  <li>
    <p>在账号B的Linux B中重复1-11步操作，不同的是第6步选择目标端，第8步选择 <code>从镜像文件恢复至本机硬盘</code>, 之后填入Linux A的IP地址，就可以开始克隆对拷了</p>
  </li>
  <li>
    <p>我在不同vultr的账号中测试了Ubuntu16.04, Centos7.1, FreeBSD 10的迁移，效果MAX</p>
  </li>
</ol>

<p>看起来步骤不少，熟练了还是能迅速操作的，clonezilla赞一个</p>

<h4 id="tooltips">一点小ToolTIps:</h4>

<ul>
  <li>
    <p>这个方法其实可以适用所有KVM虚机迁移，所以只要服务商开了自定义镜像挂载的功能，都可以跨公网对拷</p>
  </li>
  <li>
    <p>如果A和B不能直接通信的话，可以开一台中转机器C，在Linux A的一端把硬盘 clone为镜像文件，通过SSH文件服务器的方式转存到C上，然后在B上连接SSH文件服务器C，从而还原系统; 提示一下，其实生成的镜像文件挺小的，比dd之后压缩还小的多</p>
  </li>
  <li>
    <p>如果clone的时候报错，一般是A 端的文件系统有损坏，这个时候可以简单的执行 <code>shutdown -rF now</code> ,重启后自动修复一把，之后再挂载clonezilla ISO进行克隆</p>
  </li>
</ul>

<h4 id="qcow2-">最后，让我们期望所有的服务商都能提供 qcow2 的导入导出功能</h4>

]]></content>
  </entry>
  
</feed>
