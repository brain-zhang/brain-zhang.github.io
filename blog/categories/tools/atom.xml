<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-10-30T10:12:26+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Run Tmux Service Scripts on Ubuntu Start Up]]></title>
    <link href="https://happy123.me/blog/2019/10/30/how-to-run-tmux-service-scripts-on-ubuntu-start-up/"/>
    <updated>2019-10-30T10:11:38+08:00</updated>
    <id>https://happy123.me/blog/2019/10/30/how-to-run-tmux-service-scripts-on-ubuntu-start-up</id>
    <content type="html"><![CDATA[<p>是的，做了无数遍还是不长记性，昨天又在这上面踩坑了；在ubuntu上写的启动脚本不执行，仅仅是可执行权限和用户权限的问题，又浪费了一上午；</p>

<!-- more -->

<p>在unbuntu启动时自动做一些工作，最佳实践是：</p>

<h4 id="section">你想要执行一个服务</h4>

<ul>
  <li>如果是比较老的ubuntu (version&lt;=14.04LTS);</li>
</ul>

<p>这个时候你需要利用ubuntu的<a href="http://upstart.ubuntu.com/">upstart机制</a></p>

<p>简单说来，就是将一个这样的脚本:</p>

<p><code>
start on startup
task
exec /path/to/command
</code></p>

<p>存为taskxxx.conf文件，放到/etc/init 目录下面(这将会在开机时用root用户权限启动)；</p>

<p>或者存为 ~/.config/upstart(这将会在开机时用当前用户权限启动)</p>

<ul>
  <li>如果你是比较现代的ubuntu (version&gt;=16.04LTS)</li>
</ul>

<p>你需要利用 <a href="https://github.com/systemd/systemd">systemd</a> 服务，这个我们之前写文章科普过：</p>

<p>https://happy123.me/blog/2016/08/22/how-to-write-standard-startup-script/</p>

<h4 id="section-1">仅仅想执行一条简单的命令</h4>

<p><code>
sudo nano /etc/rc.local
</code></p>

<p>加入执行的命令，不要忘了最后加exit</p>

<p><code>
/opt/tmux.sh
exit 0
</code></p>

<p>增加可执行权限</p>

<p><code>
sudo chmod +x /etc/rc.local
</code></p>

<p>注意：</p>

<ul>
  <li>要有可执行权限，这个最容易踩坑，ubuntu安装完毕 /etc/rc.local 是没有可执行权限的</li>
  <li>注意执行命令的ENV变量，不确定的时候要在命令签名设定SHELL ENV Variable</li>
  <li>如果是执行一个脚本，注意脚本命令调用的shell (bash or sh or zsh)，以及ENV Variable</li>
  <li>注意执行脚本、执行命令的用户</li>
</ul>

<h4 id="section-2">如果是修改一个环境变量</h4>

<p>修改当前用户:</p>

<p><code>
nano ~/.bashrc
</code></p>

<p>所有用户生效:</p>

<p><code>
nano ~/etc/profile
</code></p>

<h4 id="section-3">最后，附赠最简单粗暴的开机执行任务方式</h4>

<p>就是在/etc/rc.local 里面启动一个tmux session，在里面执行想要运行的命令；简单粗暴有效</p>

<p>来个模板:</p>

<p>```
#!/bin/bash
# description “Start Tmux”</p>

<h1 id="sleep-for-5-seconds-if-you-are-starting-more-than-one-tmux-session">Sleep for 5 seconds. If you are starting more than one tmux session</h1>
<p>#   “at the same time”, then make sure they all sleep for different periods
#   or you can experience problems
/bin/sleep 5
# Ensure the environment is available
source ~/.bashrc
# Create a new tmux session named newscrawler..
/usr/bin/tmux new-session -d -s bitcoin
# …and control the tmux session (initially ensure the environment
#   is available, then run commands)</p>

<h1 id="usrbintmux-send-keys--t-bitcoincash0-source-bashrc-c-m">/usr/bin/tmux send-keys -t bitcoincash:0 “source ~/.bashrc” C-m</h1>
<p>tmux new-window -n console -t bitcoin
/bin/sleep 3
/usr/bin/tmux send-keys -t bitcoin:0 “cd /opt/bitcoin &amp;&amp; ./startbitcoind.sh” C-m
/bin/sleep 3
/usr/bin/tmux send-keys -t bitcoin:1 “cd /opt/bitcoin &amp;&amp; ./checkwallet start” C-m</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paste Fails When Using Bracketed-paste-magic on zsh5.1.1]]></title>
    <link href="https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1/"/>
    <updated>2019-09-13T10:50:31+08:00</updated>
    <id>https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1</id>
    <content type="html"><![CDATA[<p>突然碰到了zsh5.1.1的一个bug，粘贴中文的时候会把shell freeze；</p>

<p>不知道是不是on-my-zsh升级的时候搞坏的，一通搜索发现了这个:</p>

<p>https://github.com/zsh-users/zsh-autosuggestions/issues/102</p>

<p>没有升级zsh，我直接到配置文件里把那段自动转义的功能注释掉了，嗯，简单粗暴~~~这东西我也不想天天升级；</p>

<p><code>
~/.oh-my-zsh/lib/misc.zsh
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using a GPG Key and Ssh Auth]]></title>
    <link href="https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth/"/>
    <updated>2019-08-16T16:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth</id>
    <content type="html"><![CDATA[<p>在我的一台服务器被数不清的脚本小子暴力尝试登陆N次后，我下定决心将所有的开发环境换成统一的ssh key；并禁止用户登陆；</p>

<p>其中最折腾的部分就是使用我的GPG Key统一所有的ssh 环境；我也很纳闷，为什么自己没有早点搞定这些事情；</p>

<p>众所周知，GPG和Openssl的key是不兼容的，所以统一环境还是花了不少时间，主要是参考了这篇文章：</p>

<p>https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth</p>

<p>常用命令:
<!-- more --></p>

<h3 id="gpg">GPG</h3>

<ul>
  <li>生成证书</li>
</ul>

<p>```
gpg –gen-key</p>

<p>```</p>

<ul>
  <li>生成撤销证书</li>
</ul>

<p>```
gpg –gen-revoke [用户ID]</p>

<p>```</p>

<ul>
  <li>列出所有密钥</li>
</ul>

<p>```
gpg –list-keys</p>

<p>```</p>

<p>输出</p>

<p>```
/home/brain/.gnupg/pubring.gpg
——————————-
pub   4096R/xxxxxxxx 2018-08-16
uid                  brain.zhang (happy123.me) &lt;brain.zhangbin#xxx.com&gt;
sub   4096R/yyyyyyyy 2018-08-16</p>

<p>```</p>

<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示subkey。</p>

<ul>
  <li>输出密钥</li>
</ul>

<p>```
gpg –armor –output public-key.txt –export [用户ID]</p>

<p>```</p>

<ul>
  <li>输出密钥时转换私钥</li>
</ul>

<p>```
gpg –armor –output private-key.txt –export-secret-keys</p>

<p>```</p>

<ul>
  <li>上传公钥</li>
</ul>

<p>```
gpg –keyserver keys.gnupg.net –send-keys [pub key ID] 
…
gpg –keyserver keys.gnupg.net –search-keys brain.zhang</p>

<p>```</p>

<ul>
  <li>生成公钥指纹供别人检查</li>
</ul>

<p>```
gpg –fingerprint [用户ID]</p>

<p>```</p>

<ul>
  <li>加密文件</li>
</ul>

<p>```
gpg –recipient [用户ID] –output demo.en.txt –encrypt demo.txt</p>

<p>```</p>

<ul>
  <li>解密文件</li>
</ul>

<p>```
gpg –decrypt demo.en.txt –output demo.de.txt</p>

<p>```</p>

<ul>
  <li>对文件签名</li>
</ul>

<p>```
gpg –clearsign demo.txt</p>

<p>```</p>

<ul>
  <li>获得单独的签名文件</li>
</ul>

<p>```
gpg –armor –detach-sign demo.txt</p>

<p>```</p>

<ul>
  <li>验证签名</li>
</ul>

<p>```
gpg –verify demo.txt.asc demo.txt</p>

<p>```</p>

<h3 id="section">导入第三方公钥</h3>

<ul>
  <li>获得公钥</li>
</ul>

<p>```
gpg –keyserver keys.gnupg.net –search-keys <user>
...
gpg --keyserver hkp://subkeys.pgp.net --search-keys brain.zhang</user></p>

<p>```</p>

<ul>
  <li>验证公钥</li>
</ul>

<p>```
 gpg –edit-key <key /></p>

<p>```
你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入quit 退出。</p>

<h3 id="githubgpg">在Github中使用GPG</h3>

<ul>
  <li>输出key id</li>
</ul>

<p>```
gpg –list-secret-keys –keyid-format LONG</p>

<p>```</p>

<ul>
  <li>设置提交</li>
</ul>

<p>```
 git config  user.signingkey <key /></p>

<p>```</p>

<ul>
  <li>对单次提交进行签名： </li>
</ul>

<p>```
git commit -S -m “-S选项表示对此次提交使用gpg进行签名”</p>

<p>```</p>

<ul>
  <li>签名标签</li>
</ul>

<p>```
git tag -s <tag /></p>

<p>```</p>

<h3 id="ssh-server-gen">ssh server gen</h3>

<ul>
  <li>制作密钥对</li>
</ul>

<p>```
[root@host ~]$ ssh-keygen </p>

<p>```</p>

<ul>
  <li>把生成的/root/.ssh/id_rsa.pub拷贝到在服务器上，安装公钥</li>
</ul>

<p>```
[root@host ~]$ cd .ssh
[root@host .ssh]$ cat id_rsa.pub » authorized_keys
[root@host .ssh]$ chmod 600 authorized_keys
[root@host .ssh]$ chmod 700 ~/.ssh</p>

<p>```</p>

<ul>
  <li>设置 SSHD，打开密钥登录功能
编辑 /etc/ssh/sshd_config 文件，进行如下设置：</li>
</ul>

<p>```
PubkeyAuthentication yes
PermitRootLogin yes</p>

<p>```</p>

<ul>
  <li>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</li>
</ul>

<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>

<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>

<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>

<ul>
  <li>验证无误，关闭密码登陆</li>
</ul>

<p>```
PasswordAuthentication no
[root@host .ssh]$ service sshd restart</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wsl Best Practice]]></title>
    <link href="https://happy123.me/blog/2019/01/16/wsl-best-practice/"/>
    <updated>2019-01-16T14:13:58+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/wsl-best-practice</id>
    <content type="html"><![CDATA[<p>WSL用了一年，感觉还不错。尤其是在我的机器上pypy3.5版本的<code>SHA512 pbkdf</code>计算性能竟然超越了原生Linux和Windows。成为Python运行效率最高的平台，实在是匪夷所思的事情。</p>

<p>WSL最让我满意的，是命令行里面可以结合Windows和Linux的命令行工具来管道处理，这个实在是太赞了。纯粹计算类的程序，Windows上面有很多现成的命令行工具，现在终于能:</p>

<p>```
ping.exe -t xxx.xxx.xxx.xxx|grep xxxx|echo -I xxx ~~~</p>

<p>```</p>

<p>这样来搞了，事实上，我自己写了很多Python脚本来处理Powershell自带的很多工具输出的内容，还有不少GPU运算程序大多数跑在Windows上面，能直接重定向到Linux上面实在太好了。</p>

<p>另外，WSL网络协议栈和Windows是共享的，倒是直接省了一个事，我直接把http_proxy配置成本地的shadowsock服务就很安逸的翻墙了；方便。</p>

<p>最后，就等着磁盘性能的改善了。</p>

<p>下面记一下常用的坑：</p>

<ul>
  <li>如果开机之后插拔一个移动硬盘，需要手工在WSL中执行重新挂载命令：</li>
</ul>

<p>```
sudo umount /mnt/g &amp;&amp; sudo mount -t drvfs “G:” /mnt/g</p>

<p>```</p>

<ul>
  <li>WSL跟最新2019版本的卡巴斯基冲突，卡巴斯基默认会过滤所有HTTP流量</li>
</ul>

<p>目前无解；要么禁用卡巴斯基的HTTP过滤功能，要么回退2018版本</p>

<p>最后，多个版本实验之后，锁定Win10 1709我也能连续3个月不关机了，稳定性可喜可贺。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alias Rm to Mv]]></title>
    <link href="https://happy123.me/blog/2019/01/16/alias-rm-to-mv/"/>
    <updated>2019-01-16T14:00:18+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/alias-rm-to-mv</id>
    <content type="html"><![CDATA[<p>之前一直简单的用</p>

<p>``` 
alias rm=’mv -f $@ ~/.trash’</p>

<p>``` </p>

<p>取代rm命令。</p>

<p>这样用着有个不便的地方，就是有时候做个脚本命令，带个<code>;</code>的时候会解析有问题。今天突然发现一个用函数来替代的好办法，记一下：</p>

<p>```
alias rm=’move1(){ /bin/mv -f $@ ~/.trash/; };move1 $@’</p>

<p>```</p>

<p>参考资料：</p>

<p>https://www.cnblogs.com/f-ck-need-u/p/7385133.html</p>
]]></content>
  </entry>
  
</feed>
