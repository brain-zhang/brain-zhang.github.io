<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-11-11T10:55:51+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FRP内网穿透]]></title>
    <link href="https://happy123.me/blog/2019/11/11/frpnei-wang-chuan-tou/"/>
    <updated>2019-11-11T10:45:34+08:00</updated>
    <id>https://happy123.me/blog/2019/11/11/frpnei-wang-chuan-tou</id>
    <content type="html"><![CDATA[<p>对于没有公网 IP 的内网用户来说，远程管理或在外网访问内网机器上的服务是一个问题。之前一直用最简单的nc做反代，折腾了几次之后迁移到FRP上面了；记录一下ABC;</p>

<!-- more -->

<p>内网穿透工具 FRP，FRP 全名：Fast Reverse Proxy。</p>

<p>项目地址: https://github.com/fatedier/frp</p>

<h4 id="frp-">FRP 的作用</h4>

<ul>
  <li>
    <p>利用处于内网或防火墙后的机器，对外网环境提供 HTTP 或 HTTPS 服务。</p>
  </li>
  <li>
    <p>对于 HTTP, HTTPS 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口。</p>
  </li>
  <li>
    <p>利用处于内网或防火墙后的机器，对外网环境提供 TCP 和 UDP 服务，例如在家里通过 SSH 访问处于公司内网环境内的主机。</p>
  </li>
</ul>

<h4 id="frp--1">FRP 安装</h4>
<p>FRP 采用 Go 语言开发，支持 Windows、Linux、MacOS、ARM等多平台部署。FRP 安装非常容易，只需下载对应系统平台的软件包，并解压就可用。</p>

<p>这里以 Linux 为例，为了方便管理我们把解压后的目录重命名为 frp ：</p>

<p><code>
 wget https://github.com/fatedier/frp/releases/download/v0.29.1/frp_0.29.1_linux_amd64.tar.gz
 tar xzvf frp_0.29.1_linux_amd64.tar.gz
 mv frp_0.29.1_linux_amd64 frp
 cp frp/frpc frp/frps /usr/bin/
</code></p>

<h4 id="frp">FRP服务端配置</h4>

<ul>
  <li>首先建立配置文件</li>
</ul>

<p><code>
mkdir /etc/frp
vim /etc/frp/frps.ini
</code></p>

<p>下面是模板，根据修改一下token，dashboard_user, dashboard_pwd，默认开了6000端口作为对外ssh端口， 7000作为frpc和frps通讯端口，7500端口作为web管理界面端口；</p>

<p>```
# [common] is integral section
[common]
# A literal address or host name for IPv6 must be enclosed
# in square brackets, as in “[::1]:80”, “[ipv6-host]:http” or “[ipv6-host%zone]:80”
bind_addr = 0.0.0.0
bind_port = 7000</p>

<h1 id="udp-port-to-help-make-udp-hole-to-penetrate-nat">udp port to help make udp hole to penetrate nat</h1>
<p>bind_udp_port = 7001</p>

<h1 id="udp-port-used-for-kcp-protocol-it-can-be-same-with-bindport">udp port used for kcp protocol, it can be same with ‘bind_port’</h1>
<p># if not set, kcp is disabled in frps
kcp_bind_port = 7000</p>

<h1 id="specify-which-address-proxy-will-listen-for-default-value-is-same-with-bindaddr">specify which address proxy will listen for, default value is same with bind_addr</h1>
<p># proxy_bind_addr = 127.0.0.1</p>

<h1 id="if-you-want-to-support-virtual-host-you-must-set-the-http-port-for-listening-optional">if you want to support virtual host, you must set the http port for listening (optional)</h1>
<p># Note: http port and https port can be same with bind_port
vhost_http_port = 80
vhost_https_port = 443</p>

<h1 id="response-header-timeoutseconds-for-vhost-http-server-default-is-60s">response header timeout(seconds) for vhost http server, default is 60s</h1>
<p># vhost_http_timeout = 60</p>

<h1 id="set-dashboardaddr-and-dashboardport-to-view-dashboard-of-frps">set dashboard_addr and dashboard_port to view dashboard of frps</h1>
<p># dashboard_addr’s default value is same with bind_addr
# dashboard is available only if dashboard_port is set
dashboard_addr = 0.0.0.0
dashboard_port = 7500</p>

<h1 id="dashboard-user-and-passwd-for-basic-auth-protect-if-not-set-both-default-value-is-admin">dashboard user and passwd for basic auth protect, if not set, both default value is admin</h1>
<p>dashboard_user = user
dashboard_pwd = user</p>

<h1 id="dashboard-assets-directoryonly-for-debug-mode">dashboard assets directory(only for debug mode)</h1>
<p># assets_dir = ./static
# console or real logFile path like ./frps.log
log_file = /var/log/frps.log</p>

<h1 id="trace-debug-info-warn-error">trace, debug, info, warn, error</h1>
<p>log_level = info</p>

<p>log_max_days = 3</p>

<h1 id="disable-log-colors-when-logfile-is-console-default-is-false">disable log colors when log_file is console, default is false</h1>
<p>disable_log_color = false</p>

<h1 id="auth-token">auth token</h1>
<p>token = 123456frp</p>

<h1 id="heartbeat-configure-its-not-recommended-to-modify-the-default-value">heartbeat configure, it’s not recommended to modify the default value</h1>
<p># the default value of heartbeat_timeout is 90
# heartbeat_timeout = 90</p>

<h1 id="only-allow-frpc-to-bind-ports-you-list-if-you-set-nothing-there-wont-be-any-limit">only allow frpc to bind ports you list, if you set nothing, there won’t be any limit</h1>
<p>#allow_ports = 2000-3000,3001,3003,4000-50000
allow_ports = 80,6000,8080,18332,18333,28332,28333,60000-60010</p>

<h1 id="poolcount-in-each-proxy-will-change-to-maxpoolcount-if-they-exceed-the-maximum-value">pool_count in each proxy will change to max_pool_count if they exceed the maximum value</h1>
<p>max_pool_count = 5</p>

<h1 id="if-subdomainhost-is-not-empty-you-can-set-subdomain-when-type-is-http-or-https-in-frpcs-configure-file">if subdomain_host is not empty, you can set subdomain when type is http or https in frpc’s configure file</h1>
<p># when subdomain is test, the host used by routing is test.frps.com
subdomain_host = frps.com</p>

<h1 id="if-tcp-stream-multiplexing-is-used-default-is-true">if tcp stream multiplexing is used, default is true</h1>
<p>tcp_mux = true</p>

<h1 id="custom-404-page-for-http-requests">custom 404 page for HTTP requests</h1>
<p># custom_404_page = /path/to/404.html</p>

<p>```</p>

<ul>
  <li>再建立systemd 启动脚本</li>
</ul>

<p>```
vim /lib/systemd/system/frps.service</p>

<p>[Unit]
Description=Frp Server Service
After=network.target</p>

<p>[Service]
Type=simple
User=root
Restart=on-failure
RestartSec=5s
ExecStart=/usr/bin/frps -c /etc/frp/frps.ini</p>

<p>[Install]
WantedBy=multi-user.target
```</p>

<ul>
  <li>启动服务，再设置为开机启动</li>
</ul>

<p><code>
systemctl start frps
systemctl enable frps
</code></p>

<h4 id="frp-1">FRP客户端配置</h4>

<ul>
  <li>首先建立配置文件</li>
</ul>

<p><code>
mkdir /etc/frp
vim /etc/frp/frpc.ini
</code></p>

<p>下面是模板，根据修改server_addr、admin_user, admin_pwd字段; token要设置的跟服务端的token相同；</p>

<p>```
# [common] is integral section
[common]
# A literal address or host name for IPv6 must be enclosed
# in square brackets, as in “[::1]:80”, “[ipv6-host]:http” or “[ipv6-host%zone]:80”
server_addr = x.x.x.x
server_port = 7000</p>

<h1 id="if-you-want-to-connect-frps-by-http-proxy-or-socks5-proxy-you-can-set-httpproxy-here-or-in-global-environment-variables">if you want to connect frps by http proxy or socks5 proxy, you can set http_proxy here or in global environment variables</h1>
<p># it only works when protocol is tcp
# http_proxy = http://user:passwd@192.168.1.128:8080
# http_proxy = socks5://user:passwd@192.168.1.128:1080</p>

<h1 id="console-or-real-logfile-path-like-frpclog">console or real logFile path like ./frpc.log</h1>
<p>log_file = /var/log/frpc.log</p>

<h1 id="trace-debug-info-warn-error-1">trace, debug, info, warn, error</h1>
<p>log_level = info</p>

<p>log_max_days = 3</p>

<h1 id="disable-log-colors-when-logfile-is-console-default-is-false-1">disable log colors when log_file is console, default is false</h1>
<p>disable_log_color = false</p>

<h1 id="for-authentication">for authentication</h1>
<p>token = 123456frp</p>

<h1 id="set-admin-address-for-control-frpcs-action-by-http-api-such-as-reload">set admin address for control frpc’s action by http api such as reload</h1>
<p>admin_addr = 127.0.0.1
admin_port = 7400
admin_user = user
admin_pwd = user
# Admin assets directory. By default, these assets are bundled with frpc.
# assets_dir = ./static</p>

<h1 id="connections-will-be-established-in-advance-default-value-is-zero">connections will be established in advance, default value is zero</h1>
<p>pool_count = 5</p>

<h1 id="if-tcp-stream-multiplexing-is-used-default-is-true-it-must-be-same-with-frps">if tcp stream multiplexing is used, default is true, it must be same with frps</h1>
<p>tcp_mux = true</p>

<h1 id="your-proxy-name-will-be-changed-to-userproxy">your proxy name will be changed to {user}.{proxy}</h1>
<p>user = brainzhang.bitcoin.testnet</p>

<h1 id="decide-if-exit-program-when-first-login-failed-otherwise-continuous-relogin-to-frps">decide if exit program when first login failed, otherwise continuous relogin to frps</h1>
<p># default is true
login_fail_exit = true</p>

<h1 id="communication-protocol-used-to-connect-to-server">communication protocol used to connect to server</h1>
<p># now it supports tcp and kcp and websocket, default is tcp
protocol = tcp</p>

<h1 id="if-tlsenable-is-true-frpc-will-connect-frps-by-tls">if tls_enable is true, frpc will connect frps by tls</h1>
<p>tls_enable = true</p>

<h1 id="specify-a-dns-server-so-frpc-will-use-this-instead-of-default-one">specify a dns server, so frpc will use this instead of default one</h1>
<p># dns_server = 8.8.8.8</p>

<h1 id="proxy-names-you-want-to-start-seperated-by-">proxy names you want to start seperated by ‘,’</h1>
<p># default is empty, means all proxies
# start = ssh,dns</p>

<h1 id="heartbeat-configure-its-not-recommended-to-modify-the-default-value-1">heartbeat configure, it’s not recommended to modify the default value</h1>
<p># the default value of heartbeat_interval is 10 and heartbeat_timeout is 90
# heartbeat_interval = 30
# heartbeat_timeout = 90</p>

<h1 id="ssh-is-the-unique-proxy-name">‘ssh’ is the unique proxy name</h1>
<p># if user in [common] section is not empty, it will be changed to {user}.{proxy} such as ‘your_name.ssh’
[ssh]
# tcp | udp | http | https | stcp | xtcp, default is tcp
type = tcp
local_ip = 127.0.0.1
local_port = 22
# true or false, if true, messages between frps and frpc will be encrypted, default is false
use_encryption = false
# if true, message will be compressed
use_compression = true
# remote port listen by frps
remote_port = 6000
# frps will load balancing connections for proxies in same group
#group = test_group
## group should have same group key
#group_key = 123456
## enable health check for the backend service, it support ‘tcp’ and ‘http’ now
## frpc will connect local service’s port to detect it’s healthy status
#health_check_type = tcp
## health check connection timeout
#health_check_timeout_s = 3
## if continuous failed in 3 times, the proxy will be removed from frps
#health_check_max_failed = 3
## every 10 seconds will do a health check
#health_check_interval_s = 10</p>

<h1 id="sshrandom">[ssh_random]</h1>
<p>#type = tcp
#local_ip = 127.0.0.1
#local_port = 22
## if remote_port is 0, frps will assign a random port for you
#remote_port = 0</p>

<h1 id="if-you-want-to-expose-multiple-ports-add-range-prefix-to-the-section-name">if you want to expose multiple ports, add ‘range:’ prefix to the section name</h1>
<p># frpc will generate multiple proxies such as ‘tcp_port<em>6010’, ‘tcp_port</em>6011’ and so on.
[range:tcp_port]
type = tcp
local_ip = 127.0.0.1
#local_port = 6010-6020,6022,6024-6028,
#remote_port = 6010-6020,6022,6024-6028
local_port = 8080,18332,18333,28332,28333,60000-60010
remote_port = 8080,18332,18333,28332,28333,60000-60010
use_encryption = false
use_compression = false</p>

<p>```</p>

<ul>
  <li>再建立systemd 启动脚本</li>
</ul>

<p>```
vim /lib/systemd/system/frpc.service</p>

<p>[Unit]
Description=Frp Client Service
After=network.target</p>

<p>[Service]
Type=simple
User=root
Restart=on-failure
RestartSec=5s
ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini
ExecReload=/usr/bin/frpc reload -c /etc/frp/frpc.ini</p>

<p>[Install]
WantedBy=multi-user.target</p>

<p>```</p>

<ul>
  <li>启动服务，再设置为开机启动</li>
</ul>

<p><code>
systemctl start frpc
systemctl enable frpc
</code></p>

<h4 id="section">测试</h4>

<p>现在可以从外网通过 frps服务端的ip(比如x.x.x.x)中转，访问内网了；比如ssh:</p>

<p><code>
ssh -oPort=6000 root@x.x.x.x
</code></p>

<p>同样的，如果内网开通了某些服务，比如我们的配置模板里面已经映射出了8080,18332,18333,28332,28333,60000-60010这些端口，这些端口同样的映射到服务端了；</p>

<p>比如，我们在内网运行一个简单的web服务:</p>

<p><code>
python -m SimpleHTTPServer 8080
</code></p>

<p>可以通过frps服务端的ip(比如x.x.x.x)访问这个服务：</p>

<p><code>
curl http://x.x.x.x:8080
</code></p>

<p>我们也可以在内网运行要给bitcoin全节点+lnd，然后关闭不必要的服务，再运行一个轻量的vps，在vps上部署Tor服务，这样我们就可以通过多重跳板把闪电网络热钱包隐藏到Tor网络里面了，保证了安全性；</p>

<h4 id="section-1">管理</h4>

<p>可以通过下面的地址进入web管理界面，用户名和密码就是frps.ini中配置的dashboard_user、dashboard_pwd；</p>

<p>http://x.x.x.x:7500</p>

<h4 id="section-2">扩展</h4>

<p>FRP还有非常多的功能，比如虚拟主机、多路复用、负载均衡、点对点内网穿透等等，请参考官方文档：</p>

<p>https://github.com/fatedier/frp/blob/master/README_zh.md</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Run Tmux Service Scripts on Ubuntu Start Up]]></title>
    <link href="https://happy123.me/blog/2019/10/30/how-to-run-tmux-service-scripts-on-ubuntu-start-up/"/>
    <updated>2019-10-30T10:11:38+08:00</updated>
    <id>https://happy123.me/blog/2019/10/30/how-to-run-tmux-service-scripts-on-ubuntu-start-up</id>
    <content type="html"><![CDATA[<p>是的，做了无数遍还是不长记性，昨天又在这上面踩坑了；在ubuntu上写的启动脚本不执行，仅仅是可执行权限和用户权限的问题，又浪费了一上午；</p>

<!-- more -->

<p>在unbuntu启动时自动做一些工作，最佳实践是：</p>

<h4 id="section">你想要执行一个服务</h4>

<ul>
  <li>如果是比较老的ubuntu (version&lt;=14.04LTS);</li>
</ul>

<p>这个时候你需要利用ubuntu的<a href="http://upstart.ubuntu.com/">upstart机制</a></p>

<p>简单说来，就是将一个这样的脚本:</p>

<p><code>
start on startup
task
exec /path/to/command
</code></p>

<p>存为taskxxx.conf文件，放到/etc/init 目录下面(这将会在开机时用root用户权限启动)；</p>

<p>或者存为 ~/.config/upstart(这将会在开机时用当前用户权限启动)</p>

<ul>
  <li>如果你是比较现代的ubuntu (version&gt;=16.04LTS)</li>
</ul>

<p>你需要利用 <a href="https://github.com/systemd/systemd">systemd</a> 服务，这个我们之前写文章科普过：</p>

<p>https://happy123.me/blog/2016/08/22/how-to-write-standard-startup-script/</p>

<h4 id="section-1">仅仅想执行一条简单的命令</h4>

<p><code>
sudo nano /etc/rc.local
</code></p>

<p>加入执行的命令，不要忘了最后加exit</p>

<p><code>
/opt/tmux.sh
exit 0
</code></p>

<p>增加可执行权限</p>

<p><code>
sudo chmod +x /etc/rc.local
</code></p>

<p>注意：</p>

<ul>
  <li>要有可执行权限，这个最容易踩坑，ubuntu安装完毕 /etc/rc.local 是没有可执行权限的</li>
  <li>注意执行命令的ENV变量，不确定的时候要在命令签名设定SHELL ENV Variable</li>
  <li>如果是执行一个脚本，注意脚本命令调用的shell (bash or sh or zsh)，以及ENV Variable</li>
  <li>注意执行脚本、执行命令的用户</li>
</ul>

<h4 id="section-2">如果是修改一个环境变量</h4>

<p>修改当前用户:</p>

<p><code>
nano ~/.bashrc
</code></p>

<p>所有用户生效:</p>

<p><code>
nano ~/etc/profile
</code></p>

<h4 id="section-3">最后，附赠最简单粗暴的开机执行任务方式</h4>

<p>就是在/etc/rc.local 里面启动一个tmux session，在里面执行想要运行的命令；简单粗暴有效</p>

<p>来个模板:</p>

<p>```
#!/bin/bash
# description “Start Tmux”</p>

<h1 id="sleep-for-5-seconds-if-you-are-starting-more-than-one-tmux-session">Sleep for 5 seconds. If you are starting more than one tmux session</h1>
<p>#   “at the same time”, then make sure they all sleep for different periods
#   or you can experience problems
/bin/sleep 5
# Ensure the environment is available
source ~/.bashrc
# Create a new tmux session named newscrawler..
/usr/bin/tmux new-session -d -s bitcoin
# …and control the tmux session (initially ensure the environment
#   is available, then run commands)</p>

<h1 id="usrbintmux-send-keys--t-bitcoincash0-source-bashrc-c-m">/usr/bin/tmux send-keys -t bitcoincash:0 “source ~/.bashrc” C-m</h1>
<p>tmux new-window -n console -t bitcoin
/bin/sleep 3
/usr/bin/tmux send-keys -t bitcoin:0 “cd /opt/bitcoin &amp;&amp; ./startbitcoind.sh” C-m
/bin/sleep 3
/usr/bin/tmux send-keys -t bitcoin:1 “cd /opt/bitcoin &amp;&amp; ./checkwallet start” C-m</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paste Fails When Using Bracketed-paste-magic on zsh5.1.1]]></title>
    <link href="https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1/"/>
    <updated>2019-09-13T10:50:31+08:00</updated>
    <id>https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1</id>
    <content type="html"><![CDATA[<p>突然碰到了zsh5.1.1的一个bug，粘贴中文的时候会把shell freeze；</p>

<p>不知道是不是on-my-zsh升级的时候搞坏的，一通搜索发现了这个:</p>

<p>https://github.com/zsh-users/zsh-autosuggestions/issues/102</p>

<p>没有升级zsh，我直接到配置文件里把那段自动转义的功能注释掉了，嗯，简单粗暴~~~这东西我也不想天天升级；</p>

<p><code>
~/.oh-my-zsh/lib/misc.zsh
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using a GPG Key and Ssh Auth]]></title>
    <link href="https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth/"/>
    <updated>2019-08-16T16:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth</id>
    <content type="html"><![CDATA[<p>在我的一台服务器被数不清的脚本小子暴力尝试登陆N次后，我下定决心将所有的开发环境换成统一的ssh key；并禁止用户登陆；</p>

<p>其中最折腾的部分就是使用我的GPG Key统一所有的ssh 环境；我也很纳闷，为什么自己没有早点搞定这些事情；</p>

<p>众所周知，GPG和Openssl的key是不兼容的，所以统一环境还是花了不少时间，主要是参考了这篇文章：</p>

<p>https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth</p>

<p>常用命令:
<!-- more --></p>

<h3 id="gpg">GPG</h3>

<ul>
  <li>生成证书</li>
</ul>

<p>```
gpg –gen-key</p>

<p>```</p>

<ul>
  <li>生成撤销证书</li>
</ul>

<p>```
gpg –gen-revoke [用户ID]</p>

<p>```</p>

<ul>
  <li>列出所有密钥</li>
</ul>

<p>```
gpg –list-keys</p>

<p>```</p>

<p>输出</p>

<p>```
/home/brain/.gnupg/pubring.gpg
——————————-
pub   4096R/xxxxxxxx 2018-08-16
uid                  brain.zhang (happy123.me) &lt;brain.zhangbin#xxx.com&gt;
sub   4096R/yyyyyyyy 2018-08-16</p>

<p>```</p>

<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示subkey。</p>

<ul>
  <li>输出密钥</li>
</ul>

<p>```
gpg –armor –output public-key.txt –export [用户ID]</p>

<p>```</p>

<ul>
  <li>输出密钥时转换私钥</li>
</ul>

<p>```
gpg –armor –output private-key.txt –export-secret-keys</p>

<p>```</p>

<ul>
  <li>上传公钥</li>
</ul>

<p>```
gpg –keyserver keys.gnupg.net –send-keys [pub key ID] 
…
gpg –keyserver keys.gnupg.net –search-keys brain.zhang</p>

<p>```</p>

<ul>
  <li>生成公钥指纹供别人检查</li>
</ul>

<p>```
gpg –fingerprint [用户ID]</p>

<p>```</p>

<ul>
  <li>加密文件</li>
</ul>

<p>```
gpg –recipient [用户ID] –output demo.en.txt –encrypt demo.txt</p>

<p>```</p>

<ul>
  <li>解密文件</li>
</ul>

<p>```
gpg –decrypt demo.en.txt –output demo.de.txt</p>

<p>```</p>

<ul>
  <li>对文件签名</li>
</ul>

<p>```
gpg –clearsign demo.txt</p>

<p>```</p>

<ul>
  <li>获得单独的签名文件</li>
</ul>

<p>```
gpg –armor –detach-sign demo.txt</p>

<p>```</p>

<ul>
  <li>验证签名</li>
</ul>

<p>```
gpg –verify demo.txt.asc demo.txt</p>

<p>```</p>

<h3 id="section">导入第三方公钥</h3>

<ul>
  <li>获得公钥</li>
</ul>

<p>```
gpg –keyserver keys.gnupg.net –search-keys <user>
...
gpg --keyserver hkp://subkeys.pgp.net --search-keys brain.zhang</user></p>

<p>```</p>

<ul>
  <li>验证公钥</li>
</ul>

<p>```
 gpg –edit-key <key /></p>

<p>```
你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入quit 退出。</p>

<h3 id="githubgpg">在Github中使用GPG</h3>

<ul>
  <li>输出key id</li>
</ul>

<p>```
gpg –list-secret-keys –keyid-format LONG</p>

<p>```</p>

<ul>
  <li>设置提交</li>
</ul>

<p>```
 git config  user.signingkey <key /></p>

<p>```</p>

<ul>
  <li>对单次提交进行签名： </li>
</ul>

<p>```
git commit -S -m “-S选项表示对此次提交使用gpg进行签名”</p>

<p>```</p>

<ul>
  <li>签名标签</li>
</ul>

<p>```
git tag -s <tag /></p>

<p>```</p>

<h3 id="ssh-server-gen">ssh server gen</h3>

<ul>
  <li>制作密钥对</li>
</ul>

<p>```
[root@host ~]$ ssh-keygen </p>

<p>```</p>

<ul>
  <li>把生成的/root/.ssh/id_rsa.pub拷贝到在服务器上，安装公钥</li>
</ul>

<p>```
[root@host ~]$ cd .ssh
[root@host .ssh]$ cat id_rsa.pub » authorized_keys
[root@host .ssh]$ chmod 600 authorized_keys
[root@host .ssh]$ chmod 700 ~/.ssh</p>

<p>```</p>

<ul>
  <li>设置 SSHD，打开密钥登录功能
编辑 /etc/ssh/sshd_config 文件，进行如下设置：</li>
</ul>

<p>```
PubkeyAuthentication yes
PermitRootLogin yes</p>

<p>```</p>

<ul>
  <li>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</li>
</ul>

<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>

<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>

<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>

<ul>
  <li>验证无误，关闭密码登陆</li>
</ul>

<p>```
PasswordAuthentication no
[root@host .ssh]$ service sshd restart</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wsl Best Practice]]></title>
    <link href="https://happy123.me/blog/2019/01/16/wsl-best-practice/"/>
    <updated>2019-01-16T14:13:58+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/wsl-best-practice</id>
    <content type="html"><![CDATA[<p>WSL用了一年，感觉还不错。尤其是在我的机器上pypy3.5版本的<code>SHA512 pbkdf</code>计算性能竟然超越了原生Linux和Windows。成为Python运行效率最高的平台，实在是匪夷所思的事情。</p>

<p>WSL最让我满意的，是命令行里面可以结合Windows和Linux的命令行工具来管道处理，这个实在是太赞了。纯粹计算类的程序，Windows上面有很多现成的命令行工具，现在终于能:</p>

<p>```
ping.exe -t xxx.xxx.xxx.xxx|grep xxxx|echo -I xxx ~~~</p>

<p>```</p>

<p>这样来搞了，事实上，我自己写了很多Python脚本来处理Powershell自带的很多工具输出的内容，还有不少GPU运算程序大多数跑在Windows上面，能直接重定向到Linux上面实在太好了。</p>

<p>另外，WSL网络协议栈和Windows是共享的，倒是直接省了一个事，我直接把http_proxy配置成本地的shadowsock服务就很安逸的翻墙了；方便。</p>

<p>最后，就等着磁盘性能的改善了。</p>

<p>下面记一下常用的坑：</p>

<ul>
  <li>如果开机之后插拔一个移动硬盘，需要手工在WSL中执行重新挂载命令：</li>
</ul>

<p>```
sudo umount /mnt/g &amp;&amp; sudo mount -t drvfs “G:” /mnt/g</p>

<p>```</p>

<ul>
  <li>WSL跟最新2019版本的卡巴斯基冲突，卡巴斯基默认会过滤所有HTTP流量</li>
</ul>

<p>目前无解；要么禁用卡巴斯基的HTTP过滤功能，要么回退2018版本</p>

<p>最后，多个版本实验之后，锁定Win10 1709我也能连续3个月不关机了，稳定性可喜可贺。</p>
]]></content>
  </entry>
  
</feed>
