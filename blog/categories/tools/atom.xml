<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2021-01-09T16:29:08+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Modify an Invalid '/etc/sudoers' File?]]></title>
    <link href="https://happy123.me/blog/2021/01/09/how-to-modify-an-invalid-slash-etc-slash-sudoers-file/"/>
    <updated>2021-01-09T16:16:31+08:00</updated>
    <id>https://happy123.me/blog/2021/01/09/how-to-modify-an-invalid-slash-etc-slash-sudoers-file</id>
    <content type="html"><![CDATA[<p>刚说小心驶得万年船，就想自己偷奸耍滑，手工裸编辑 <code>/etc/sudoers</code> 文件把sudo权限搞挂了…-_-</p>

<p>仔细瞅了瞅，少加了一个冒号，导致现在进退两难…</p>

<!-- more -->

<p>解决这个问题的标准方法是pkexec，参考：</p>

<p>https://askubuntu.com/questions/73864/how-to-modify-an-invalid-etc-sudoers-file</p>

<p>但是执行pkexec的时候又暴露了一个问题:</p>

<p><code>
polkit-agent-helper-1: error response to PolicyKit daemon: GDBus.Error:org.freedesktop.PolicyKit1.Error.Failed: No session for cookie
==== AUTHENTICATION FAILED ===
Error executing command as another user: Not authorized
</code></p>

<p>最后解决需要一点小技巧:</p>

<ol>
  <li>
    <p>在第一个shell种执行:<code>echo $$</code>，得到PID</p>
  </li>
  <li>
    <p>再开一个shell，再执行<code>pkttyagent --process PID</code></p>
  </li>
  <li>
    <p>再回到第一个shell执行<code>pkexec visudo</code></p>
  </li>
</ol>

<p>参考：</p>

<p>https://github.com/NixOS/nixpkgs/issues/18012</p>

<p>最后的教训是：人就是这样，要求别人头头是道，轮到自己偷奸耍滑；早用<code>visudo</code>还有这种事吗？</p>

<p>三省吾身，不说了，我得赶紧检查下自己其它耍滑头找方便留下的口子;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux服务器极简安全配置]]></title>
    <link href="https://happy123.me/blog/2021/01/06/linuxfu-wu-qi-de-ji-jian-an-quan-pei-zhi/"/>
    <updated>2021-01-06T17:33:38+08:00</updated>
    <id>https://happy123.me/blog/2021/01/06/linuxfu-wu-qi-de-ji-jian-an-quan-pei-zhi</id>
    <content type="html"><![CDATA[<p>网络知识了解的越多，就越胆小；也许，这就是江湖吧；</p>

<p>当配置一台新的Linux服务器并上线时，其实就是将Server暴露到了炮火横飞的战场上，任何的大意都会让其万劫不复；但由于永恒的人性的弱点，我们总是在安全和便利之间摇摆；</p>

<p>本文希望能提供一种最简单的办法，帮助我们抵抗大多数的炮火；</p>

<!-- more -->

<h4 id="section">用户管理</h4>

<p>最重要的就是不要用root用户操作，当一台服务器部署初期，为不同用途划分不同用户组以及用户能避免绝大多数悲剧；</p>

<ol>
  <li>
    <p>增加一个用户组 <code>develop</code></p>

    <p><code>
 groupadd develop
</code></p>
  </li>
  <li>
    <p>增加一个用户<code>brain</code>，设置密码，并把他加入到组 <code>develop</code></p>

    <p><code>
 useradd -d /home/brain -s /bin/bash -m brain
</code></p>

    <p><code>
 passwd brain
</code></p>

    <p><code>
 usermod -a -G develop brain
</code></p>
  </li>
  <li>
    <p>允许用户登录</p>

    <p><code>
 vim /etc/sudoers
</code></p>

    <p>找到类似下面的一行，并在后面增加一行</p>

    <p><code>
 root     ALL=(ALL:ALL) ALL
</code></p>

    <p><code>
 brain    ALL=(ALL) NOPASSWD: ALL
</code></p>

    <p>上面的NOPASSWD表示，切换sudo的时候，不需要输入密码，这样比较省事。如果出于安全考虑，也可以强制要求输入密码。</p>

    <p><code>
 root    ALL=(ALL:ALL) ALL
</code></p>

    <p><code>
 brain    ALL=(ALL:ALL) ALL
</code></p>

    <p>然后，切换到新用户的身份，检查到这一步为止，是否一切正常。</p>

    <p><code>
 su brain
</code></p>
  </li>
</ol>

<h4 id="section-1">防火墙</h4>

<p>防火墙为我们抵抗绝大多数的脚本小子的攻击，是最省力，性价比最高的配置，切勿偷懒;</p>

<p>几乎所有的公有云都提供了非常傻瓜化的web 操作界面，来设置防火墙规则，一般情况下这些设置足够了；</p>

<p>设置第一原则是：只开放必要的端口</p>

<p>如果是自己设置防火墙，iptable的使用比较复杂，我们采用最简单的规则链:</p>

<p>待整理……</p>

<h4 id="sshd">sshd配置</h4>

<p>几条最简单的配置，即能避免90%以上的恶意嗅探；</p>

<ol>
  <li>
    <p>修改默认端口</p>

    <p><code>
 vim /etc/ssh/sshd_config
</code></p>

    <p>找到默认的22端口</p>

    <p><code>
 Port 22
</code></p>

    <p>修改为</p>

    <p><code>
 Port 12222
</code></p>
  </li>
  <li>
    <p>DNS</p>

    <p><code>
 UseDNS no
</code>
 提升ssh连接速度</p>
  </li>
  <li>
    <p>Key</p>

    <p>首先，确定有SSH公钥（一般是文件~/.ssh/id_rsa.pub），如果没有的话，使用ssh-keygen命令生成一个</p>

    <p><code>
 echo "ssh-rsa [your public key]" &gt; ~/.ssh/authorized_keys
</code></p>

    <p><code>
 sudo chmod 600 ~/.ssh/authorized_keys &amp;&amp; chmod 700 ~/.ssh/
</code></p>

    <p>修改/etc/ssh/sshd_config</p>

    <p><code>
 PermitRootLogin no
</code></p>

    <p><code>
 PermitEmptyPasswords no
</code></p>

    <p><code>
 PasswordAuthentication no
</code></p>

    <p><code>
 RSAAuthentication yes
</code></p>

    <p><code>
 PubkeyAuthentication yes
</code></p>

    <p><code>
 AuthorizedKeysFile .ssh/authorized_keys
</code></p>
  </li>
  <li>
    <p>重新启动sshd服务让配置生效</p>

    <p><code>
 systemctl restart sshd
</code></p>
  </li>
  <li>
    <p>验证</p>

    <p>注意，此时不要退出终端；而是另开一个终端，验证配置无误，可以正常登陆后再关闭老终端；</p>

    <p>如果出现什么问题无法登录，而之前的终端窗口又关闭了，如果是远程机房，那就有得麻烦了。所以一切验证无误后再收工，是个好习惯。</p>
  </li>
</ol>

<h4 id="fail2ban">Fail2Ban</h4>

<p>警惕那些不怀好意的撞库者，用Fail2Ban 将尝试暴力破解的脚本小子自动封禁</p>

<ul>
  <li>
    <p>安装</p>

    <p>centos:
  <code>
  yum -y install epel-release
 </code></p>

    <p><code>
  sudo yum install fail2ban
 </code></p>

    <p>ubuntu:
  <code>
  sudo apt-get install fail2ban
 </code></p>
  </li>
  <li>
    <p>编辑规则文件</p>
  </li>
</ul>

<p>```
    vim /etc/fail2ban/jail.local
    [DEFAULT]
    ignoreip = 127.0.0.1/8
    bantime  = 86400
    maxretry = 5
    findtime = 1800
    destemail = xxxx@xxx.com
    sender = xxxx@gmail.com
    mta = mail
    protocol = tcp
    banaction = firewallcmd-ipset
    action = %(action_mwl)s</p>

<pre><code>[sshd]
enabled = true
filter  = sshd
port    = 12222
action = %(action_mwl)s
logpath = /var/log/secure ```
</code></pre>

<ul>
  <li>设定邮件转发</li>
</ul>

<p>```
    vim /etc/nail.rc</p>

<pre><code>## Add sendmail settings
set from=xxxx@gmail.com
set smtp=smtps:smtp.gmail.com:587
set smtp-auth-user=xxxx@gmail.com
set smtp-auth-password=xxxxx
set smtp-auth=login
set ssl-verify=ignore
set nss-config-dir=/etc/pki/nssdb ```
</code></pre>

<ul>
  <li>设定邮件模板</li>
</ul>

<p>```
     vim /etc/fail2ban/action.d/mail-whois-lines.conf</p>

<pre><code># Fail2Ban configuration file
#
# Author: Cyril Jaquier
#
#

[Definition]

# Option: actionstart
# Notes.: command executed once at the start of Fail2Ban.
# Values: CMD
#
actionstart = printf %%b "Hi,\n The jail &lt;name&gt; has been started successfully.\n Regards,\n Fail2Ban"|mail -s "[Fail2Ban] &lt;name&gt;: started on `uname -n`" &lt;dest&gt;

# Option: actionstop
# Notes.: command executed once at the end of Fail2Ban
# Values: CMD
#
actionstop = printf %%b "Hi,\n The jail &lt;name&gt; has been stopped.\n Regards,\n Fail2Ban"|mail -s "[Fail2Ban] &lt;name&gt;: stopped on `uname -n`" &lt;dest&gt;

# Option: actioncheck
# Notes.: command executed once before each actionban command
# Values: CMD
#
actioncheck =

# Option: actionban
# Notes.: command executed when banning an IP. Take care that the
# command is executed with Fail2Ban user rights.
# Tags: See jail.conf(5) man page
# Values: CMD
#
actionban = printf %%b "Hi,\n The IP &lt;ip&gt; has just been banned by Fail2Ban after &lt;failures&gt; attempts against &lt;name&gt;.\n\n Here are more information about &lt;ip&gt;:\n `whois &lt;ip&gt;`\n `/bin/curl http://ip.taobao.com/service/getIpInfo.php?ip=&lt;ip&gt;`\n\n Regards,\n Fail2Ban"|mail -s "[Fail2Ban] &lt;name&gt;: banned &lt;ip&gt; from `uname -n`" &lt;dest&gt;

# Option: actionunban
# Notes.: command executed when unbanning an IP. Take care that the
# command is executed with Fail2Ban user rights.
# Tags: See jail.conf(5) man page
# Values: CMD
#
actionunban =

[Init]

# Default name of the chain
#
name = default

# Destination/Addressee of the mail
#
dest = root
</code></pre>

<p>```</p>

<ul>
  <li>启动服务，查看状态</li>
</ul>

<p><code>
    systemctl start fail2ban
    systemctl status fail2ban
    fail2ban-client status
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Sort by Length of String Followed by Alphabetical Order]]></title>
    <link href="https://happy123.me/blog/2020/08/17/how-to-sort-by-length-of-string-followed-by-alphabetical-order/"/>
    <updated>2020-08-17T08:34:52+08:00</updated>
    <id>https://happy123.me/blog/2020/08/17/how-to-sort-by-length-of-string-followed-by-alphabetical-order</id>
    <content type="html"><![CDATA[<p>shell中，多行文本，先按照字母长度排序，相同长度再按照字母序排列；</p>

<p>做了很多次，隔几天就忘，让人绝望：</p>

<p><code>
cat /tmp/xxx.txt|sort -u | awk '{print length($0), $0}'  | sort -k2,2n -k1,1n -k3,3 |cut -d" " -f2-|less
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xargs Sh -c Skipping the First Argument]]></title>
    <link href="https://happy123.me/blog/2020/08/12/xargs-sh-c-skipping-the-first-argument/"/>
    <updated>2020-08-12T16:46:27+08:00</updated>
    <id>https://happy123.me/blog/2020/08/12/xargs-sh-c-skipping-the-first-argument</id>
    <content type="html"><![CDATA[<p>其实这个问题已经见过很多次了，但是知其然不知其所以然；今天偶尔在stackoverflow上看到了，记录一下；</p>

<h4 id="shellarg1-arg2">shell中的arg1, arg2…</h4>

<p>在bash shell中，<code>$1</code>, <code>$2</code>代表arg1, arg2，比如</p>

<p>```
# echo hello world|xargs echo $1 $2</p>

<p>hello world
```</p>

<!-- more -->

<p><code>$0</code> 代表执行环境，如果是一个执行脚本的话，<code>$0</code> 代表其脚本名；比如下面这个脚本hello.sh:</p>

<p>```
#!/bin/bash</p>

<p>echo $0
echo $1
echo $2
```</p>

<p>执行:</p>

<p>```
# ./hello.sh arg1 arg2</p>

<p>```
会输出</p>

<p><code>
./hello.sh
arg1
arg2
</code></p>

<h4 id="xargs-sh--c-arg">xargs 调用sh -c 中的arg</h4>

<p>但是使用<code>xargs sh -c</code>时会出现一个比较疑惑的情况，比如执行:</p>

<p>```
# echo hello world|xargs sh -c ‘echo $1 $2’</p>

<p>world
```</p>

<p>此时<code>$1</code>代表world，<code>$2</code>已经没有值了；而执行</p>

<p>```
# echo hello world|xargs sh -c ‘echo $0 $1’</p>

<p>hello world
```</p>

<p>反而得到了正确结果；</p>

<h4 id="why">why</h4>

<p>之前我一直认为<code>xargs sh -c</code>调用的时候吃掉了<code>$0</code>，不求甚解；偶尔读了一下sh的手册才发现玄机:</p>

<blockquote>
  <p>From the documentation for the -c option:</p>
</blockquote>

<blockquote>
  <p>Read commands from the command_string operand. Set the value of special parameter 0 (see Special Parameters) from the value of the command_name operand and the positional parameters ($1, $2, and so on) in sequence from the remaining argument operands.</p>
</blockquote>

<p>就是说在上面这条命令中，其实是没有找到要执行的命令，或者说要执行的命令为空，而hello world作为<code>$1</code>, <code>$2</code>传给一个空命令了；</p>

<p>后面追加一个dummy的命令会看的更清楚:</p>

<p>```
# echo hello world|xargs sh -c ‘echo $1 $2’ _</p>

<p>hello world
```</p>

<p>后面我加了一条下划线作为xargs的dummy command，这样<code>$1</code>, <code>$2</code>就恢复正常了；</p>

<h4 id="section">总结</h4>

<p>虽然这是一个啥用也没有的Magic Topic，但是搞明白之后还是挺有意思的，娱乐用；</p>

<p>另外隐隐约约觉得这里面隐含着一些安全方面的问题，暂时只是一种感觉，将来需要留意有没有这方面的hack手段;</p>

<h4 id="section-1">引用</h4>

<p>https://stackoverflow.com/questions/41043163/xargs-sh-c-skipping-the-first-argument</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSL环境备份恢复]]></title>
    <link href="https://happy123.me/blog/2019/11/18/wslhuan-jing-bei-fen-hui-fu/"/>
    <updated>2019-11-18T11:04:27+08:00</updated>
    <id>https://happy123.me/blog/2019/11/18/wslhuan-jing-bei-fen-hui-fu</id>
    <content type="html"><![CDATA[<p>WSL环境是可以单独备份还原的，有个工具名为LxRunOffline:</p>

<p>https://github.com/DDoSolitary/LxRunOffline</p>

<p>release版本下载下来之后直接使用就可以；记录一下操作命令:</p>

<!-- more -->

<h4 id="wsl">备份wsl</h4>

<p><code>
LxRunOffline.exe export -n Ubuntu-18.04 -f ubuntu18.04.backup.tar.gz
</code></p>

<p>-n ：wsl的别名，就是之前用list查看的其中一个</p>

<p>-f ：备份的路径，我这直接备份到当前路径backup.tar.gz</p>

<h4 id="wsl-1">还原wsl</h4>

<p><code>
LxRunOffline.exe install -n Ubuntu-18.04 -d C:\wsl -f D:\temp\ubuntu18.04.backup.tar.gz
</code></p>

<p>-n ：起个名字</p>

<p>-d ：wsl安装目录</p>

<p>-f ：备份文件目录</p>

<h4 id="wsl-2">删除WSL环境</h4>

<p>可以直接用wsl原生的命令：wslconfig</p>

<p><code>
wslconfig /u Ubuntu-18.04
</code></p>
]]></content>
  </entry>
  
</feed>
