<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Living a Simple Life is a Happy Life]]></title>
  <link href="https://brain-zhang.github.io/blog/categories/tools/atom.xml" rel="self"/>
  <link href="https://brain-zhang.github.io/"/>
  <updated>2024-10-14T14:10:52+08:00</updated>
  <id>https://brain-zhang.github.io/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Resize Partition on Linux]]></title>
    <link href="https://brain-zhang.github.io/blog/2024/04/19/how-to-resize-partition-on-linux/"/>
    <updated>2024-04-19T16:16:46+08:00</updated>
    <id>https://brain-zhang.github.io/blog/2024/04/19/how-to-resize-partition-on-linux</id>
    <content type="html"><![CDATA[<p>之前操作Linux，扩容已有分区，一直是手工<code>fdisk</code>删除分区重建搞定的，这种方式不直观且容易出错；最近采用<code>parted</code>操作了以下，发现很直观；</p>

<p>比如我要对 /dev/sda1 从 100GB，扩容至200GB，操作如下</p>

<h3 id="section">查看当前分区情况</h3>

<p><code>
# 进入 parted 工具
$ sudo parted
GNU Parted 3.4
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
# 查看磁盘信息
(parted) print /dev/sda
</code></p>

<p>我只有 /dev/sda1 一个分区，因此很好办</p>

<h3 id="section-1">根分区扩容</h3>

<p><code>
# 进入 parted 工具
$ sudo parted /dev/sda
# 查看磁盘信息
(parted) print
# 此时应该只有一个分区，直接扩展这个分区
(parted)resizepart 1
Warning: Partition /dev/sda1 is being used. Are you sure you want to continue?
# 直接输入 yes 确认
Yes/No? yes
# 输入新的结束点
# 这里输入的数值，就是上方输出中 Disk: 后方的数值
End?  [200GB]? 200GB
# 扩展完成之后退出 parted
(parted) quit
</code></p>

<h3 id="resize2fs-">用resize2fs 工具扩展文件系统</h3>

<p><code>
$ sudo resize2fs /dev/sda1
</code></p>

<p>不出意外，应该搞定了； </p>

<h3 id="section-2">注意事项</h3>

<p>扩容之前，最好用 <code>lsof</code> 查看以下扩容分区，把所有的读写进程都停掉，如果条件允许，umount 这个分区再扩容，更加安全</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Solve 'PCI Passthrough Failed: Got Timeout' With PVE Vm Starts Failed]]></title>
    <link href="https://brain-zhang.github.io/blog/2024/04/03/how-to-solve-pci-passthrough-failed-got-timeout-with-pve-vm-starts-failed/"/>
    <updated>2024-04-03T14:38:15+08:00</updated>
    <id>https://brain-zhang.github.io/blog/2024/04/03/how-to-solve-pci-passthrough-failed-got-timeout-with-pve-vm-starts-failed</id>
    <content type="html"><![CDATA[<p>PVE的虚机做了显卡直通后，有时候启动会报错:</p>

<p><code>
start failed .... got timeout.
</code></p>

<p>这一般是因为系统的内存不够了，因为硬件直通，虚拟机的内存需要跟物理内存的DMA映射一致，他就需要物理上连续的内存空间；如果此时物理机的空余内存看起来是够的，但是连续空间不够，就会报错；</p>

<!-- more -->

<p>解决方法有几个:</p>

<p>方法1. 比如我的机器是开启ZFS的ARC占用内存过多导致的，可以简单的执行下面的命令回收一下，可能内存就够了：</p>

<p><code>
echo 3 &gt; /proc/sys/vm/drop_caches
</code></p>

<p>方法2. 如果通过1确定是ZFS的缓存导致内存占用过高，可以设置ZFS的最大缓存限制:</p>

<p>```
$ vim /etc/modprobe.d/zfs.conf</p>

<h1 id="zfs-tuning-for-a-proxmox-machine-that-reserves-8gb-for-zfs">ZFS tuning for a proxmox machine that reserves 8GB for ZFS</h1>
<p>#
# Don’t let ZFS use less than 4GB and more than 8GB
options zfs zfs_arc_min=4294967296
options zfs zfs_arc_max=8589934592
#
# disabling prefetch is no longer required
options zfs l2arc_noprefetch=0</p>

<p>```</p>

<p>上面的配置把ZFS的最大缓存占用限制在4GB-8GB之间；</p>

<p>然后执行下面命令重新生成内核，重启物理机器生效</p>

<p><code>
$ update-initramfs -u
</code></p>

<p>方法3. 上面两种方法都属于指标不治本，最直接有效的方法就是预先留下一定量的内存，只能给特定虚拟机使用，没有分配的话宁可一直闲着也不用；</p>

<p>这可以用Linux的hugepage机制来实现:</p>

<p>修改 <code>/etc/default/grub</code> 中的启动参数，加入</p>

<p><code>
default_hugepagesz=1G hugepagesz=1G hugepages=128
</code></p>

<p>比如我的机器，修改为</p>

<p><code>
GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`
#GRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt pcie_acs_override=downstream,multifunction nofb textonly nomodeset video=efifb:off"
GRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt pcie_acs_override=downstream default_hugepagesz=1G hugepagesz=1G hugepages=128,multifunction nofb textonly nomodeset video=efifb:off"
GRUB_CMDLINE_LINUX=""
</code>
然后执行下面命令重新生成引导配置文件，最后重启物理机器生效</p>

<p><code>
update-grub
</code></p>

<p>重启后，系统会保留128G内存不用，如果要指定某台虚拟机使用，比如ID 121 虚拟机，请手工修改它的配置文件，加入hugepage参数:</p>

<p>```
$ vim /etc/pve/qemu-server/121.conf</p>

<p>…
hugepages: 1024
…
```</p>

<p>之后启动虚拟机，他就会从128G内存中分配它需要的内存；当然，这个虚拟机的内存是不能大于128GB的；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable /etc/rc.local With Systemd on Ubuntu 20.04]]></title>
    <link href="https://brain-zhang.github.io/blog/2023/08/20/enable-slash-etc-slash-rc-dot-local-with-systemd-on-ubuntu-20-dot-04/"/>
    <updated>2023-08-20T15:01:38+08:00</updated>
    <id>https://brain-zhang.github.io/blog/2023/08/20/enable-slash-etc-slash-rc-dot-local-with-systemd-on-ubuntu-20-dot-04</id>
    <content type="html"><![CDATA[<h1 id="setup-systemd-service-file">setup systemd service file</h1>

<p>```
sudo vi /etc/systemd/system/rc-local.service</p>

<p>[Unit]
 Description=/etc/rc.local Compatibility
 ConditionPathExists=/etc/rc.local
[Service]
 Type=forking
 ExecStart=/etc/rc.local start
 TimeoutSec=0
 StandardOutput=tty
 RemainAfterExit=yes
 SysVStartPriority=99
[Install]
 WantedBy=multi-user.target
```</p>

<h1 id="enable-systemd-service">enable systemd service</h1>

<p><code>
sudo systemctl enable rc-local
</code></p>

<h1 id="create-rclocal">create rc.local</h1>

<p>```
sudo vi /etc/rc.local</p>

<h1 id="binbash">!/bin/bash</h1>
<p>…</p>

<p>sudo chmod +x /etc/rc.local
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios Dev and Xcode Cheat]]></title>
    <link href="https://brain-zhang.github.io/blog/2023/08/02/ios-dev-and-xcode-cheatsheet/"/>
    <updated>2023-08-02T15:30:42+08:00</updated>
    <id>https://brain-zhang.github.io/blog/2023/08/02/ios-dev-and-xcode-cheatsheet</id>
    <content type="html"><![CDATA[<p>自学Swfit开发了一个App，记录一下坑:</p>

<ul>
  <li>
    <p>Swift和ObjectC混编的时候，检查 <code>ProjectName--Bridging-Header.h</code> 文件是否被指定为桥接文件 : <code>Target-&gt; Build Settings -&gt;Swift Compiler -&gt; Install Object-C Compatibility  Header</code> 设置为Yes， <code>Target-&gt;Build Settings -&gt; Swift Compiler -&gt;Object-C Briding Header</code> 是否设置为这个文件</p>
  </li>
  <li>
    <p><code>xxx-Bridging-header.h</code> 文件内容一般是 swift的头文件和公共的头文件，内容一般是</p>
  </li>
</ul>

<p><code>
	#import "xxx.h"
</code></p>

<ul>
  <li>当引用类似 <code>#import "happynet-Swfit.h"</code> 提示找不到的时候， 请检查引用次序，类似:</li>
</ul>

<p>```
@import TestDylib;</p>

<h1 id="include-xxx-swifth">include “xxx-Swift.h”</h1>

<h1 id="import-xxxmanagerh">import “xxxmanager.h”</h1>
<p>```</p>

<ul>
  <li>编译提示少符号的时候，检查 <code>Target-&gt; Build Phases-&gt; Compile Sources</code> 是否把所有文件添加进去了</li>
  <li>调试第三方库，例如Tunnel的时候，先用 <code>Debug-&gt;Attach To Process by PID Or Name</code> 挂载进程</li>
  <li>如果是线程错误，xcode会弹出一个Text Table，显示汇编指令哪一行有问题，同时临近的Table回显示代码文件中对应的哪一行，一般是淡绿色标注那一行</li>
  <li>如果出现莫名其妙的编译错误，先<code>Build -&gt; Clean Build xxx</code>；清理一下，重新编译试试</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fix Connection Error Between Ipad and Macbook]]></title>
    <link href="https://brain-zhang.github.io/blog/2023/04/09/fix/"/>
    <updated>2023-04-09T16:44:24+08:00</updated>
    <id>https://brain-zhang.github.io/blog/2023/04/09/fix</id>
    <content type="html"><![CDATA[<p>iOS真机调试，Mac连上iPad一直闪，信任不了设备问题</p>

<p>打开终端Terminal，输入</p>

<p><code>
$ sudo killall -STOP -c usbd
</code></p>

<p>命令回车，即可把进程关闭。插上iPhone，正常连接，问题解决。</p>
]]></content>
  </entry>
  
</feed>
