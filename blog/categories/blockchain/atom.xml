<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-01-23T19:23:49+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-2]]></title>
    <link href="https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2/"/>
    <updated>2019-01-23T19:05:29+08:00</updated>
    <id>https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2</id>
    <content type="html"><![CDATA[<p>比特币的发展史上，非常非常早期就出现了一种名为侧链(sideChain)的技术；</p>

<p>这个技术早在2008年比特币代码尚未发布时，就在论坛上有所讨论，从最初的namecoin(域名币)，到后来的（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链；再到后来百链齐开，大家试图在完全不同的链上转移交换资产；以及最近到blockstream的<a href="https://blockstream.com/liquid/">Liquid</a>，以及基于闪电网络的原子交换(Atomic Swap)，这个技术的发展一直不温不火，但毫无疑问，侧链技术绝对是blockchain技术的重要组成部分。</p>

<p>我初次接触到这个技术时，不禁感叹社区的强大，连这么匪夷所思的东东都能想出来，总之可以总结为:</p>

<p><code>还有这种操作?</code></p>

<p>那么，接下来就从2008年，比特币尚未诞生前说起，这个侧链的技术究竟是如果诞生、演化的。</p>

<p>~~ 填坑中</p>

<!-- more -->


<h2>参考资料:</h2>

<p><a href="http://www.blockstream.com/sidechains.pdf">http://www.blockstream.com/sidechains.pdf</a></p>

<p><a href="https://en.bitcoin.it/wiki/Atomic_swap">https://en.bitcoin.it/wiki/Atomic_swap</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-1]]></title>
    <link href="https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1/"/>
    <updated>2019-01-21T17:44:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1</id>
    <content type="html"><![CDATA[<p>blockchain是个新造词，至少在2008年之前网上是搜索不到这个词的；</p>

<p>比特币的白皮书里面出现过<code>chain of blocks</code>的描述，但是没有直接用<code>block chain</code>的句子;</p>

<p>在早期bitcointalk.org上面的讨论中，为了方便讨论，早期参与者频繁引用<code>chain of blocks</code>的主题，但是谁是最早的引用者，已不可考据。</p>

<p>如果真正要较真blockchain这个单词第一次出现的地方，我想大概是中本聪的第一版bitcoin 源代码中；</p>

<p>bitcoin v0.01源代码中，中本聪第一次在<a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.h#L596">函数注释中</a> 完整的引用了<code>block chain</code>这个术语，鉴于中本聪在比特币白皮书发表的2年前已经开始编写源码；所以有理由确认：</p>

<ol>
<li>blockchain这个名词是2007-2008年间诞生于世间的</li>
<li>中本聪是比特币之父，比特币是blockchain之母</li>
</ol>


<p>现在有一种说法，是比特币和区块链是不同的，比特币是个没有什么前途的庞氏货币，而区块链作为一种新兴的基础技术将会在很多领域发扬光大，前景光明；</p>

<p>对于这个说法，我认为Andreas的一场演讲值得一看：</p>

<p><a href="https://www.youtube.com/watch?v=SMEOKDVXlUo">https://www.youtube.com/watch?v=SMEOKDVXlUo</a></p>

<!-- more -->


<p>好了，八卦完毕，我们开始探究比特币里面的blockchain究竟是个什么样的技术，它是解决什么问题的，实现细节是怎样的；</p>

<p>然后我们一贯的风格是:<code>光说不练假把式</code>；在原理说明中，我们会用代码parse真正的比特币区块链文件来一探究竟。</p>

<h2>由来</h2>

<p>还记得我们<a href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/">之前的文章</a>里面提到的，如果要建立一个分布式的账本，要解决两个问题:</p>

<ol>
<li>什么样的交易是一笔合法的交易</li>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>我们在比特币交易的系列文章中解答了第一个问题，现在是解决第二个问题的时候了。</p>

<p>先思考一下货币发行的问题，比特币网络中，会有成千上万的节点参与者，哪些节点能获得发币的权利呢？或者说，凭什么这些节点能有记账权呢？</p>

<p>在金银货币时代，发币是通过开采金矿来实现的；采矿者承担了勘探、挖掘的风险，大家认可其开采成果并承认其铸币权；那么映射到电子世界中，能不能有一种类似的挖矿的机制呢？</p>

<p>中本聪的回答就是POW (proof of work&mdash;工作量证明)；全网的所有节点一起算一个毫无意义的随机数字，这个数字满足以下的条件，凡是能算出这个数字的人，我们就承认他有一次的记账权：即一次铸币的权利；这个条件如下：</p>

<h4>在一个计算周期内，计算出来的这个数字R满足 F(Chain[R]) &lt; Target；其中F是SHA256算法，Chain是账本，Target是不断减小的，这意味着寻找R的几率会越来越小</h4>

<p>中本聪认为算力是非常公平的、不可伪造的一种证明手段；凡是能在规定周期内正确解答谜题的人，理应获得回报；所有加入到这个比特币网络的人，都应该承认这一点，如果你不承认，那比特币网络就不欢迎你；</p>

<p>那么，铸币的问题解决了；但是如何防止有的节点获取记账权之后，伪造账本呢？</p>

<p>答案是将POW的计算结果嵌入到账本中，每一次新周期的计算，其结果必须在之前所有计算结果的基础上完成；这样如果有人想要伪造账单条账目，他就必须在一个计算周期内伪造更多的账目；如果想要伪造整个账本，就需要将比特币创世之初到现在所有的POW重新计算一遍，而能够获得这样的算力，基本上是不可能的。</p>

<p>那么，如何将这个计算证明过程嵌入到账本里面呢？</p>

<p>答案就是每个计算周期生成一个block，这个block包含了这个周期内全网的交易，而Target就嵌入到这个block中，然后将block用HASH值作为指针串联起来，构造成一条坚不可摧的chain；这就是blockchain的由来。</p>

<h2>区块结构</h2>

<p>如果你运行最新版本的bitcond(>=v0.16)，会发现在数据目录有四类文件:</p>

<ol>
<li>datadir/blocks/blkxxxxx.dat: 存储原始的区块数据，这就是我们常说的blockchain数据</li>
<li>datadir/blocks/index/xxxx.ldb: 区块的原始数据索引，有了它，我们就可以根据HASH值快速查找交易和区块</li>
<li>datadir/chainstate/xxx:这个目录中,存放着LevelDB中的UTXO记录,以及一些这些交易来源的元数据.这些数据用来校验收到的区块和交易</li>
<li>datadir/blocks/revxxxxx.dat: 在区块链分叉重组的时候需要用回滚记录去更新UTXO记录</li>
</ol>


<p>1是原始区块数据，第2，3类数据可以从1中重建，但重建会花很长时间；在一台16Core, 32GB内存，SSD磁盘的机器上，大概要花1天左右。</p>

<p>第4类数据比较特殊，如果存储的数据已经落后了当前区块高度非常远的距离，其实可以删除的；但是为了保证 100%的严谨和安全，目前默认的实现还是全部保留。</p>

<p>3，4类数据在最初的比特币版本中，没有写入文件，就是内存里面放个MAP数据结构临时存着；后来交易量变大，多次代码重构后，变成了今天这个样子。</p>

<p>截至2019-01，以上数据加起来，已经超过了200GB。</p>

<p>那我们就主要来分析第1类数据，就是原始区块数据。</p>

<h4>Block结构</h4>

<p>一个block的结构异常简单，列表如下:</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> Block Size </td>
<td> 当前block的大小</td>
</tr>
<tr>
<td>80 bytes </td>
<td> Block Header </td>
<td> block头信息</td>
</tr>
<tr>
<td>1-9 bytes (VarInt) </td>
<td> Transaction Counter </td>
<td> 这个block包含的交易数量</td>
</tr>
<tr>
<td>Variable </td>
<td> Transactions </td>
<td> 交易</td>
</tr>
</tbody>
</table>


<p>如果去parse blkxxxx.dat 文件，按照这个结构就能很容易拆分出每一个block；来一个工具:</p>

<p><a href="https://github.com/alecalve/python-bitcoin-blockchain-parser">https://github.com/alecalve/python-bitcoin-blockchain-parser</a></p>

<p>另外值得注意的是，因为bitcoind写入区块文件的时候是并行的，所以按照字节序解析出来的区块并不是按时间顺序排列的，blkxxxx.dat文件中，区块存储的次序是随机的；</p>

<h4>Block Header</h4>

<p>区块头由三组区块元数据组成。</p>

<p>首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。就是我们前面讲的作为指针的HASH值。</p>

<p>第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，本质上就是前面公式里面的R值和Target值。</p>

<p>第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构，我们在后面会介绍）。</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 |</td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 |</td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key |</td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 |</td>
</tr>
<tr>
<td>4 bytes </td>
<td> Difficulty Target </td>
<td> 当前block的POW难度值 |</td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce |</td>
</tr>
</tbody>
</table>


<p>PS:比特币客户端除了bitcoin core之外，任何团队都可以根据当前的协议开发自己的比特币软件，事实上当前也有不少其他的实现，而各个团队之间开发的不同客户端需要遵循同样的协议标准，这个协议的版本管理就是依靠开头的version字段，规则请参照<a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">BIP009</a></p>

<h4>block标识符</h4>

<p>block header中，我们有一个<code>Previous Block Hash</code>值，这就是我们所说的将block串联成为chain的指针。那么这个指针值是怎样计算出来的呢？</p>

<p>还是以<a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">创世块</a>为例，让我们仔细研究下:</p>

<p>创世块的HASH值为<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>，这是一个32字节的HASH值，通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。注意，这个值仅仅是根据区块头得到的，即 <code>SHA256(SHA256(Block Header))</code>;</p>

<p>仅仅依赖区块头就够了吗？是的，不要忘了，我们在区块头里面还有一个重要的HASH值，就是<code>Merkle Root</code>，<code>Merkle Root</code>标识了block中所有的交易，而<code>Block Hash</code> 通过HASH包含了<code>Merkle Root</code>的<code>Block Header</code>，唯一、明确地标识了一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>

<p>通过<code>Merkle Root</code>和<code>Block Hash</code>决定了，一个区块被铸造出来，恶意的第三方节点是无法修改它的；</p>

<p>另外需要注意的一点是: 区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。</p>

<p>当我parse block得到<code>previous block hash</code>值时，如何去判断存在上一个真正的block呢？一般都会到索引文件里面找，就是我们前面所说的 index/xxxx.ldb文件。</p>

<h4>区块高度</h4>

<p>除了这个HASH值作为区块标识符，我们一般还会在区块浏览器上面看到一个说明<code>Height</code>；比如创世块的<code>Height</code>就是0；</p>

<p>这是程序员们按照block在chain上面的次序为block的编号，这个信息是不会写入blockchain的，只是作为<code>区块高度</code>在很多时候方便表示和计算；</p>

<p>当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。</p>

<p>和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况是怎样发生的呢？</p>

<p>因为一个全节点会时时刻刻接收全网的区块广播，在一个生产周期内，不可避免的，会产生两个或更多的符合条件的block，这个时候会发生什么呢？</p>

<p>所有区块高度相同的区块会争夺成为链接上chain的权利，此时所有的矿工便会收集所有可能的chain分支，并选取最长的那一条在上面继续挖矿。</p>

<p>如果把这个情景图像化，我们会看到blockchain时时刻刻都处在分叉状态中，新产生的block会在chain的末尾组成多个分支，不断的消亡、新生、重组，就就好像一条末端散开的绳子有了生命一样；</p>

<p>关于这个情景，有个很诗意的描述词：<code>HASH DANCE</code>；</p>

<p>作为一个Geek，这真是一场让人意醉神迷的数字之舞啊。</p>

<h4>创世区块</h4>

<p>区块链里的第一个区块创建于2009-01-03 18:15:05 GMT，被称为创世区块(Genesis block)。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。</p>

<p>因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。</p>

<p>创世块比较特殊，它不是挖出来的，是中本聪手工构造的；参见这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439">https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439</a></p>

<p>关于创世块，之前我们提到一个有趣的事情：创世块的50BTC奖励是不能花的，这是为什么呢？</p>

<p>这需要我们好好研究下中本聪发布的v0.01版本的比特币源码：</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01">https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01</a></p>

<ol>
<li>整个比特币系统接收一笔交易的时候怎么判断其合法性呢？就是判断这笔交易的vin是否关联着一笔合法交易的vout，这些vout统称UTXO，在初版比特币里面，判断一个合法的UTXO的标准就是有没有放进区块链的索引文件中；这个索引文件和区块链文件不是一个东西，他是单独的；如果你运行初版比特币软件(v0.01)；就可以看到中本聪把区块存储在blk0001.dat这样的文件里面，而把所有区块的索引存储在blkindex.dat这个文件里面；</li>
<li>那么问题就出现了，blkindex.dat 什么时机才能写入呢？通读源码发现，只有自己挖矿挖到区块，或者收到周围的广播区块的时候，才有机会写入blkindex.dat这个文件;</li>
<li>中本聪不知道有意无意，在前面手工构造创世区块的时候，没有构建索引写入blkindex.dat里面</li>
<li>后来比特币的源码不断变迁，存储UTXO的方式由BDB变成了levelDB，但是创世块一直没有没有写入到索引文件里面，这样花费创世交易的时候，没有相应的索引，创世交易的UTXO就是非法的，所以没法花费</li>
</ol>


<h5>那么如何解决呢？有两个办法：</h5>

<ol>
<li>就是把创世区块写到区块索引里面</li>
<li>或者在检查交易合法性的时候，单独的加一个判断条件，判断UTXO是否出自创世区块</li>
</ol>


<h5>为什么迟迟没有修正：</h5>

<ol>
<li>每个办法都需要一次硬分叉</li>
<li>这需要全网节点都升级这个只影响创世块的50BTC，中本聪都不在乎，何苦为了50BTC就全网升级呢？</li>
<li>最后，创世块见证着历史，其实不能花费挺好的。</li>
</ol>


<h4>coinbase</h4>

<p>紧接着<code>block header</code>的，就是当前block的所有交易，其中第一笔交易就是coinbase 交易。关于coinbase交易，我们曾经在之前的文章中详细介绍过，这里就增加说明一点，coinbase交易的输出包括了所有交易的手续费，将来比特币网络的额定产出越来越少的时候，矿工们还是可以通过打包交易费用获利，来维持比特币网络的正常运转。</p>

<p>就当前的情况来看，再来一次减半，基本上交易费用和新区快产出就对等了。</p>

<h4>隔离见证</h4>

<p>实施了隔离见证之后，对于<code>block header</code>和coinbase都有一些变化，我们以后会详细再提。</p>

<h2>区块链接成为区块链</h2>

<p>比特币的全节点在本地保存了区块链从创世区块起的完整副本。随着新的区块的产生，该区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。</p>

<p>最后所有区块组成了blockchain:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg1.jpg" alt="img" /></p>

<h2>Merkle树</h2>

<p>区块链的数据是永不删除的，随着交易量越来越大，整个区块数据量也越来越大，那么问题又来了，不可能每个节点都下载数百GB的数据来来验证一笔交易的合法性，而作为一个分布式系统，我们是不能信赖任何中心节点的！我们怎样在一个手机钱包软件里面验证一笔交易呢？</p>

<p>答案是一个绝妙的数据结构: <code>Merkle</code>；</p>

<p>将比特币系统的交易和区块用Merkle树组织起来，会获得一项不可思议的能力，即使整个区块达到数百GB，每个轻节点只需要接收少许数据(MB级别)，就可以完成交易的合法性校验，并且无需任何中心化的节点。</p>

<p>初次接触到Merlke树算法的时候，我觉得这简直是为比特币系统量身定做的，我觉得这是整个系统里面最优美、最简单、最不可思议的算法。</p>

<p>这是怎么做到的呢？呵呵，偶很懒，自己去翻参考资料吧。</p>

<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></p>

<h4>SPV(简单支付)</h4>

<p>Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。</p>

<p>例如，一个SPV节点想知道它钱包中某个比特币地址即将到达的支付。该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkleblock消息的形式发送该区块。Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联，交易与区块、区块和区块链，就可以证明交易存在于区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千多倍。</p>

<h2>小结</h2>

<p>blockchain作为比特币的基本技术支撑之一，毫无疑问是一项前无古人的真正创新；这项技术怎么高估都不过分，我认为数十年后，可能会作为一种工业革命的基础技术跟蒸汽机、电力应用、信息技术相提并论；</p>

<p>比特币的链为我们提供了两项能力:</p>

<ol>
<li>不可伪造的电子时间戳证明；任何依赖于有序时间的处理程序(博彩、公证、法律等等)都可以上链</li>
<li>提供了一个构造发行自定义资产(证券、股票)的基础手段，货币只是一个基本应用，任何人都可以以比特币主链为基础，构造一条侧链，并在其之上实现自己的资产发行、定价、转移功能</li>
</ol>


<p>在未来的世界里，关于这方面的应用和创新简直层出不穷，例如预言机的实现，微支付通道，原子交换等等；我所读过的最好的关于blockchain的一些设想是这个：</p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>

<p>好啦，为了能在未来的世界里面不落人后，我们要继续学习，等我们之后的文章吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一种提高比特币私钥碰撞机率的思路]]></title>
    <link href="https://happy123.me/blog/2019/01/18/%5B%3F%5D-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu/"/>
    <updated>2019-01-18T10:41:40+08:00</updated>
    <id>https://happy123.me/blog/2019/01/18/[?]-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu</id>
    <content type="html"><![CDATA[<p>之前的文章里面我们提到了一个名为<a href="https://lbc.cryptoguru.org">LBC</a>的项目；它采用了遍历所有比特币私钥，bloomfilter所有未花费的币的地址来碰撞比特币私钥。</p>

<p>这个项目本身详尽<a href="https://lbc.cryptoguru.org/stats">计算了这种碰撞成功的几率</a>，目前碰撞空间大概在 2<sup>136</sup> 级别。</p>

<p>目前在一台最顶级的AWS GPU计算节点上面的碰撞效率是这样的:</p>

<p><code>
AWS p2.8xlarge  32 vCores Xeon v4, 8x K80 GPUs (50% each)   ~80-88M/s
</code></p>

<p>每秒钟大概碰撞8000w次；目前LBC这个项目最顶峰的时候，算力到了1G的级别，这样计算下来:
<code>
2^136 / 2^30 = 2 ^106
</code></p>

<p>2<sup>106</sup> 级别的碰撞效率还是遥遥无期啊；</p>

<!-- more -->


<p>如果通读我们之前的文章就知道，比特币地址的生成，主要花费在ECDSA、SHA256, RIPEMD 这三个算法的操作之上，但其实用GPU计算，这三个步骤花费的时间是很少的，在整个碰撞过程中，其实大部分时间是耗费在bloomfilter上面的；</p>

<p>而bloomfilter的原理，采用的是多级HASHMAP，常理来看，这已经是判断一个元素是否存在某集合的极限效率了；</p>

<p>但是有一点我们不要忘记，比特币的地址采用base58编码，他的地址空间是有规律的，简单来说，就是所有比特币地址的前缀分布，是有规律可循的，他应该在base58的编码范围内成正态分布；而bloomfilter的HASHMAP是没有这种条件优化的，所以说bloomfilter的算法我们可以再改进一下，提升效率。</p>

<p>我分析了截至2018-12以前的所有比特币地址，简便起见，提取了所有的P2PKH地址(共
377059211个地址)，取其前4个字符地址前缀；执行:</p>

<p><code>
sort 4prefix.addr|uniq -c|sort -nr
</code></p>

<p>得到了所有地址前缀的分布列表，差不多是个正态分布。</p>

<p>列举一下最常用的地址前缀TOP10:</p>

<p><code>
  23600 1bit
  23086 1btc
  21895 13vs
  21329 1gbx
  21267 1gbt
  21267 1gba
  21210 1gbb
  21206 1gbf
  21196 1gbu
  21189 1gbr
</code></p>

<p>最常见的是1bit和1btc这两个前缀，各比第三名多出了10000个左右，这多出来20000个地址应该是Geek们自己生成的虚荣地址。</p>

<p>所有的比特币P2PKH地址，4字母前缀共有42877种组合。</p>

<p>好了，这就是我们可以优化的地方，把bloomfilter的第一级HASHMAP，采用这些前缀组合先来一把过滤，再去执行常规的Bloomfilter，碰撞效率会再提高一个数量级。</p>

<p>我在自己机器上实验了一下，在GTX750Ti 2G显卡上面，最终效率可以达到 10M/s。</p>

<p>瓶颈现在又变成了genaddress环节，我估计在一块RX480卡上面，可以达到和AWS顶配GPU一样的效率；</p>

<p>不过，效率提升十倍，也不过是 2<sup>100</sup> 的碰撞范围，还是遥遥无期啊。</p>

<h4>更深入的分析</h4>

<p>早期在bitcointalk.org论坛上，Laszlo Hanyecz曾经有过一个想法，就是随着硬件性能的发展，最终碰撞比特币私钥的收益会不会超过挖矿的收益？</p>

<p>中本聪当时的回答是，要达到这个碰撞算力很远很远。</p>

<p>我们来仔细分析一下：</p>

<p>比特币的地址生成是很容易硬件ASIC化的，如果用这种前缀过滤法，也不需要多少内存，所以可以近似认为：如果硬件化，比特币私钥碰撞的效率和挖矿效率是差不多的。</p>

<p>目前比特币全网算力在40EH左右，就是2<sup>62</sup>，这已经是相当于400w台蚂蚁S9的机器同时24X365 运行了；消耗的电力估计已经超过了上海市的居民用电，比特币矿机的能源消耗，完全可以说是抵得上一个小型国家的能源消耗了。</p>

<p>如果私钥碰撞达到2<sup>62</sup>级别，那么毛估估，碰撞几率就能减小到 &frac12;<sup>60</sup> 级别了；</p>

<p>但是这个概率还是太低了。</p>

<p>而且另外一个无法预测的情况就是，将来人们的安全意识加强，一般一个地址只要用过就会丢弃掉，所以最终bloomfilter的条目变化会非常频繁，还要考虑一个数量级的损耗。</p>

<p>目前测算，随着手续费用的提高，即使多次减半，将来挖矿的收益估计很长期稳定1-10btc/block级别，在如果将来以1年时间碰撞一个私钥的概率期望测算的话，一年大概是2<sup>25</sup> 秒，这样碰撞效率至少要提高到 2<sup>95</sup> 级别，才能达到<code>破解私钥得利</code>><code>挖矿得利</code> 的效果；</p>

<p>算力提高到2<sup>95</sup>，不管用什么技术，即使是量子计算，也很难想象能到这个量级啊；</p>

<p>而且，即使到了这一天，把RIPEMD替换成一种碰撞空间更大的算法就OK了。</p>

<p>这样看来，bitcoin的安全性还是无懈可击。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-7]]></title>
    <link href="https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7/"/>
    <updated>2019-01-06T17:34:55+08:00</updated>
    <id>https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7</id>
    <content type="html"><![CDATA[<p>比特币的交易网络最为人诟病的一点便是交易性能：全网每秒 7 笔左右的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认将导致约 1 个小时的最终确认时间。</p>

<p>为了提升性能，社区提出了闪电网络等创新的设计。</p>

<p>闪电网络的主要思路十分简单——将大量交易放到比特币区块链之外进行，只把关键环节放到链上进行确认。该设计最早于 2015 年 2 月在论文《The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments》中提出。</p>

<p>闪电网络需要单独部署，没有包含在bitcoin core实现里面。闪电网络是一个开放的协议，任何人都能自由的实现它，目前比较流行的版本有:</p>

<p><a href="https://github.com/lightningnetwork/">https://github.com/lightningnetwork/</a></p>

<p><a href="https://github.com/mit-dci/lit">https://github.com/mit-dci/lit</a></p>

<p><a href="https://github.com/ElementsProject/lightning">https://github.com/ElementsProject/lightning</a></p>

<!-- more -->


<p>让我们先自己思考一下，A和B之间频繁有多次交易，最自然，最直接的建立链下交易的办法是什么？</p>

<p>一个假想的场景，就是在没有网络，没有通信的环境中，两个人面对面各自手持私钥签名，证明自己的账户上有多少资金，然后签订一份合同，每次交易记录签名之后不广播，只写在合同上面，等到大批交易做完之后，再统一轧账清算；如果中间有人耍赖，就拿着写满签名交易的合同去法院仲裁。这个过程中间他们唯一的信息渠道就是有人单向传真给他们每笔交易的资金变动；</p>

<p>当然这是一种异想天开，而且依赖于中心化的法院裁决的方式，在现实世界中是行不通的；但是我们可以将这个方案作为起点，代入到电子化的解决方案里面：</p>

<ol>
<li>首先，两个人面对面，一是为了通过验证签名检查账户资金，二是防止第三者窃听；映射到电子方案中，就是通过两个人建立一个加密的通信信道来传递信息</li>
<li>另外，两个人的每一笔交易打印到合同上，就是为了防止某一方作假诈骗，而且两个人面对面互相监督，就防止有一方私自广播对方的交易然后闪人，但是放到网络中，没有法官裁决的威慑，没有相互监督，怎么才能信任对方最终一定会根据所有的历史交易来清算呢？</li>
</ol>


<p>第一个问题的解决方案称之 HTLC（Hashed Timelock Contract），解决了支付通道(资金池)的问题；</p>

<p>第二个问题的解决方案称之为RSMC (Recoverable Sequence Maturity Contract)，解决了链下交易的确认问题。</p>

<h2>RSMC</h2>

<h4>概述</h4>

<p>Recoverable Sequence Maturity Contract，即“可撤销的顺序成熟度合约”。这个词很绕，其实主要原理很简单，类似资金池机制。</p>

<p>再想一下我们之前的问题，为什么A和B每次交易都要记在合同上，最后一把清算呢？既然是双方账户的加加减减，为什么不是每发生一笔新交易，立即对交易后产生资金分配结果共同进行确认，然后作废之前一笔交易呢？</p>

<p>Yes! 这样做之后，在双方的资金池通道中，不管之前双方进行了多少笔交易，永远只存在一笔清算交易，这笔交易就是当前的轧账结果，不管什么时候，直接广播这笔交易，对双方都是公平的。</p>

<p>那么，该如何防止一方做了一笔付款之后，没有广播，就抢先把资金池里面的自有资金提现呢？</p>

<ol>
<li>A和B各拿出1BTC放入了资金池通道中，这时候资金池里面共有2BTC</li>
<li>A和B发生了数笔交易之后，A与B的资金变为1.5:0.5BTC，这个时候通道中留着一笔清算交易没有广播，但是任何一方都可以直接广播把这个状态做实</li>
<li>这个时候A又向B发送了1BTC，但是在B广播清算交易之前，A要把资金全部提走，也就是1.5BTC；这样B就损失了1BTC，怎么预防这种情况呢？</li>
</ol>


<p>解决方法就是提现一定要双方都签名承认才可以：任何一方在任何时候都可以提出提现，提现时需要提供一个双方都签名过的资金分配方案（意味着肯定是某次交易后的结果，被双方确认过，但未必是最新的结果）。在上面的那种情况下，B是无论如何也不会同意的。这就阻止了A的提现。</p>

<p>另外，为了威慑A这种行为，在一定时间内，如果另外一方拿出证明表明这个方案其实之前被作废了（非最新的交易结果），则资金罚没给质疑方；否则按照提出方的结果进行分配。罚没机制可以确保了没人会故意拿一个旧的交易结果来提现。</p>

<p>最后，即使双方都确认了某次提现，首先提出提现一方的资金到账时间要晚于对方，这就鼓励大家尽量都在链外完成交易。通过RSMC，可以实现大量中间交易发生在链外。</p>

<p>那么如果有一方耍小心眼，就是损人不利己，死活不签名来阻止另一方的提现呢？也没关系，在这个模型中，有了惩罚机制，提现的一方可以直接拿最后一笔清算交易的状态来广播(这笔交易是双方都签名承认的)，代价就是晚一点得到资金而已。</p>

<ul>
<li>整个过程里面，最重要的就是惩罚机制的实现，我如何认定跟我交易的对方也遵从这个惩罚机制呢？这是用多重签名来保证的。因为多重签名实际上是个合约，所以这个方案被命名为RSMC。</li>
</ul>


<h4>让我们详细的描述这个过程</h4>

<p>内容引自： <a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<h4>RSMC 创建</h4>

<p>Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入通道中，便于业务往来。解释一下下方RSMC交易的结构，左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg1.jpg" alt="img" /></p>

<ol>
<li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时， Funding    Tx未签名，更不广播。</li>
<li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li>
<li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li>
<li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li>
<li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li>
<li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。上述过程以及结构图的描述，就是创建RSMC的全部过程。</li>
</ol>


<p>C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p>

<p>这个过程的精巧之处，就在于构造了一个被动机制，将自己的资金放入到一个嵌套多重签名的地址里面，任何一方想要提现，一定要先归还另一个人的资金。并且这个机制构造完成之后，我们才真正在支付通道中充值。</p>

<h4>交易更新</h4>

<p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。</p>

<p>于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg2.jpg" alt="img" /></p>

<p>交易更新时的交易结构此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？</p>

<p>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2  的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg3.jpg" alt="img" /></p>

<p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。</p>

<p>若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。</p>

<p>Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。</p>

<p>引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p>

<h4>交易关闭</h4>

<p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p>

<h2>HTLC 中转交易</h2>

<p>RSMC要求交易的双方一定要都缴纳一笔保证金，我每天都跟不同的商家打交道，不能跟每个人都去建立RSMC，存入一笔资金吧。而且通道的建立和关闭都是需要链上广播的，如果要建立多个支付通道，交易费用也不容小觑，这有点本末倒置了吧。</p>

<p>为了解决这个问题，闪电网络又引入了HTLC ( Hashed Timelock Contract )，中文意思是“哈希的带时钟的合约”。这个其实就是限时转账。理解起来也很简单，通过智能合约，双方约定转账方先冻结一笔钱，并提供一个哈希值，如果在一定时间内有人能提出一个字符串，使得它哈希后的值跟已知值匹配（实际上意味着转账方授权了接收方来提现），则这笔钱转给接收方。</p>

<p>推广一步，甲想转账给丙，丙先发给甲一个哈希值。甲可以先跟乙签订一个合同，如果你在一定时间内能告诉我一个暗语，我就给你多少钱。乙于是跑去跟丙签订一个合同，如果你告诉我那个暗语，我就给你多少钱。丙于是告诉乙暗语，拿到乙的钱，乙又从甲拿到钱。最终达到结果是甲转账给丙。这样甲和丙之间似乎构成了一条完整的虚拟的“支付通道”。而乙就做了中转节点。</p>

<p>Alice想要支付0.5BTC给Bob，但她并没有一个渠道来和他进行交易。幸运的是，她和Charlie有一个交易渠道，而Charlie正好和Bob有一个交易渠道。这样Alice就能借助Charlie的交易渠道，通过哈希时间锁定合约（HTLC）来和Bob进行交易了。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg4.png" alt="img" /></p>

<p>为了完成这次交易，Alice就会给Bob发短信说：“嘿！我要给你付笔款。”这时Bob自己将收到一个随机数字（R），接着Bob便会回一个被哈希的数字（H）（你可以认为被哈希的数字R是随机数字的一种加密形式）给Alice。</p>

<p>然后Alice的钱包紧接着就会联系Charlie说：“嘿，Charlie。如果你给我生成（H）的未加密值（R），那么我就同意更新我们渠道的支付分配，这样你就可以得到的就会比0.5BTC多一点，我得的比0.5少一点。”</p>

<p>尽管Charlie并不知道R，但他也会同意。之后Charlie便会去找Bob说：“嘿，Bob。如果你给我那个能生成H的未加密的值R，我将同意更新我们渠道的支付分配，这样你就可以得到的会比0.5BTC多一点，我得到的比0.5少一点。”因为R就是从Bob这里生成的，所以他肯定知道。接着他马上将R告诉Charlie，并更新了其渠道的支付分配。然后Charlie将R告诉给了Alice之后也更新他们的渠道，最后交易完成，Alice以脱链的形式付给Bob0.5BTC。</p>

<h4>扩展</h4>

<p>HTLC给了任意两个点之间，通过路由转发达到支付的目标。这样用户无需打开过多的通道，只需要存入一笔资金跟一个比较大的中介机构建立通道就好了。之后所有的支付行为，我们都期望这个中介机构能自动路由到商家。</p>

<p>在闪电网络的极大繁荣时间，可以看作是现在互联网模型的克隆。</p>

<h2>优缺点大辩论</h2>

<h4>关于支付通道建立</h4>

<ul>
<li><p>乐观： 建立的闪电网络渠道可以与现有钱包和系统内置无缝过程。当收到和支付比特币时，资金需要存到某个地方。资金可以在收到时立即进入闪电网络的通道中，因此建立该通道不需要额外的步骤或成本。</p></li>
<li><p>悲观：为了建立闪电网络渠道，用户必须手动创建一个新的昂贵的链上交易。</p></li>
</ul>


<h4>关于通道关闭</h4>

<ul>
<li><p>乐观:可能不需要关闭渠道，用户可以无限期地或长时间地将钱存放在通道中。</p></li>
<li><p>悲观:一旦支付完成，就需要透过手动创建昂贵的在线交易来关闭通道。</p></li>
</ul>


<h4>关于网络路由</h4>

<ul>
<li><p>乐观:现有的P2P网络已经需要网络拓扑和消息传递，节点通常具有八个连接。闪电网络拓扑结构只是其中的一个延伸。路由不是一个重要的问题，因为即使在大规模网络中，用户之间路径的平均步数也是很小的。即使路由有问题，也可以简单地在链上进行支付，而用户甚至感觉不到两者的差异。少数大型渠道运营商可以防止路由发生任何问题。</p></li>
<li><p>悲观:路由可能是一个较大的问题，因为找到各方之间最短的路径对于演算法来说是个难题。如果找不到清晰的路线，则用户和商户将不得不通过繁琐的过程来手动改变并选择在链上交易的过程。</p></li>
</ul>


<h4>关于支付通道的中心化</h4>

<ul>
<li><p>乐观:有些经济奖励措施是用来对抗这种中心化的，任何人都可以设立节点，因为进入门槛低。除此之外，还可以通过收取较低的费用来削减其他节点对网络的影响力。即使网络集中在几个大型交易枢纽上，闪电网络仍然提供了一个有用而有趣的系统。比特币已经有一些像 Coinbase 这样的大机构来管理大量的资金。在闪电网络下，这些机构没有资金保管权，只是用来传递用于支付的数据。</p></li>
<li><p>悲观:   网络将集中围绕在几个大型交易枢纽，因为这是最有效的模式。这种集中化增加了系统性渠道失效的风险，即少数大渠道出现故障，导致支付渠道同时大量外流，造成连锁拥堵，使部分资金在到期前无法退出渠道。</p></li>
</ul>


<h4>关于流动性</h4>

<ul>
<li><p>乐观:将有机制激励用户运行闪电网络节点，并提供流动性，以收取费用，网络便可以用于小额支付，支付额度可以远小于最大渠道容量，确保有足够的流动性。</p></li>
<li><p>悲观:支付渠道流动性不足，因此其规模将受到限制。任何较具规模的支付几乎可以立即消耗掉整个渠道的流动性，瘫痪闪电网络的支付渠道。</p></li>
</ul>


<h4>关于要求收款人在收款时在线</h4>

<ul>
<li><p>乐观:虽然收件人必须在线才能收到付款，但这与大多数在线支付系统没有显着不同，因为如果收款人不在线上，他们不知道或无法验证收款。直接收款的用户或设备也不需要存储私钥。例如，商店 PoS 终端或加密 ATM 机可以在收款前通过互联网从公司的总部确认签署回收交易，因为无论如何双方在收款时都需要沟通。</p></li>
<li><p>悲观:通过链上交易，发件人需要的是收款地址，而收件人不需要在线。与此相反，收款人在接收付款之前需要签署收回交易。这是一个重大的限制，意味着收件人必须将私钥暴露在热钱包中。这使得闪电网络在下列许多情况下便的不切实际，例如在 ATM 上，在商店 PoS 系统上进行大额支付，或者支付给那些难以连上互联网的收款人。</p></li>
</ul>


<h4>闪电网络较大的安全风险</h4>

<ul>
<li><p>在收款时必须在线的要求：如上所述，在收款之前，收款人需要签署收回交易，以便汇款人知道如果渠道不正常的关闭或拒绝签署的情况发生，他们可以收回资金。因此，收钱需要一个热钱包，这意味着如果发生安全事件，私钥可能被暴露。</p></li>
<li><p>监督渠道的要求：可能需要闪电网络参与者或瞭望塔主动监督网络渠道。这可能给用户或瞭望塔带来负担，并且与存储在区块链上的比特币相比，潜在地降低了渠道内的资金安全性。未能适当监督渠道或由在线网络造成的拥塞可能增加用户错过了回收交易截止日期的风险。</p></li>
<li><p>矿工可以审查渠道关闭交易：作为不属于交易双方的矿工可以通过审查渠道关闭交易，一旦他们具有 51％ 的哈希率便可能有能力从闪电网络用户窃取资金。虽然这种类型的攻击就算在没有应用闪电网络的情况下已经具有破坏性的后果，但闪电网络的应用可能会提供一个更大的攻击面。</p></li>
</ul>


<h2>小结</h2>

<p>RSMC 保障了两个人之间的直接交易可以在链下完成，HTLC保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。闪电网络整合这两种机制，就可以实现任意两个人之间的交易都在链下完成了。</p>

<p>在整个交易中，智能合约起到了中介的重要角色，而区块链网络则确保最终的交易结果被确认。</p>

<p>闪电网络似乎可以在整体网络交易规模上带来重大改进。从而导致交易速度提高和交易费用大幅下降，而整体又不会影响核心基础安全性。然而，至关重要的是，闪电网络自身在安全性上的不足可能使闪电网络不适合用于大额支付（或者至少用其进行大额支付的行为可能是不负责任的）。投机和投资等行为是需要大额支付的，而这些行为目前看来是加密货币领域的主要的交易推动力，相比之下，零售小额支付的数量相对较小。</p>

<p>最后附赠一个技术讲解比较好但是旗帜鲜明反对闪电网络的视频教程：</p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p>当然再为闪电网络声援一下，闪电网络的思想发源于微支付通道，Satoshi实际上早期对微支付通道已经有了基本的设想：</p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p>孰对孰错，是非只能自己判断。</p>

<h2>架设一个闪电网络节点，完成一笔交易</h2>

<p>光说不练假把式，增加一把实战</p>

<h4>运行一个bitcoind全节点</h4>

<p>我们选用bitcoind运行一个testnet模式的全节点，配置文件如下:</p>

<p>bitcoin.conf:</p>

<p>```
rpcuser=xxxx
rpcpassword=xxxx
rpcallowip=192.168.2.1/16
rpcport=8332
test.rpcport=18332
rpcthreads=10
server=1
rest=1
testnet=1</p>

<h1>for lnd</h1>

<p>server=1</p>

<h1>daemon=1</h1>

<p>zmqpubrawblock=tcp://192.168.2.1:28332
zmqpubrawtx=tcp://192.168.2.1:28333
```</p>

<p>启动bitcoind:</p>

<p><code>
bitcoind --conf=/opt/blockdata/testnet3/bitcoin.conf --datadir=/opt//blockdata/ --deprecatedrpc=signrawtransaction &gt;&gt; test.log 2&gt;&amp;1
</code></p>

<h4>建立闪电网络节点</h4>

<p>我们采用lightningnetwork这个Go版本的实现(全程需要翻墙)：</p>

<p><a href="https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md">https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md</a></p>

<ul>
<li>安装go环境</li>
</ul>


<p><code>
sudo apt-get install golang-1.11-go
</code></p>

<ul>
<li>设置环境变量</li>
</ul>


<p><code>
export GOPATH=~/gocode
export PATH=$PATH:$GOPATH/bin
</code></p>

<ul>
<li>Clone &amp;&amp; 编译</li>
</ul>


<p><code>
go get -d github.com/lightningnetwork/lnd
cd $GOPATH/src/github.com/lightningnetwork/lnd
make &amp;&amp; make install
</code></p>

<ul>
<li>启动lnd</li>
</ul>


<p><code>
lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxx --bitcoind.rpcpass=xxxx --bitcoind.zmqpubrawblock=tcp://192.168.2.1:28332 --bitcoind.zmqpubrawtx=tcp://192.168.2.1:28333
</code></p>

<h4>建立一个新钱包，充值</h4>

<p><code>
lncli --network=testnet create
</code>
之后按照提示一路回车下去，建立一个新钱包，然后执行下列命令得到一个新地址</p>

<p><code>
lncli --network=testnet newaddress np2wkh
</code></p>

<ul>
<li>去下面这几个网址列表领取一些免费的TestNet Bitcoin:</li>
</ul>


<p><a href="https://lnroute.com/testnet-faucets/">https://lnroute.com/testnet-faucets/</a></p>

<ul>
<li>执行下面命令看看余额</li>
</ul>


<p><code>
lncli --network=testnet walletbalance
</code></p>

<h4>连接通道</h4>

<ul>
<li>首先执行下面命令确认我们的节点的同步状态</li>
</ul>


<p><code>
lncli --network=testnet getinfo
</code>
确认<code>synced_to_chain</code>字段已经变成true，代表区块头同步完毕。</p>

<ul>
<li>然后去下面的网址找一个可用的闪电节点:</li>
</ul>


<p><a href="https://explorer.acinq.co/">https://explorer.acinq.co/</a></p>

<ul>
<li>我们选一个channel数比较多的然后连接这个节点：cosmicApotheosis</li>
</ul>


<p><code>
lncli --network=testnet connect 03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028@138.229.205.237:9735
</code></p>

<ul>
<li>下一步建立通道，这里我们存0.1btc到通道里:</li>
</ul>


<p><code>
lncli --network=testnet openchannel --node_key=03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028 --local_amt=10000000
</code></p>

<ul>
<li>查看节点连接状态：</li>
</ul>


<p><code>
lncli --network=testnet listpeers
</code></p>

<p>这里我们还需要等待3次确认，通道才能建立成功，记住刚才建立完的transaction id，去网上查询等待3次确认。</p>

<ul>
<li>检查通道的状态：</li>
</ul>


<p><code>
lncli --network=testnet listchannels
</code>
当通道打开的时候，就可以用闪电网络支付啦！</p>

<h4>支付</h4>

<ul>
<li>我们去<a href="https://testnet.satoshis.place/">satoshi.place</a> 随便来几笔涂鸦，得到一个支付地址:</li>
</ul>


<p><code>
lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d
</code></p>

<ul>
<li>在命令行里支付：</li>
</ul>


<p><code>
lncli  --network=testnet sendpayment --pay_req  lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d
</code></p>

<p>顺利的话，瞬间支付成功。</p>

<h4>小结</h4>

<p>看起来是不是很麻烦，相信我，实际做一遍的话坑也不少。</p>

<p>目前有小部分钱包实现了闪电网络支付；但是拍脑袋想想就知道钱包里面无法包含闪电节点的全部功能：因为收款需要时时刻刻的监控，所以不可避免的需要一个类似于<code>瞭望塔</code>式的服务，最合理的办法就是将这个功能的实现剥离出来，单独部署到一台服务器上。</p>

<p>electrum轻钱包在<a href="https://github.com/spesmilo/electrum/issues/2557">这里</a>讨论了典型的实现方式。</p>

<p>可以预见到将来，实现闪电网络的钱包除了要自建全节点之外，还需要建立稳定的闪电网络节点实现类似<code>瞭望塔</code>的功能，当闪电网络极大繁荣的时候，钱包服务商实际上会占据及其有利的地位，闪电网络的发展，需要比特币钱包软件的进化，这是一个非常大的商机。</p>

<h2>参考资料:</h2>

<p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html">https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html</a></p>

<p><a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<p><a href="https://www.8btc.com/article/92887">https://www.8btc.com/article/92887</a></p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p><a href="https://blog.bitmex.com/zh_cn-the-lightning-network/">https://blog.bitmex.com/zh_cn-the-lightning-network/</a></p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p><a href="https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/">https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy 10th Birthday Bitcoin]]></title>
    <link href="https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin/"/>
    <updated>2019-01-03T21:12:12+08:00</updated>
    <id>https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin</id>
    <content type="html"><![CDATA[<p>自 <a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a>在2009-01-03 诞生以来，bitcoin 已经运行十年了。从一个个人项目，成长为世界话题，一段不可思议的旅程。</p>

<p>有人在&lt;纽约时报>上面为其庆生：</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/">https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/</a></p>

<p>我在2013年初次读到白皮书的时候申请了一个域名:</p>

<p><a href="http://20090103.com/">http://20090103.com/</a></p>

<p>出于好玩的心态一直维护着，看看下一个十年会是怎样。</p>

<h4>Hi, Happy 10th birthday bitcoin!</h4>
]]></content>
  </entry>
  
</feed>
