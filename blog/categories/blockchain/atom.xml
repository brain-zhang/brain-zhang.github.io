<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2018-11-29T11:50:30+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Event-stream,一次可怕的社工]]></title>
    <link href="https://happy123.me/blog/2018/11/27/event-stream/"/>
    <updated>2018-11-27T16:06:38+08:00</updated>
    <id>https://happy123.me/blog/2018/11/27/event-stream</id>
    <content type="html"><![CDATA[<p>几天前有人在github创建了一个issue:</p>

<p><a href="https://github.com/dominictarr/event-stream/issues/116">https://github.com/dominictarr/event-stream/issues/116</a></p>

<p>标题为："I don&rsquo;t know what to say.&ldquo;，翻译过来大概就是“我无语了”。因为 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p>

<!-- more -->


<p>event-stream 被很多的前端流行框架和库使用，每月有几千万的下载量。作为最流行的前端框架之一，在 Vue 的官方脚手架 vue-cli 中也使用了这个依赖，作为最流行的前端框架之一，这个影响还是挺大的，这个影响还是挺大的。而 React 则躲过了。</p>

<p>flatmap-stream 中的恶意代码会扫描用户的 nodemodules 目录，因为所有从 npm 下载的模块都会放在此目录。如果发现了在 nodemodules 存在特定的模块，则将恶意代码注入进去，从而盗取用户的数字货币。</p>

<p>COPAY钱包因为引用了event-stream库，它在今年9、10、以及11月27日之前发布的所有版本都受到了感染，COPAY是bitpay旗下的开源钱包，市场占有率不可小觑；下面这个链接进行了分析，使用被感染钱包的用户很有可能被窃取私钥:</p>

<p><a href="https://github.com/bitpay/copay/issues/9346">https://github.com/bitpay/copay/issues/9346</a></p>

<p>COPAY紧急发布了5.2.2修正版本：</p>

<p><a href="https://github.com/bitpay/copay/pull/9348">https://github.com/bitpay/copay/pull/9348</a></p>

<h2>使用COPAY钱包的人，请立即升级新版本，并且生成新的钱包，把老钱包里面的币转走。</h2>

<p>这个恶意模块更可怕之处，在于背后的骇客是个深谋远虑、精于社工的人。</p>

<p>这个人的github账号叫做<a href="https://github.com/right9ctrl">right9ctrl</a>，他应该是精心分析了COPAY引用的所有模块，发现event-stream有机可乘。于是给event-stream的创始人-<code>dominictarr</code>发去了邮件，承诺会自愿维护这个项目。</p>

<p><code>dominictarr</code>是一个高产的开发者，他维护着多个NPM包，有人能自愿分担他的工作，他自然是高兴之至，于是将这个模块的仓库控制权移交给了<code>right9ctl</code>。</p>

<p>刚开始的时候，<code>right9ctl</code>非常小心的进行着常规的维护。一段时间后，即在 3 个月前，黑客在 GitHub 上新建了一个 flatmap-stream 仓库（内含恶意代码），并在这个项目中引用了自己的仓库。</p>

<p>直到几天前这个有漏洞的仓库才被发现，然后 npm 紧急将这个含有恶意代码的 flatmap-stream 模块删除了。</p>

<p>这个模块的攻击行为也很隐蔽，首先他只有引用了 event-stream 这个库，并且依赖引用了 flatmap-stream，用户在编译自己的项目时，才会感染恶意代码。</p>

<p>感染恶意代码的程序，也不会全部发作。只有COPAY钱包运行时，他才会悄悄的窃取用户信息，并发送到下面这几台服务器：</p>

<p><code>
copayapi.host
51.38.112.212
145.249.104.239
111.90.151.134
</code></p>

<p>我不知道截止到现在黑客获取了多少币，但整个事件非常惊悚。而且这个漏洞刚刚被发现，我认为还会持续有消息不灵通的受害者。</p>

<p>另外，如果想查看自己的项目是否受到影响，可以运行：</p>

<p><code>
$ npm ls event-stream flatmap-stream...flatmap-stream@0.1.1...
</code></p>

<p>如果在输出里面包含了 flatmap-stream 则说明你也可能被攻击。</p>

<p>如果使用 yarn 则可以运行：</p>

<p><code>
$ yarn why flatmap-stream
</code></p>

<h2>区块链历史中的传奇HACK手段</h2>

<p>我在以前的文章中多次感叹所谓的区块链技术出来后，简直是黑客的黄金年代！大概从2011年开始，精彩的HACK事件层出不穷，如果要全部整理出来，可能会是一部让所谓的<code>区块链专家</code>和<code>区块链投资者</code>冷汗直流，后怕不已的手册。</p>

<p>撇开这几天的市场动荡，币价大跌不提，单单从技术上评估，能有多少人意识到他们所谓的投资的技术风险！</p>

<p>我随意的说几件印象非常深刻的HACK事件。</p>

<h4>整个国家DNS 流量劫持事件</h4>

<p>我记得大概是2015年，巴西的骨干网DNS整个被黑客劫持了，导致当时的blockchain.info 在线钱包有几个小时的流量完全被导向了钓鱼网站，这次事件导致的丢币数目不可统计。</p>

<p>但是给你一个启示，当利益足够大的时候，任何设施，包括国家设施都是不可信、不安全的。结合这两天发现的jd.com流量返利劫持，你就知道：网络世界里，有的组织或者个人，完全可以劫持一个国家的网络流量，这不是天方夜谭。</p>

<h4>官方域名劫持事件</h4>

<p>今年二月份的时候，有人花大价钱买了"electrumltc.org"这个域名，仿照"<a href="https://electrum-ltc.org/">https://electrum-ltc.org/</a>&ldquo;官网，精心炮制了一个以假乱真的网站，然后把下载链接改成了恶意钱包，并且做了Google SEO，把自己的骗子网站搜索结果推到了第一名；有人因此丢了2399个LTC，那个时候可是不少钱。</p>

<p>很讽刺的是，恰恰是因为真正的开发者买不起这个域名，才搞了一个山寨的域名发布自己的软件，让骇客有机可乘。</p>

<p>讽刺吧，原作者辛辛苦苦开发，却因为没钱买域名不得已搞个屌丝网站，骇客财大气粗，直接买下第一官方域名然后钓鱼，并且真的获取巨大收益。</p>

<p>这种钓鱼手法在多个钱包、多个网站上面一再重演，受害小白不计其数！</p>

<p><code>杀人放火金腰带，修桥补路无尸骸。</code>这个世界就是这样。</p>

<p>整个事件回顾：</p>

<p><a href="https://github.com/pooler/electrum-ltc/issues/176">https://github.com/pooler/electrum-ltc/issues/176</a></p>

<h4>~~~~</h4>

<p>这么罗列下去，我可以轻易列举出更多的涉及上亿美元的hack事件。每个事件说起来好像天方夜谭一样，不明技术的小白可能会惊叹：怎么可能有这种事情？！</p>

<p>但是事实就是这样，而且将来这样的悲剧会一再重复下去，说再多也没用，人的安全意识总敌不过懒惰、贪婪等等等等，可悲的人性啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoind Conf Template]]></title>
    <link href="https://happy123.me/blog/2018/11/26/bitcoind-conf-template/"/>
    <updated>2018-11-26T14:51:43+08:00</updated>
    <id>https://happy123.me/blog/2018/11/26/bitcoind-conf-template</id>
    <content type="html"><![CDATA[<p>bitcoin core 0.17版本开始废弃了不少RPC调用，另外RPC配置增加了test.rpcport参数，存一份模板:</p>

<!-- more -->


<p><code>
rpcuser=xxxx
rpcpassword=xxxx
rpcallowip=127.0.0.1
rpcport=18332
test.rpcport=8332
rpcthreads=10
server=1
rest=1
walletnotify=/usr/bin/python3 /xxx.py
</code></p>

<p>另外<code>getaddressesbyaccount</code>即将废弃，可以使用<code>getaddressesbylabel</code>代替</p>

<p><code>signrawtransaction</code>即将废弃，实在要用的话只能在启动命令行中加deprecatedrpc指定。</p>

<p><code>
bin/bitcoind --conf=/xxx/bitcoin.conf --datadir=/xxx/blockdata/mainnet --deprecatedrpc=signrawtransaction
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-1]]></title>
    <link href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/"/>
    <updated>2018-11-23T18:48:39+08:00</updated>
    <id>https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1</id>
    <content type="html"><![CDATA[<p>在我们前面的文章中，我们提到，从建设银行转账到工商银行10w元，过程其实是这样的:</p>

<ol>
<li>建设银行发送报文到人行CNAPS系统</li>
<li>人行CNAPS发送转账报文到工商银行</li>
<li>工商银行发送响应报文给人行CNAPS</li>
<li>人行发送响应报文给建设银行</li>
<li>转账成功，建设银行、人行、工商银行各自更新账本</li>
</ol>


<p>整个过程中，有几个很有趣的事实：</p>

<!-- more -->


<ol>
<li>所谓的转账交易，不过是账本上数字的加加减减</li>
<li>我们的账户，除了各自在工行、建行开设的户头之外，在人行还有一个总账；人行是所有银行的妈，你在任何银行开设的账户，人行都有一个总账；所以打印征信的时候我们要到人行打印</li>
<li>建设银行和工商银行间的转账需要人行做清算，人行提供了信用；建行和工行相信人行不会造假</li>
<li>我们需要信任三个机构：人行、工行、建行，我们相信他们不会造假</li>
<li>人行是所有账目的中心节点，人行的账本对不上了，中国的金融系统就乱套了</li>
</ol>


<p>然后作为对比，我们来看看比特币是怎样设计的。</p>

<p>中本聪创造比特币之初，在<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis Block</a>里面付了一句有名的话:&ldquo;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"。在白皮书中他很自豪的宣称:"We have proposed a system for electronic transactions without relying on trust. &rdquo; 去中心化一直是比特币的指导纲领，那么问题来了，如果让我们来设计一个去中心化的账本，将会面临哪些技术问题，又该如何解决呢？</p>

<p>很自然的，我们设想的是一个类似于分布式数据库的系统，整个系统维护着唯一的账本，每个节点（node）都是一个副本（Replica Set），每个副本保有完全的账本数据，并且节点间相互同步数据，如果部分节点挂掉，不影响整个系统的运行。</p>

<p>用户转账的行为，其实就是这个分布式账本的增删查改。当然，为了简化设计，我们这个账本可以只支持账目写入，不支持删改。</p>

<p>我们开始思考这个分布式账本要解决的两个核心问题：</p>

<h4>什么样的交易是一笔合法的交易</h4>

<ul>
<li>一笔交易中，如何保证交易账户的完全所有权；如果保证用户A的资金不会被用户B盗用</li>
<li>用户A本来有1000元，如何保证他不会转出2000元？</li>
</ul>


<h4>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</h4>

<ul>
<li>如果有部分节点是不诚实的，它就会有动机去伪造不存在的交易来获取利益，如何识别并排除不诚实的节点？(拜占庭将军问题)</li>
<li>如果A的账户有1000元，发送了1000元给B，由于是分布式系统，部分节点收到了这笔交易，这时候A又发送了1000元给C，另一部分收到了这笔交易，这时候该如何处理？如何保证一笔钱不会被花两次？ (双重支付问题)</li>
</ul>


<p>为了解决这两个问题，比特币引入了三个核心技术：UTXO交易模型、POW工作量证明、blockchain数据结构组织。且让我们一一道来。</p>

<h2>初版交易设计</h2>

<p>如果读了之前我们的&lt;比特币HD钱包>系列文章；天然的，我们意识到非对称加密方法是在分布式账本中建立账户的天选之术；</p>

<h4>存款</h4>

<p>用户A想要建立一个账户，只要在帐目中增加一笔 <code>公钥+金额</code> 的记录就可以了。我们用一个表格表示整个账本，用户A以及用户B各存入50个币的动作可以记作:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50)</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50)</td>
</tr>
</tbody>
</table>


<p>这个原始存入的资金我们先不去纠结怎么来的，总之此时账本中有两笔交易，代表着A以及B各自有50个币</p>

<h4>验证</h4>

<p>在账目1中，如何验证A确实是这笔资金的拥有者呢？非常简单，就是账户资金增加的时候，A对这笔交易数据的摘要用私钥做一个签名，然后再把公钥附在后面就可以了，这样账目就变成了这样:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
</tbody>
</table>


<p>任何一个要验证账户A的节点或第三方，对其所有权证明用公钥解密，然后对照摘要(digest)即可。</p>

<h4>转账</h4>

<p>如果A要向B转账20个币呢，我们最简单的设计，就是构造Trans1 &ndash; 20，然后同样的方法构造签名即可，这样账本如下:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
<tr>
<td>3 </td>
<td> Trans3:Trans1-20 &ndash;> B</td>
<td> signature(digest(Trans1 &ndash; 20 &ndash;> B))+A公钥</td>
</tr>
<tr>
<td>4 </td>
<td> Trans4:存入(B公钥+20) </td>
<td> signature(digest(Trans4))+B公钥</td>
</tr>
</tbody>
</table>


<p>看起来一切还好，但是这个时候我们发现了一些缺点</p>

<ol>
<li>收到汇款的时候因为要添加所有权证明，账户拥有者得一直在线监控自己的账户地址</li>
<li>收款人还得验证汇款人的合法性，感觉都点怪；我收钱就好了，还得去管这个钱合不合法？</li>
<li>如果多重转账，或者一对多，或多对一，这个记录格式就复杂了</li>
<li>用户B要验证一笔交易合法性的时候，可能要回溯到账本非常深的位置，因为上一笔交易可能发生在很久之前，这种交易记录的存储设计很难高效查询</li>
<li>最后，这个账目设计中，所有账户的公钥是暴漏在外的；虽然椭圆曲线算法目前看来牢不可破，但是整个安全体系只依赖一个非对称加密算法，比较脆弱</li>
</ol>


<p>解决方法其实也简单，换个思路，就是A转账给B，B是不需要验证的，只要A提供账户所有权的证明就好了，想想我们平时转账，不也是这样的吗？</p>

<p>那么最简洁的设计，就是借鉴现实世界。每一笔交易都看作是硬币的流转，硬币其实没有特征，它只是从A的保险箱转移到了B的保险箱而已，那么，采用什么办法来表示：<code>这是A的保险箱中的一笔资金币</code>这个譬喻呢？</p>

<h2>进阶交易设计</h2>

<h4>UTXO 模型</h4>

<p>比特币的账本世界，构筑在UTXO (Unspent Transaction Output)之上；其实每个UTXO代表着未花费的一笔硬币(数额可大可小，没有限制)；一个账户的资金，其实就是一堆UTXO的集合；转账交易，就是一个或多个UTXO的输入再输出为另外的UTXO而已。你可以想象成现实世界中金银铸币的流通。</p>

<p>那么一个UTXO中包含什么呢？如何作为输入呢？如何构造输出呢？这就是比特币交易的核心技术。</p>

<ul>
<li>我们用下面一张图来表示<code>A保险箱里面的50个硬币</code> 这件事：</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg1.jpg" alt="img" /></p>

<p>把它想象成一个邮筒构造的保险箱，在不打开的前提下，投币是只进不出的。可以注意到，我们并没有直接将Public Key明晃晃暴露在外面，而是先HASH一下，然后贴到保险箱子上面，想要存币的人，只要知道这个HASH值，作为保险箱的ID，就可以直接投币进去啦。</p>

<p>但是保险箱的锁在哪里呢？</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg2.jpg" alt="img" /></p>

<ul>
<li>这张图中，我们引入了一个脚本，称之为 <code>Pubkey Script</code>；具体内容是:</li>
</ul>


<p><code>
OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></p>

<p>呵呵，像天书吧，不要怕；这是我们特有的保险锁构造。细节会在后面讲到。这里你可以这样简单理解：</p>

<p>为了锁住这个保险箱里的资金，比特币系统设置了一个谜题作为锁。解开这个谜题，才能转移里面的资金。</p>

<p>这个谜题是这样构造的:</p>

<ol>
<li>记录了A的公开的<code>Public key hash</code>值，开锁的人，需要提供A的<code>full public key</code>，同时验证 <code>hash160(public key) == Public key hash</code></li>
<li>需要提供A的私钥基于这笔交易的签名Signature, 这样系统可以用<code>full public key</code>来验证公私钥是否匹配</li>
</ol>


<p>这个过程是通过上面的脚本指令通过入栈出栈执行的，这也为比特币系统验证更复杂的交易逻辑提供了基础，甚至能作为一个简单的虚拟机执行更复杂的组合指令。</p>

<p>整个过程组织如下图：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg3.jpg" alt="img" /></p>

<p>当我提供一个signature以及full public key的时候，就可以开锁了，开锁下一步自然就是转移资金啦。我们给B汇款50个币，而B的保险箱又是怎么表示的呢？和A保险箱是一样的。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg4.jpg" alt="img" /></p>

<ul>
<li><p>带有<code>public key hash</code> ID的保险箱是一个UTXO，这个保险箱用<code>public key hash</code>上锁，而提供<code>signature</code>和<code>full public key</code>开锁，转移资金的过程，就是花费UTXO的过程，其实就是把A的UTXO转移到B的UTXO的过程，这就是比特币最简单的一笔交易</p></li>
<li><p>我们可以继续拓展下去，可以1对多支付，多对1支付，多对多支付，更复杂的多签名支付，延迟支付等等，今后我们会详细介绍</p></li>
</ul>


<p>这个系统有如下优点:</p>

<ol>
<li>所有的交易都抽象为了UTXO的转移，你可以想象一下，一堆硬币在几个保险箱之间转移的样子</li>
<li>用户其实可以不检查交易的合法性，只要运行分布式账本的所有节点检查通过合法后，确保写入账本就保证资金的安全转移了</li>
<li>每个账户的拥有者在真正花费UTXO之前，是不用暴露公钥的</li>
<li>验证UTXO交易合法行的函数，抽象为几个指令的集合，这个验证行为指令通用化，为智能合约编写创造了条件</li>
<li>这样的交易记录非常容易组织，我们以后可以看到；把这些交易批量打包，组织成名为blockchain的精巧数据结构，有许多优点</li>
<li>一个用户A可以用一个私钥加密多个保险箱，或者多个私钥加密多个保险箱，非常灵活</li>
</ol>


<h2>小结</h2>

<p>好啦，看到这里，我们对比特币的最简单的交易构造已经有感性认识了。但是俗话说得好: <code>光说不练假把式</code>，下篇文章我们就会手工构造一笔完整的交易，让你搞明白其中细节。</p>

<p>另外，我们前面提出了好几个问题:</p>

<ul>
<li>原始资金从何处来？</li>
<li>节点如何解决拜占庭将军问题？</li>
<li>节点如何解决双重支付问题？</li>
</ul>


<p>后面我们会一一解答，那么，下次再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币、支付、清算漫谈]]></title>
    <link href="https://happy123.me/blog/2018/11/19/huo-bi-%2C-zhi-fu-%2C-qing-suan-man-tan/"/>
    <updated>2018-11-19T16:55:29+08:00</updated>
    <id>https://happy123.me/blog/2018/11/19/huo-bi-,-zhi-fu-,-qing-suan-man-tan</id>
    <content type="html"><![CDATA[<p>又看了一遍 <a href="https://book.douban.com/subject/26802686/">The book of Satoshi</a> 这本书，果然常读常新啊；又有很多想法冒出来，结合最近的BCH分叉事件，我不禁又开始思考金融系统的两大环节：清算和支付，究竟会如何发展？</p>

<p>我从事银行业务系统监控很长时间，结合咱的职业生涯所学，再重新梳理一遍支付和清算的发展史吧。</p>

<!-- more -->


<p>除了支付和清算，还有一个拓展概念，即结算。看一下权威机构的定义:</p>

<p>按照国际清算银行支付结算委员会的定义，所有涉及到资金转移的行为，都可视作支付行为，支付的概念最大，清算和结算属于支付过程中的特定环节，其中，清算是发生在结算前的支付环节，该环节的功能主要是为了提高结算的标准化水平和结算的效率。</p>

<ul>
<li><p>支付：完成付款人向收款人转移可以接受的货币债权的过程，包括交易过程、清算过程和结算过程等三个过程。</p></li>
<li><p>清算：包含了在收付款人金融机构之间交换支付工具以及计算金融机构之间待结算的债权，支付工具的交换也包括交易撮合、交易清分、数据收集等。</p></li>
<li><p>结算：该过程是完成债权最终转移的过程，包括收集待结算的债权并进行完整性检验、保证结算资金具有可用性、结清金融机构之间的债券债务以及记录和通知各方。</p></li>
</ul>


<h2>史前阶段</h2>

<p>支付清算的历史其实要比货币历史久远的多，但货币的演变是支付清算体系发展的原动力。</p>

<p>在货币产生前，物物交换其实就是一种支付行为，比如原始人甲有桃子，但喜欢苹果，而此时刚好碰到原始人乙，乙有苹果，但喜欢桃子，这样两个人就刚好满足双方的需求，甲向乙支付桃子，得到苹果，乙向甲支付苹果，得到桃子。这就是最原始的“支付”。随着持有香蕉的原始人丙也加入上述交易，那么必须形成需求的闭环，而且随着交易的物品数量、种类逐渐增多，就需要再找一个不参与交易的原始人丁专门做交易的分类、计数和记录，并且甲乙丙在丁面前都作出承诺：一是手里的桃子、苹果、香蕉都是真实存在的。二是交易的意愿都是真实的，不会拿了人家的东西却不给出自己的东西。那么丁做的事情就是最原始的“清算”。之后，桃子、苹果、香蕉交割到了新的主人手中，此时丁宣布交易成功结束，甲乙丙三方各不相欠&mdash;最原始的“结算”。</p>

<p>此时丁付出信用，承担了清算的网关。当然，这种清算是非常粗糙的，作为一个支付行为的环节不明显。</p>

<p>后来随着商品交换规模的扩大，统一的支付媒介就出现了。从最原始的贝壳，到铁铜铸币，再到金银物品，形成了人们统一承认的货币媒介。实物货币如金银货币的出现极大地提升了商品交易的成功率，形成了以货币为核心和交易媒介的支付清算体系雏形，极大地推动了贸易和经济社会发展。</p>

<p>此时的清算其实和支付行为频率差不多的，因为当时的贸易市场并不繁荣，货币媒介还很粗笨，可以说每一笔支付就伴随着一笔清算，清算如此重要，以至于此时的货币市场上最重要的并不是货币本身，而是记账的权力，最经典的例子就是我们前面文章中提到的雅浦岛的石币故事。</p>

<h2>纸币阶段</h2>

<p>但随着商品交易规模和范围的不断扩大，金银货币越来越不能更好地满足贸易经济大规模发展的需要，人们就开始尝试以收兑金银之后的收据代替金银实物进行流通，随着这种收据广为人们接受，纸币就此诞生了&mdash;这是货币发展史上的一个重要突破。当然，纸币是要与其背后的金银货币的成色、数量挂钩的，也就是金银本位制，而且发行纸币的单位是多样的，可以是国家，也可以是有实力有信誉的金银铸造商等等。这时的纸币仅仅只是一种“表征货币”。纸币的出现极大地提升了支付的便利性，但由于纸币的伪造难度和成本比金银货币低太多，如何避免收到假冒伪劣的纸币甚至防止纸币超发成为突出的难题。自此，支付的便利性与安全性因为支付工具（如纸币）从交易媒介（如金银货币）分离独立而始终成为一对矛盾。</p>

<p>纸币阶段其实和金银实体是并存的，这个时候的清算行为其实更好分辨；拿我们熟悉的晋商作为例子：</p>

<blockquote><p>早在清道光（1823年）年间，山西平遥商人就创立了“日升昌”等专门办理汇款业务的票号（古代的票号、钱庄就是现代银行的雏形）。
著名的红顶商人胡雪岩就是做票号生意起家的。
当时的票号支持异地汇款业务：客户来日升昌汇款，交了银子之后，票号就开出汇票给客户。
跟银行一样，票号也有总号和分号，客户可以携带汇票或者把票寄给亲人，只要凭票就可以到日升昌全国各地的分号兑出银子，分号给客户兑换之后先记内部账，日后再和总号清算债务。
从此之后，商人在城市之间贸易可以不用携带大量的银子。而汇票在不同城市的各个分号之间流转也形成了很多债务，有大量的银子需要周转，镖局就专为票号来运送银子以及为商人运送票据，有点类似于现在为银行押钞的威豹，不过镖局的手续费可是高达5%！</p></blockquote>

<p>整个过程中，每个月或年底各个分号之间周转银子，轧平账目的过程就是清算。虽然清算是整个支付环节的一部分，但是清算的频率比较低，平均下来多笔支付可能才发生一笔清算，所以此时表面上看货币是非常活跃的，清算作为一种记账行为默默引申到了后台。</p>

<h2>信用阶段</h2>

<p>牛顿爵士开创了金本位，其实在整个货币史上不过短短一段时间，然后我们现在就飞速的跳跃到了信用货币阶段，信用货币发展的技术基础，就是越来越完善普及的电子设备。可以想象，将来即使在非洲，持有一个智能电子钱包(不一定是手机)的成本也会小于持有纸币的成本，所以货币电子化的趋势不可逆转。</p>

<p>铸币信用化，表现形式电子化之后，最明显的一个改变，就是<code>清算</code>这个行为，夹杂在整个支付过程中越来越频繁了；</p>

<ul>
<li>原来钱庄分号之间轧账，周期可能半年一年记</li>
<li>金银铸币时代，两国之间的轧账，也可能持续几周</li>
<li>纸币化之后，可能国际汇兑、债券市场之间的清算，通过电报以及联行信件，就缩短到几天了</li>
<li>到了今天，跨行汇款，已经缩短到分钟级别了；移动支付，都可以到秒级了</li>
</ul>


<p>此时清算的次数又大致跟支付行为一个量级了，记账的技术又开始一轮飞跃；</p>

<p>放到我国来，伴随着改革开放，我们的金融市场30年走完了欧美100年的历史，其中支付清算系统的发展就是经典的代表，这段历史我比较熟悉，下面就我国的支付清算系统建设流水账一番;</p>

<h3>全国手工联行系统 (1949-1990)</h3>

<p>建国初期的银行是比较LOW的，那个时候的银行是沿袭历史发展过来的。因此银行之间的资金往来(通存通兑)，其实跟晋商时代的票号差不多，每个银行都和其它大行之间签订协议，开设备付金账户，实现互兑。</p>

<p>比如三家银行： 工行、建行、招行，他们每家银行都要在另外两家银行开设账户，存入准备金，不同银行间的业务往来像票号一样定期轧账。</p>

<p>此时，每家银行都是一个清算机构，为银行间的资金往来做清算。</p>

<p>这种清算方式无疑是低效的，每成立一家银行，要开启业务，都得一家家的在同行那里开设账户，费时费力。所幸那个时候的银行少，而且计划经济金融业务少，这么多年就凑合过来了。</p>

<p>一直到1984年中国人民银行专门行使中央银行职能之后，我们国家确立了法定存款准备金制度。央行的备付金系统正式确立。此时，银行跨行的资金清算有两种选择：</p>

<ul>
<li>用老办法，在所有有往来的银行开立清算账户清算</li>
<li>所有金融机构都在央行开立清算账户，由央行为商业银行统一清算</li>
</ul>


<p>显然大家都想用第二个方案。然而在那个时代，央行能承担的职责是很有限的，各银行内部数据还没有集中，没有电子化的记账系统，国内甚至都还没有银行卡，客户要转账也没有满大街的ATM。总之一句话，国内的金融环境还没有达到让央行推行全国统一结算制度的客观条件。</p>

<p>为了满足跨行结算的需求，央行当时提出商业银行要“自成联行系统，跨行直接通汇，相互发报移卡，及时清算资金”。也就是说同一家银行的总行及分支机构称为“联行系统”。同一联行内的资金结算，由联行总行自己做。这样，建行深圳分行和建行北京分行之间的资金清算由建行自己内部解决。跨银行之间要能支持直接汇款。跨行业务可以由央行清算，也可以由商业银行自己清算。</p>

<p>这是个各家银行系统很不智能，体验很差的时期，我们称为“全国手工联行”时期。于是，每家银行都可以接受跨行的汇款，银行每天自行轧差，各种交易汇总计算后，需要告知其他行的交易信息写成一张张特定的公文，加盖印鉴后在银行间送来送去。这种公文叫做联行信件，而收发联行信件就是当时邮电局的重要业务。</p>

<h3>全国电子联行系统EIS (1989-2005)</h3>

<p>随着银行业的不断发展，银行每天处理各类跨行业务的数量增多，各家银行之间的债权债务关系变得非常复杂，由各家银行自行轧差进行清算变得非常困难。这种状况要求央行必须承担起一个全国清算中心的角色。于是，央行在1989年12月6日，发布了“关于改革联行清算制度的通知”。</p>

<p>随后在1990年，中国人民银行清算中心建成，专门为金融机构提供支付清算服务。这个清算中心包括NPC和CCPC：</p>

<ul>
<li>NPC（National Process Center，国家金融清算总中心）</li>
<li>CCPC（City Clearing Processing Center，城市处理中心）</li>
</ul>


<p>1991年4月1日，基于金融卫星通讯网的应用系统——全国电子联行系统（EIS）开始试运行。EIS是人民银行专门用于处理异地（包括跨行和行内）资金清算和资金划拨的系统。它连接了商业银行、央行、NPC和CCPC。</p>

<p>假设客户在深圳建行汇款给北京工行，通过EIS处理一次跨行汇款的流程如下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg1.png" alt="img" /></p>

<p>可以看到，清算中心在各地建立了一个个分站，分站和总中心通过卫星网络互联，总站和分站共同构成了清算网络，为其它接入EIS的各家商业银行提供清算服务。</p>

<p>从此之后，各个银行之间的跨行汇款，以及同一银行的异地分行，就可以直接通过这样的电子化操作来完成了，客户的资金在途时间缩短到了一两天，这也算是中国金融系统的一大里程碑了。</p>

<p>PS: 直到2015年，我都在一些银行的老系统中见过EIS，这个东东真的很经典，生命力很顽强啊。</p>

<h3>现代支付系统CNAPS (1991-现在)</h3>

<p>1991年EIS试运行后，又发生了两件大事：</p>

<ul>
<li><p>各大银行核心系统投产，各家商业银行的内部联网系统纷纷建成投产</p>

<p>  银行内部资金划转都可以通过自己的核心系统解决了。这意味着各大行都可以做电子化的行内清算了，行内异地转账就不用再依赖EIS。笔者跑过许多银行，见识了许多核心系统的投产，几乎所有的核心系统设计都是一个套路，将来有时间可以再有一篇文章细说一下。</p></li>
<li><p>中国现代化支付系统（CNAPS）开始设计</p>

<p>  1991年10月，中国开始着手建设中国国家金融通信网（CNFN）和中国现代化支付系统（CNAPS，China National Automatic Payment System）。从此，全国电子联行（EIS）系统逐步向CNAPS过渡。到了二十一世纪，IT技术飞速发展，央行的CNAPS一代系统（大小额支付系统）也开始走上历史舞台。中国的支付清算步入了现代化支付系统CNAPS的时代。</p></li>
</ul>


<p>CNAPS值得我们大说特说，今天银行的主力业务都跑在它的基础上，它的发展历史上有几件大事:</p>

<ol>
<li>2002年，央行大额实时支付系统（HVPS）投产，用于处理同城和异地的商业银行跨行之间（也包括行内一定金额以上的）大额贷记业务。</li>
<li>2005年，央行小额批量支付系统（BEPS）投产，用来处理同城和异地纸凭证截留的借记支付业务以及每笔金额在5万以下的小额贷记支付业务。</li>
</ol>


<p>这两个业务统称为大小额系统，我们平时的跨行转账，走的就是这两个系统，他们之间有如下区别:</p>

<ul>
<li>首先，大小额的开放时间不同</li>
</ul>


<p>大额系统是工作日的 8:30 ~ 17:00，所以在节假日经常会收到银行通知说某些业务暂停了经常就是因为央行在节假日对大额系统做维护。小额系统全年无休，7*24小时工作。</p>

<ul>
<li>业务处理上不同</li>
</ul>


<p>大额是每笔交易都实时发送，实时清算的，所以基本上能实时到账，跨行资金零在途。小额系统是在收集若干笔交易后打一个包统一处理，定时清算。所以，用小额系统转账经常要几分钟甚至半个小时才能到账，银行间头寸交割也是非实时的。尽管理论上跨行转账业务不管用大额还是小额，一般在几分钟内都能到账，但是因为要经过央行，所以在这一时期基本没有银行敢向客户承诺资金多久能到账。比如我们早期银行卡转账，一半会发现一个<code>两小时内到账</code>的提醒，这就说明他走的是小额支付系统。</p>

<ul>
<li>金额不同</li>
</ul>


<p>大额系统没有金额限制，小额系统支持的单笔金额上限是5万元。从用途上讲，大额系统侧重于资金转移的时效性，主要用于资本市场、货币市场交易和大额贸易资金结算。小额系统对数据吞吐量要求较高，主要用于小额贸易支付和个人消费服务。</p>

<p>下面一张图就说明了CNAPS大小额的业务实现:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg3.png" alt="img" /></p>

<p>目前大部分手机网银跨行转账都没有手续费。所以如果你在晚上10点想跨行转账10万元，此时大额转账系统已经关闭了，建议你分成两个5万并且用加急方式来转账。</p>

<p>不管怎么说，现在我们的跨行汇款速度总算提高到小时级别了。</p>

<p>PS: 大小额支付的协议细节非常复杂，协议规范有上千页文档，是我去现场部署监控系统时永远的痛啊~~~</p>

<h3>第二代现代支付系统CNAPS2 (2013-现在)</h3>

<p>大小额系统已经很好用了，但是随着金融市场发展，业务需求是无穷无尽的；2013年10月6日，央行的第二代支付系统(CNAPS2)正式投产运行，其中包括2010年就推出的网上支付跨行清算系统（俗称“超级网银”）。超级网银是对大小额支付系统的一个补充，有两大亮点：</p>

<ul>
<li><p>接入机构不再限于银行</p>

<p>  支付宝、财付通等第三方支付也可以接入，所以有的第三方支付给商户提供的提现代发功能就是基于超级网银做的。</p></li>
<li><p>7*24小时实时到账，单笔上限5万元</p>

<p>  这就相当于在非工作日非营业时间增加了一种大额支付系统特性的渠道了。只不过金额限制是跟小额系统一致的。</p></li>
</ul>


<p>最后来一张总体架构图:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg2.jpg" alt="img" /></p>

<p>PS: 现场协议监控部署，<code>人行二代支付</code>是我听了上万遍的词汇啊，睡觉都无法摆脱~~~</p>

<h3>三方支付渠道</h3>

<p>人行的CNAPS2为不同银行间提供了清算服务，银行内部的核心系统为自己不同的分行间提供了清算服务。这两块已经覆盖了大多数的银行业务场景，包括:</p>

<ul>
<li>银行柜台&mdash;直接大小额转账</li>
<li>手机网银&mdash;大小额转账+超级网银</li>
</ul>


<p>但是还有一部分商业市场没有涉及到，就是我们常说的三方支付。我把它又分为两个场景:</p>

<ol>
<li>ATM 刷卡取款和POS机刷卡</li>
<li>网银支付</li>
</ol>


<p>在支付宝普及之前，POS机刷卡以及ATM取款都是我们日常生活中比较常见的资金流转渠道。相信大家都有不少储蓄卡及信用卡有着<code>银联</code>标识。这个银联又是何方神圣？</p>

<p>银联全称<code>中国银联银行卡跨行支付系统</code>，英文缩写为CUPS；我们说支付市场是很大而且油水很足的，人行作为银行的妈，建设清算系统主要是政治考量，而商业银行进军支付领域是要挣钱，所以2002年3月26日，经中国人民银行批准,各大发卡行的商业银行参股，成立了银联。</p>

<p>银联的目的就是提供人行二代支付之外的资金清算渠道，在支付场景捞油水。我们看一下ATM刷卡和POS机业务中，银联发挥的作用。</p>

<h4>POS机刷卡</h4>

<p>POS机刷卡的参与方比较多。以你在星巴克刷卡为例：</p>

<ul>
<li>持卡人——你</li>
<li>发卡行——你办这张卡的银行，我们假设是工行</li>
<li>商户——星巴克，我们假设星巴克的账户开在建行</li>
<li>收单行——星巴克的刷卡机的归属银行，假设也是建行</li>
<li>转接机构——银联</li>
<li>清算机构——银联和人行</li>
</ul>


<p>于是，当你用工行卡在星巴克消费的时候，资金流和现金流是这样发生的：</p>

<ol>
<li>你在收单行（建行）的POS机上刷卡消费</li>
<li>建行将消费报文发送给银联</li>
<li>银联交易系统记录交易数据，将消费报文给你的发卡行（工行）</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行的POS机</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
<li>银联通过小额支付系统或当地票据交换系统，完成建行和星巴克结算账户的资金划拨（收单清算）</li>
</ol>


<p>在这个过程中，银联提供两种清算：</p>

<p>1.建行和工行的清算叫“跨行清算”；
2.建行和星巴克的建行账户之间的清算叫“收单清算”；</p>

<p>无论是跨行清算还是收单清算，银联都是作为CNAPS的一个特许参与者，使用大小额支付清算系统，完成银行卡业务的资金划拨。本质上，银联提供交易转接、清分和对账，人行提供结算。</p>

<h4>ATM跨行取款</h4>

<p>你拿着一张工行卡去建行的ATM取了100元，这个跨行业务在CNAPS体系中的过程如下：</p>

<ol>
<li>你在建行ATM上输入100元按下取款按钮</li>
<li>建行将报文信息发送给银联</li>
<li>银联交易系统记录交易数据，将报文给你的发卡行(工行)</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行ATM</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
</ol>


<p>我们看到，ATM和POS渠道，是由银联的CUPS来对接各大商业银行做支付转接，解决信息流问题；银联同时提供清分和对账服务，对完账之后再调用央行大小额系统解决资金流问题；</p>

<p>当央行系统升级的时候，通过银行柜台和手机银行是不能做跨行转账的，但是通过ATM和POS却可以跨行取款和跨行支付，这是因为银联暂且处理了清分和对账，等到央行系统升级完毕后，他们才进行清算；</p>

<p>所以一般央行挑放假的日子升级系统，这个时候一般没有对公业务，但是我们平常的刷卡消费可以正常进行。</p>

<p>另外，我们说，资金跨行清算的发展中，出现了一位豪杰，就是三方支付的大佬：支付宝</p>

<h4>支付宝等势力的发展</h4>

<p>支付宝早期为了服务淘宝客户和商家，不可避免的要跟银联抢生意，对接各大银行的支付接口。</p>

<p>银联作为既得利益者，绝不会开放接口给支付宝的。所以当时支付宝拿到支付牌照之后，苦逼的一家一家跟跟银行洽谈对接，值得注意的是，支付宝对接的各机构间跨行转账，没有走人行的大小额系统，而是走的支付宝内部资金池。</p>

<p>支付宝积硅步以至千里，慢慢的接入的银行多了，服务竟然能叫板银联了。</p>

<p>印象特别深刻的是，有一年国庆节人行系统升级，当时的小额转账竟然有大多数交易走的支付宝渠道，这时候支付宝已经有能力作为第三大清算网关服务大众了;</p>

<p>另外举一个有趣的例子，因为支付宝早期转账有免费的短信留言服务，所以有人用每笔1分钱的转账服务聊天！而发条短信都1毛钱呢，这跟如今的bitmessage、memocash记录信息何其相似。</p>

<p>我后来工作走了不少地方性的小银行，因为供应商不一样，他们每家的对接方案都不同，支付宝竟然有耐心一家一家的啃下来了，不得不佩服他们下的苦功夫。</p>

<p>当然，后来微信支付也异军突起，三方支付平台各路神仙纷纷跳出来分蛋糕，银联节节败退之后，祭出杀手锏；找央妈诉苦。于是为了平衡各方利益，一纸文件下来，决定建立网联平台，大家之前的自留地接入废除，各方统一接入网联，利益均沾。支付宝之前的平台建设就完成历史使命了。</p>

<p>网联平台的建设由于有阿里和腾讯的研发力量加入，开发异常顺利。2017年开始逐步上线，2018年双十一，就在前几天，官方号称TPS超过了9万笔。实在了得。不得不承认，我国的交易金融系统处理能力在世界上已经是单独一档了。</p>

<h4>小结</h4>

<p>上面长篇大论了我国支付清算系统的建设和发展，无非说明几个问题:</p>

<ol>
<li>金融越发达，支付行为越多，清算所占的比例也水涨船高</li>
<li>清算的速度越来越快，处理效率越来越高</li>
<li>虽然清算接入的机构越来越多，但是清算网关呈现大一统的趋势</li>
<li>清算的交易笔数指数级增长，中国支付清算协会发布《中国支付清算行业运行报告（2018）》称，2017年，国内商业银行共处理移动支付业务375多亿笔，非银行支付机构共处理移动支付业务2390多亿笔，这之中大部分都包含有清算行为</li>
</ol>


<h2>区块链时代</h2>

<p>我认为区块链技术诞生后，清算技术又是一个进化。但是这个进化过程初期表现十分笨拙，以至于看起来像是退化。</p>

<p>在比特币诞生之前，Ripple网络其实已经在传统清算网关的基础上，基于中心化的共识，提出了新的清算网关方案。他们的技术其实很有意思，也非常创新。我们打算放到其它篇章来介绍。目前我们单独谈谈比特币的技术方案。</p>

<h4>容量</h4>

<p>首先比特币由于是去中心化的网络，处理能力是非常低的；即使引入了Segwit附带一点扩容效果，目前也不过是3~4 TPS，和中心化的清算网关相比，简直可怜。</p>

<p>但是比特币系统的特殊之处就在于，他没有集中的账户管理节点，这意味着网络中的每个全节点都承担清算网关的职能，每一笔支付必然带有一笔清算，清算率100%。</p>

<p>这实在是像极了早期雅浦岛上的石头货币系统，我们一再强调这个寓言故事，因为它和比特币如此相像；比特币系统简直是雅浦岛的石币系统的电子版！连处理能力也是如此相似的性能低下！</p>

<p>值得庆幸的是，雅浦岛上的居民限于物理条件，系统性能提升有极限；而现代的电子设备性能提升，横向扩展的话，几乎是无穷尽的。</p>

<p>当前比特币的扩容方案主要是两大流派，经济利益夹杂着技术讨论，是是非非就不评说了，我们撇开矿霸、专利、以及阴谋论，只是整理一下他们目前的发展状况</p>

<h5>闪电网络链下扩容</h5>

<p>主要路线是Segwit 解决交易延展性问题，然后在此基础上实现二层闪电网络。目前来看，Segwit已经占了主网交易的半壁江山，估计最终能扩容到4-8 TPS，这当然不够用。所以二层网络的闪电网络至关重要。</p>

<p>闪电网络目前还是处于试验阶段，虽然推出了一些应用，但总体还是和比特币早期发展一样，只是部分Geek在使用。</p>

<p>优点:</p>

<ol>
<li>中转节点越多，处理能力越强</li>
<li>如果两个节点间能形成比较短的支付路径，理论上它的处理能力会很惊人的，至少是比现在几个数量级的提升</li>
<li>微支付通道里面的交易记录不上主网，这样跑全节点的开销只会线性增长，有利于比特币的去中心化</li>
</ol>


<p>缺点:</p>

<ol>
<li>收款需要保持在线</li>
<li>形成微支付通道需要双方缴纳保证金</li>
<li>建立和销毁微支付通道都需要主网广播，如果支付笔数少，建立通道的得不偿失；因为这个原因，目前来看闪电网络的实际应用不多</li>
<li>闪电网络的中转节点需要大量的保证金，会天然的会向大公司、集权化发展，这也是区块扩容党最诟病的一点</li>
</ol>


<h5>大区快链上扩容</h5>

<p>优点:</p>

<ol>
<li>代码简单，即刻扩容</li>
<li>技术方面来讲，扩容到32M-128M其实开销也不大；根据硬件设备的发展，长远来看，1GB的大区快可能也行得通</li>
<li>有人认为Segwit引入了复杂度，原本的交易格式更改了，技术上有洁癖的人接受不了，大区快扩容没有技术债</li>
</ol>


<p>缺点：</p>

<ol>
<li>有人认为今天32MB，明天更多，扩容起来无穷无尽，早晚只有矿场才会运行全节点，这样去中心化吃枣药丸</li>
<li>交易延展性问题早晚得解决，目前来看Segwit解决方案还是比较成功的，扩容党只是嘴硬，早晚得上</li>
<li>扩容再多，性能也比上闪电网络</li>
</ol>


<h4>总结</h4>

<p>近日BCH社区又经历了一场硬分叉斗争，有利益相争的地方就有恩怨，有恩怨就有江湖；很有可能大家搞来搞去，Bitcoin就搞死了，很正常。</p>

<p>其实看到最后，最核心的分歧其实就是Bitcoin 主网是否每个节点该继续承担清算的工作，这其实和现实中的货币发展十分相似：</p>

<ol>
<li>市场初期不是那么繁荣，即使交易一次清算一次，货币的物理特性也能顶住，这和bitcoin初期很相似，每个全节点都是清算网关，每笔交易都有一笔清算，安安稳稳跑了十年</li>
<li>市场爆发，原有的清算体系扛不住了，这个时候需要升级技术方案解决；有分歧了，需要把全部交易都上主网吗？买杯咖啡需要记录到主链上吗？毕竟今天区块链还是非常金贵的资源，这个系统每天消耗的电力资金数以亿计了，在上面画画写诗实在是有点浪费；从历史来看，引入闪电网络，小笔交易不再并入主网，变成两个特殊清算节点之间的轧账比较合适</li>
<li>分歧就在这里，有人觉得硬件性能增长完全可以让主网记录人类所有的交易；有人说扯犊子，买咖啡不应该上主网</li>
</ol>


<p>目前的情况来看：</p>

<ol>
<li>闪电网络还是处于实验阶段，有力使不上，主网一直满负荷</li>
<li>扩容派各种斗争，要上位还很远</li>
</ol>


<p>看不清未来方向；其实历史是波浪式前进的，如果顶层设计，我可能倾向于:</p>

<p>先区块扩容一点(提高清算能力)&ndash;>Segwit+闪电网络(集中清算)&ndash;>硬件性能跟上了，继续扩容(再分布式清算)</p>

<p>但是现实斗争就是这么残酷哦，技术最优不代表市场最优，技术市场最优不代表拳头最大~~~所以说历史发展是随机的；像基督教分为犹太教、新教、天主教等等，佛教搞成藏传、南派北派等等，人类就是折腾中前进，比特币出来以后，一度把清算技术搞成了教派斗争，这挺有意思的</p>

<h4>更丰富的商业场景</h4>

<p>不管怎么说，我对于技术的前进还是乐观的，不管是传统的清算中心，还是区块链，如果将来我们的清算能力再有一个指数级飞升，我觉得又会有新的商业模式出现</p>

<ul>
<li>现在的保险行业，比如车险，保险的时段只能一整块时段，同样买了一辆车，有的几个司机合伙24*365天天在外跑，有的上下班每周就几个小时的使用时间，交一样的钱其实不公平；未来可能只有你的引擎发动之后，真正在路上跑了，按照分钟收费，你的钱要一点一点打到保险公司账户上，这样比较合理</li>
<li>娱乐消费行业，目前也是整段时间收费，未来你听一首歌，可能按照 0.0000001元/秒的速度慢慢付款给音乐公司</li>
<li>公益行业: 真正的贫困人口可以开设经过认证的账号，这样土豪捐款的时候可以绕过红十字会，平均账户发放救济金之类，而且可以有各种算法监控，比如每个月固定发个100元，这个账户之后走的是哪个清算单元，进行了什么消费，杜绝骗子的不正当用途</li>
<li>资金审计: 将来的所有公益和对公账户，审计不再是一个问题了，因为你可以追踪所有的清算单元，用智能算法来判断资金最终的流向和目的，财务造假的难度大大增加</li>
</ul>


<h4>引用：</h4>

<p><a href="http://www.gongxiangcj.com/posts/1478">http://www.gongxiangcj.com/posts/1478</a></p>

<p><a href="https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf">https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf</a></p>

<p><a href="https://www.zhihu.com/question/22148261">https://www.zhihu.com/question/22148261</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BCH分叉承担的风险--51%攻击者概率问题]]></title>
    <link href="https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti/"/>
    <updated>2018-11-17T18:42:09+08:00</updated>
    <id>https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>2018-11-16 01:40(UTC+8)发生的BCH分叉实在好看，转载一下进程说明:</p>

<!-- more -->


<blockquote><p>  “分叉前夕：
  BCH硬分叉过程中：第一个区块由澳本聪阵营svpool爆出，区块大小为51.385KB，区块高度为556761。BCH硬分叉连续爆出6个区块才会正式开始分叉。</p>

<p>  BCH硬分叉过程中：第二个区块由澳本聪阵营coingeek爆出，区块大小为8.24kB，区块高度为556762。</p>

<p>  BCH硬分叉过程中：第三个区块由澳本聪阵营SVPool爆出，区块大小为29.44kB，区块高度为556763。</p>

<p>  在BCH硬分叉过程中，ABC阵营开始反击，比特大陆旗下第一大矿池BTC.com已经获得部分客户同意，切换算力支援BCH ABC。ABC阵营Bitcoin.com矿池的BCH算力在分叉前24小时大增1593.09%，超过澳本聪阵营的Coingeek矿池，排名第一。</p>

<p>  BCH硬分叉过程中：第四个区块由吴忌寒阵营Bitcoin.com挖出。区块大小为57.11 kB，区块高度为556764。</p>

<p>  BCH硬分叉过程中：第五个区块由吴忌寒阵营ViaBTC爆出，区块大小为315.40 kB，区块高度为556765。</p>

<p>  BCH硬分叉过程中：第六个区块由澳本聪阵营SVPool爆出，区块大小为2597.76 kB，区块高度为556766。</p>

<p>  区块高度556766：正式分叉。算力大战正式开始。随后比特大陆阵营率先出两个块，并保持持续领先。”</p></blockquote>

<p>Bitcoin.com矿池临时集了4000P的算力，巅峰时Bitcoin ABC的算力达到了8500P，而Bitcoin SV始终没有超过5000P。分叉当晚，实力差距明显。</p>

<p><a href="https://cash.coin.dance/blocks/hashrate">https://cash.coin.dance/blocks/hashrate</a></p>

<p>但是Bitcoin SV目前没有放弃的意思，而且Bitcoin.com抽调的算力会慢慢撤回去，因为SV链没有重放保护，如果一直烧钱维护下去，现在还不能称胜负已分。</p>

<p>Bitcoin SV作为进攻方，按照现在1T算力0.1元/小时的价格计算，每天SV要烧掉$200W 维持这场战争。而且目前在BCH链上挖矿收益绝对小于BTC链，如此烧钱确实是土豪行径。如果CSW始终不加重放保护跟Bitcoin ABC死磕，确实是下决心了。但是如果怂了开始炒作Bitcoin SV，那就说明他也不过是个出来割韭菜的。</p>

<p>但是群众其实也不关心鹿死谁手，反正分叉明朗之前不动就可以了。看戏之余，不妨回顾一下中本聪白皮书中关于51%攻击的计算:</p>

<p>(参考第十一章:计算)</p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p>这个计算过程还是很有意思的，我们天天听各种媒体讲<code>51%攻击</code>，那么现实世界中，现在确实发生了两方争霸的情况，我们定义几个变量:</p>

<ul>
<li>P = 诚实节点制造下一个节点的概率</li>
<li>Q = 攻击者制造下一个节点的概率</li>
<li>Qz = 攻击者追上诚实节点z个区块的差距</li>
</ul>


<p>目前(2018-11-17 17:00 UTC+8)Bitcoin SV链算力4278PH，Bitcoin ABC链算力5677PH，Bitcoin SV落后7个Block。Bitcoin ABC为防守方，Bitcoin SV为进攻方，假如Bitcoin SV就这么死磕到底的话，算力保持不变的情况下，有多大机率能51%攻击呢？如果要提高攻击成功的概率，Bitcoin SV又需要多大的算力呢？</p>

<p>我们又要复习一下概率论里面的ABC了，搬来小方凳，数学课开始~~~~</p>

<h2>酒鬼漫步问题</h2>

<p>当一个喝大了的酒鬼在路上摇摇晃晃时，你是否会担心他还有能力避开一切障碍，成功找到家门而不是掉到某个下水沟里吗？</p>

<p>实际上，这正是非常有趣的酒鬼漫步问题，不妨让这个酒鬼的处境更夸张一些，设想他站在悬崖边，面前就是万丈深渊。如果他往后退一步远离悬崖的概率是 2/3 , 向前一步靠近悬崖的概率则是 1/3。那他摔下悬崖的概率是多少?</p>

<p>答案肯定不会是简单的 1/3。那不如先来看看酒鬼最初的几步会发生什么。下图是对这个酒鬼最初几步所有可能的轨迹的枚举。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg1.png" alt="img" /></p>

<p>从图中可以看到，达到<code>0</code> 即意味着跌落悬崖。所以在 <code>0</code> 的那些概率的和便是酒鬼前六步掉下悬崖的概率。这个图可以无限推演下去。</p>

<p>所以让我们把这个场景放到数轴上，换一种方式来看。如此一来醉鬼悬崖边漫步就相当于质点沿轴心运动这类问题了。酒鬼在这个数轴上随意地左右走动， 走到 x = 0 的位置意味着被吸收 ，也就是摔下了悬崖。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg2.png" alt="img" /></p>

<p>假设他向右一步的概率为 <code>p</code>，向左的概率为 <code>1－p</code>。当他在 <code>x = n（n&gt;0）</code> 的位置的时候，不是向右就是向左。记 <code>P（n）</code>为从 <code>x = n</code> 的位置出发，最后到达 <code>x = 0</code> 被吸收的概率。酒鬼一开始在 <code>x = 1</code> 的位置，我们要求的就是他到 0 的概率。</p>

<p>当酒鬼走完第一步后，他要么到了 <code>x = 0</code>（此事件发生的概率是 1－p），要么到了 <code>x = 2</code> 的位置（此事件发生的概率是 p），他再从 <code>x = 2</code> 出发最终走到 <code>x = 0</code> 被吸收的概率就是 <code>P（2）</code>。这时我们可以得到方程1:</p>

<p><code>
P(1) = 1 - p + p * P(2)
</code></p>

<p>而自 <code>x =2</code> 走出并最终到达 <code>x = 0</code> 的情况可以分解为两个阶段：先从 <code>x = 2</code> 到 <code>x = 1</code>（可以走任意步）, 然后从 <code>x = 1</code>到 <code>x = 0</code>（同样可以走任意步）。我们知道后一个的概率是 P（1）,那么前一个呢？其实是一样的，也是 P（1），它可以看作后一种情况的平移。又因为这两个事件相互独立，所以得到方程2:</p>

<p><code>
P(2) = P(1)²
</code></p>

<p>将方程2代入方程1，得到一个简单的一元二次方程:</p>

<p><code>
P(1) = 1 - p + p* P(1)²
</code></p>

<p>解得  <code>P(1) = 1</code>  或者   <code>P(1) = (1-p)／p</code></p>

<p>注意到这里 p 表示的是酒鬼每次向x轴正方向前进一步的概率，也就是他站在悬崖边上向后退的概率。我们不妨根据这个概率的取值情况来对酒鬼悬崖漫步这个问题做个总结。</p>

<p>当 p 等于 0 或 1 时，这显然就成了必然事件，酒鬼一定掉下悬崖或者一定能安全地离开。</p>

<p>但有趣的是，即便当 p 不是 0，在它小于等于 &frac12; 时，这个酒鬼一样难逃失足的厄运。</p>

<p>当 <code>p = 1/2</code>时， P(1) = 1</p>

<p>众所周知，一个事件发生的概率不会超过 1。所以从上面可以看出，当 <code>p ≤  1/2</code>时，也就是这个酒鬼每步选择向后退的概率不足一半时，不管他能离开悬崖有多远，最终都必将粉身碎骨。</p>

<p>而如果 p 在 （1/2 , 1） 这个区间里，这时候酒鬼摔落悬崖的概率实际上是一个关于 p 的连续函数。我们可以做出 P(1) 的图像如下</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg3.png" alt="img" /></p>

<p>现在让我们回答最初的问题，当酒鬼向后走的概率为2/3时，他摔下悬崖的概率为 &frac12; 。 很违背直觉的结果，保持一半清醒是不够的，最少要2/3的清醒。</p>

<h2>从酒鬼漫步到赌徒破产</h2>

<p>把酒鬼徘徊应用到赌博中会得到一个不可思议的结论。假设一个赌徒的赌金是 n，每次的下注金额是 1，而每盘赌局输赢概率各是 1／2。如果一直赌下去的话，赌徒输光的概率是多少呢？</p>

<p>由前面的分析可知，他破产的概率就是前面定义的 <code>P（n）</code>。 <code>P（n）</code>是 <code>P（1）</code> 的 n 次方，而 <code>P（1）</code> 在酒鬼等概率地向两个方向迈步的时候等于 1,所以 <code>P（n）＝1</code> ！这告诉我们，即使是公平赌局，你跟赌场玩，最后也一定会输光的！</p>

<p>这就是著名的赌徒破产问题（Gambler’s ruin）。</p>

<p>显然，赌徒的钱越多，输光需要的局数也越多。当赌徒的赌金是 n 时，我们记输光的概率为 p(n)。因为每次赌局有一半的可能赢，一半的可能输，赢的时候赌金变成 <code>n + 1</code>，输的时候变成 <code>n - 1</code>，所以 <code>p(n) = (p(n + 1) + p(n - 1))／2</code>。当 <code>n = 0</code> 的时候，即使不用赌，所有东西也都输光了，所以 <code>p(0) = 1</code>。</p>

<p>由此，p 可以看作一个满足下列递推关系的数列</p>

<p>```
p(0) = 1</p>

<p>p(n+1) = 2 * p(n) &ndash; p(n-1)，</p>

<p>```</p>

<p>也就是
<code>
p(n+1) - p(n) = p(n) - p(n-1)
</code></p>

<p>容易验证 <code>p(n) = n * p(1) - (n-1)</code> 正好符合上面的递推关系。</p>

<p>又因为<code>p(n) ≥ 0</code>，所以对于任意的 n，必定有 <code>p(1) ≥ 1 - 1／n</code>。因此 <code>p(1) = 1</code>。那么对于所有的 n，则有 <code>p(n) = 1</code>。这意味着，在无限次的赌博中，赌徒在某一次赌博中输光的概率是 1。</p>

<p>这个发现其实和经典的赌徒谬误异曲同工。上帝创造这个世界的一些规则真是意味深长啊，当你要赌的时候，50%的胜率是不够的，一定要有>50%的把握!</p>

<h2>从赌徒破产到算力攻击</h2>

<p>将上面两个例子映射到区块链算力争霸的过程中，发现有惊人的相似点。</p>

<h4>情况1</h4>

<p>当两条分叉从同一起点开始竞争时，就是一个酒鬼漫步问题；攻击者一方相当于不断的要逼近诚实者一方挖出的区块高度；</p>

<ul>
<li>诚实节点：block1&mdash;&mdash;&mdash;block2&mdash;&mdash;&mdash;block3&mdash;&mdash;&mdash;block4&mdash;&mdash;&mdash;</li>
<li>攻击节点：block1&mdash;&mdash;&mdash;block2A&mdash;&mdash;-block3A&mdash;&mdash;&ndash;</li>
</ul>


<p>攻击节点从block2开始攻击，尝试双花其中的交易，并挖出区块block2A。攻击节点挖出的链要比诚实节点挖出的链长——在本例中，它至少要挖到block5——才算攻击成功。我们把诚实节点的链长度减去攻击节点的链长度，得到的差记为n。诚实节点每挖出一个块则n+1；攻击节点每挖出一个块则n-1。我们把n放到数轴上<code>n-1  ←  n  → n+1</code>；攻击节点挖出一个块，相当于酒鬼向左移一步；诚实节点挖出一个块，相当于酒鬼向右移一步。设诚实节点领先n个块，如果攻击节点的算力达到或超过了全网的50%，那么它一定能把n减到0。而如果攻击者算力小于50%，则n越大，也就是确认数越多越安全。从这里你们也可以看出来，我们通常所说的51%攻击，是一个没看懂白皮书的人定下的名词。其实应该定名为50%攻击，攻击者不需要大于50%的算力就能成功。</p>

<p>在BCH的分叉战中，如果有一条链的算力一开始能达到算力的50%并保持下去，就可以杀死另外一条链；</p>

<h4>情况2</h4>

<p>但是随着链的延长，两边的算力便会拉开差距，挖出的快总是有多有少；算力战预测的初始条件变成了这样:</p>

<p>从交易被收录进区块的时候开始，诚实矿工出了z个块。攻击矿工在此期间出块数记为k，只要攻击者不广播别人就不知道，k可能等于0、1、2……直到无穷大。</p>

<ul>
<li>若k>z，攻击直接成功；若k&lt;=z，攻击者仍有可能追上，其成功的可能性即赌徒破产问题。因为攻击失败的情况有限，所以计算成功概率改为计算等价的<code>1-攻击失败的概率</code>。</li>
</ul>


<p>首先研究k，假定诚实矿工以均匀的速度出块，则k近似服从泊松分布：<code>P(k, λ)</code>；</p>

<p>就是“在一个指定长度的固定区间内有k个点（事件）”的概率。诚实矿工出z块的时间即“指定长度的固定区间”，攻击矿工出块次数k即“事件”，每种k出现的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg4.png" alt="img" /></p>

<p>其中λ是攻击矿工出块的期望，假设比特币的算力简化计算为:</p>

<p>速度 * 时间 = 工作量。</p>

<p>z是防御者的工作量，p是防御者的速度，z/p是防御者消耗的时间。防御者的时间=攻击者的时间。攻击者的速度=q；</p>

<p><code>攻击者的工作量期望 = 攻击者的速度 * 攻击者的时间 = q * z / p</code>。 即 <code>λ = z*q/p</code>。</p>

<p>根据赌徒破产问题，在落后了z-k个块之后仍旧能追上的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg5.png" alt="img" /></p>

<p>追不上的概率为:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg6.png" alt="img" /></p>

<p>每种k (k&lt;=z)出现的概率，乘以它追不上的概率，就是这个k的失败率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg7.png" alt="img" /></p>

<p>1-所有攻击失败情况的概率之和，就是攻击成功的概率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg8.png" alt="img" /></p>

<h2>总结</h2>

<p>当前Bitcoin SV算力占总算力的43%，落后7个block，取q=0.43, p=0.57, 计算成功率已然小于10%了。</p>

<p>那么，Bitcoin SV要把算力提高到多少，才能有50%的希望追上Bitcoin ABC呢？ 这是个复杂的问题啊，首先从分叉一晚的算力战来看，目前BitcoinABC可以调动的算力总量为8500P，所以Bitcoin SV目前一定要调动>8500P的算力，才能有翻盘的机会，至于需要多大才能把翻盘机会搞到50%，课后作业计算吧。</p>

<blockquote><p>PS:有个小漏洞，因为BCH的难度计算和BTC是不一样的，我不是很确定情况2的计算是否可以假设为泊松分布。</p></blockquote>

<p>当然，这是一个模拟，真实情况是，发生危机时，bitmain会不断的从BTC那边调集算力过来；这其实是BCH在吸血BTC的算力；</p>

<p>目前来看，BTC的算力有46EH，目前市场上所有的SHA256算力可能总共>60EH；如果算力占再升级，都可以看成是BCH链对BTC链的攻击了。而且只要Bitcoin SV一天不加重放保护，那么交易所就不太可能开放冲提币，这样BCH 链上的交易就会继续停滞，表面上来看是Bitcoin SV一方在烧钱，其实是BCH整条链都在烧钱。现在真正是考验信仰的时候，短期来看，输家会一无所有。赢家也未必能赚到什么。非常残酷的算力战。这真是难得一见，再过10年，真的像中本聪预测的那样，比特币广泛应用后，这种算力战出现的概率极小。某种意义上来说，这个热闹真好看啊:</p>

<p>每天投入$200W的豪赌!</p>

<p>这也进一步验证了，同一个POW算法，最多只能存在一条链，因为即使加了重放保护分叉，还是无法逃脱算力威胁；BCH是一条非常非常特殊的链，它是由bitmain大算力保证的小算力链；这么说可能有点绕口，可以看成BTC和BCH的战争会持续下去，我认为一定会有一方死亡！至于持续多长时间就不好说了，但是我认为这种平衡不可能无限保持下去，必然会发生黑天鹅事件。</p>

<p>另外，像PPC等SHA256 POW币，或者ETC之于ETH，也是同样的情况；我抱持一种观点：</p>

<blockquote><p>同样的POW算法，如果有大算力存在的情况下，一定归于一条链；
中间可能会多链并存很长时间，但总会发生黑天鹅事件将其它链清零</p></blockquote>

<h4>引用:</h4>

<p><a href="https://www.guokr.com/article/59575/?page=3">https://www.guokr.com/article/59575/?page=3</a></p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p><a href="https://www.zhihu.com/question/263764571">https://www.zhihu.com/question/263764571</a></p>
]]></content>
  </entry>
  
</feed>
