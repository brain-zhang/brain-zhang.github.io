<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2018-11-03T12:31:16+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-2]]></title>
    <link href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/"/>
    <updated>2018-11-02T13:31:50+08:00</updated>
    <id>https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2</id>
    <content type="html"><![CDATA[<p>好了，有了上一篇文章的基础，我们可以从零开始完全探究数字货币的地址生成、管理方法；下面的代码均使用Linux Bash shell和Python3来处理；另外需要安装<a href="https://github.com/richardkiss/pycoin">pycoin</a>这个库。</p>

<!-- more -->


<h2>生成私钥</h2>

<p>一般来说，私钥是个256bit的随机字符。为了演示方便，我们用一个人民大众喜闻乐见的地址生成为例子，私钥选取为 sha256(&ldquo;satoshi&rdquo;)</p>

<p>```</p>

<blockquote><p>printf &ldquo;satoshi&rdquo;|sha256sum
da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f  &ndash;
```</p></blockquote>

<p>得到私钥为<code>da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</code></p>

<h2>用WIF (Wallet Import Format)表示私钥</h2>

<p>我们看到私钥本质上是256bit的数字，他可以用二进制表示，也可以用16进制字符串表示，也可以用Base58Check来表示；为了在不同的钱包中方便的导入导出私钥，也为了方便二维码的生成，比特币采用了名为<code>WIF</code>的表示方法，下面列一个表格来说明:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Prefix </th>
<th> Description </th>
<th> Private key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raw </td>
<td> None </td>
<td> 32 bytes binary </td>
<td>  11011010001010000&hellip;&hellip;&hellip;..</td>
</tr>
<tr>
<td>HEX </td>
<td> None </td>
<td> 64 hexadecimal digits </td>
<td> da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</td>
</tr>
<tr>
<td>WIF </td>
<td> 5 </td>
<td> Base58Check encoding </td>
<td> 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</td>
</tr>
<tr>
<td>WIF-compressed </td>
<td> K or L </td>
<td> Base58Check encoding </td>
<td> L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6</td>
</tr>
</tbody>
</table>


<p>得到WIF 代码示例:</p>

<p>```
def gen_pubk_from_privk(private_key, compressed=True):</p>

<pre><code># private_key = codecs.encode(os.urandom(32), 'hex').decode()
secret_exponent = int('0x' + private_key, 0)
print('WIF: ' + encoding.secret_exponent_to_wif(secret_exponent, compressed=compressed))
public_pair = ecdsa.public_pair_for_secret_exponent(ecdsa.secp256k1.generator_secp256k1, secret_exponent)
print('public pair:', public_pair)
return public_pair
</code></pre>

<p>```</p>

<p>WIF格式分为非压缩和压缩格式，压缩私钥其实是对非压缩私钥后缀追加了01之后的Base58Check编码，具体生成过程为:</p>

<ul>
<li>压缩私钥: 私钥前缀80+私钥本体+压缩私钥后缀01 + 校验</li>
<li>非压缩私钥: 私钥前缀80+私钥本体+校验</li>
</ul>


<p>和字面意思相相反的是，压缩私钥比非压缩私钥还长。为啥这么折腾呢？这个我们在公钥生成的部分说明。</p>

<h2>生成公钥</h2>

<p>我们之前的文章介绍了，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头。</p>

<p>下面是由前文中的私钥所生成的公钥，其坐标x和y如下:</p>

<ul>
<li><p>public pair:</p>

<ul>
<li>x = 89077434373547985693783396961781741114890330080946587550950125758215996319671</li>
<li>y = 114001858762817543140175961139571810325965930451644331549950109688554928624341</li>
</ul>
</li>
</ul>


<p>加上前缀04，完整的公钥为:</p>

<p><code>
K = 0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341
</code></p>

<h4>为什么要区分压缩格式和非压缩格式</h4>

<p>这是一个历史问题，初版比特币运行时，中本聪没有考虑到一个问题:</p>

<p>一个公钥是一个椭圆曲线上的点(x,y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程 <code>y^2 % p = (x^3 + 7) % p</code>得到y坐 标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256 bits。如果每笔交易所 需要的字节数减少了近一半，随着时间推移，节省的数据传输和存储空间还是很客观的。</p>

<p>所以后来开发团队推出了压缩公钥，为了跟之前老版本的非压缩公钥相区分，就加上了02和03作为前缀。</p>

<p>那么为什么要加两个前缀(02,03)呢？</p>

<p>因为椭圆曲线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在 x坐标轴的上面或者下面。椭圆曲线图中曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</p>

<p>总结出来，一个公钥的表现形式可以又两种:</p>

<ol>
<li>04开头的非压缩公钥: (130位十六进制 2+64+64)</li>
<li>02或03开头的压缩公钥:（66位十六进制 2+64）</li>
</ol>


<p>这样继续推导，两种表现形式可以推导出两个地址，也就是手握一个私钥，可以推导出两个合法的比特币地址。</p>

<p>这样又间接解释了为什么会有压缩私钥和非压缩私钥两种表现：</p>

<ul>
<li>当中本聪实现第一版比特币客户端钱包的时候，没有考虑到公钥可以压缩，所以采用了最原始直接的办法存储公钥和私钥</li>
<li>后来人们发现公钥可以简化存储来节省一部分空间，于是加入了压缩公钥格式，为了跟之前的非压缩公钥区分，引入了前缀</li>
<li>同样，使用压缩公钥格式的钱包导入导出私钥时，为了区分，也必须为私钥标明它对应的公钥是否压缩格式，所以也为私钥的表示引入了后缀</li>
<li>压缩私钥的意思是，由这个私钥导出的公钥表示方法是压缩的，私钥本身还需要引入一个01作为后缀，长度反而多了一个字节</li>
</ul>


<h2>从公钥到比特币地址</h2>

<p>得出公钥之后，地址的生成还要经过三重变换， 公钥为K，变换过程如下:</p>

<ol>
<li>首先计算 A = SHA256(K)</li>
<li>计算 B = RIPEMD160(A)</li>
<li>Addr = Base58Check（prefix + B）</li>
</ol>


<h4>为什么要有RIPEMD160(SHA256(K)) 的过程</h4>

<p>因为中本聪设计之初充分考虑到了安全性方面的问题，一笔交易广播后，并不是直接把公钥K暴漏在外，如果你不花费这个UTXO，暴漏的只有<code>RIPEMD160(SHA256(K))</code>这个值。假如将来有一种计算机的计算能力得到指数级别的提升，有一定可能暴力破解椭圆曲线算法。解决方案就是引入<code>RIPEMD160(SHA256(K))</code>的过程，这样要破解一个未花费的UTXO，需要逆向RIPEMD160，SHA256，secp256k1三种不同的算法，即使将来量子计算发展到实用阶段，也很难做到吧。</p>

<p>但是根据比特币交易的设计，一个地址重复使用就会暴露公钥K，所以我们推荐的安全做法就是一笔UTXO花费后就更换地址。这也是所有安全钱包的默认实现方法。</p>

<p>这个设计的唯一的瑕疵，在我看来，就是RIPEMD160将公钥的碰撞空间减小了，由 2<sup>256</sup> 减小到了 2<sup>160</sup>，当然 2<sup>160</sup> 的碰撞空间对于现有计算能力也是个天文数字，我想中本聪没有选择SHA3等算法的原因，应该是充分考虑了散列算法的复杂度和差异度，最后选择的RIPEMD160吧。</p>

<h4>Base58Check编码</h4>

<p>WIF格式和比特币地址都是用Base58Check编码表示的，Base58是Base64基础上发展来的，它具有以下功能:</p>

<ul>
<li>一个任意大小的payload。</li>
<li>一组58个字母数字符号，由易于区分的大小写字母组成(不使用0OIl)</li>
<li>一个字节的版本/应用程序信息。比特币地址为这个字节使用0x00</li>
<li>四个字节（32位）基于SHA256的错误检查代码。此代码可用于自动检测并可能纠正排版错误。</li>
<li>保留数据中零开头的额外步骤</li>
</ul>


<p>创建过程:</p>

<ol>
<li><p>获取版本字节和payload字节，并将它们连接在一起（按字节顺序）。</p></li>
<li><p>取SHA256(SHA256(步骤1的结果))的前四个字节</p></li>
<li><p>将步骤1的结果和步骤2的结果连在一起（按字节顺序）。</p></li>
<li><p>处理步骤3的结果 &ndash; 一系列字节 &ndash; 作为单个大端序号，使用正常的数学步骤（bignumber division）和下面描述的base-58字母表转换为base-58。结果应该被标准化为没有任何前导零（字符'1'）的base-58。</p></li>
<li><p>在base58中，值为零的前导字符'1'被保留用于表示整个前导零字节，就像它处于前导位置时一样，没有值作为base-58符号。必要时可以有一个或多个前导'1'来表示一个或多个前导零字节。计算步骤3结果中的前导零字节数（对于旧的比特币地址，至少有一个用于版本/应用程序字节;对于新地址，将永远不会有）。每个前导零字节在最终结果中应由其自己的字符'1'表示。</p></li>
<li><p>将步骤5中的1与步骤4 的结果连接起来。这是Base58Check的结果。</p></li>
</ol>


<p>最后综合起来，从公钥K到比特币地址完整的示意图如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181102/bg1.jpg" alt="img" /></p>

<p><code>satoshi</code>作为seed计算出私钥，进而计算出公钥K之后，最终进一步生成地址</p>

<p>```
def genaddress_from_pubk(compressed=True)</p>

<pre><code># 首先计算 RIPEMD160(SHA256(K))
ripemd160 = encoding.public_pair_to_hash160_sec(public_pair, compressed=compressed)
# 再用Base58Check计算最终地址
addr = encoding.hash160_sec_to_bitcoin_address(ripemd160)
return addr
</code></pre>

<p>```</p>

<p>因为公钥存在压缩形式和非压缩两种形式，所以完整的结果是:</p>

<p>```
seed: satoshi
sha256 private key: da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</p>

<p>compress address
WIF: L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
hash160: 0a8ba9e453383d4561cbcdda36e5789c2870dd41
Bitcoin address:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</p>

<p>uncompress address
WIF: 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
hash160: 650d0497e014e60d4680fce6997d405de264f042
Bitcoin address:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE
```</p>

<p><code>satoshi</code>作为seed生成了两个地址:</p>

<p><code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>，这都是两个正在使用的地址哦，到今天为止还有热心人源源不断的为<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>转账一些零钱作为中本聪的纪念。你可以将WIF导入钱包，然后运行一个全节点，在bitcoin.conf文件中加入<code>walletnotify</code>这个选项，关联一个脚本，当收到比特币时就自动转账到自己的地址，参与这两个地址的抽奖哦。</p>

<h2>一些Base58Check版本前缀和编码后的结果</h2>

<p>看到这里，我们发现Base58Check 编码的过程中，最后一步会引入一个前缀。而在比特币中，除了WIF私钥和地址，大多数需要向用户展示的数据都使用Base58Check编码，理所当然的，引入了不同的前缀来区分不同的信息，下面展示了一些版本前缀和他们对应的Base58格式:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Version prefix </th>
<th> Base58 result prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Address </td>
<td> 0x00 </td>
<td> 1</td>
</tr>
<tr>
<td>Pay to Script Hash Address </td>
<td> 0x05 </td>
<td> 3</td>
</tr>
<tr>
<td>Bitcoin Testnet Address </td>
<td> 0x5F </td>
<td> m or n</td>
</tr>
<tr>
<td>Private Key WIF </td>
<td> 0x80 </td>
<td> 5, K or L</td>
</tr>
<tr>
<td>BIP-38 Encrypted Private Key </td>
<td> 0x0142 </td>
<td> 6P</td>
</tr>
<tr>
<td>BIP-32 Encrypted public Key </td>
<td> 0x0488B21E </td>
<td> xpub</td>
</tr>
</tbody>
</table>


<p>除了我们已经提到的WIF和Bitcoin Address，我们还发现了奇怪的BIP-38和BIP-32，这个需要到解释比特币原始交易编码的时候来讲解。</p>

<h2>Brain Wallet</h2>

<p>好啦，我们上面已经完整的再现了由一个 seed单词 <code>satoshi</code>，导出两个比特币地址的过程；你只要记好<code>satoshi</code>这个单词，就可以在世界上的任何地方，任何时间，掌管发送给<code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>这两个地址的比特币了。</p>

<p>你不需要银行账号，不需要密保卡，只需要有个可以联网的地方，就能秘密发送交易啦。将来有了免费的卫星网络的话，我想你都不用登陆互联网，可能在家里屋顶上架个锅，淘宝买些零件天线DIY一个设备，要转帐的时候，只要输入<code>satoshi</code>就可以秘密完成数亿美元的汇款，而且丝毫不用担心这个账户被政府查封，世界上也只有你一个人能动用这个账户，真是完美的洗钱逃汇工具！也难怪有人说，比特币是人类历史上第一次用技术手段保证了财产的完全私有权。</p>

<p>这个<code>satoshi</code>的seed，就是所谓脑钱包的口令，相对于天书一般的256 bits私钥无疑更好记忆，早期这样的工具非常受欢迎，到现在为止你也可以到这个<a href="https://brainwalletx.github.io/">在线工具</a> 去重复我们以上推导的所有过程。</p>

<p>但是这个方法有个致命的弱点，他的安全性完全取决于seed这个单词的复杂度，像<code>satoshi</code>这样的seed，就像<code>123456</code>的密码一样，不用说大家都知道安全度为0啊。</p>

<p>而且你自以为选取生日啊、姓名缩写啊、恋人海誓山盟的话语啊，这些东西作为seed，其实也是非常脆弱的。总有人孜孜不倦的遍历所有可能的seed。这在后期导致了非常多的hack事件。</p>

<p>截至2018-10，我检索区块链，统计公开的比特币地址已经超过了3亿个，如果有万分之一的地址是由脑钱包生成的话，不安全的地址也超过了3w个，所以后来脑钱包这种方式就不被推荐了。</p>

<p>下面可以列举一些已经公开的seed，这都是我用一些公开语料库随意碰撞出来的，你就知道这种方法的危险性啦：</p>

<p><code>
FINAL_CRACK_ADDRESS: hash160:sha256:seed:address:wif-priv
FINAL_CRACK_ADDRESS:0a8ba9e453383d4561cbcdda36e5789c2870dd41:c:sha256:satoshi:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V:L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
FINAL_CRACK_ADDRESS:650d0497e014e60d4680fce6997d405de264f042:u:sha256:satoshi:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE:5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
FINAL_CRACK_ADDRESS:c71e3a0989754d4ffae45a1c6ef8e348539cd83c:u:sha256:satoshinakamoto:1K9qgN3H2wB2v3LwJEBDbRRJ3znHXEQP4Y:5HqE1vZMMLc7jZRF5wZb79QexyCguNeNdaHLdKTGndvLBrCHD31
FINAL_CRACK_ADDRESS:ec42ad7fd54f931274b83f6137379206e458b106:u:sha256:1satoshi:1NYEM85RpgkSofLqDfwjb21o3MD4ibSo49:5JSGPQ2Jw1P5cVi2L8LeuWnMF5H8rLGrPPgVM2XE1cahG1BQDzY
FINAL_CRACK_ADDRESS:fd8d22e02b3a41bc38f69516c43f7ebd6268e16b:u:sha256:satoshi nakamoto:1Q7f2rL2irjpvsKVys5W2cmKJYss82rNCy:5K7EWwEuJu9wPi4q7HmWQ7xgv8GxZ2KqkFbjYMGvTCXmY22oCbr
FINAL_CRACK_ADDRESS:0000d85a71f305a1c907cdc7437c43b2eecc35e5:u:sha256:CHARINA143:11121ioKu4MCB1LLzPF98AVtzFsEg7UYKm:5JhayTrDhzDHqCg2v16Y2gZWi4kWF6BFoZR3MyaaxWtyKHzKJ8d
FINAL_CRACK_ADDRESS:0002439f087ffefb973c5b9bbd52f509984d3cbe:c:sha256:purple99:113iKJcZeRxEYRVcWNgVxmjodPAisDZ45:KxFLoyseSyVtKGXQNkYBajT8EqviQSuH64Y6GE1g6KXuvcFaSrqc
FINAL_CRACK_ADDRESS:00027a0ef2b9295011b10b089c8caf2e69f6b6f7:u:sha256:bridesmaid:113y6FCRm2WHh5Aru2R7ot37wkNDtxqf3:5JsYc8oXiHBJm9rzRPJHaCSYBBx7KCTx5L81rqRMZBArsdZTsan
FINAL_CRACK_ADDRESS:00030fa763130b5310afe68b12204009e60e935c:u:sha256:masturbating:114fh9qiRhubJJDV5rCthFxmGyYeLQ2B6:5J8TgeF9jU3BPRrsCD75Ks4a6aWxgzLKENDSbsLufDTWq7evCQa
FINAL_CRACK_ADDRESS:0005736b486f87e5823909a89eb48dda185d3956:u:sha256:nitro:117XjTn3UdBNjVo3KsB17WRFDDmcW2pPa:5JkUWsPzNEZEvMFwWQjoXCeem5LL6LDcC7K6H1LWiwXFAA9LFo1
FINAL_CRACK_ADDRESS:00080beae5c3a433fbae8ff0b69e705ac3ce5464:u:sha256:resultantly:11Ae5tbiSZ7QJWh4okWJhDKuPfAvk3a13:5KftjbtsSmhy5Y42AYpfEAm4U4vQKP9VhjbS6xtFqBDhUfAGaFj
FINAL_CRACK_ADDRESS:00083c18c738e883ebc1b5ca270569ee8f9f790e:u:sha256:suggestively:11AsAKWdMZj5ScSYRoAQ8xG4J7Y6s7cW9:5JvrusiSgSmCTV7x7f5vgdWUMLjwk153j9UXmNHvRAJ8m7rtsJD
FINAL_CRACK_ADDRESS:000e4d1774a3fc0251e9e6caf0a8617639e80093:u:sha256:dezoxiribonukleinsav:11J8fK9qhgxdQ96ZvvXExkfFvQSPQiPKN:5KSkRxaAbk94wzzzynDNj2bzRFmJZXCrhtYj3iGU9JjUxnRXTYM
FINAL_CRACK_ADDRESS:00135d1c8f99cc657ad1f246bc5051ad03f95d32:u:sha256:Mussolini:11QCR3sk9r4jeyMqCKGEYabGTfjzhgGdZ:5K2x6UanMSevNX7f19oB4to46C3zXoGTUBGVqv8WNtCRwJNGBGC
FINAL_CRACK_ADDRESS:001ed6fae0af0b37126004029defcc4521b300dd:u:sha256:meagerness:11dwnVzCyGoMZcGDndQteWgR9b7FKsJMu:5JKVJhbZWXmHxj2MuttZCDaFk7TC9KBVYjbPRjztP63mmAUV6Vm
FINAL_CRACK_ADDRESS:002607c11a2311825a087f37c95d7816e0491a9d:u:sha256:vertebrate:11nZPfxYPeDm4d4fd93BaFa1BezFRTP6F:5HsBbgzEXZEaeLRCZHs66ho2ekpFEqeAJyyBPe8YyMkCqCHWv6j
...
</code></p>

<p>不过我们现在已经掌握到了比特币地址的生成原理，所以如何提高安全性就不用我再啰嗦了，相信你心中已有答案。</p>

<h2>那些山寨币们</h2>

<p>比特币项目是2009-01-03正式开始运行的，之后简单的复制一下比特币的代码，稍作修改就推出的山寨币们数不胜数；这些山寨币第一个要修改的，就是地址格式，以免和比特币地址混淆；</p>

<p>怎么修改呢？注意到前面Base58Check Encode的最后一步了吗？那个时候我们需要引入一个前缀作为地址的区分；得益于比特币这种前瞻性的设计，山寨币们只要改动一下这个前缀就可以了，下面列举一下我所知道的山寨币的实现：</p>

<p>引用自:
<a href="https://github.com/walletgeneratornet/WalletGenerator.net">https://github.com/walletgeneratornet/WalletGenerator.net</a></p>

<p>```
name, networkVersion, privateKeyPrefix, WIF_Start, CWIF_Start
&ldquo;2GIVE&rdquo;,               0x27, 0xa7, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;42coin&rdquo;,              0x08, 0x88, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;Acoin&rdquo;,               0x17, 0xe6, &ldquo;8&rdquo;,    &ldquo;b&rdquo;
&ldquo;AGAcoin&rdquo;,             0x53, 0xd3, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;Alphacoin&rdquo;,           0x52, 0xd2, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;Alqo&rdquo;,                0x17, 0xc1, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Animecoin&rdquo;,           0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Anoncoin&rdquo;,            0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Apexcoin&rdquo;,            0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Auroracoin&rdquo;,          0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Aquariuscoin&rdquo;,        0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Axe&rdquo;,                 0x4B, 0xCB, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;BBQcoin&rdquo;,             0x55, 0xd5, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Biblepay&rdquo;,            0x19, 0xb6, &ldquo;7&rdquo;,    &ldquo;[TU]&rdquo;
&ldquo;Bitcoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;BitcoinCash&rdquo;,         0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;BitcoinDark&rdquo;,         0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Bitcore&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;BitcoinGold&rdquo;,         0x26, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Bitconnect&rdquo;,          0x12, 0x92, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Birdcoin&rdquo;,            0x2f, 0xaf, &ldquo;6&rdquo;,    &ldquo;[ST]&rdquo;
&ldquo;BitSynq&rdquo;,             0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;BitZeny&rdquo;,             0x51, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Blackcoin&rdquo;,           0x19, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;BlackJack&rdquo;,           0x15, 0x95, &ldquo;[56]&rdquo;, &ldquo;P&rdquo;
&ldquo;BlockNet&rdquo;,            0x1a, 0x9a, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;BolivarCoin&rdquo;,         0x55, 0xd5, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;BoxyCoin&rdquo;,            0x4b, 0xcb, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;BunnyCoin&rdquo;,           0x1a, 0x9a, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Cagecoin&rdquo;,            0x1f, 0x9f, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CampusCoin&rdquo;,          0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CanadaeCoin&rdquo;,         0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CannabisCoin&rdquo;,        0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Capricoin&rdquo;,           0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CassubianDetk&rdquo;,       0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CashCoin&rdquo;,            0x22, 0xa2, &ldquo;6&rdquo;,    &ldquo;[QR]&rdquo;
&ldquo;Catcoin&rdquo;,             0x15, 0x95, &ldquo;[56]&rdquo;, &ldquo;P&rdquo;
&ldquo;ChainCoin&rdquo;,           0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;ColossusCoinXT&rdquo;,      0x1e, 0xd4, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Condensate&rdquo;,          0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Copico&rdquo;,              0x1c, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;CopperCoin&rdquo;,          0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Corgicoin&rdquo;,           0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CryptoBullion&rdquo;,       0x0b, 0x8b, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;CryptoClub&rdquo;,          0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Cryptoescudo&rdquo;,        0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Cryptonite&rdquo;,          0x1c, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;CryptoWisdomCoin&rdquo;,    0x49, 0x87, &ldquo;5&rdquo;,    &ldquo;[LM]&rdquo;
&ldquo;C2coin&rdquo;,              0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Dash&rdquo;,                0x4c, 0xcc, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;DeafDollars&rdquo;,         0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;DeepOnion&rdquo;,           0x1f, 0x9f, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Deutsche eMark&rdquo;,      0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;Devcoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;DigiByte&rdquo;,            0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Digitalcoin&rdquo;,         0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Dimecoin&rdquo;,            0x0f, 0x8f, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;DNotes&rdquo;,              0x1f, 0x9f, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Dogecoin&rdquo;,            0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;DogecoinDark&rdquo;,        0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;eGulden&rdquo;,             0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;eKrona&rdquo;,              0x2d, 0xad, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;ELECTRA&rdquo;,             0x21, 0xa1, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Ember&rdquo;,               0x5c, 0x32, &ldquo;2&rdquo;,    &ldquo;8&rdquo;
&ldquo;Emerald&rdquo;,             0x22, 0xa2, &ldquo;6&rdquo;,    &ldquo;[QR]&rdquo;
&ldquo;Emercoin&rdquo;,            0x21, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;EnergyCoin&rdquo;,          0x5c, 0xdc, &ldquo;8&rdquo;,    &ldquo;Z&rdquo;
&ldquo;Espers&rdquo;,              0x21, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Fastcoin&rdquo;,            0x60, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Feathercoin&rdquo;,         0x0e, 0x8e, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Fedoracoin&rdquo;,          0x21, 0x80, &ldquo;5&rdquo;,    &ldquo;[KL]&rdquo;
&ldquo;Fibre&rdquo;,               0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Florincoin&rdquo;,          0x23, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Flurbo&rdquo;,              0x23, 0x30, &ldquo;6&rdquo;,    &ldquo;8&rdquo;
&ldquo;Fluttercoin&rdquo;,         0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;FrazCoin&rdquo;,            0x23, 0xA3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Freicoin&rdquo;,            0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;FUDcoin&rdquo;,             0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Fuelcoin&rdquo;,            0x24, 0x80, &ldquo;5&rdquo;,    &ldquo;[KL]&rdquo;
&ldquo;Fujicoin&rdquo;,            0x24, 0xa4, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;GabenCoin&rdquo;,           0x10, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Garlicoin&rdquo;,           0x26, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;GlobalBoost&rdquo;,         0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Goodcoin&rdquo;,            0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;GridcoinResearch&rdquo;,    0x3e, 0xbe, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Gulden&rdquo;,              0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Guncoin&rdquo;,             0x27, 0xa7, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;HamRadioCoin&rdquo;,        0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;LK&rdquo;
&ldquo;HFRcoin&rdquo;,             0x10, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;HOdlcoin&rdquo;,            0x28, 0xa8, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;HTMLCoin&rdquo;,            0x29, 0xa9, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;HyperStake&rdquo;,          0x75, 0xf5, &ldquo;9&rdquo;,    &ldquo;d&rdquo;
&ldquo;ImperiumCoin&rdquo;,        0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;IncaKoin&rdquo;,            0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;IncognitoCoin&rdquo;,       0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;LK&rdquo;
&ldquo;Influxcoin&rdquo;,          0x66, 0xe6, &ldquo;8&rdquo;,    &ldquo;b&rdquo;
&ldquo;Innox&rdquo;,               0x4b, 0xcb, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;IridiumCoin&rdquo;,         0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;iCash&rdquo;,               0x66, 0xcc, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;iXcoin&rdquo;,              0x8a, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Judgecoin&rdquo;,           0x2b, 0xab, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;Jumbucks&rdquo;,            0x2b, 0xab, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;KHcoin&rdquo;,              0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;KittehCoin&rdquo;,          0x2d, 0xad, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;Lanacoin&rdquo;,            0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Latium&rdquo;,              0x17, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;LBRY Credits&rdquo;,        0x55, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Litecoin&rdquo;,            0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;LiteDoge&rdquo;,            0x5a, 0xab, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;LoMoCoin&rdquo;,            0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MadbyteCoin&rdquo;,         0x32, 0x6e, &ldquo;4&rdquo;,    &ldquo;H&rdquo;
&ldquo;MagicInternetMoney&rdquo;,  0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Magicoin&rdquo;,            0x14, 0x94, &ldquo;5&rdquo;,    &ldquo;[NP]&rdquo;
&ldquo;Marscoin&rdquo;,            0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MarteXcoin&rdquo;,          0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MasterDoge&rdquo;,          0x33, 0x8b, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;Mazacoin&rdquo;,            0x32, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Megacoin&rdquo;,            0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MintCoin&rdquo;,            0x33, 0xb3, &ldquo;[67]&rdquo;, &ldquo;T&rdquo;
&ldquo;MobiusCoin&rdquo;,          0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;MonetaryUnit&rdquo;,        0x10, 0x7e, &ldquo;5&rdquo;,    &ldquo;K&rdquo;
&ldquo;Monocle&rdquo;,             0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MoonCoin&rdquo;,            0x03, 0x83, &ldquo;5&rdquo;,    &ldquo;L&rdquo;
&ldquo;Myriadcoin&rdquo;,          0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;NameCoin&rdquo;,            0x34, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Navcoin&rdquo;,             0x35, 0x96, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;NeedleCoin&rdquo;,          0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;NEETCOIN&rdquo;,            0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;NYC&rdquo;,                 0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Neoscoin&rdquo;,            0x35, 0xb1, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Nevacoin&rdquo;,            0x35, 0xb1, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Novacoin&rdquo;,            0x08, 0x88, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;Nubits&rdquo;,              0x19, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Nyancoin&rdquo;,            0x2d, 0xad, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;Ocupy&rdquo;,               0x73, 0xf3, &ldquo;9&rdquo;,    &ldquo;[cd]&rdquo;
&ldquo;Omnicoin&rdquo;,            0x73, 0xf3, &ldquo;9&rdquo;,    &ldquo;[cd]&rdquo;
&ldquo;Onyxcoin&rdquo;,            0x73, 0xf3, &ldquo;9&rdquo;,    &ldquo;[cd]&rdquo;
&ldquo;PacCoin&rdquo;,             0x18, 0x98, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Particl&rdquo;,             0x38, 0x6c, &ldquo;4&rdquo;,    &ldquo;[HG]&rdquo;
&ldquo;Paycoin&rdquo;,             0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Pandacoin&rdquo;,           0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;ParkByte&rdquo;,            0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Peercoin&rdquo;,            0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Pesetacoin&rdquo;,          0x2f, 0xaf, &ldquo;6&rdquo;,    &ldquo;[ST]&rdquo;
&ldquo;PHCoin&rdquo;,              0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;PhoenixCoin&rdquo;,         0x38, 0xb8, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;PiggyCoin&rdquo;,           0x76, 0xf6, &ldquo;9&rdquo;,    &ldquo;d&rdquo;
&ldquo;Pinkcoin&rdquo;,            0x3,  0x83, &ldquo;[RQP]&rdquo;,&ldquo;L&rdquo;
&ldquo;PIVX&rdquo;,                0x1e, 0xd4, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;Peercoin&rdquo;,            0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Potcoin&rdquo;,             0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Primecoin&rdquo;,           0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;ProsperCoinClassic&rdquo;,  0x3a, 0xba, &ldquo;7&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Quark&rdquo;,               0x3a, 0xba, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Qubitcoin&rdquo;,           0x26, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Reddcoin&rdquo;,            0x3d, 0xbd, &ldquo;7&rdquo;,    &ldquo;[UV]&rdquo;
&ldquo;Riecoin&rdquo;,             0x3c, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Rimbit&rdquo;,              0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;ROIcoin&rdquo;,             0x3c, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Rubycoin&rdquo;,            0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Rupaya&rdquo;,              0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Sambacoin&rdquo;,           0x3e, 0xbe, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SecKCoin&rdquo;,            0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SibCoin&rdquo;,             0x3f, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;SixEleven&rdquo;,           0x34, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;SmileyCoin&rdquo;,          0x19, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;SongCoin&rdquo;,            0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SpreadCoin&rdquo;,          0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;StealthCoin&rdquo;,         0x3e, 0xbe, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Stratis&rdquo;,             0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SwagBucks&rdquo;,           0x3f, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Syscoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Tajcoin&rdquo;,             0x41, 0x6f, &ldquo;6&rdquo;,    &ldquo;H&rdquo;
&ldquo;Terracoin&rdquo;,           0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Titcoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;TittieCoin&rdquo;,          0x41, 0xc1, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Topcoin&rdquo;,             0x42, 0xc2, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;TransferCoin&rdquo;,        0x42, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;TreasureHuntCoin&rdquo;,    0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;TrezarCoin&rdquo;,          0x42, 0xC2, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Unobtanium&rdquo;,          0x82, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;USDe&rdquo;,                0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Vcash&rdquo;,               0x47, 0xc7, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;Versioncoin&rdquo;,         0x46, 0xc6, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;VergeCoin&rdquo;,           0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Vertcoin&rdquo;,            0x47, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Viacoin&rdquo;,             0x47, 0xc7, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;VikingCoin&rdquo;,          0x46, 0x56, &ldquo;3&rdquo;,    &ldquo;D&rdquo;
&ldquo;W2Coin&rdquo;,              0x49, 0xc9, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;WACoins&rdquo;,             0x49, 0xc9, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;WankCoin&rdquo;,            0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;WeAreSatoshiCoin&rdquo;,    0x87, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;WorldCoin&rdquo;,           0x49, 0xc9, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;XP&rdquo;,                  0x4b, 0xcb, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;Yenten&rdquo;,              0x4e, 0x7b, &ldquo;5&rdquo;,    &ldquo;K&rdquo;
&ldquo;Zcash&rdquo;,        [0x1c,0xb8], 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Zetacoin&rdquo;,            0x50, 0xE0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Testnet Bitcoin&rdquo;,     0x6f, 0xef, &ldquo;9&rdquo;,    &ldquo;c&rdquo;
&ldquo;Testnet Dogecoin&rdquo;,    0x71, 0xf1, &ldquo;9&rdquo;,    &ldquo;c&rdquo;
&ldquo;Testnet MonetaryUnit&rdquo;,0x26, 0x40, &ldquo;3&rdquo;,    &ldquo;A&rdquo;
&ldquo;Testnet PIVX&rdquo;,        0x8b, 0xef, &ldquo;9&rdquo;,    &ldquo;c&rdquo;
&ldquo;Testnet WACoins&rdquo;,     0x51, 0xd1, &ldquo;8&rdquo;,    &ldquo;[XY]&rdquo;</p>

<p>```</p>

<p>哈哈，洋洋大观啊。这也说明了folk一个山寨币的成本是如何的低；然后有了以太坊的ERC20之后，发一个新币的成本简直低到令人发指，也无怪乎场子里面骗子横行了。</p>

<h2>以太坊的地址生成</h2>

<p>Ethereum项目是不走寻常路的，他作为比特币之后最具创新性的后辈，地址设计反而简单的多。</p>

<p>直到生成公钥这一步，以太坊和比特币都是一致的，采用了secp256k1算法，只是最后的地址生成以太坊很简洁，直接Keccak256 hash，然后取最后的40位16进制字符得到的。</p>

<p>为什么比特币实现复杂呢？这是因为比特币的交易是以UTXO为核心的，每个UTXO包含其所有者及价值信息，系统中的每一笔的交易由若干UTXO输入和若干UTXO输出组成。UTXO无法只提取部分，每次必须完整的使用，这有点像我们生活现实中的现金。比特币系统中，一个用户的“余额”是该用户的私钥能够有效签名的所有UTXO的总和。要深刻的理解这一点，还需要我们了解了比特币的交易数据构成之后才能探讨。我们后面会写文章解释这一点啦。</p>

<p>而以太坊采用了与比特币不同的实现方式——账户，类似我们生活中的银行卡。以账户为核心的设计比较节省空间,而且以太坊的block组织更为精巧。另外，以太坊的设计目标和比特币是不同的：</p>

<ul>
<li>首先以太坊的账户除了普通的收发币的账户(俗称外部账户EOA)，还有合约账户，合约账户需要一个固定的地址，不然每次调用合约都会很麻烦；这样就要求以太坊的合约账户不像比特币交易那样频繁的更换地址；</li>
<li>他并不执着于强迫用户去注意隐私问题，以太坊的态度是，如果用户注重隐私问题，你就自己搞定；你需要通过合约中的签名数据包协议来建立一个加密“混合器”进行加密。</li>
<li>总之以太坊因为要实现的目标更为宏大，他的设计理念是根据最初的用户都是一群Geek们来建立的；Geek们最喜欢啥？就是不要过度设计，让我来自己搞定</li>
</ul>


<p>所以在以太坊系统中，账户是一个20字节的地址，他关联的信息包含四个部分：</p>

<ol>
<li><p>随机数，用于确定每笔交易只能被处理一次的计数器</p></li>
<li><p>账户目前的以太币余额</p></li>
<li><p>账户的合约代码，如果有的话</p></li>
<li><p>账户的存储（默认为空）</p></li>
</ol>


<p>可以采用<a href="https://github.com/ethereum/pyethereum">pyethereum</a>这个库，用以下代码模拟以太坊地址的生成:</p>

<p>```</p>

<h1>&ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>&ldquo;&rdquo;&ldquo;doctopt ethereum address generate tools</p>

<p>Usage:
  genaddr.py p2addr         <private>
  genaddr.py word2addr      <word></p>

<p>Options:
  -h &mdash;help                                             Show this screen.
  &mdash;version                                             Show version.</p>

<p>Example:</p>

<pre><code>genaddr.py p2addr 6bd3b27c591                                         # gen address from private 0x6bd3b27c591=&gt;1PiFuqGpG8yGM5v6rNHWS3TjsG6awgEGA1
genaddr.py word2addr 'Money is the root of all evil.'                 # gen address from private wordlist
</code></pre>

<p>&ldquo;&rdquo;"</p>

<p>from docopt import docopt</p>

<p>import os
import sys
from ethereum import utils</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>arguments = docopt(__doc__, version='1.0')

if arguments['p2addr']:
    private_key = bytes.fromhex(arguments['&lt;private&gt;'])
    passpharse = b'unknown'

elif arguments['word2addr']:
    passpharse = arguments['&lt;word&gt;'].encode('utf-8')
    private_key = utils.sha3(passpharse)

raw_address = utils.privtoaddr(private_key)
account_address = utils.checksum_encode(raw_address)
print("word:{}:private:{}:address:{}".format(passpharse.decode('utf-8'), private_key.hex(), account_address))
</code></pre>

<p>```</p>

<p>```</p>

<blockquote><p>python genaddr.py word2addr &lsquo;hello&rsquo;</p></blockquote>

<p>word:hello:private:1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8:address:0x5ccfa55C29F0522f062E3C15004E35a69dD45F6B
```</p>

<p>以太坊账户方式的一个弱点是：为了阻止重放攻击，每笔交易必须有nonce。这就使得账户需要跟踪nonce的使用情况。而且，不再使用的账户，无法从账户状态中移除。</p>

<p>关于重放攻击，我们会在后面说明。</p>

<h2>重放攻击</h2>

<p>在网络中重放攻击是一种很常见的攻hack方式，关于相关攻防有足够丰富的案例；但是在区块链历史上却是一个悲伤的故事；在此我们用一点点篇幅回忆一下区块链上第一次大规模的重放攻击(replay Attack)。</p>

<h4>缘起</h4>

<p>众所周知，以太坊作为<code>智能合约</code>的首创者，在区块链技术史上是继比特币之后最大的创新。在V神于2015-07-30正式推出运行后，立即吸引了众多Geek来探究如何实现白皮书中所说的去中心化程序。其中最受关注的就是2016-04-30日开始募资的<code>The DAO</code>项目。</p>

<p>关于这个项目的始末，实在是槽点满满。即使已经两年后的今天，估计你去搜索这起著名的事件，非码农人士也很难搞明白。简而言之，就是<code>The DAO</code>作为一个去中心化的项目基金会开始募资，令人觉得神奇的是，这个项目背后没有一个控制人！即使这个项目筹到一大笔钱，也没有一个人有权利单独动用它，只能所有投资人投票才能决定资金的使用，这是写在区块链代码上的铁律，这就是去中心化的魅力！</p>

<p>但是一个没有控制人，没有开发目标，拿到了钱也不知道今后要干啥的项目组织，说要募资了，然后人们纷纷掏钱买股权，是不是很神奇！</p>

<p>咱们说传销还得有个愿景呢！但是当时<code>去中心化程序</code>的概念横空出世，官网页面美轮美奂，诸多<code>专家</code>纷纷发表晦涩难懂的高大上文章齐赞<code>The DAO</code>的历史意义，就在那种巨大的泡沫环境中，人们害怕的是错过发财的上车机会，于是根本搞不明白这是个什么东西，就慷慨解囊。</p>

<p>你可能觉得好笑，可是看看今天，那些所谓的高大上的区块链项目，所谓的伟大愿景，那些山寨币，那些要颠覆这颠覆那的各路神仙，和当时何其相似！熙熙攘攘的投资人群中，有几人能花时间去搞明白比特币和以太坊的白皮书？</p>

<p>所谓的区块链技术的发展，充斥着贪婪和诈骗。就和人性一样。</p>

<h4>崩溃</h4>

<p>同样，一个骗局的破绽，也始于人类的愚蠢。</p>

<p>截至2016-05-15，<code>The DAO</code>项目的合约募集了大约当时价值约1.5亿美元Ether，占当时Ether发行总量的15%。讽刺的是，这个项目募集了巨大的金额，却没有一个像样的专家去做一个合约代码安全审计！</p>

<p>终于，THE DAO创始人之一Stephan Tual发现其合约代码有部分缺陷，他于6月12日宣布，他们发现了软件中存在的“递归调用漏洞”问题，不过对DAO资金来说则不会出现风险。讽刺的是还是没有多少人注意到这个问题。</p>

<p>2016-06-17，一名黑客在编码上发现了真正的漏洞，使得他可以从<code>The Dao</code>上抽走资金。在攻击的头几个小时，360万的Ether被转出，在当时价值相当于七千万美元。当时引起的混乱可想而知，社区采用紧急措施冻结了所有的币，但是
只要以太坊的根基代码不变，就无法阻止黑客取现这些财富。</p>

<p>你可以想象当时那些投资人的反应，有人气急败坏要求以太坊开发团队立即采取措施，作废黑客的攻击行为，回退区块链并退回所有投资人的Ether。</p>

<p>而真正的区块链信徒认为<code>代码即正义、代码即法律</code>，传统世界中的法律不能应用到cyberpunk世界中，即使是黑客的盗窃行为，也理应收到这种正义保护！回退作废Block的行为其实就是否认区块链的技术意义，它会毁灭以太坊项目。</p>

<p>你可以想象，当你损失了几十万美元，对面的一群码农却做出这种<code>奇谈怪论</code>，肯定是想砍人的心都有了。当时的各路利益纠葛者吵了一个翻天覆地。甚至黑客本人也跳出来发表了一通公开信，先为自己的盗窃行为辩护一番，然后承诺只要社区不回退，就会返还一部分金额。整个事件好一场精彩大戏。</p>

<h4>分裂</h4>

<p>经历了无休止的利益、法律、技术等等辩论后，以太坊社区分裂了。争论的结果就是诞生了ETH Classic (即ETC)项目；一批坚持<code>代码即正义</code>者分裂出来创造了ETH Classic 网络，这个项目称自己才是真正的以太坊，并承认黑客的攻击行为且继续将这条链运行下去。而现在仍旧运行的Ethereum网络保护了投资者的利益，做出了妥协；</p>

<p>这个分叉开启于Ethereum网络编号为1920000区块。</p>

<p>这是世界上第一次公开的人为的区块链分叉事件。但是好戏才刚刚开始。</p>

<h4>重放攻击</h4>

<h2>Bitcoin Cash地址生成</h2>

<p>待续</p>

<h2>总结</h2>

<p>以上长篇大论了比特币系统的地址是如何生成的，当然我们也略过了许多细节，比如钱包如何加salt，如何加passphrase等等，这些直接去读BIP 规范更为精确；但是一个完整的钱包，可不仅仅是要解决地址生成这个问题，还要能方便的管理私钥。</p>

<p>在比特币早期，私钥的管理是非常粗暴的，就是每次创建新钱包时，系统自动随机生成100个私钥，然后随着用户交易增多用光之后，再生成100个私钥；钱包文件就是一个二进制文件，即使加了密码保护，也很容易暴力破解泄密；</p>

<p>这导致了无穷多的hack事件；不管你信不信，初期很多从事比特币交易的网站，其wallet.dat文件就明晃晃的放在服务器上，管理员粗心大意，完全可以形容为 <code>没头脑+不高兴</code>，很多人连个最基本的密码保护也不设置；另外也发生过很多悲剧的<code>rm -rf</code>事件，我认为由于这样的失误导致的比特币丢失至少在100w+ 币的级别；换算今天的汇率，你能相信有个银行将数亿美元现金的保险柜不加锁，明晃晃的摆在大堂上摆阔吗？</p>

<p>在一连串的悲剧事件中(具体是哪些悲剧可以写一本书哦)，作为登峰造极者，mtgox当之无愧！ 80多万个比特币的丢失，史上独一份。这个交易所的老板也是心大，80w+币的钱包密码也不设置一个，就在那里任由黑客予取予求；还不是一天两天哦，是持续好几周的hack事件！</p>

<p>mtgox是比特币历史上巨大的迷雾，他不光牵扯到许多比特币的早期玩家，还有BTC-E, FBI牵涉其中，我认为这是仅次于<code>中本聪到底何方神圣</code>的谜题。所幸法胖还活着，我希望有生之年能读到这个事件的完整披露。</p>

<p>好了，假如你是一个交易所的老板，你会很快发现自己面临着以下问题：</p>

<ul>
<li>不需要给每个用户的账户都建立一个钱包文件，我希望能有一个总的账户管理方案</li>
<li>可能交易所有1000个大户，你希望他们的钱包是冷存储的，提币的时候他们可以耐心等一段时间，但是剩下的100000个普通用户的账户就要存放到一个热钱包上，只留有部分资产来应付流动性</li>
<li>有很多部门需要批准获取一些资金，比如研发要用啦做测试，市场部门要用来搞活动等等</li>
<li>最后，私钥最好只能由少数人，最好只有我本人来掌握，不然私钥的传播过程中，随便一个人就能让你万劫不复</li>
<li>我如果有一些合伙人的话，肯定也希望能掌管一部分资金</li>
<li>如果有突发情况，我能迅速把公司账上所有的币都转移到另外一个安全的账户上，这有可能是要迅速完成上万笔的交易转移</li>
<li>最后，我希望所有的交易，签署和广播是在不同的机器上进行的，存有私钥的机器不能联网，这台机器签名完毕后，调用远端的服务端广播交易，这样完全实现钱包的冷隔离</li>
</ul>


<p>好啦，假如我们现在只有前面那种一个wallet.dat钱包的管理方案，要怎么做呢？</p>

<p>很明显的，这种管理太粗糙了。社区们经过不断的探索，提出了BIP-32，BIP-39，BIP-44等规范，以绝妙的办法解决了这些问题。这就是比特币HD钱包的由来。同时这些规范不仅仅适用于比特币系统，还适用于所有的电子货币方案，也许今后，你可以同时在一个钱包里管理你的ETH, BTC, 支付宝余额等等~~~</p>

<p>那到底要怎么做呢？</p>

<p>我们已经探索了这么远，估计你也不耐烦了，但是我们还要说，这还早的很呢！那么下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoin-cli Cheat]]></title>
    <link href="https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat/"/>
    <updated>2018-10-26T16:28:23+08:00</updated>
    <id>https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat</id>
    <content type="html"><![CDATA[<p>今天踩了一个巨坑。</p>

<p>我一直以为<code>bitcoin-cli sendfrom</code>命令是可以花费uncomfirmed UTXO的。</p>

<!-- more -->


<p>然后今天发现bitcoin-core 0.17版本已经开始废弃这个命令和<code>bitcoin account</code>的支持了。于是去修改万年之前的一个脚本。</p>

<p>然后我切换到TESTNET里面发了几笔交易，惊奇的发现sendfrom并不能花费uncomfirmed UTXO。执行:</p>

<p>```</p>

<blockquote><p>bitcoin-cli sendfrom &ldquo;&rdquo; &ldquo;1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd&rdquo; 0.01 0
```</p></blockquote>

<p>明明我已经发给测试账户0.1BTC过去了，getwalletinfo可以看到这个币了，我也把minconf设为0了，却在执行sendfrom的时候总是提示我<code>Account has insufficient funds</code>；</p>

<p>我一路代码追下去，在这里:</p>

<p><a href="https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915">https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915</a></p>

<p>惊奇的发现只有自己的找零才会在uncomfirmed的情况下被计入credit fund，震惊了。我这个脚本运行了半年了，才发现这个坑。</p>

<p>没办法，自己又封装了一遍<code>createrawtransaction</code>，<code>signrawtransaction</code>, <code>sendrawtransaction</code>，来代替sendfrom的功能。</p>

<p>找这个问题我在TESTNET里面发了不下一百笔交易，wallet部分的代码已经翻遍了，我深深为之感叹bitcoin core实现wallet这部分的精巧，好多地方的细节已经不是人类能理解的了；太可怕了。</p>

<p>另外记一下远程调用bitcoind rpc接口的套路:</p>

<p>```</p>

<blockquote><p>bitcoin_cli &mdash;rpcconnect=192.168.2.7 &mdash;rpcpassword=&ldquo;xxxxx&rdquo; &mdash;rpcuser=test getwalletinfo
```</p></blockquote>

<p>相应的，bitcoin.conf也要允许远端调用rpc接口的权限:</p>

<p>```
rpcuser=test
rpcpassword=xxxxx
rpcallowip=192.168.2.0/255.255.255.0
rpcport=8332
rpcthreads=10
server=1</p>

<p>```</p>

<p>ps: bitcoin.conf 可以直接放到blockchain的数据目录，反正我看0.15的代码，已经把这个路径默认加到path搜索里面了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-1]]></title>
    <link href="https://happy123.me/blog/2018/10/23/bi-te-bi-de-hdqian-bao-yan-hua-1/"/>
    <updated>2018-10-23T18:49:26+08:00</updated>
    <id>https://happy123.me/blog/2018/10/23/bi-te-bi-de-hdqian-bao-yan-hua-1</id>
    <content type="html"><![CDATA[<h2>密钥分发的问题</h2>

<p>在之前我们的一篇文章<a href="https://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/">加密技术发展</a> 中提到了一个经典的问题:</p>

<!-- more -->


<ul>
<li><p>Alice和Bob是朋友，他们的住处离得比较远，Alice想要发送一则隐私消息给Bob</p></li>
<li><p>Eve想要窃听Alice和Bob的通信，Alice和Bob无法防止Eve的偷看</p></li>
<li><p>Alice把信放在一个盒子里，她上了锁，让邮差发给Bob，Eve没有钥匙，无法打开盒子，但是Bob也无法打开</p></li>
</ul>


<p>那么问题来了，Alice如何把钥匙发给Bob呢？</p>

<p>Alice如何发送钥匙给Bob的问题，就是现代密码学中<code>密钥分发</code>的问题;现代密码学的大部分研究，就是围绕这个问题展开的。</p>

<p>我们在思想实验中虚拟了两个解决方案:</p>

<h4>方案A</h4>

<ul>
<li><p>Alice把信息放到铁盒子里，上锁，发给Bob</p></li>
<li><p>Bob收到盒子，没有去想办法打开它，而是又加上了自己的一把锁，发回给Alice</p></li>
<li><p>Alice打开自己加的锁，发回给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
</ul>


<h4>方案B</h4>

<ul>
<li><p>Bob满世界散播自己的锁，随便一个人都能捡到Bob的锁并且能分辨是否被别人伪造</p></li>
<li><p>Alice捡了一把Bob的锁，把消息放进铁盒子里，锁上，发给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
</ul>


<p>这两个虚拟的解决方案意义非同寻常，它证明了两个人可以互相交换秘密的信息而不怕密钥泄露；但是在真实世界中，对一则文本信息加密，并不完全像给一个铁盒子上锁那样方便，我们如何把这两个故事的寓意融入到真正的密码术当中去呢？</p>

<h2>单向/双向函数</h2>

<p>在密码学中，很常用的一个数学特性叫做<code>单向函数</code>。</p>

<p>同样与之相对的，还有一个概念叫做<code>双向函数</code>。</p>

<p>让我们来看看他们是什么东东。</p>

<h4>双向函数</h4>

<p>大部分函数都是双向函数，<code>双向</code>意味着可逆。比如加倍函数就是一个双向函数:</p>

<p><code>
y = 2x
</code></p>

<p>知道了x，很容易能求得y；同理，知道了y，很容易逆向求得x。</p>

<h4>单向函数</h4>

<p>与上面相对的，知道x，很容易能求得y；但是知道了y，逆向很难推出x。这就是单向函数。举一个最常见的例子:</p>

<p><code>
y = 453^x % 21997
</code></p>

<p>一个很大的数的x次方来模除另一个很大的数，取模得到y，知道x，y是很容易计算的，但是反向从y推导x却十分困难。这就是一个单向函数。</p>

<p>码农童鞋们非常熟悉的一种算法:HASH(散列)，其原理就是建立在单向函数之上的；但是现在我们先把这个应用放到一边，单单探讨单向函数在密钥交换中的作用</p>

<h4>单向函数在密码学中的应用</h4>

<p>Alice和Bob在不懈的努力之后，发现采用上述 M<sup>x</sup> % P = y 的单向函数可以帮助他们交换密钥，而且
不怕遭到Eve的窃听，让我们看看他们怎么做到的：</p>

<table>
<thead>
<tr>
<th>选择 7<sup>x</sup> % 11 = y 这个单向函数作为约定函数 </th>
<th>Alice </th>
<th> Bob</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一步 </td>
<td> Alice随机选择了一个数字代入x，比如3 </td>
<td> Bob 随机选择了一个数字代入x，比如6</td>
</tr>
<tr>
<td>第二步 </td>
<td> Alice运算得到 7<sup>3</sup> % 11 = 2  </td>
<td> Bob 运算得到 7<sup>6</sup> % 11 = 4</td>
</tr>
<tr>
<td>第三步 </td>
<td> Alice把2发给Bob  </td>
<td> Bob 把4发给Alice</td>
</tr>
<tr>
<td>第四步 </td>
<td> Alice得到Bob发送的结果4，代入单向函数再一次运算得到 4<sup>3</sup> % 11 = 9  </td>
<td> Bob 得到Alice的2后进行同样的运算 2<sup>6</sup> % 11 = 9</td>
</tr>
</tbody>
</table>


<p>神奇的事情发生了，第四步中Alice和Bob得出了相同的数字9，这个数字就是他们需要传递的密钥。</p>

<p>让我们再重新审视一遍，Alice和Bob在这次交换密钥的过程中都传递了什么呢？</p>

<ol>
<li>他们约定了单向函数的 M, P值</li>
<li>他们各自选定了一个x值，然后计算结果y值并互相传递</li>
<li>通过前面两组信息，他们各自独立计算出了密钥值</li>
<li>Eve如果监听到了M,P,以及两个人传递的y，是很难逆向计算出x，并得出密钥值的；这是单向函数的数学特性决定的</li>
</ol>


<p>通过仔细的选定一个稳妥的单向函数，就可以通过公开的讨论来建立一个密钥。这是密码学史上一个伟大发现。它是如此的简单和违反直觉，简直让人觉得不可思议。</p>

<p>如果仔细看看，两个人交换模除结果y的过程，是不是和我们之前提到过的<code>方案A</code>有点像呢，这就是思想实验在理论世界中的映射。</p>

<p>这个发现是由我们前面那篇<a href="https://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/">加密技术发展</a>中帅帅的大叔们在1972年的工作成果，向他们致敬！</p>

<h2>非对称加密算法的建立</h2>

<p>虽然我们上面所建立的交换密钥的方案已经取得了巨大的进步，但是这个方案并不完美，因为它有一个不方便的地方:</p>

<p>Alice 想要给Bob发信，必须拿到Bob的y值，除非是热恋的情人，谁能一直在线回复你的消息呢？所以Alice要发信，一定要Bob配合达成一个密钥才可以；如果Bob恰巧睡觉了，这封信就只能延迟发了</p>

<p>这个不方便之处促使密码学家们寻求更完美的解决之道，这促成了非对称加密算法的建立。</p>

<p>我们至今为止的所有探讨都是建立在对称加密算法之上的。所谓<code>对称加密</code>，就是你有一个密钥，使用这个密钥加密一段信息，同样可以使用这个密钥解密这段信息。正是之前所有的加密算法都是建立在这个基础上的，所以密钥的传递才是如此重要。</p>

<h4>现在让我们思考另外一种看似违反直觉的方案</h4>

<p>如果有一种加密解密函数，它的加密密钥和解密密钥是不同的。在这个系统中，如果Alice只知道加密密钥，她只能加密，加密之后自己却无法解密&mdash;除非她知道另外一个解密密钥。</p>

<p>听起来好像有点绕口。用现代密码学的定义来解释，就是Alice需要同时拥有两把密钥：私钥和公钥。私钥用来解密，公钥用来加密。这样Alice只要好好藏好自己的私钥，然后把公钥广播天下，谁想要给Alice写情书，就用Alice广播出来的公钥加密寄给她就好啦，只有持有私钥的Alice才能解密这封情书。</p>

<p>这个系统的巨大优点就是两人通信不需要同时在线来来回回折腾了，只要两人把各自把自己的公钥广而告之，任何一个人就可以毫不顾忌的用公钥加密，写一些只能给Alice和Bob才能解密的隐私信息了。</p>

<p>这个方案是由帅帅的Whtfield Diffie想到的，在此我们要撒一把狗粮；这位老兄灵光一现想到这个方案之后，第一个想要与之分享的人是他的妻子玛丽，当时的情形是这样的:</p>

<blockquote><p>那是在下午发生的，维特不得不等几个小时，玛丽才会回来。
&ldquo;维特等在门口，"玛丽回忆说，"他说有事要告诉我，他脸上的表情很奇怪。我进了门，他说:&lsquo;请坐下来，我想和你说话。我相信我有一个重大的发现&mdash;-我是第一个知道这问题答案的人。'那一刻我感觉时间突然停止了，我似乎生活在好莱坞的电影中。&rdquo;</p></blockquote>

<p>好，单身狗童鞋们从暴击伤害中回过神来没有，让我们继续艰难的人生~~~</p>

<p>虽然Whtfield Diffie早在1975年就提出了这个方案，但是他没有找到他所需要的函数。他公开发表了论文，号召同时代的数学家们一起来找；但是时间飞逝，年底还是没人能找到这样的函数，有些人灰心了；正在这时，远在5000公里之外的美国西海岸，有个小组找到了这样的函数~~~这就是今天大名鼎鼎的RSA算法的诞生。</p>

<h4>那些个帅帅的大叔们</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg1.jpg" alt="RSA加密发明人" /></p>

<p>额，关于RSA算法，阮一峰老师的文章写的更清晰，我就不多废话了；童鞋们可以移步<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">这里</a>来探讨细节，当然，懒得去理解数学原理对于我们下面的探讨也没啥影响~~~~</p>

<h4>让我们总结一下一个典型的非对称加密算法的特点，并看看它是如何应用到实际中的</h4>

<ol>
<li>Bob手里有两把钥匙，一把是公钥，另一把是私钥。有了私钥能推导出公钥，有了公钥不能推导出私钥</li>
<li>用私钥加密，可以使用公钥解密</li>
<li>用公钥加密，可以使用私钥解密</li>
<li>Bob把公钥送给他的朋友们&mdash;&mdash;Alice, Sam ~~每人一把；或者直接把公钥公示在自己的个人网页上，谁都能看；</li>
<li>Alice要给Bob写一封保密的信。她写完后用Bob的公钥加密，就可以达到保密的效果。</li>
<li>Bob收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要Bob的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</li>
<li>Bob给Alice回信，决定采用"数字签名"。他写完后先用Hash函数，生成信件的摘要（digest）。</li>
<li>然后，Bob使用私钥，对这个摘要加密，生成"数字签名"（signature）。Bob将这个签名，附在信件下面，一起发给Alice。</li>
<li>Alice收信后，取下数字签名，用Bob的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</li>
<li>Alice再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</li>
<li>复杂的情况出现了。Eve想欺骗Alice，他偷偷使用了Alice的电脑，用自己的公钥换走了鲍勃的公钥。此时，Alice实际拥有的是Eve的公钥，但是还以为这是Bob的公钥。因此，Eve就可以冒充Bob，用自己的私钥做成"数字签名"，写信给Alice，让Alice用假的Bob公钥进行解密。</li>
<li>后来，Alice感觉不对劲，发现自己无法确定公钥是否真的属于Bob。每次都去寻找Bob的个人网页去比对也很麻烦；她想到了一个办法，要求Bob去找"证书中心"（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对Bob的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。</li>
<li>Bob拿到数字证书以后，就可以放心了。以后再给Alice写信，只要在签名的同时，再附上数字证书就行了。</li>
<li>Alice收到信后，用CA的公钥解开数字证书，就可以拿到Bob真实的公钥了，然后就能证明"数字签名"是否真的是Bob签的。</li>
<li>以上过程涉及了<code>非对称加密</code>，<code>HASH</code>，<code>签名</code>,<code>Digest</code>，<code>CA</code>等等名词，没错，我们说的就是HTTPS</li>
</ol>


<p>完整的资料参看这里：</p>

<p><a href="http://www.youdzone.com/signature.html">http://www.youdzone.com/signature.html</a></p>

<h2>椭圆曲线ECC加密算法（Elliptic Curve Cryptography）</h2>

<p>我们看到了，非对称加密的核心，依赖于一个非常健壮的单向函数。RSA采用的是大素数分解的单向函数。这基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难。大质数分解问题一直是数学里面的热门问题。</p>

<p>即便如此，因式分解在位对位基础里不是最难的问题。这些因式分解算法随着被因式分解的数字变得越大而变得越有效率。因式分解大批数字和乘以大批数字的难度的差距随着数字（即秘钥的字节长度）变大而缩小。随着有效解码数字的资源增加，秘钥的大小必须更快增长。对限制计算能力的手机和低功率设备来说，这不是一个可持续的情况。从长期来看，因式分解和乘法的差距是不可持续的。</p>

<p>所有这一切意味着RSA不是理想的系统对将来的密码学来说。在一个完美的trapdoor函数里，对于数字大小的问题，简单方法和困难方法都一同样的速率变难。所以我们需要一个基于更好的trapdoor的公钥系统。</p>

<p>以上RSA的这些不完美加速了另外一种算法的诞生：在1985年，加密算法被提议以一个叫椭圆曲线的数学密码分支为基础。这也是比特币地址采用的核心加密方法。</p>

<h4>什么是椭圆曲线</h4>

<p>对于我们小白来说，椭圆曲线可以暂时简单的理解为描述了特定点的集合的公式：</p>

<p><code>
y^2 = X^3 + ax + b
</code></p>

<p>取不同的a值和b值，这个函数在坐标轴上绘制出来的曲线大概是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg2.jpg" alt="椭圆曲线" /></p>

<p>a和b的取值变化决定了曲线在坐标系上的不同形状。从图中可以看到，椭圆曲线是相对X轴对称。</p>

<p>通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的。椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。</p>

<h4>secp256k1椭圆加密曲线</h4>

<p>a和b的不同取值可以画出多条不同的曲线，比特币使用了secp256k1标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线：</p>

<p><code>
y^2 % p = (X^3 + 7) % p
</code></p>

<p>看到了吧，这个函数结合了我们之前介绍的取模操作和椭圆曲线函数。</p>

<p>上述素数p取模表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2<sup>256</sup> – 2<sup>32</sup> – 2<sup>9</sup> – 2<sup>8</sup> – 2<sup>7</sup> – 2<sup>6</sup> – 2<sup>4</sup> – 1， 这是个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散落的点，因此很难可视化。不过，其中的数学原理与实数范围的椭圆曲线相似。</p>

<p>这条曲线画出来的样子大概是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg3.jpg" alt="椭圆曲线" /></p>

<p>在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。</p>

<p>还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3 = P1 + P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线相交于另外一个地方。此点记为 P3'= (x，y)。然后，在x轴做翻折获得 P3=(x，-y)。</p>

<p>下面是几个可以解释“穷远点”之存在需要的特殊情况。</p>

<p>若 P1和 P2是同一点，P1和P2间的连线则为点P1 的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微积分求得。即使限制曲线点为两个整数坐标也可求得斜率！</p>

<p>在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3 = “无穷远点”。</p>

<p>若P1就是“无穷远点”，那么其和 P1 + P2= P2。类似地，当P2是无穷远点，则P1+ P2 = P1。这就是把无穷远点类似于0的作用。 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)+C = A+(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。 因此，我们已经定义了椭圆加法，我们可以对乘法用拓展加法的标准方法进行定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，在这种情况下k有时被混淆而称为“指数”。</p>

<h4>生成公钥</h4>

<p>以一个随机生成的私钥k为起点，我们将其与曲线上预定的生成点G相乘以获得曲线上的另一点，也就是相应的公钥 K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p>

<p>{K = k * G}</p>

<p>其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将 得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生） 与任何人共享而不会泄露私钥（k）的原因。</p>

<p>提示 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。</p>

<p>为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：</p>

<p>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</p>

<p>公钥K 被定义为一个点 K = (x, y)：</p>

<p>K = (x, y)</p>

<p>其中，</p>

<p>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</p>

<p>y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</p>

<p>为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一 点，然后翻折到x轴。</p>

<p>下图显示了在曲线上得到 G、2G、4G 的几何操作。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg4.jpg" alt="椭圆曲线" /></p>

<h4>比特币账户</h4>

<p>呼呼，以上就是比特币的账户核心算法的一部分。</p>

<ol>
<li>选定了secp256k1算法，其实是通用的椭圆曲线的特化(a=0, b=7)，另外选定一个非常大的模除数字p</li>
<li>选定了一个G点;G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</li>
<li>随机生成了一个私钥k</li>
<li>求得公钥K = k * G，这里对G进行了k次翻转，一个不可逆的操作得到公钥K</li>
<li>对K再做后续变形，最终得到比特币账户的地址，这个变形又是一系列神操作，我们在后面的文章会讲</li>
</ol>


<h2>寻求更极限的安全</h2>

<p>到目前为止，密码学家们为了实现更安全的非对称加密算法，探索了模除、大素数分解、以及椭圆曲线；他们的共同特点就是逆向运算极难极难；但是极难并不代表着不可能，随着量子计算的发展，谁也不能保证今后逆向运算的复杂度会不会有大幅降低；所以寻求更安全的单向函数始终是密码学家们最重要的工作之一；</p>

<p>近年来，这个探索的边界又有了更大的突破，就是为人们所熟知的量子加密技术。</p>

<p>限于篇幅，我们就不做更多的科普了，可以参考这本书:</p>

<p><a href="https://book.douban.com/subject/1036413/">https://book.douban.com/subject/1036413/</a></p>

<p>PS:一个小科普，量子计算机和量子加密其实没有多大关系哦，他们之间其实是雷锋和雷峰塔的关系，就是名字相似而已，可不要被忽悠哦</p>

<h2>总结</h2>

<p>呼呼，老实说，我最初想要介绍的是比特币HD钱包的演化过程，BIP32,BIP44,BIP49，BIP84以及BIP141这些文档共同定义了比特币HD钱包的底层构造。</p>

<p>从BIP44开始，比特币账户的管理其实已经在中本聪最初定义的一个简单地址生成的路上又走了很远；我也觉得HD钱包是比特币社区为区块链技术贡献的一个非常重要、非常有用的部分；这个钱包生成的技术超出了比特币本身，在可见的未来，会在多个领域发挥巨大作用。</p>

<p>为了学习比特币HD钱包的基础理论支撑，我们从最原始的凯撒加密，到Alice和Bob的思想实验，到单向函数，再到安全的密钥分发方法，到非对称加密，椭圆曲线，甚至还隐约看到了量子加密，这一切的一切是近2000年来无数密码学家们日日夜夜的冥思苦想的成果；</p>

<p>然后站在所有这些成果的基础上，到了中本聪及比特币技术社区手中融合发扬光大；创造了独一无二的电子货币金融账户；这个账户设计的方法之精妙，值得我们再长篇大论一番；那么，下次文章再见。</p>

<p>参考资料:</p>

<p><a href="https://book.douban.com/subject/30280401/">https://book.douban.com/subject/30280401/</a></p>

<p><a href="https://book.douban.com/subject/1036413/">https://book.douban.com/subject/1036413/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[黎曼猜想的证明会对加密货币产生影响吗?]]></title>
    <link href="https://happy123.me/blog/2018/09/26/li-man-cai-xiang-de-zheng-ming-hui-dui-jia-mi-huo-bi-chan-sheng-ying-xiang-ma/"/>
    <updated>2018-09-26T10:19:00+08:00</updated>
    <id>https://happy123.me/blog/2018/09/26/li-man-cai-xiang-de-zheng-ming-hui-dui-jia-mi-huo-bi-chan-sheng-ying-xiang-ma</id>
    <content type="html"><![CDATA[<p>当今资讯发达，娱乐界、学术界以及投机赌博界已然不分家了。</p>

<p>Michael Atiyah老爷子来一场数学报告，已然惊动众多娱乐媒体和赌徒大佬。老爷子的秀场视频在这里，快去瞻仰:</p>

<p><a href="https://www.youtube.com/watch?v=oe4Jo4i3w_w">https://www.youtube.com/watch?v=oe4Jo4i3w_w</a></p>

<p>为了跟上时代的步伐，民工也要求上进啊，只能又去填鸭科普了一下数学ABC。</p>

<!-- more -->


<h3>黎曼猜想是啥</h3>

<p>黎曼猜想起源于素数的研究。素数在自然数中是一种特别的数，它只能被1和自己整除。而且素数的个数是无限的。</p>

<p>素数如此特别，数学家们试图搞清楚如何判断一个数是素数。给你一个小的数，例如7，你很容易判断它是素数。但是当给你一个很大的数字时，判断一个数是否为素数，是需要方法的。由此产生了素数判定的算法。</p>

<p>为了更好地理解素数，数学家们在 19 世纪便不再尝试预测素数的精确位置，转而将素数的现象视为一个整体。这个预测素数分布规律的挑战吸引了众多大佬，包括我们的数学王子gauss，独行侠Selberg等等，最著名的还是Riemann hypothesis提出的黎曼猜想。这段历史可以参考卢昌海老师的<a href="https://www.changhai.org/articles/science/mathematics/riemann_hypothesis/index.php">科普文</a>。</p>

<p>黎曼1859年在他的论文《论小于已知数的素数个数》提出了这个著名的猜想，但它并非该论文的中心目的，他也没有试图给出证明。这个猜想描述如下:</p>

<p><img src="https://ws1.sinaimg.cn/large/893d6e9dly1fvmquq5a8ej211y04wgqb.jpg" alt="黎曼猜想" /></p>

<p>这个函数称之为黎曼 zeta 函数。黎曼给出了一个推测：黎曼 zeta 函数的所有非平凡零点可能都全部位于实部等于1/2的直线上。上述公式中的第二项，x 的 ρ 次幂的ρ就是黎曼 zeta 函数非平凡零点。</p>

<h4>简而言之，任意给定一个自然数x，通过这个公式能更精确的得出 x 以内素数的个数。</h4>

<p>那么这个公式是正确的吗，通过现在的计算机暴力计算，不能证伪，好像是正确的。但是也没有人能给出严格的证明，所以称之为是猜想。</p>

<h3>如果猜想被证明，对安全界有什么影响</h3>

<p>这又得从我们码农熟知的非对称加密算法开始说起了。众所周知，SSL/TLS(https)等一系列安全协议都是建立在RSA算法之上的，而RSA作为非对称加密算法的典型代表，又是建立在大素数分解的基础上的。这部分可以参考阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">科普文</a>。</p>

<p>那么黎曼猜想如果被证明，是不是意味着RSA算法就不再安全了呢？作为吃瓜群众，大可不必去跟风娱乐媒体，不需要多高深的数学知识就能自己来判断:</p>

<ol>
<li><p>黎曼猜想是在1859年提出的，虽然没人能证明，但是也没人能证伪，这说明这个方法作为一个判别素数个数分布的工具，已然被广泛运用多年了</p></li>
<li><p>非对称加密是在20世纪70年代末提出的，如果黎曼猜想能加速大素数分解的计算，那么其实1970s左右，RSA诞生之初，就已经面临重大威胁了</p></li>
<li><p>素数检测和整数分解是两回事，至今还没有人找到他们之间有何联系</p></li>
<li><p>如果素数的检测能加速分解计算的话，即使有某个人或某个组织掌握了这个技术，那么全世界的网络，包括各大银行、金融、政府组织，都会受到严重威胁；但是目前为止还没有啥迹象；</p></li>
</ol>


<h3>如果猜想被证明，对加密数字货币(如比特币)有什么影响</h3>

<p>我们知道，比特币的安全设计是远远领先于时代的，我们之前在<a href="https://happy123.me/blog/2018/04/24/cryptocurrency-security/">这篇文章</a>中，曾经谈到过比特币的地址安全问题。</p>

<ol>
<li><p>基本上所有加密货币的地址都是参考比特币，采用椭圆曲线非对称加密算法为基础生成的</p></li>
<li><p>椭圆曲线和RSA的套路完全不同，和素数分解也没啥关系，即使RSA被破解了，和比特币也是雷峰塔倒掉和学雷锋的关系&mdash;&mdash;就是没关系</p></li>
<li><p>大多数加密货币的挖矿采用了许多不同的单向散列(HASH)函数，目前理论来看，这基本上也和素数分布没啥关系</p></li>
</ol>


<h2>结论</h2>

<ol>
<li><p>黎曼猜想能不能成功证明、有没有人能理解这个证明还是两说</p></li>
<li><p>即使黎曼猜想不能被证明，它作为一个检测素数分布的工具使用已经好多年了，如果真的对基于素数分解的非对称加密算法有威胁，100多年了，早也应该暴雷了吧</p></li>
<li><p>即使RSA GAME OVER了，对于以椭圆曲线为基础的比特币等加密货币，没啥影响</p></li>
<li><p>估计娱乐媒体又要对中本聪一顿<code>先知</code>神吹了</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自由交易创造财富?]]></title>
    <link href="https://happy123.me/blog/2018/09/12/zi-you-jiao-yi-chuang-zao-cai-fu/"/>
    <updated>2018-09-12T15:44:14+08:00</updated>
    <id>https://happy123.me/blog/2018/09/12/zi-you-jiao-yi-chuang-zao-cai-fu</id>
    <content type="html"><![CDATA[<p>有人调侃说，这世上有些事人人都觉得自己懂：音乐，政治，和经济。</p>

<!-- more -->


<p>看看股市里面各种股评家就知道了，感觉人人都是斯密再生，什么不可能三角，反身性，蓄水池，M0 M1 M2，做空美国，汇率战争&hellip;&hellip;纵论世界经济大势，舍我其谁。</p>

<p>作为一个财经盲，听到人家谈论这些话题的时候完全是一脸懵逼，智商失联；为了提高一点点可怜的交际能力，近期恶补一番《国富论》。</p>

<p>于是，我由文盲晋级到小白，Level+1。这里记录一下小白的瞎想：</p>

<h2>斯密全书反复强调的一个观点: 分工和自由交易可以创造巨大的财富</h2>

<h4>分工创造财富</h4>

<p>书中开篇就举了一个例子:</p>

<blockquote><p>以前一个工匠一天最多做几十枚铁钉。但是在一个现代化工厂中，一天则可以生产几万枚。之所以有如此大的提升，原因就是进行了细致的分工：</p>

<p>有的人负责把铁熔成铁水，有的人负责把铁水抽成铁丝，有的人负责把铁丝斩断，再有的人负责把铁丝磨尖，另外有人把头给打出来，这个流程每一个人都特别熟悉自己的哪一个非常小的环节。这种分工协作，让每个人都对自己的这一个环节特别熟悉，生产效率得到了上百倍的提高。</p></blockquote>

<p>斯密观察到了这种现象，专业分工可以极大的提高生产力、创造财富——这个结论在今天已经成为常常识，在中学的课本上我们就对其耳熟能详。</p>

<h4>自由交易创造财富</h4>

<p>交易创造财富呢？</p>

<p>这一听好像是非常违背常识的事情。我们的吃穿用度，都是劳动人民辛辛苦苦用汗水换来的，是生产活动创造了财富；</p>

<p>而交易，无非是投机倒把，更甚者，那些金融掮客们，不事生产，不辨菽麦，怎么能说他们创造财富呢？一批金融人士和股民集体中枪中&hellip;.</p>

<p>斯密先生是如何解释的呢？他在<code>分工创造财富</code>的基础上继续追问，是什么促成了专业分工这种生产方式？</p>

<blockquote><p>他进一步分析，得出结论：专业分工是基于庞大的、自由的市场交易。</p>

<p>一是市场得庞大，二是交易得自由：</p>

<p>如果在某一个闭塞的小地方建立一个工厂，每日生产几万颗铁钉，铁钉是卖不出去的，因为一个人一年只需要五六根——市场不够大。市场不够大，高密度的分工就不会出现。这就是资本主义国家总是想打开封闭国家的大门的原因。</p>

<p>市场够大了，但是如果交易不自由，被各种限制，也不行。当时的欧洲，还存在封建割据。商人要把一个东西从英国卖到德国去，中间要穿过几十个封建小国，过一个关，收一道税，“通关文牒”上密密麻麻盖满了章。而且有些产品还不让过，严重阻碍了交易自由。这样，高密度的分工也不会出现。</p>

<p>当时的欧洲，还流行封建行会制度：不能说你有技术，能做鞋，你就开店去做鞋了！得经过行会批准，否则就是非法经营，就砸你的店。而且工人也不能自由跳槽，你跟了一个师傅，就像拜师学艺，不能说这个师傅对你不好，你就另找一个师傅！那不行，那是违背“道德”的。</p>

<p>这种“道德”和封建制度的枷锁，对生产力的束缚是非常之大。</p>

<p>不只是普通商品需要自由交易，土地、资本、劳动力等生产要素，也都应该可以自由交易才行——交易自由是基本的人权。</p></blockquote>

<h4>&ldquo;交易"在大部分人的直觉中，只是转移、交换，财富是不会增加的。其中的秘密是什么呢？</h4>

<p>斯密提出了一个非常著名的悖论：</p>

<blockquote><p>空气和水对于我们非常重要，却几乎是免费的，黄金钻石属于非必需品，没有它也能照样生活，却贵得要死。</p></blockquote>

<p>衣服比较需要，价格比较便宜，汽车不一定需要，价格相当昂贵。你会发现越是你不需要的东西，价格越贵。</p>

<p>为什么会这样？</p>

<p>斯密想：是什么决定了物品的价值？</p>

<p>他开创性地提出了使用价值（用值）和交换价值（换值）的概念：用值高的东西，换值可能很低，用值低的东西，换值可能很高。</p>

<p>后来有了"边际"概念之后，后人发现，换值其实就是边际用值。</p>

<p>水的用值非常高，但在喝了5杯水之后，再多喝一杯的用值则非常低了，喝到你不想再多喝一口！其边际用值非常低。</p>

<ul>
<li><p>一只画笔，在放羊娃的手里一钱不值，但到了齐白石手中，丹青妙笔下的画卷价值万金；</p></li>
<li><p>一亩鱼塘，游牧民族不屑一顾，江南农民眼里可能就千金不换；</p></li>
</ul>


<p>而这些资源，天分是老天爷随机配比的，每个人都不可能生下来物尽其用、才尽其用、各得其所；更何况一个人的境遇、天然的环境是时时变化的，齐白石也可能拿不动笔，骑马的汉子也可能会娶江南的姑娘，他也需要一亩鱼塘来养家糊口；于是便产生了交易；</p>

<p>财富的本质，源于"资源的有效配置"，就是有效的交易；资源可以是自然资源、天分、知识、美貌等等一切有人看重的东西；</p>

<p>当交易无时无刻不在发生，那么价值就无时无刻不在创造。</p>

<p>交易创造财富！</p>

<p>这种自由交易的机制，不需要有人去刻意安排，也不需要刻意维持和鼓励。只要你不去人为地打压，它就会如野草般自己生长。</p>

<p>原因何在呢？斯密先生的解释是：</p>

<blockquote><p>很多时候，一个人会需要兄弟朋友的帮助，但假如他真的要依靠他们的仁慈之心，他将会失望。倘若在需求中他能引起对方的利己之心，从而证明帮助他人是对自己有益的事，那么这个人的成功机会较大。任何人向他人提出任何形式的交易建议，都是这样想：给我所需要的，我就会给你所需要的——这是每一个交易建议的含义；而我们从这种互利的办法中，所获的会比我们所需的更多。我们的晚餐可不是得自屠夫、酿酒商人，或面包师傅的仁慈之心，而是因为他们对自己的利益特别关注。我们认为他们给我们供应，并非行善，而是为了他们的自利。</p>

<p>所以，每个人都会尽其所能，运用自己的资本来争取最大的利益。一般而言，他不会意图为公众服务，也不自知对社会有什么贡献。他关心的仅是自己的安全、自己的利益。但如此一来，他就好像被一只无形之手引领，在不自觉中对社会的改进尽力而为。在一般的情形下，一个人为求私利而无心对社会作出贡献，其对社会的贡献远比有意图作出的更大。</p></blockquote>

<p>这样看来，一个有意思的推论就产生了：</p>

<h4>某些财富可能不过是一种幻觉！！</h4>

<p>我们所看重的东西，所谓的财富，不管是我们的衣食住行实实在在的实物，还是音乐文学绘画等等精神产品，建立的基础是人们的需求。而人们的需求并不是万古不变的:</p>

<p>比如美学产品，很难说几千年后毕加索的作品会有何种评价；或者科幻一点，将来有了可飞行的汽车，市中心的房子能有多大市场&hellip;&hellip;</p>

<p>说的更唯心一点，劳动人民不过是在一种精神层面需求的驱动下生产的，财富的第一创造驱动力来自于交易。</p>

<p>D(t) > 0；交易创造财富；</p>

<p>简明版本的解释就是：</p>

<ul>
<li><p>人们喜欢吃梨子和苹果，于是培育了果树</p></li>
<li><p>我喜欢吃梨，但是家里只有苹果树；你喜欢吃苹果，家里只有梨树</p></li>
<li><p>我拿苹果换梨子，需求满足++，创造了财富</p></li>
</ul>


<h4>为什么会有人限制苹果换梨子</h4>

<p>既然自由的市场是最好的，为什么政府还会有种种管制行为呢？为什么还会有贸易战呢？再进一步，为什么需要政府插手经济呢？</p>

<ul>
<li>自由市场是会崩溃的。</li>
</ul>


<blockquote><p>16世纪后期的荷兰，出现了发达的商业贸易。但也是商业贸易，促成了“郁金香泡沫”的爆发，这是有史记载的第一次金融泡沫。</p>

<p>从16世纪中期到17世纪初期，人们逐渐对郁金香产生了狂热。一些郁金香珍品被卖到了不同寻常的高价，富人们竞相在他们的花园中展示稀有的品种。1635年，一种叫Childer的郁金香品种单株卖到了1615弗罗林（florins，荷兰货币）。一株这玩意，就能换3头公牛。第二年，一株稀有品种的郁金香（当时荷兰全境只有两株）卖到了4600弗罗林的价格，除此之外，购买者还需要支付一辆崭新的马车、两匹灰马和一套完整的马具。</p>

<p>但是，所有的金融泡沫，正如它们在现实世界中的名字所喻示的那样脆弱。这个因为自由交易而导致的泡沫，最终崩溃了。</p></blockquote>

<p>正常交易创造了财富值100，人的贪婪本性注定了有人想要攫取财富值1000；于是有了欺诈和恐惧，于是有了管制；国家也是一样的，总有一些国家更加贪婪，或者说每个国家都会更加贪婪，它们之间也会有恐惧和欺诈，于是诞生了贸易战。</p>

<ul>
<li>自由交易的市场能创造出一切东西，唯独不能创造市场本身</li>
</ul>


<p>一个公平的环境需要信用，目前为止，人类历史更迭，尝试了无数种办法，能维系信用的唯有<code>暴力</code>；这促成了国家的诞生。国家一定要用暴力来维护市场。</p>

<p>人类财富的创造源泉，最终由<code>交易</code>推导到了<code>信用</code></p>

<h2>让我们谈谈区块链(blockchain)吧</h2>

<p>我是非常不愿对这个东西夸夸其谈的，因为卷入这个场子的人，在我看来，就像美国大淘金时代一样，小偷、骗子、强盗实在太多。</p>

<p>好吧，我也一样，自以为悟到了一些东西就来夸夸其谈，大家当成笑料听听就好，不用当真。</p>

<h4>区块链是人类历史上第一次找到了这样一种工具：它维系市场，超乎暴力之上</h4>

<p>区块链是信用的承载。让我们这样想象：</p>

<p>来源于名为<code>Bitcoin</code>的信用之水，得益于早期信徒的开采维护，汇集成了一条小溪汩汩向东流去；</p>

<p>一路上有更多的信徒创造更多的信用，合力汇集为一条名为<code>blockchain</code>的大河，滚滚东流；</p>

<p>这条大河是最终到达信用之海，创造出一个超出暴力之上的信用汇集而成的新市场；还是因为没有更多的信用注入，逐渐干涸为沼泽，沦为一个庞氏骗局，没有人能预言。</p>

<p>不过可以这样推想，信用是个很神奇的东西：它无法定量计算，但是社会上产生的信用多寡又是如此明显；人人都知道一个正直的人创造的信用值肯定大于一个骗子；同理，同样的人口，一个民风淳朴的国家创造的信用肯定大于索马里人民的信用值；</p>

<p>最神奇的，一个人可以创造的信用没有明显的上限；信用也可以由一代代的人无限创造；相对的，信用也可能不断损耗，最终趋近于0。</p>

<p>我们所景仰的奥马哈先知曾多次强调：比特币是老鼠药的平方。</p>

<p>当区块链上承载的信用量不再增加的时候，就是一朵郁金香。奥马哈的先知此时是对的。</p>

<p>当区块链上承载的信用无限增加的时候，就是永不终结的市场。当然这个概率有多少，没人能预测。</p>

<h4>回到未来</h4>

<p>让我们掏出水晶球，冒险预言一下blockchain的未来：</p>

<ul>
<li>初期</li>
</ul>


<p>就像早期大淘金时代一样，这个市场会充斥骗子、小偷、强盗、投机家，以及一些英雄人物；但还是摆脱不了<code>庞氏骗局</code>的帽子</p>

<p>正如我们前面所强调了，区块链是一条信用之链，而且目前维护这样一条链的代价及其昂贵；</p>

<p>既然是如此金贵的资源，那么最初利用它做什么呢？有什么东西是信息量无限小，价格无限大呢？</p>

<p>我们把能想到的领域排排坐：</p>

<p>1.铸币权</p>

<p>2.投机博彩传销</p>

<p>3.洗钱</p>

<p>4.黑市</p>

<p>5.国际汇款</p>

<p>6.券商承兑，金融产品</p>

<p>7.法律公证等等一切需要用到公章的地方</p>

<p>8.版权、数字营销、保险、电子证据、物联网、供应链、积分共享、征信、公益、游戏道具等等PPT概念产品</p>

<p>9.工业能源政务医疗衣食住行阿猫阿狗等等忽悠</p>

<p>&hellip;&hellip;</p>

<p>目前占大头的应用是什么呢？上面的诸家应用能在什么阶段落地呢？</p>

<p>是不是看出来有些东西永远不能落地，为什么呢？</p>

<p>大家自有分辨。</p>

<ul>
<li>早期</li>
</ul>


<p>一个国家金融业完善发达，一个国家还处于一穷二白，谁更需要所谓的数字货币，所谓的区块链呢？</p>

<p>与直觉相反，我认为将来比特币会在中东这种政治动荡之地，拉美这种经济动荡之地，非洲这种一穷二白之地发挥巨大作用；</p>

<p>对于其它经济体，肯定会抵制、再抵制，直到无可奈何，开一道小口子，让其在外贸领域有点活命的机会；或者说，比特币是永远不能登上主流舞台的，它只能跟投机、黑市、国家破产等等联系在一起。</p>

<p>那是不是说，这个技术就没有前途呢？就等着各国纷纷禁止，然后戳破泡沫，价格归零呢？</p>

<ul>
<li>中期</li>
</ul>


<p>不是的，它是一项非常非常危险的创造，潘多拉魔盒一旦打开，无法关闭。数字货币的生命力可能会超过许多国家的寿命，成为新时代的黄金，但是是一种不能为国家所容忍的黄金。</p>

<p>所以，这个泡沫会 破灭->复兴->破灭，不断的循环下去，投身于其中的人会越来越多；</p>

<p>这是一个泡沫，但是可能会持续几十年甚至超过国家的寿命，也可能一夜归零后，等待几年甚至几十年才能有下次复兴；</p>

<p>blockchain本质上是一项跟国家抢夺铸币权、抢夺信用定价权的技术，它从根本上动摇了国家的根基，所以可能会出现绝大多数国家联起手来，共同封杀这项技术的一天。</p>

<ul>
<li><p>后期</p>

<ul>
<li><p>究竟是人类的贪婪占据上风，信用之河就此干涸成为沼泽，最终作为最大的郁金香泡沫永载史册呢?</p></li>
<li><p>还是一小撮信徒自诩为摩西，或者卫星上天，或者公海游弋，或者开疆裂土，建立一个信用自由港呢？</p></li>
<li><p>还是开天辟地，超脱国家和暴力，成立一个新的信用市场呢？</p></li>
</ul>
</li>
</ul>


<h4>唯有时间能给出答案。</h4>

<hr />

<p>PS: 神遭遭瞎扯了这么多，其实我是被Bitcoin Core的闪电网络的代码搞烦了，我怎么也理解不了；</p>

<p>理解不了的东西让我对他的安全性产生重大怀疑，我能创造的的信用值直线下降；</p>

<p>市场动荡之际，我投入BCH阵营了；好吧，这一次我是个投机者了，Maybe将来很悲惨，所以回到未来记下这一惨痛投机教训。</p>
]]></content>
  </entry>
  
</feed>
