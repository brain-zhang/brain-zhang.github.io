<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2018-11-17T21:09:15+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BCH分叉承担的风险--51%攻击者概率问题]]></title>
    <link href="https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti/"/>
    <updated>2018-11-17T18:42:09+08:00</updated>
    <id>https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>2018-11-16 01:40(UTC+8)发生的BCH分叉实在好看，转载一下进程说明:</p>

<!-- more -->


<blockquote><p>  “分叉前夕：
  BCH硬分叉过程中：第一个区块由澳本聪阵营svpool爆出，区块大小为51.385KB，区块高度为556761。BCH硬分叉连续爆出6个区块才会正式开始分叉。</p>

<p>  BCH硬分叉过程中：第二个区块由澳本聪阵营coingeek爆出，区块大小为8.24kB，区块高度为556762。</p>

<p>  BCH硬分叉过程中：第三个区块由澳本聪阵营SVPool爆出，区块大小为29.44kB，区块高度为556763。</p>

<p>  在BCH硬分叉过程中，ABC阵营开始反击，比特大陆旗下第一大矿池BTC.com已经获得部分客户同意，切换算力支援BCH ABC。ABC阵营Bitcoin.com矿池的BCH算力在分叉前24小时大增1593.09%，超过澳本聪阵营的Coingeek矿池，排名第一。</p>

<p>  BCH硬分叉过程中：第四个区块由吴忌寒阵营Bitcoin.com挖出。区块大小为57.11 kB，区块高度为556764。</p>

<p>  BCH硬分叉过程中：第五个区块由吴忌寒阵营ViaBTC爆出，区块大小为315.40 kB，区块高度为556765。</p>

<p>  BCH硬分叉过程中：第六个区块由澳本聪阵营SVPool爆出，区块大小为2597.76 kB，区块高度为556766。</p>

<p>  区块高度556766：正式分叉。算力大战正式开始。随后比特大陆阵营率先出两个块，并保持持续领先。”</p></blockquote>

<p>Bitcoin.com矿池临时集了4000P的算力，巅峰时Bitcoin ABC的算力达到了8500P，而Bitcoin SV始终没有超过5000P。分叉当晚，实力差距明显。</p>

<p><a href="https://cash.coin.dance/blocks/hashrate">https://cash.coin.dance/blocks/hashrate</a></p>

<p>但是Bitcoin SV目前没有放弃的意思，而且Bitcoin.com抽调的算力会慢慢撤回去，因为SV链没有重放保护，如果一直烧钱维护下去，现在还不能称胜负已分。</p>

<p>Bitcoin SV作为进攻方，按照现在1T算力0.1元/小时的价格计算，每天SV要烧掉$200W 维持这场战争。而且目前在BCH链上挖矿收益绝对小于BTC链，如此烧钱确实是土豪行径。如果CSW始终不加重放保护跟Bitcoin ABC死磕，确实是下决心了。但是如果怂了开始炒作Bitcoin SV，那就说明他也不过是个出来割韭菜的。</p>

<p>但是群众其实也不关心鹿死谁手，反正分叉明朗之前不动就可以了。看戏之余，不妨回顾一下中本聪白皮书中关于51%攻击的计算:</p>

<p>(参考第十一章:计算)</p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p>这个计算过程还是很有意思的，我们天天听各种媒体讲<code>51%攻击</code>，那么现实世界中，现在确实发生了两方争霸的情况，我们定义几个变量:</p>

<ul>
<li>P = 诚实节点制造下一个节点的概率</li>
<li>Q = 攻击者制造下一个节点的概率</li>
<li>Qz = 攻击者追上诚实节点z个区块的差距</li>
</ul>


<p>目前(2018-11-17 17:00 UTC+8)Bitcoin SV链算力4278PH，Bitcoin ABC链算力5677PH，Bitcoin SV落后7个Block。Bitcoin ABC为防守方，Bitcoin SV为进攻方，假如Bitcoin SV就这么死磕到底的话，算力保持不变的情况下，有多大机率能51%攻击呢？如果要提高攻击成功的概率，Bitcoin SV又需要多大的算力呢？</p>

<p>我们又要复习一下概率论里面的ABC了，搬来小方凳，数学课开始~~~~</p>

<h2>酒鬼漫步问题</h2>

<p>当一个喝大了的酒鬼在路上摇摇晃晃时，你是否会担心他还有能力避开一切障碍，成功找到家门而不是掉到某个下水沟里吗？</p>

<p>实际上，这正是非常有趣的酒鬼漫步问题，不妨让这个酒鬼的处境更夸张一些，设想他站在悬崖边，面前就是万丈深渊。如果他往后退一步远离悬崖的概率是 2/3 , 向前一步靠近悬崖的概率则是 1/3。那他摔下悬崖的概率是多少?</p>

<p>答案肯定不会是简单的 1/3。那不如先来看看酒鬼最初的几步会发生什么。下图是对这个酒鬼最初几步所有可能的轨迹的枚举。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg1.png" alt="img" /></p>

<p>从图中可以看到，达到<code>0</code> 即意味着跌落悬崖。所以在 <code>0</code> 的那些概率的和便是酒鬼前六步掉下悬崖的概率。这个图可以无限推演下去。</p>

<p>所以让我们把这个场景放到数轴上，换一种方式来看。如此一来醉鬼悬崖边漫步就相当于质点沿轴心运动这类问题了。酒鬼在这个数轴上随意地左右走动， 走到 x = 0 的位置意味着被吸收 ，也就是摔下了悬崖。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg2.png" alt="img" /></p>

<p>假设他向右一步的概率为 <code>p</code>，向左的概率为 <code>1－p</code>。当他在 <code>x = n（n&gt;0）</code> 的位置的时候，不是向右就是向左。记 <code>P（n）</code>为从 <code>x = n</code> 的位置出发，最后到达 <code>x = 0</code> 被吸收的概率。酒鬼一开始在 <code>x = 1</code> 的位置，我们要求的就是他到 0 的概率。</p>

<p>当酒鬼走完第一步后，他要么到了 <code>x = 0</code>（此事件发生的概率是 1－p），要么到了 <code>x = 2</code> 的位置（此事件发生的概率是 p），他再从 <code>x = 2</code> 出发最终走到 <code>x = 0</code> 被吸收的概率就是 <code>P（2）</code>。这时我们可以得到方程1:</p>

<p><code>
P(1) = 1 - p + p * P(2)
</code></p>

<p>而自 <code>x =2</code> 走出并最终到达 <code>x = 0</code> 的情况可以分解为两个阶段：先从 <code>x = 2</code> 到 <code>x = 1</code>（可以走任意步）, 然后从 <code>x = 1</code>到 <code>x = 0</code>（同样可以走任意步）。我们知道后一个的概率是 P（1）,那么前一个呢？其实是一样的，也是 P（1），它可以看作后一种情况的平移。又因为这两个事件相互独立，所以得到方程2:</p>

<p><code>
P(2) = P(1)²
</code></p>

<p>将方程2代入方程1，得到一个简单的一元二次方程:</p>

<p><code>
P(1) = 1 - p + p* P(1)²
</code></p>

<p>解得  <code>P(1) = 1</code>  或者   <code>P(1) = (1-p)／p</code></p>

<p>注意到这里 p 表示的是酒鬼每次向x轴正方向前进一步的概率，也就是他站在悬崖边上向后退的概率。我们不妨根据这个概率的取值情况来对酒鬼悬崖漫步这个问题做个总结。</p>

<p>当 p 等于 0 或 1 时，这显然就成了必然事件，酒鬼一定掉下悬崖或者一定能安全地离开。</p>

<p>但有趣的是，即便当 p 不是 0，在它小于等于 &frac12; 时，这个酒鬼一样难逃失足的厄运。</p>

<p>当 <code>p = 1/2</code>时， P(1) = 1</p>

<p>众所周知，一个事件发生的概率不会超过 1。所以从上面可以看出，当 <code>p ≤  1/2</code>时，也就是这个酒鬼每步选择向后退的概率不足一半时，不管他能离开悬崖有多远，最终都必将粉身碎骨。</p>

<p>而如果 p 在 （1/2 , 1） 这个区间里，这时候酒鬼摔落悬崖的概率实际上是一个关于 p 的连续函数。我们可以做出 P(1) 的图像如下</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg3.png" alt="img" /></p>

<p>现在让我们回答最初的问题，当酒鬼向后走的概率为2/3时，他摔下悬崖的概率为 &frac12; 。 很违背直觉的结果，保持一半清醒是不够的，最少要2/3的清醒。</p>

<h2>从酒鬼漫步到赌徒破产</h2>

<p>把酒鬼徘徊应用到赌博中会得到一个不可思议的结论。假设一个赌徒的赌金是 n，每次的下注金额是 1，而每盘赌局输赢概率各是 1／2。如果一直赌下去的话，赌徒输光的概率是多少呢？</p>

<p>由前面的分析可知，他破产的概率就是前面定义的 <code>P（n）</code>。 <code>P（n）</code>是 <code>P（1）</code> 的 n 次方，而 <code>P（1）</code> 在酒鬼等概率地向两个方向迈步的时候等于 1,所以 <code>P（n）＝1</code> ！这告诉我们，即使是公平赌局，你跟赌场玩，最后也一定会输光的！</p>

<p>这就是著名的赌徒破产问题（Gambler’s ruin）。</p>

<p>显然，赌徒的钱越多，输光需要的局数也越多。当赌徒的赌金是 n 时，我们记输光的概率为 p(n)。因为每次赌局有一半的可能赢，一半的可能输，赢的时候赌金变成 <code>n + 1</code>，输的时候变成 <code>n - 1</code>，所以 <code>p(n) = (p(n + 1) + p(n - 1))／2</code>。当 <code>n = 0</code> 的时候，即使不用赌，所有东西也都输光了，所以 <code>p(0) = 1</code>。</p>

<p>由此，p 可以看作一个满足下列递推关系的数列</p>

<p>```
p(0) = 1</p>

<p>p(n+1) = 2 * p(n) &ndash; p(n-1)，</p>

<p>```</p>

<p>也就是
<code>
p(n+1) - p(n) = p(n) - p(n-1)
</code></p>

<p>容易验证 <code>p(n) = n * p(1) - (n-1)</code> 正好符合上面的递推关系。</p>

<p>又因为<code>p(n) ≥ 0</code>，所以对于任意的 n，必定有 <code>p(1) ≥ 1 - 1／n</code>。因此 <code>p(1) = 1</code>。那么对于所有的 n，则有 <code>p(n) = 1</code>。这意味着，在无限次的赌博中，赌徒在某一次赌博中输光的概率是 1。</p>

<p>这个发现其实和经典的赌徒谬误异曲同工。上帝创造这个世界的一些规则真是意味深长啊，当你要赌的时候，50%的胜率是不够的，一定要有>50%的把握!</p>

<h2>从赌徒破产到算力攻击</h2>

<p>将上面两个例子映射到区块链算力争霸的过程中，发现有惊人的相似点。</p>

<h4>情况1</h4>

<p>当两条分叉从同一起点开始竞争时，就是一个酒鬼漫步问题；攻击者一方相当于不断的要逼近诚实者一方挖出的区块高度；</p>

<ul>
<li>诚实节点：block1&mdash;&mdash;&mdash;block2&mdash;&mdash;&mdash;block3&mdash;&mdash;&mdash;block4&mdash;&mdash;&mdash;</li>
<li>攻击节点：block1&mdash;&mdash;&mdash;block2A&mdash;&mdash;-block3A&mdash;&mdash;&ndash;</li>
</ul>


<p>攻击节点从block2开始攻击，尝试双花其中的交易，并挖出区块block2A。攻击节点挖出的链要比诚实节点挖出的链长——在本例中，它至少要挖到block5——才算攻击成功。我们把诚实节点的链长度减去攻击节点的链长度，得到的差记为n。诚实节点每挖出一个块则n+1；攻击节点每挖出一个块则n-1。我们把n放到数轴上<code>n-1  ←  n  → n+1</code>；攻击节点挖出一个块，相当于酒鬼向左移一步；诚实节点挖出一个块，相当于酒鬼向右移一步。设诚实节点领先n个块，如果攻击节点的算力达到或超过了全网的50%，那么它一定能把n减到0。而如果攻击者算力小于50%，则n越大，也就是确认数越多越安全。从这里你们也可以看出来，我们通常所说的51%攻击，是一个没看懂白皮书的人定下的名词。其实应该定名为50%攻击，攻击者不需要大于50%的算力就能成功。</p>

<p>在BCH的分叉战中，如果有一条链的算力一开始能达到算力的50%并保持下去，就可以杀死另外一条链；</p>

<h4>情况2</h4>

<p>但是随着链的延长，两边的算力便会拉开差距，挖出的快总是有多有少；算力战预测的初始条件变成了这样:</p>

<p>从交易被收录进区块的时候开始，诚实矿工出了z个块。攻击矿工在此期间出块数记为k，只要攻击者不广播别人就不知道，k可能等于0、1、2……直到无穷大。</p>

<ul>
<li>若k>z，攻击直接成功；若k&lt;=z，攻击者仍有可能追上，其成功的可能性即赌徒破产问题。因为攻击失败的情况有限，所以计算成功概率改为计算等价的<code>1-攻击失败的概率</code>。</li>
</ul>


<p>首先研究k，假定诚实矿工以均匀的速度出块，则k近似服从泊松分布：<code>P(k, λ)</code>；</p>

<p>就是“在一个指定长度的固定区间内有k个点（事件）”的概率。诚实矿工出z块的时间即“指定长度的固定区间”，攻击矿工出块次数k即“事件”，每种k出现的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg4.png" alt="img" /></p>

<p>其中λ是攻击矿工出块的期望，假设比特币的算力简化计算为:</p>

<p>速度 * 时间 = 工作量。</p>

<p>z是防御者的工作量，p是防御者的速度，z/p是防御者消耗的时间。防御者的时间=攻击者的时间。攻击者的速度=q；</p>

<p><code>攻击者的工作量期望 = 攻击者的速度 * 攻击者的时间 = q * z / p</code>。 即 <code>λ = z*q/p</code>。</p>

<p>根据赌徒破产问题，在落后了z-k个块之后仍旧能追上的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg5.png" alt="img" /></p>

<p>追不上的概率为:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg6.png" alt="img" /></p>

<p>每种k (k&lt;=z)出现的概率，乘以它追不上的概率，就是这个k的失败率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg7.png" alt="img" /></p>

<p>1-所有攻击失败情况的概率之和，就是攻击成功的概率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg8.png" alt="img" /></p>

<h2>总结</h2>

<p>当前Bitcoin SV算力占总算力的43%，落后7个block，取q=0.43, p=0.57, 计算成功率已然小于10%了。</p>

<p>那么，Bitcoin SV要把算力提高到多少，才能有50%的希望追上Bitcoin ABC呢？ 这是个复杂的问题啊，首先从分叉一晚的算力战来看，目前BitcoinABC可以调动的算力总量为8500P，所以Bitcoin SV目前一定要调动>8500P的算力，才能有翻盘的机会，至于需要多大才能把翻盘机会搞到50%，课后作业计算吧。</p>

<blockquote><p>PS:有个小漏洞，因为BCH的难度计算和BTC是不一样的，我不是很确定情况2的计算是否可以假设为泊松分布。</p></blockquote>

<p>当然，这是一个模拟，真实情况是，发生危机时，bitmain会不断的从BTC那边调集算力过来；这其实是BCH在吸血BTC的算力；</p>

<p>目前来看，BTC的算力有46EH，目前市场上所有的SHA256算力可能总共>60EH；如果算力占再升级，都可以看成是BCH链对BTC链的攻击了。而且只要Bitcoin SV一天不加重放保护，那么交易所就不太可能开放冲提币，这样BCH 链上的交易就会继续停滞，表面上来看是Bitcoin SV一方在烧钱，其实是BCH整条链都在烧钱。现在真正是考验信仰的时候，短期来看，输家会一无所有。赢家也未必能赚到什么。非常残酷的算力战。这真是难得一见，再过10年，真的像中本聪预测的那样，比特币广泛应用后，这种算力战出现的概率极小。某种意义上来说，这个热闹真好看啊:</p>

<p>每天投入$200W的豪赌!</p>

<p>这也进一步验证了，同一个POW算法，最多只能存在一条链，因为即使加了重放保护分叉，还是无法逃脱算力威胁；BCH是一条非常非常特殊的链，它是由bitmain大算力保证的小算力链；这么说可能有点绕口，可以看成BTC和BCH的战争会持续下去，我认为一定会有一方死亡！至于持续多长时间就不好说了，但是我认为这种平衡不可能无限保持下去，必然会发生黑天鹅事件。</p>

<p>另外，像DogCoin等SHA256 POW币，或者ETC之于ETH，也是同样的情况；我抱持一种观点：</p>

<blockquote><p>同样的POW算法，如果有大算力存在的情况下，一定归于一条链；
中间可能会多链并存很长时间，但总会发生黑天鹅事件将其它链清零</p></blockquote>

<h4>引用:</h4>

<p><a href="https://www.guokr.com/article/59575/?page=3">https://www.guokr.com/article/59575/?page=3</a></p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p><a href="https://www.zhihu.com/question/263764571">https://www.zhihu.com/question/263764571</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bicoin Cash分叉在即]]></title>
    <link href="https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji/"/>
    <updated>2018-11-15T15:08:32+08:00</updated>
    <id>https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji</id>
    <content type="html"><![CDATA[<p>Bitcoin Cash 将于UNIX时间1542300000 (即北京时间2018年11月16日00：40)发生硬分叉;</p>

<p>分叉两派是比特大陆为首支持的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc">Bitcoin ABC</a>实现，以及Craig Steven Wright为首的<a href="https://github.com/bitcoin-sv/bitcoin-sv">BItcoin SV</a>实现。</p>

<p>两派的恩恩怨怨政治斗争无心吐槽，咱也没有明确的倾向；但是作为码农咱要黑一黑；</p>

<!-- more -->


<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/2ab7775797a5a37ab311ab9a067771e5c1bfe22a">这里</a>是bitcoin SV 从Bitcoin ABC项目里面开始folk出来的修改；截至他们发布Bitcoin SV Beta1.0；最后提交的代码是<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/d9b12a23dbf0d2afc5f488fa077d762b302ba873">d9b12a23dbf0d2afc5f488fa077d762b302ba873</a></p>

<p>执行 <code>git diff 802629f d9b12a --stat</code> 瞄一眼:</p>

<p><code>
699 files changed, 11634 insertions(+), 197401 deletions(-)
</code></p>

<p>看起来改了不少，但是从头review一遍，他们从2018-08-22搞到现在，啥实质改动都没有，就开了几个操作码，改了几个测试；原本MAXBLOCKSIZE就变成可配置的了，他们不过是稍稍改了一下判断条件而已，改动最大的反而是README和release notes文件，最值得吐槽的就是这个提交：</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d">https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d</a></p>

<p>好吧，也不能无脑黑你，你还是修掉了一个比较重要的BUG的:</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86</a></p>

<p>凭良心说，Bitcoin ABC的开发比不上Bitcoin Core的活跃，但起码Bitcoin Core有什么更新，人家能及时Merge过来啊！</p>

<p>曾经，像Bitcoin Gold之流，改个POW算法就出来割韭菜了，大家还愤愤不平；</p>

<p>Litecoin和Dogcoin还是改了改币数上限和出块时间的，这是在早期，咱们也忍了~~</p>

<p>如今Bitcoin SV的代码库让我见识了什么叫任性！</p>

<p>如果不赞成升级，原版代码运行就是；现在哥们，你们倒是放开了操作码！但是操作码执行实现的部分好好测试过了吗，对应的测试在哪里？就两天时间开放出来不怕出BUG吗？</p>

<p>同样的一个<a href="https://bitcoincore.org/en/2018/09/20/notice/">重要BUG处理</a>:</p>

<p>Bitcoin ABC的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc/commit/7e20479893089b2b80f81cc2e7e5712a2d4158ba">重构+修正</a>，BitcoinSV的<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">修正</a>; 态度啊~~</p>

<p>我觉得数字货币这个场子没啥正义公理权威可言，就是中本聪重现人间，相信说话也没多大分量了；但是代码质量是没办法靠嘴炮提升的；长久来看，占据市场还是要靠产品质量啊。</p>

<p>但是不管怎么样，接下来的战争是一场明刀明枪的较量，没有重放保护，双方都是投入真金白银维护自己的立场，这比空气币收割韭菜实诚多了；</p>

<p>比特币这个社会实验已然十年，终于出现了白皮书所描写的第一场大规模算力战争，值得期待啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-3]]></title>
    <link href="https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3/"/>
    <updated>2018-11-07T19:59:04+08:00</updated>
    <id>https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3</id>
    <content type="html"><![CDATA[<p>通过前面两篇文章，我们认识到比特币的所有权是通过私钥来确定的。</p>

<p>那么我们就在此基础上研究比特币钱包的构成。广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，比特币钱包的核心就是对私钥的管理。</p>

<p>在比特币的历史发展中，钱包大致经过了三次进化:</p>

<ol>
<li><p>非确定性（随机）钱包</p></li>
<li><p>确定性（种子）钱包</p></li>
<li><p>分层确定性钱包（HD Wallets (BIP-32/BIP-44)）</p></li>
</ol>


<p>下面我们就好好说说钱包的历史发展轨迹</p>

<!-- more -->


<h2>非确定性（随机）钱包</h2>

<p>在比特币刚诞生时，Bitcoin Core客户端实现了第一个钱包功能，当时因为早期的用户并不多且都是专业人士，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。具体的实现细节就是:
比特币核心客户端预先生成100个随机私钥，每个密钥只使用一次；用完之后再生成100个；</p>

<p>这样做的缺点十分明显：</p>

<p>如果你生成很多私钥，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址重复使用将多个交易和地址关联在一起，这会减少隐私。</p>

<p>当比特币用户群逐渐扩大时，不少人因为随机生成的100个私钥用完后，没有备份老钱包，生成新的私钥后原先的钱包弃用，造成了未花费币的丢失。现在看看是个不可思议的幼稚的BUG，但是在比特币蛮荒时代，这种漫不经心的错误导致的丢币比比皆是。</p>

<h2>确定性（种子）钱包</h2>

<p>比特币私钥可以用任意方法生成，自然也可以通过一个随机短语进行多次hash得到不同的私钥。这种思路下，社区提出了确定性（种子）钱包的方案。</p>

<p>确定性，或者“种子”钱包包含通过使用HASH函数而可从公共的种子生成的私钥。种子是随机生成的数字。在确定性钱包中，种子足够恢复所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包导入或者导出。这就很容易允许使用者的私钥在钱包之间轻松转移。</p>

<p>比如，我们上一篇文章中用<code>satoshi</code>作为种子，得到SHA256(&lsquo;satoshi&rsquo;)作为私钥，完全可以继续用SHA256(SHA256(&lsquo;satoshi&rsquo;))&hellip;这样推导下去得出更多的私钥，同时，只需要记住<code>satoshi</code>这个种子，就可以方便的导入导出私钥。更进一步，可以加入password和更多的混淆短语，提高私钥生成的健壮性。</p>

<p>这种方案提出后，因为简单易行，多个轻钱包都做了自己的实现；虽然原理相似，但是他们之间并不通用，所以不同的钱包私钥导入导出还有一些不方便。社区就在此基础上继续探索，最终整理形成了BIP32、BIP39、BIP43，BIP44等规范，创造了我们今天通用的HD钱包。</p>

<h2>分层确定性钱包（Hierarchical Deterministic wallet&mdash;HD Wallet）</h2>

<p>首先用一张经典的图来描述HD钱包的私钥生成:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg1.jpg" alt="img" /></p>

<p>分层钱包说白了，就是将<code>seed-&gt;私钥</code>的过程变成了，<code>助记词-&gt;seed-&gt;一级私钥-&gt;二级私钥-&gt;三级私钥....</code>，即多层树状私钥生成的方案。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。HD钱包有两个主要的优势。</p>

<ol>
<li><p>树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。</p></li>
<li><p>它可以允许使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要存储私钥。</p></li>
</ol>


<p>再来一个在线工具用于验证:</p>

<p><a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a></p>

<p>最初的私钥seed来源于一个助记词（又称为Mnemonic Code），为了便于在不同的钱包中转移、导出和导入，社区对助记词的长度，范围，变换标准等等做了详尽的描述，最终形成了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>规范。这个规范由Trezor硬件钱包背后的公司提出，已经成为事实上的行业标准。</p>

<p>BIP-39定义了助记符码和种子的创建， 为了清楚起见，该过程分为两部分：</p>

<p>先是创建助记词，然后是从助记词到种子。下面我们从一个<code>ffffffffffffffffffffffffffffffff</code> 的128bits 熵开始，演示HD钱包是如何生成、管理私钥的。让我们一步一步解释。</p>

<h3>先看看创建助记词的部分</h3>

<h4>生成步骤</h4>

<ul>
<li><p>1、创建一个128到256位的随机序列（熵）。我们取<code>ffffffffffffffffffffffffffffffff</code>，称之为原始熵。</p></li>
<li><p>2、用SHA256 HASH原始熵，就可以创造一个随机序列的校验和。代码如下</p></li>
</ul>


<p><code>
from binascii import unhexlify
from hashlib import sha256
data = 'f' * 32
data_unhexlify = unhexlify(data)
h = hashlib.sha256(data_unhexlify)
checksum = bin(int(h, 16))[2:].zfill(256)[:len(data) * 8 // 32]
</code></p>

<p>得到checksum为<code>0101</code></p>

<ul>
<li>3、首先求得原始熵的二进制表示，然后将校验和添加到随机序列的末尾。代码如下:</li>
</ul>


<p><code>
from binascii import unhexlify, hexlify
data = 'f' * 32
data_unhexlify = unhexlify(data)
body = bin(int(hexlify(data), 16))[2:].zfill(len(data) * 8)
final_result = body + checksum
</code>
得出的结果为</p>

<p><code>
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101
</code></p>

<ul>
<li>4、将序列划分为包含11位的不同部分。</li>
</ul>


<p><code>
11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111110101
</code></p>

<ul>
<li>5、将每个包含11位部分的值作为下标索引，与一个已经预先定义2048个单词的字典做对应。BIP39中对应的字典文件可以参考这里:</li>
</ul>


<p><a href="https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist">https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist</a></p>

<p>以上二进制表示的下标值为:</p>

<p><code>
2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2037
</code></p>

<p>为什么单词数目是2048呢？ 其实seed可以有12-24个单词，所有的组合可能性为 2048<sup>12</sup> &mdash; 20418<sup>24</sup>；</p>

<p>还记得我们之前的文章吗？比特币公钥->地址的倒数第二步是RIPEMD160，他一共有2<sup>160</sup>可能性，上面seed的生成空间覆盖了RIPEMD160的生成空间。</p>

<ul>
<li>6、生成的有顺序的单词组，就是助记码(Mnemonic Code)。在咱们的例子中如果采用英文字典，对应的结果为:</li>
</ul>


<p><code>
zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong
</code></p>

<p>一张图展示熵如何生成助记词:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg2.jpg" alt="img" /></p>

<p>在上面这个例子中，我们选取了128Bits 原始熵，BIP39规范中，用户有128bits, 160bits, 192bits, 224bits, 256bits多个选择;下面的表格说明了熵数据的大小和助记词的长度之间的关系:</p>

<table>
<thead>
<tr>
<th>Entropy(bits) </th>
<th> Checksum(bits)</th>
<th> Entropy + checksum(bits) </th>
<th> Mnemonic length(words)</th>
</tr>
</thead>
<tbody>
<tr>
<td>128</td>
<td>4</td>
<td>132</td>
<td>12</td>
</tr>
<tr>
<td>160</td>
<td>5</td>
<td>165</td>
<td>15</td>
</tr>
<tr>
<td>192</td>
<td>6</td>
<td>198</td>
<td>18</td>
</tr>
<tr>
<td>224</td>
<td>7</td>
<td>231</td>
<td>21</td>
</tr>
<tr>
<td>256</td>
<td>8</td>
<td>264</td>
<td>24</td>
</tr>
</tbody>
</table>


<p>目前最流行的实现还是跟我们上面的例子一样，选取128bits->12words 的Mnemonic code生成。</p>

<h3>从助记词生成种子</h3>

<p>现在我们已经从<code>ffffffffffffffffffffffffffffffff</code>随机熵得到了助记码<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>，现在需要从助记码再生成种子。</p>

<h4>PBKDF2函数</h4>

<p>这里我们需要先介绍一个函数:PBKDF2(Password-Based Key Derivation Function)，它是一个用来导出密钥的函数，常用于生成加密的密码。</p>

<p>它的基本原理是通过一个伪随机函数（例如HMAC函数），把明文和一个salt值作为输入参数，然后重复进行运算，并最终产生密钥。</p>

<p>如果重复的次数足够大，破解的成本就会变得很高。而salt值的添加也会增加“彩虹表”攻击的难度。</p>

<p>嗯，我们还要稍微解释一下HMAC的意义:</p>

<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>

<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p>

<p>采用不同的hash算法时如何混入salt，可能大家八仙过海各显神通；后来为了统一化，有人提出了Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把salt混入计算过程中。</p>

<p>简而言之，HMAC提供了标准的在HASH过程中混入salt的方法。 HMAC方法适用于任意HASH函数。</p>

<p>而比特币私钥生成过程中采用的PBKDF2算法，大量使用HMAC-SHA512算法，使用2048次 HASH来延伸助记符和salt参数，产生一个512位的值作为其最终输出。</p>

<p>这个512位的值就是种子。</p>

<h4>利用PBKDF2从助记词得到种子步骤</h4>

<p>1、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符(<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>)。</p>

<p>2、PBKDF2密钥延伸函数的第二个参数是salt。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成 (<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code> + <code>test</code>)。</p>

<p>3、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和salt参数，产生一个512位的值作为其最终输出。 这个512bits的值就是种子:</p>

<p>```</p>

<blockquote><p>import hashlib
import hmac
from pbkdf2 import PBKDF2
from binascii import hexlify
PBKDF2_ROUNDS = 2048
mnemonic = &ldquo;zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong&rdquo;
passphrase = &ldquo;test&rdquo;
seed = PBKDF2(mnemonic, &lsquo;mnemonic&rsquo; + passphrase, iterations=PBKDF2_ROUNDS, macmodule=hmac, digestmodule=hashlib.sha512).read(64)
print(hexlify(seed))</p></blockquote>

<p>b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'
```</p>

<h3>从种子中创造HD钱包</h3>

<p>我们已经得到了一个512bits的种子，我们把这个种子称之为<code>根种子</code>(root seed)。这个根种子是下面一切私钥产生的源泉。</p>

<p>让我们再回忆一下最开始的一张示意图：所有的私钥是成树状结构的。树的每一层都有无限分支，然后每一个分支都可以派生出下一层，这个结构该如何从根种子来构建呢？</p>

<p>这是一个精妙的设计。下面我们还是采用步步为营的方法来演示一遍:</p>

<h4>私有子密钥的衍生</h4>

<ul>
<li>1、 首先我们需要安装一个BIP32 Python解析库<code>pip install bip32utils</code>:</li>
</ul>


<p><a href="https://pypi.org/project/bip32utils/">https://pypi.org/project/bip32utils/</a></p>

<ul>
<li>2、 根种子输入到HMAC-SHA512中，得到一个512bits的输出:</li>
</ul>


<p>```</p>

<blockquote><p>import binascii
import hmac
seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'
entropy = binascii.hexlify(seed)
I = hmac.new(b"Bitcoin seed", entropy, hashlib.sha512).digest()
```</p></blockquote>

<ul>
<li>3、 这个512bits的<code>I</code>可以分为两个部分，左边的256bits用作Master Private Key，右边的256bits用作Master Chain Code。Master Private Key又可以推导出Master Public Key。整个表示如下:</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg3.jpg" alt="img" /></p>

<ul>
<li><p>4、 这样我们从一个512bits的输出里面分成了两个变量: Master Pirvate Key以及Master  Chain Code；下面分别说说他们的作用</p>

<ul>
<li><p>Master Private Key: 又被称作母私钥，很明显的，它可以衍生出公钥以及地址；但是我们的需求是生成多个公私钥对，所以我们又引入了一个索引号(32 bits)的概念，这样，一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，因为另一半是为特定类型的推导而保留的，我们将在稍后讨论。</p></li>
<li><p>Master Chain Code: 有了Master Private Key，可以在这一层生成2<sup>31</sup>个子私钥，但是这样无法得到我们想要的分层结构；于是就需要Master Chain Code的帮忙。这样上面的步骤我们需要三个输入：将Master Chain Code和Master Private Key以及索引号作为HMAC-SHA512的输入，又可以得到一个512bits的输出，左边的256bts就是我们需要的子私钥；重复这个过程，我们就得到了一个分层的私钥结构</p></li>
</ul>
</li>
<li><p>5、让我们总结一下这个过程:</p>

<ul>
<li>每次HMAC-SHA512，都得到一对Master Private Key以及Master Chain Code，再加上引入一个索引号，我们就能在这一层生成2<sup>31</sup>个私钥</li>
<li>用这一层的Master Chain Code和Master Chain Code以及选取一个固定的索引号作为HMAC-SHA512的输入，又可以得到下一层的Master Private Key以及Master Chain Code，</li>
<li>重复这个递归的过程就可以构造一棵私钥树状结构</li>
<li>这个递归构造的函数我们称之为CKD（child key derivation)函数</li>
</ul>
</li>
<li><p>6、 CKD (子密钥衍生函数): 这个函数有三个输入</p>

<ul>
<li>一个母私钥(Master Private Key 256bits)</li>
<li>一个链码(Master Chain code 256 bits)</li>
<li>一个索引号 (32 bits)</li>
</ul>
</li>
</ul>


<p>这三个输入可以得到一个512bits的输出，在得到一个私钥的同时，也可以作为一棵树的根节点，从而衍生出无数个子密钥。</p>

<p>叶子节点衍生出的子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。</p>

<h4>扩展密钥</h4>

<p>正如我们之前看到的，CKD函数可以被用来创造密钥树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key）。术语“extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p>

<p>引入我们之前的例子，这里我们第一层的扩展密钥为:
```</p>

<blockquote><p>from bip32utils import BIP32Key
from binascii import hexlify
seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870d
root = BIP32Key.fromEntropy(hexlify(seed))
print(root.ExtendedKey())</p></blockquote>

<p>xprv9s21ZrQH143K35KaAEjp6RjB4LoeCR3prWBv6vmX7HuGnPFygragV39uDC24D3UZvMnWbhame5nykoXCcfy1Rbgg8uqSzmwoQgFEqt2bUNy
```</p>

<p>第一层的扩展私钥也被称之为<code>BIP32 Root Key</code>；</p>

<p>得到了一个扩展私钥，就代表得到了树状结构中某个层级的完全控制权，这个扩展密钥可以创造出子密钥并且作为根节点能创造出密钥树结构中的整个分支。分享扩展密钥就可以访问整个分支。</p>

<h4>公共子密钥推导</h4>

<p>再审视一下前面的CKD函数，第一个输入是<code>一个母私钥(Master Private Key 256bits)</code>，这让我们思考，如果不是输入私钥，而是输入公钥会发生什么呢？</p>

<p>通过母公钥衍生子私钥为分层确定性钱包带来的一个很有用的特点，就是可以不通过私钥而直接从公共母密钥派生出公共子密钥的能力。</p>

<p>因此，扩展密钥可以在HD钱包结构的分支中，被用来衍生所有的公钥（且只有公钥）。</p>

<p>这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。</p>

<p>这种方案的常见应用是安装扩展公钥电商的网络服务器上。网络服务器可以使用这个公钥衍生函数去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公钥。</p>

<p>这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包），与此同时扩展公钥可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如 Trezor）签署交易。下图阐述了扩展母公钥来衍生子公钥的传递机制。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg4.jpg" alt="img" /></p>

<h4>硬化子密钥的衍生</h4>

<p>从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。</p>

<p>为了应对这种风险，HD钱包使用一种叫做硬化衍生(hardened derivation）的替代衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥，如图所示。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg5.jpg" alt="img" /></p>

<p>当强化私钥衍生函数被使用时，得到的子私钥以及链码与使用一般衍生函数所得到的结果完全不同。得到的密钥“分支”可以被用来生产不易被攻击的扩展公钥，因为它所含的链码不能被用来开发或者暴露任何私钥。强化衍生也因此被用在上一层级，使用扩展公钥的密钥树中创造“间隙”。</p>

<p>简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层级的子密钥最好使用强化衍生。</p>

<h4>正常衍生和强化衍生的索引号码</h4>

<p>还记得我们前面说:一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，另一半是做什么的呢？</p>

<p>用在衍生函数中的索引号码是32位的整数。为了区分密钥是从正常衍生函数中衍生出来还是从强化衍生函数中产出，这个索引号被分为两个范围。索引号在0和2<sup>31</sup>–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2<sup>31</sup>和2<sup>32</sup>– 1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生。因此，索引号小于2<sup>31</sup>就意味着子密钥是常规的，而大于或者等于2<sup>31</sup>的子密钥就是强化型的。</p>

<p>为了让索引号码更容易被阅读和展示，强化子密钥的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0'。第二个强化密钥依序有了索 引号0x80000001，且被显示为1'，以此类推。当你看到HD钱包索引号i'，这就意味着 2<sup>31</sup>+i。</p>

<h3>HD钱包密钥识别符</h3>

<p>我们看到，一个树状的私钥组织，命名就成了一个问题，如何快速的表示<code>这是一个由第三层的第n个扩展子私钥衍生的主密钥</code>呢？</p>

<p>答案是类似于文件路径的命名规则。</p>

<p>每个级别之间用斜杠（/）字符来表示。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。</p>

<p>密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。</p>

<h4>HD钱包树状结构的导航</h4>

<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及子分支的可能性是无穷的。</p>

<p>两个比特币改进建议（BIPs）提供了这个复杂问题的解决办法——通过创建几个HD钱包树的提议标准。BIP-43提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP-43，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i'/是 为了表明那个被索引号“i”定义的特殊为目地。</p>

<p>在BIP-43标准下，为了延长的那个特殊规范，BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m/44'/。 BIP-44指定了包含5个预定义树状层级的结构：</p>

<p><code>
m / purpose' / coin_type' / account' / change / address_index
</code></p>

<p>第一层的purpose总是被设定为44'。</p>

<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44'/0'、Bitcoin Testnet is m/44'/1'，以及 Litecoin is m/44'/2', Ethereum 是 60'。</p>

<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性子账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m/44'/0'/0' 和 m/44'/0'/1'。每个账户都是它自己子树的根。</p>

<p>第四层级就是“change”。每一个HD钱包有两个子树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>

<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44'/0'/0'/0/2。</p>

<h2>几个BIP规范</h2>

<p>到这里为止，我们已经了解到了比特币HD钱包的绝大部分构造知识。如果能完全理解了上述内容，我们已经是<code>专家</code>了。让我们再简要回顾一下过程:</p>

<ol>
<li>生成一个随机序列作为原始熵</li>
<li>通过一系列变换操作得到了一个Mnemonic Code，这些操作需要大量的HASH过程，抵御了暴力碰撞。同时，生成的Mnemonic Code作为人类易读的助记词，可以轻易的抄写备份，导入导出，这个Mnemonic  Code代表着钱包的完全控制权</li>
<li>从Mnemonic得到了一个root seed，进而转化为 BIP32 Root Key，这可以构造一棵私钥树的根节点</li>
<li>从BIP32 Root Key开始，可以构造更多的公共子密钥，或者公共密钥；根据使用场景的不同，可以构造出完全控制的HD钱包，或者离线签署的只读钱包。</li>
</ol>


<p>这上面一系列的操作细节，被社区总结到了几个BIP规范当中。</p>

<h4>BIP32</h4>

<p>定义 Hierarchical Deterministic wallet (简称 &ldquo;HD Wallet&rdquo;)，是一个系统可以从单一个 seed 产生一树状结构储存多组 keypairs（私钥和公钥）。好处是可以方便的备份、转移到其他相容装置（因为都只需要 seed），以及分层的权限控制等。</p>

<h4>BIP39</h4>

<p>将 seed 用方便记忆和书写的单字表示。一般由 12 个单字组成，称为 mnemonic code(phrase)，中文称为助记词或助记码。例如：</p>

<p><code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code></p>

<h4>BIP43</h4>

<p>提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”</p>

<h4>BIP44</h4>

<p>基于 BIP32和BIP43 的定义，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支持多币种、多帐户等。各层定义如下：</p>

<p><code>
m / purpose' / coin_type' / account' / change / address_index
</code></p>

<p>其中的 purporse' 固定是 44'，代表使用 BIP44。而 coin_type' 用来表示不同币种，例如 Bitcoin 就是 0'，Ethereum 是 60'。</p>

<h4>BIP49，BIP84, BIP141</h4>

<p>加入隔离验证后的账户方案</p>

<h2>总结</h2>

<p>呼，漫长的一顿操作之后；我们终于拥有了一个完整的HD钱包，它有下面几个特性:</p>

<ol>
<li>只要记住seed，即12-24个单词，就可以在不同得系统中导入/导出这个钱包，并掌有完全的控制权，除了知道seed的人，世界上没有任何一个组织能操作这个账户</li>
<li>这个钱包拥有衍生无数个账户的能力，并通过树状层次组织</li>
<li>这棵树的任意一个节点都可以衍生出一棵子树，适用于大型组织的财务处理；比如国王拥有根seed的绝对掌控权，他分配了几个一级扩展私钥给总理大臣，而这几个一级扩展私钥又可以作为根节点衍生出二级扩展私钥分配给更多的人&hellip;..依次衍生下去无穷无尽，每一级的扩展私钥掌控者都拥有下级的资金调度权力，而同级别的私钥掌控者互不可见；</li>
<li>通过一个类似于文件系统命名的路径方式，扩展私钥的拥有者可以掌管任意一个子节点的账户，比如将来全家共享一个钱包，父母对子女的零花钱流水账有完全的掌控</li>
<li>可以构造出一个完全离线的只用来收款而不能付款的钱包账户，用于海量用户的电子商户系统</li>
<li>可以汇聚多个公私钥体系的电子货币；可以想象，未来所有的电子货币系统都聚集在一个钱包之中</li>
</ol>


<p>是不是非常神奇的感觉；呼呼，写到这里，我们已经将电子货币系统的钱包设计完全探究了一番；</p>

<p>其实这么长篇大论下来，我想要探讨的真正题目是比特币的交易构成，而不是什么钱包构造。</p>

<p>这个文章3年前就想写了，但是无穷尽的前置知识实在是让人望而却步；目前我们总算是对于比特币的账户系统有所了解了，反正我搞明白之后只能发出感叹：<code>设计的实在是太精巧了</code>；</p>

<p>但是比特币的交易构造之精巧，又胜过钱包十倍。走了这么远的路，还是那句话，还早得很呢。</p>

<p>那么，比特币的交易构造又是怎样的呢？我们下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-2]]></title>
    <link href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/"/>
    <updated>2018-11-02T13:31:50+08:00</updated>
    <id>https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2</id>
    <content type="html"><![CDATA[<p>好了，有了上一篇文章的基础，我们可以从零开始完全探究数字货币的地址生成、管理方法；下面的代码均使用Linux Bash shell和Python3来处理；另外需要安装<a href="https://github.com/richardkiss/pycoin">pycoin</a>这个库。</p>

<!-- more -->


<h2>生成私钥</h2>

<p>一般来说，私钥是个256bit的随机字符。为了演示方便，我们用一个人民大众喜闻乐见的地址生成为例子，私钥选取为 sha256(&ldquo;satoshi&rdquo;)</p>

<p>```</p>

<blockquote><p>printf &ldquo;satoshi&rdquo;|sha256sum
da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f  &ndash;
```</p></blockquote>

<p>得到私钥为<code>da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</code></p>

<h2>用WIF (Wallet Import Format)表示私钥</h2>

<p>我们看到私钥本质上是256bit的数字，他可以用二进制表示，也可以用16进制字符串表示，也可以用Base58Check来表示；为了在不同的钱包中方便的导入导出私钥，也为了方便二维码的生成，比特币采用了名为<code>WIF</code>的表示方法，下面列一个表格来说明:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Prefix </th>
<th> Description </th>
<th> Private key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raw </td>
<td> None </td>
<td> 32 bytes binary </td>
<td>  11011010001010000&hellip;&hellip;&hellip;..</td>
</tr>
<tr>
<td>HEX </td>
<td> None </td>
<td> 64 hexadecimal digits </td>
<td> da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</td>
</tr>
<tr>
<td>WIF </td>
<td> 5 </td>
<td> Base58Check encoding </td>
<td> 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</td>
</tr>
<tr>
<td>WIF-compressed </td>
<td> K or L </td>
<td> Base58Check encoding </td>
<td> L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6</td>
</tr>
</tbody>
</table>


<p>得到WIF 代码示例:</p>

<p>```
def gen_pubk_from_privk(private_key, compressed=True):</p>

<pre><code># private_key = codecs.encode(os.urandom(32), 'hex').decode()
secret_exponent = int('0x' + private_key, 0)
print('WIF: ' + encoding.secret_exponent_to_wif(secret_exponent, compressed=compressed))
public_pair = ecdsa.public_pair_for_secret_exponent(ecdsa.secp256k1.generator_secp256k1, secret_exponent)
print('public pair:', public_pair)
return public_pair
</code></pre>

<p>```</p>

<p>WIF格式分为非压缩和压缩格式，压缩私钥其实是对非压缩私钥后缀追加了01之后的Base58Check编码，具体生成过程为:</p>

<ul>
<li>压缩私钥: 私钥前缀80+私钥本体+压缩私钥后缀01 + 校验</li>
<li>非压缩私钥: 私钥前缀80+私钥本体+校验</li>
</ul>


<p>和字面意思相相反的是，压缩私钥比非压缩私钥还长。为啥这么折腾呢？这个我们在公钥生成的部分说明。</p>

<h2>生成公钥</h2>

<p>我们之前的文章介绍了，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头。</p>

<p>下面是由前文中的私钥所生成的公钥，其坐标x和y如下:</p>

<ul>
<li><p>public pair:</p>

<ul>
<li>x = 89077434373547985693783396961781741114890330080946587550950125758215996319671</li>
<li>y = 114001858762817543140175961139571810325965930451644331549950109688554928624341</li>
</ul>
</li>
</ul>


<p>加上前缀04，完整的公钥为:</p>

<p><code>
K = 0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341
</code></p>

<h4>为什么要区分压缩格式和非压缩格式</h4>

<p>这是一个历史问题，初版比特币运行时，中本聪没有考虑到一个问题:</p>

<p>一个公钥是一个椭圆曲线上的点(x,y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程 <code>y^2 % p = (x^3 + 7) % p</code>得到y坐 标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256 bits。如果每笔交易所 需要的字节数减少了近一半，随着时间推移，节省的数据传输和存储空间还是很客观的。</p>

<p>所以后来开发团队推出了压缩公钥，为了跟之前老版本的非压缩公钥相区分，就加上了02和03作为前缀。</p>

<p>那么为什么要加两个前缀(02,03)呢？</p>

<p>因为椭圆曲线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在 x坐标轴的上面或者下面。椭圆曲线图中曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</p>

<p>总结出来，一个公钥的表现形式可以又两种:</p>

<ol>
<li>04开头的非压缩公钥: (130位十六进制 2+64+64)</li>
<li>02或03开头的压缩公钥:（66位十六进制 2+64）</li>
</ol>


<p>这样继续推导，两种表现形式可以推导出两个地址，也就是手握一个私钥，可以推导出两个合法的比特币地址。</p>

<p>这样又间接解释了为什么会有压缩私钥和非压缩私钥两种表现：</p>

<ul>
<li>当中本聪实现第一版比特币客户端钱包的时候，没有考虑到公钥可以压缩，所以采用了最原始直接的办法存储公钥和私钥</li>
<li>后来人们发现公钥可以简化存储来节省一部分空间，于是加入了压缩公钥格式，为了跟之前的非压缩公钥区分，引入了前缀</li>
<li>同样，使用压缩公钥格式的钱包导入导出私钥时，为了区分，也必须为私钥标明它对应的公钥是否压缩格式，所以也为私钥的表示引入了后缀</li>
<li>压缩私钥的意思是，由这个私钥导出的公钥表示方法是压缩的，私钥本身还需要引入一个01作为后缀，长度反而多了一个字节</li>
</ul>


<h2>从公钥到比特币地址</h2>

<p>得出公钥之后，地址的生成还要经过三重变换， 公钥为K，变换过程如下:</p>

<ol>
<li>首先计算 A = SHA256(K)</li>
<li>计算 B = RIPEMD160(A)</li>
<li>Addr = Base58Check（prefix + B）</li>
</ol>


<h4>为什么要有RIPEMD160(SHA256(K)) 的过程</h4>

<p>因为中本聪设计之初充分考虑到了安全性方面的问题，一笔交易广播后，并不是直接把公钥K暴漏在外，如果你不花费这个UTXO，暴漏的只有<code>RIPEMD160(SHA256(K))</code>这个值。假如将来有一种计算机的计算能力得到指数级别的提升，有一定可能暴力破解椭圆曲线算法。解决方案就是引入<code>RIPEMD160(SHA256(K))</code>的过程，这样要破解一个未花费的UTXO，需要逆向RIPEMD160，SHA256，secp256k1三种不同的算法，即使将来量子计算发展到实用阶段，也很难做到吧。</p>

<p>但是根据比特币交易的设计，一个地址重复使用就会暴露公钥K，所以我们推荐的安全做法就是一笔UTXO花费后就更换地址。这也是所有安全钱包的默认实现方法。</p>

<p>这个设计的唯一的瑕疵，在我看来，就是RIPEMD160将公钥的碰撞空间减小了，由 2<sup>256</sup> 减小到了 2<sup>160</sup>，当然 2<sup>160</sup> 的碰撞空间对于现有计算能力也是个天文数字，我想中本聪没有选择SHA3等算法的原因，应该是充分考虑了散列算法的复杂度和差异度，最后选择的RIPEMD160吧。</p>

<h4>Base58Check编码</h4>

<p>WIF格式和比特币地址都是用Base58Check编码表示的，Base58是Base64基础上发展来的，它具有以下功能:</p>

<ul>
<li>一个任意大小的payload。</li>
<li>一组58个字母数字符号，由易于区分的大小写字母组成(不使用0OIl)</li>
<li>一个字节的版本/应用程序信息。比特币地址为这个字节使用0x00</li>
<li>四个字节（32位）基于SHA256的错误检查代码。此代码可用于自动检测并可能纠正排版错误。</li>
<li>保留数据中零开头的额外步骤</li>
</ul>


<p>创建过程:</p>

<ol>
<li><p>获取版本字节和payload字节，并将它们连接在一起（按字节顺序）。</p></li>
<li><p>取SHA256(SHA256(步骤1的结果))的前四个字节</p></li>
<li><p>将步骤1的结果和步骤2的结果连在一起（按字节顺序）。</p></li>
<li><p>处理步骤3的结果 &ndash; 一系列字节 &ndash; 作为单个大端序号，使用正常的数学步骤（bignumber division）和下面描述的base-58字母表转换为base-58。结果应该被标准化为没有任何前导零（字符'1'）的base-58。</p></li>
<li><p>在base58中，值为零的前导字符'1'被保留用于表示整个前导零字节，就像它处于前导位置时一样，没有值作为base-58符号。必要时可以有一个或多个前导'1'来表示一个或多个前导零字节。计算步骤3结果中的前导零字节数（对于旧的比特币地址，至少有一个用于版本/应用程序字节;对于新地址，将永远不会有）。每个前导零字节在最终结果中应由其自己的字符'1'表示。</p></li>
<li><p>将步骤5中的1与步骤4 的结果连接起来。这是Base58Check的结果。</p></li>
</ol>


<p>最后综合起来，从公钥K到比特币地址完整的示意图如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181102/bg1.jpg" alt="img" /></p>

<p><code>satoshi</code>作为seed计算出私钥，进而计算出公钥K之后，最终进一步生成地址</p>

<p>```
def genaddress_from_pubk(compressed=True)</p>

<pre><code># 首先计算 RIPEMD160(SHA256(K))
ripemd160 = encoding.public_pair_to_hash160_sec(public_pair, compressed=compressed)
# 再用Base58Check计算最终地址
addr = encoding.hash160_sec_to_bitcoin_address(ripemd160)
return addr
</code></pre>

<p>```</p>

<p>因为公钥存在压缩形式和非压缩两种形式，所以完整的结果是:</p>

<p>```
seed: satoshi
sha256 private key: da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</p>

<p>compress address
WIF: L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
hash160: 0a8ba9e453383d4561cbcdda36e5789c2870dd41
Bitcoin address:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</p>

<p>uncompress address
WIF: 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
hash160: 650d0497e014e60d4680fce6997d405de264f042
Bitcoin address:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE
```</p>

<p><code>satoshi</code>作为seed生成了两个地址:</p>

<p><code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>，这都是两个正在使用的地址哦，到今天为止还有热心人源源不断的为<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>转账一些零钱作为中本聪的纪念。你可以将WIF导入钱包，然后运行一个全节点，在bitcoin.conf文件中加入<code>walletnotify</code>这个选项，关联一个脚本，当收到比特币时就自动转账到自己的地址，参与这两个地址的抽奖哦。</p>

<h2>一些Base58Check版本前缀和编码后的结果</h2>

<p>看到这里，我们发现Base58Check 编码的过程中，最后一步会引入一个前缀。而在比特币中，除了WIF私钥和地址，大多数需要向用户展示的数据都使用Base58Check编码，理所当然的，引入了不同的前缀来区分不同的信息，下面展示了一些版本前缀和他们对应的Base58格式:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Version prefix </th>
<th> Base58 result prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Address </td>
<td> 0x00 </td>
<td> 1</td>
</tr>
<tr>
<td>Pay to Script Hash Address </td>
<td> 0x05 </td>
<td> 3</td>
</tr>
<tr>
<td>Bitcoin Testnet Address </td>
<td> 0x5F </td>
<td> m or n</td>
</tr>
<tr>
<td>Private Key WIF </td>
<td> 0x80 </td>
<td> 5, K or L</td>
</tr>
<tr>
<td>BIP-38 Encrypted Private Key </td>
<td> 0x0142 </td>
<td> 6P</td>
</tr>
<tr>
<td>BIP-32 Encrypted public Key </td>
<td> 0x0488B21E </td>
<td> xpub</td>
</tr>
</tbody>
</table>


<p>除了我们已经提到的WIF和Bitcoin Address，我们还发现了奇怪的BIP-38和BIP-32，这个需要到解释比特币原始交易编码的时候来讲解。</p>

<h2>Brain Wallet</h2>

<p>好啦，我们上面已经完整的再现了由一个 seed单词 <code>satoshi</code>，导出两个比特币地址的过程；你只要记好<code>satoshi</code>这个单词，就可以在世界上的任何地方，任何时间，掌管发送给<code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>这两个地址的比特币了。</p>

<p>你不需要银行账号，不需要密保卡，只需要有个可以联网的地方，就能秘密发送交易啦。将来有了免费的卫星网络的话，我想你都不用登陆互联网，可能在家里屋顶上架个锅，淘宝买些零件天线DIY一个设备，要转帐的时候，只要输入<code>satoshi</code>就可以秘密完成数亿美元的汇款，而且丝毫不用担心这个账户被政府查封，世界上也只有你一个人能动用这个账户，真是完美的洗钱逃汇工具！也难怪有人说，比特币是人类历史上第一次用技术手段保证了财产的完全私有权。</p>

<p>这个<code>satoshi</code>的seed，就是所谓脑钱包的口令，相对于天书一般的256 bits私钥无疑更好记忆，早期这样的工具非常受欢迎，到现在为止你也可以到这个<a href="https://brainwalletx.github.io/">在线工具</a> 去重复我们以上推导的所有过程。</p>

<p>但是这个方法有个致命的弱点，他的安全性完全取决于seed这个单词的复杂度，像<code>satoshi</code>这样的seed，就像<code>123456</code>的密码一样，不用说大家都知道安全度为0啊。</p>

<p>而且你自以为选取生日啊、姓名缩写啊、恋人海誓山盟的话语啊，这些东西作为seed，其实也是非常脆弱的。总有人孜孜不倦的遍历所有可能的seed。这在后期导致了非常多的hack事件。</p>

<p>截至2018-10，我检索区块链，统计公开的比特币地址已经超过了3亿个，如果有万分之一的地址是由脑钱包生成的话，不安全的地址也超过了3w个，所以后来脑钱包这种方式就不被推荐了。</p>

<p>下面可以列举一些已经公开的seed，这都是我用一些公开语料库随意碰撞出来的，你就知道这种方法的危险性啦：</p>

<p><code>
FINAL_CRACK_ADDRESS: hash160:sha256:seed:address:wif-priv
FINAL_CRACK_ADDRESS:0a8ba9e453383d4561cbcdda36e5789c2870dd41:c:sha256:satoshi:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V:L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
FINAL_CRACK_ADDRESS:650d0497e014e60d4680fce6997d405de264f042:u:sha256:satoshi:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE:5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
FINAL_CRACK_ADDRESS:c71e3a0989754d4ffae45a1c6ef8e348539cd83c:u:sha256:satoshinakamoto:1K9qgN3H2wB2v3LwJEBDbRRJ3znHXEQP4Y:5HqE1vZMMLc7jZRF5wZb79QexyCguNeNdaHLdKTGndvLBrCHD31
FINAL_CRACK_ADDRESS:ec42ad7fd54f931274b83f6137379206e458b106:u:sha256:1satoshi:1NYEM85RpgkSofLqDfwjb21o3MD4ibSo49:5JSGPQ2Jw1P5cVi2L8LeuWnMF5H8rLGrPPgVM2XE1cahG1BQDzY
FINAL_CRACK_ADDRESS:fd8d22e02b3a41bc38f69516c43f7ebd6268e16b:u:sha256:satoshi nakamoto:1Q7f2rL2irjpvsKVys5W2cmKJYss82rNCy:5K7EWwEuJu9wPi4q7HmWQ7xgv8GxZ2KqkFbjYMGvTCXmY22oCbr
FINAL_CRACK_ADDRESS:0000d85a71f305a1c907cdc7437c43b2eecc35e5:u:sha256:CHARINA143:11121ioKu4MCB1LLzPF98AVtzFsEg7UYKm:5JhayTrDhzDHqCg2v16Y2gZWi4kWF6BFoZR3MyaaxWtyKHzKJ8d
FINAL_CRACK_ADDRESS:0002439f087ffefb973c5b9bbd52f509984d3cbe:c:sha256:purple99:113iKJcZeRxEYRVcWNgVxmjodPAisDZ45:KxFLoyseSyVtKGXQNkYBajT8EqviQSuH64Y6GE1g6KXuvcFaSrqc
FINAL_CRACK_ADDRESS:00027a0ef2b9295011b10b089c8caf2e69f6b6f7:u:sha256:bridesmaid:113y6FCRm2WHh5Aru2R7ot37wkNDtxqf3:5JsYc8oXiHBJm9rzRPJHaCSYBBx7KCTx5L81rqRMZBArsdZTsan
FINAL_CRACK_ADDRESS:00030fa763130b5310afe68b12204009e60e935c:u:sha256:masturbating:114fh9qiRhubJJDV5rCthFxmGyYeLQ2B6:5J8TgeF9jU3BPRrsCD75Ks4a6aWxgzLKENDSbsLufDTWq7evCQa
FINAL_CRACK_ADDRESS:0005736b486f87e5823909a89eb48dda185d3956:u:sha256:nitro:117XjTn3UdBNjVo3KsB17WRFDDmcW2pPa:5JkUWsPzNEZEvMFwWQjoXCeem5LL6LDcC7K6H1LWiwXFAA9LFo1
FINAL_CRACK_ADDRESS:00080beae5c3a433fbae8ff0b69e705ac3ce5464:u:sha256:resultantly:11Ae5tbiSZ7QJWh4okWJhDKuPfAvk3a13:5KftjbtsSmhy5Y42AYpfEAm4U4vQKP9VhjbS6xtFqBDhUfAGaFj
FINAL_CRACK_ADDRESS:00083c18c738e883ebc1b5ca270569ee8f9f790e:u:sha256:suggestively:11AsAKWdMZj5ScSYRoAQ8xG4J7Y6s7cW9:5JvrusiSgSmCTV7x7f5vgdWUMLjwk153j9UXmNHvRAJ8m7rtsJD
FINAL_CRACK_ADDRESS:000e4d1774a3fc0251e9e6caf0a8617639e80093:u:sha256:dezoxiribonukleinsav:11J8fK9qhgxdQ96ZvvXExkfFvQSPQiPKN:5KSkRxaAbk94wzzzynDNj2bzRFmJZXCrhtYj3iGU9JjUxnRXTYM
FINAL_CRACK_ADDRESS:00135d1c8f99cc657ad1f246bc5051ad03f95d32:u:sha256:Mussolini:11QCR3sk9r4jeyMqCKGEYabGTfjzhgGdZ:5K2x6UanMSevNX7f19oB4to46C3zXoGTUBGVqv8WNtCRwJNGBGC
FINAL_CRACK_ADDRESS:001ed6fae0af0b37126004029defcc4521b300dd:u:sha256:meagerness:11dwnVzCyGoMZcGDndQteWgR9b7FKsJMu:5JKVJhbZWXmHxj2MuttZCDaFk7TC9KBVYjbPRjztP63mmAUV6Vm
FINAL_CRACK_ADDRESS:002607c11a2311825a087f37c95d7816e0491a9d:u:sha256:vertebrate:11nZPfxYPeDm4d4fd93BaFa1BezFRTP6F:5HsBbgzEXZEaeLRCZHs66ho2ekpFEqeAJyyBPe8YyMkCqCHWv6j
...
</code></p>

<p>不过我们现在已经掌握到了比特币地址的生成原理，所以如何提高安全性就不用我再啰嗦了，相信你心中已有答案。</p>

<h2>那些山寨币们</h2>

<p>比特币项目是2009-01-03正式开始运行的，之后简单的复制一下比特币的代码，稍作修改就推出的山寨币们数不胜数；这些山寨币第一个要修改的，就是地址格式，以免和比特币地址混淆；</p>

<p>怎么修改呢？注意到前面Base58Check Encode的最后一步了吗？那个时候我们需要引入一个前缀作为地址的区分；得益于比特币这种前瞻性的设计，山寨币们只要改动一下这个前缀就可以了，下面列举一下我所知道的山寨币的实现：</p>

<p>引用自:
<a href="https://github.com/walletgeneratornet/WalletGenerator.net">https://github.com/walletgeneratornet/WalletGenerator.net</a></p>

<p>```
name, networkVersion, privateKeyPrefix, WIF_Start, CWIF_Start
&ldquo;2GIVE&rdquo;,               0x27, 0xa7, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;42coin&rdquo;,              0x08, 0x88, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;Acoin&rdquo;,               0x17, 0xe6, &ldquo;8&rdquo;,    &ldquo;b&rdquo;
&ldquo;AGAcoin&rdquo;,             0x53, 0xd3, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;Alphacoin&rdquo;,           0x52, 0xd2, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;Alqo&rdquo;,                0x17, 0xc1, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Animecoin&rdquo;,           0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Anoncoin&rdquo;,            0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Apexcoin&rdquo;,            0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Auroracoin&rdquo;,          0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Aquariuscoin&rdquo;,        0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Axe&rdquo;,                 0x4B, 0xCB, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;BBQcoin&rdquo;,             0x55, 0xd5, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Biblepay&rdquo;,            0x19, 0xb6, &ldquo;7&rdquo;,    &ldquo;[TU]&rdquo;
&ldquo;Bitcoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;BitcoinCash&rdquo;,         0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;BitcoinDark&rdquo;,         0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Bitcore&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;BitcoinGold&rdquo;,         0x26, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Bitconnect&rdquo;,          0x12, 0x92, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Birdcoin&rdquo;,            0x2f, 0xaf, &ldquo;6&rdquo;,    &ldquo;[ST]&rdquo;
&ldquo;BitSynq&rdquo;,             0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;BitZeny&rdquo;,             0x51, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Blackcoin&rdquo;,           0x19, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;BlackJack&rdquo;,           0x15, 0x95, &ldquo;[56]&rdquo;, &ldquo;P&rdquo;
&ldquo;BlockNet&rdquo;,            0x1a, 0x9a, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;BolivarCoin&rdquo;,         0x55, 0xd5, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;BoxyCoin&rdquo;,            0x4b, 0xcb, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;BunnyCoin&rdquo;,           0x1a, 0x9a, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Cagecoin&rdquo;,            0x1f, 0x9f, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CampusCoin&rdquo;,          0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CanadaeCoin&rdquo;,         0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CannabisCoin&rdquo;,        0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Capricoin&rdquo;,           0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CassubianDetk&rdquo;,       0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CashCoin&rdquo;,            0x22, 0xa2, &ldquo;6&rdquo;,    &ldquo;[QR]&rdquo;
&ldquo;Catcoin&rdquo;,             0x15, 0x95, &ldquo;[56]&rdquo;, &ldquo;P&rdquo;
&ldquo;ChainCoin&rdquo;,           0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;ColossusCoinXT&rdquo;,      0x1e, 0xd4, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Condensate&rdquo;,          0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Copico&rdquo;,              0x1c, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;CopperCoin&rdquo;,          0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Corgicoin&rdquo;,           0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;CryptoBullion&rdquo;,       0x0b, 0x8b, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;CryptoClub&rdquo;,          0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Cryptoescudo&rdquo;,        0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Cryptonite&rdquo;,          0x1c, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;CryptoWisdomCoin&rdquo;,    0x49, 0x87, &ldquo;5&rdquo;,    &ldquo;[LM]&rdquo;
&ldquo;C2coin&rdquo;,              0x1c, 0x9c, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Dash&rdquo;,                0x4c, 0xcc, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;DeafDollars&rdquo;,         0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;DeepOnion&rdquo;,           0x1f, 0x9f, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Deutsche eMark&rdquo;,      0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;Devcoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;DigiByte&rdquo;,            0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Digitalcoin&rdquo;,         0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Dimecoin&rdquo;,            0x0f, 0x8f, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;DNotes&rdquo;,              0x1f, 0x9f, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Dogecoin&rdquo;,            0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;DogecoinDark&rdquo;,        0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;eGulden&rdquo;,             0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;eKrona&rdquo;,              0x2d, 0xad, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;ELECTRA&rdquo;,             0x21, 0xa1, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Ember&rdquo;,               0x5c, 0x32, &ldquo;2&rdquo;,    &ldquo;8&rdquo;
&ldquo;Emerald&rdquo;,             0x22, 0xa2, &ldquo;6&rdquo;,    &ldquo;[QR]&rdquo;
&ldquo;Emercoin&rdquo;,            0x21, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;EnergyCoin&rdquo;,          0x5c, 0xdc, &ldquo;8&rdquo;,    &ldquo;Z&rdquo;
&ldquo;Espers&rdquo;,              0x21, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Fastcoin&rdquo;,            0x60, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Feathercoin&rdquo;,         0x0e, 0x8e, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Fedoracoin&rdquo;,          0x21, 0x80, &ldquo;5&rdquo;,    &ldquo;[KL]&rdquo;
&ldquo;Fibre&rdquo;,               0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Florincoin&rdquo;,          0x23, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Flurbo&rdquo;,              0x23, 0x30, &ldquo;6&rdquo;,    &ldquo;8&rdquo;
&ldquo;Fluttercoin&rdquo;,         0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;FrazCoin&rdquo;,            0x23, 0xA3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Freicoin&rdquo;,            0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;FUDcoin&rdquo;,             0x23, 0xa3, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Fuelcoin&rdquo;,            0x24, 0x80, &ldquo;5&rdquo;,    &ldquo;[KL]&rdquo;
&ldquo;Fujicoin&rdquo;,            0x24, 0xa4, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;GabenCoin&rdquo;,           0x10, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;Garlicoin&rdquo;,           0x26, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;GlobalBoost&rdquo;,         0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Goodcoin&rdquo;,            0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;GridcoinResearch&rdquo;,    0x3e, 0xbe, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Gulden&rdquo;,              0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Guncoin&rdquo;,             0x27, 0xa7, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;HamRadioCoin&rdquo;,        0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;LK&rdquo;
&ldquo;HFRcoin&rdquo;,             0x10, 0x90, &ldquo;5&rdquo;,    &ldquo;N&rdquo;
&ldquo;HOdlcoin&rdquo;,            0x28, 0xa8, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;HTMLCoin&rdquo;,            0x29, 0xa9, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;HyperStake&rdquo;,          0x75, 0xf5, &ldquo;9&rdquo;,    &ldquo;d&rdquo;
&ldquo;ImperiumCoin&rdquo;,        0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;IncaKoin&rdquo;,            0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;IncognitoCoin&rdquo;,       0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;LK&rdquo;
&ldquo;Influxcoin&rdquo;,          0x66, 0xe6, &ldquo;8&rdquo;,    &ldquo;b&rdquo;
&ldquo;Innox&rdquo;,               0x4b, 0xcb, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;IridiumCoin&rdquo;,         0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;iCash&rdquo;,               0x66, 0xcc, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;iXcoin&rdquo;,              0x8a, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Judgecoin&rdquo;,           0x2b, 0xab, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;Jumbucks&rdquo;,            0x2b, 0xab, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;KHcoin&rdquo;,              0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;KittehCoin&rdquo;,          0x2d, 0xad, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;Lanacoin&rdquo;,            0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Latium&rdquo;,              0x17, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;LBRY Credits&rdquo;,        0x55, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Litecoin&rdquo;,            0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;LiteDoge&rdquo;,            0x5a, 0xab, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;LoMoCoin&rdquo;,            0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MadbyteCoin&rdquo;,         0x32, 0x6e, &ldquo;4&rdquo;,    &ldquo;H&rdquo;
&ldquo;MagicInternetMoney&rdquo;,  0x30, 0xb0, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Magicoin&rdquo;,            0x14, 0x94, &ldquo;5&rdquo;,    &ldquo;[NP]&rdquo;
&ldquo;Marscoin&rdquo;,            0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MarteXcoin&rdquo;,          0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MasterDoge&rdquo;,          0x33, 0x8b, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;Mazacoin&rdquo;,            0x32, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Megacoin&rdquo;,            0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MintCoin&rdquo;,            0x33, 0xb3, &ldquo;[67]&rdquo;, &ldquo;T&rdquo;
&ldquo;MobiusCoin&rdquo;,          0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;MonetaryUnit&rdquo;,        0x10, 0x7e, &ldquo;5&rdquo;,    &ldquo;K&rdquo;
&ldquo;Monocle&rdquo;,             0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;MoonCoin&rdquo;,            0x03, 0x83, &ldquo;5&rdquo;,    &ldquo;L&rdquo;
&ldquo;Myriadcoin&rdquo;,          0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;NameCoin&rdquo;,            0x34, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Navcoin&rdquo;,             0x35, 0x96, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;NeedleCoin&rdquo;,          0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;NEETCOIN&rdquo;,            0x35, 0xb5, &ldquo;7&rdquo;,    &ldquo;T&rdquo;
&ldquo;NYC&rdquo;,                 0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Neoscoin&rdquo;,            0x35, 0xb1, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Nevacoin&rdquo;,            0x35, 0xb1, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;Novacoin&rdquo;,            0x08, 0x88, &ldquo;5&rdquo;,    &ldquo;M&rdquo;
&ldquo;Nubits&rdquo;,              0x19, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Nyancoin&rdquo;,            0x2d, 0xad, &ldquo;6&rdquo;,    &ldquo;S&rdquo;
&ldquo;Ocupy&rdquo;,               0x73, 0xf3, &ldquo;9&rdquo;,    &ldquo;[cd]&rdquo;
&ldquo;Omnicoin&rdquo;,            0x73, 0xf3, &ldquo;9&rdquo;,    &ldquo;[cd]&rdquo;
&ldquo;Onyxcoin&rdquo;,            0x73, 0xf3, &ldquo;9&rdquo;,    &ldquo;[cd]&rdquo;
&ldquo;PacCoin&rdquo;,             0x18, 0x98, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Particl&rdquo;,             0x38, 0x6c, &ldquo;4&rdquo;,    &ldquo;[HG]&rdquo;
&ldquo;Paycoin&rdquo;,             0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Pandacoin&rdquo;,           0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;ParkByte&rdquo;,            0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Peercoin&rdquo;,            0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Pesetacoin&rdquo;,          0x2f, 0xaf, &ldquo;6&rdquo;,    &ldquo;[ST]&rdquo;
&ldquo;PHCoin&rdquo;,              0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;PhoenixCoin&rdquo;,         0x38, 0xb8, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;PiggyCoin&rdquo;,           0x76, 0xf6, &ldquo;9&rdquo;,    &ldquo;d&rdquo;
&ldquo;Pinkcoin&rdquo;,            0x3,  0x83, &ldquo;[RQP]&rdquo;,&ldquo;L&rdquo;
&ldquo;PIVX&rdquo;,                0x1e, 0xd4, &ldquo;8&rdquo;,    &ldquo;Y&rdquo;
&ldquo;Peercoin&rdquo;,            0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Potcoin&rdquo;,             0x37, 0xb7, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Primecoin&rdquo;,           0x17, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;ProsperCoinClassic&rdquo;,  0x3a, 0xba, &ldquo;7&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Quark&rdquo;,               0x3a, 0xba, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Qubitcoin&rdquo;,           0x26, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Reddcoin&rdquo;,            0x3d, 0xbd, &ldquo;7&rdquo;,    &ldquo;[UV]&rdquo;
&ldquo;Riecoin&rdquo;,             0x3c, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Rimbit&rdquo;,              0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;ROIcoin&rdquo;,             0x3c, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Rubycoin&rdquo;,            0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Rupaya&rdquo;,              0x3c, 0xbc, &ldquo;7&rdquo;,    &ldquo;U&rdquo;
&ldquo;Sambacoin&rdquo;,           0x3e, 0xbe, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SecKCoin&rdquo;,            0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SibCoin&rdquo;,             0x3f, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;SixEleven&rdquo;,           0x34, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;SmileyCoin&rdquo;,          0x19, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;SongCoin&rdquo;,            0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SpreadCoin&rdquo;,          0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;StealthCoin&rdquo;,         0x3e, 0xbe, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Stratis&rdquo;,             0x3f, 0xbf, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;SwagBucks&rdquo;,           0x3f, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;Syscoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Tajcoin&rdquo;,             0x41, 0x6f, &ldquo;6&rdquo;,    &ldquo;H&rdquo;
&ldquo;Terracoin&rdquo;,           0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Titcoin&rdquo;,             0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;TittieCoin&rdquo;,          0x41, 0xc1, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Topcoin&rdquo;,             0x42, 0xc2, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;TransferCoin&rdquo;,        0x42, 0x99, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;TreasureHuntCoin&rdquo;,    0x32, 0xb2, &ldquo;6&rdquo;,    &ldquo;T&rdquo;
&ldquo;TrezarCoin&rdquo;,          0x42, 0xC2, &ldquo;7&rdquo;,    &ldquo;V&rdquo;
&ldquo;Unobtanium&rdquo;,          0x82, 0xe0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;USDe&rdquo;,                0x26, 0xa6, &ldquo;6&rdquo;,    &ldquo;R&rdquo;
&ldquo;Vcash&rdquo;,               0x47, 0xc7, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;Versioncoin&rdquo;,         0x46, 0xc6, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;VergeCoin&rdquo;,           0x1e, 0x9e, &ldquo;6&rdquo;,    &ldquo;Q&rdquo;
&ldquo;Vertcoin&rdquo;,            0x47, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Viacoin&rdquo;,             0x47, 0xc7, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;VikingCoin&rdquo;,          0x46, 0x56, &ldquo;3&rdquo;,    &ldquo;D&rdquo;
&ldquo;W2Coin&rdquo;,              0x49, 0xc9, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;WACoins&rdquo;,             0x49, 0xc9, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;WankCoin&rdquo;,            0x00, 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;WeAreSatoshiCoin&rdquo;,    0x87, 0x97, &ldquo;6&rdquo;,    &ldquo;P&rdquo;
&ldquo;WorldCoin&rdquo;,           0x49, 0xc9, &ldquo;7&rdquo;,    &ldquo;W&rdquo;
&ldquo;XP&rdquo;,                  0x4b, 0xcb, &ldquo;7&rdquo;,    &ldquo;X&rdquo;
&ldquo;Yenten&rdquo;,              0x4e, 0x7b, &ldquo;5&rdquo;,    &ldquo;K&rdquo;
&ldquo;Zcash&rdquo;,        [0x1c,0xb8], 0x80, &ldquo;5&rdquo;,    &ldquo;[LK]&rdquo;
&ldquo;Zetacoin&rdquo;,            0x50, 0xE0, &ldquo;8&rdquo;,    &ldquo;a&rdquo;
&ldquo;Testnet Bitcoin&rdquo;,     0x6f, 0xef, &ldquo;9&rdquo;,    &ldquo;c&rdquo;
&ldquo;Testnet Dogecoin&rdquo;,    0x71, 0xf1, &ldquo;9&rdquo;,    &ldquo;c&rdquo;
&ldquo;Testnet MonetaryUnit&rdquo;,0x26, 0x40, &ldquo;3&rdquo;,    &ldquo;A&rdquo;
&ldquo;Testnet PIVX&rdquo;,        0x8b, 0xef, &ldquo;9&rdquo;,    &ldquo;c&rdquo;
&ldquo;Testnet WACoins&rdquo;,     0x51, 0xd1, &ldquo;8&rdquo;,    &ldquo;[XY]&rdquo;</p>

<p>```</p>

<p>哈哈，洋洋大观啊。这也说明了folk一个山寨币的成本是如何的低；然后有了以太坊的ERC20之后，发一个新币的成本简直低到令人发指，也无怪乎场子里面骗子横行了。</p>

<h2>以太坊的地址生成</h2>

<p>Ethereum项目是不走寻常路的，他作为比特币之后最具创新性的后辈，地址设计反而简单的多。</p>

<p>直到生成公钥这一步，以太坊和比特币都是一致的，采用了secp256k1算法，只是最后的地址生成以太坊很简洁，直接Keccak256 hash，然后取最后的40位16进制字符得到的。</p>

<p>为什么比特币实现复杂呢？这是因为比特币的交易是以UTXO为核心的，每个UTXO包含其所有者及价值信息，系统中的每一笔的交易由若干UTXO输入和若干UTXO输出组成。UTXO无法只提取部分，每次必须完整的使用，这有点像我们生活现实中的现金。比特币系统中，一个用户的“余额”是该用户的私钥能够有效签名的所有UTXO的总和。要深刻的理解这一点，还需要我们了解了比特币的交易数据构成之后才能探讨。我们后面会写文章解释这一点啦。</p>

<p>而以太坊采用了与比特币不同的实现方式——账户，类似我们生活中的银行卡。以账户为核心的设计比较节省空间,而且以太坊的block组织更为精巧。另外，以太坊的设计目标和比特币是不同的：</p>

<ul>
<li>首先以太坊的账户除了普通的收发币的账户(俗称外部账户EOA)，还有合约账户，合约账户需要一个固定的地址，不然每次调用合约都会很麻烦；这样就要求以太坊的合约账户不像比特币交易那样频繁的更换地址；</li>
<li>他并不执着于强迫用户去注意隐私问题，以太坊的态度是，如果用户注重隐私问题，你就自己搞定；你需要通过合约中的签名数据包协议来建立一个加密“混合器”进行加密。</li>
<li>总之以太坊因为要实现的目标更为宏大，他的设计理念是根据最初的用户都是一群Geek们来建立的；Geek们最喜欢啥？就是不要过度设计，让我来自己搞定</li>
</ul>


<p>所以在以太坊系统中，账户是一个20字节的地址，他关联的信息包含四个部分：</p>

<ol>
<li><p>随机数，用于确定每笔交易只能被处理一次的计数器</p></li>
<li><p>账户目前的以太币余额</p></li>
<li><p>账户的合约代码，如果有的话</p></li>
<li><p>账户的存储（默认为空）</p></li>
</ol>


<p>可以采用<a href="https://github.com/ethereum/pyethereum">pyethereum</a>这个库，用以下代码模拟以太坊地址的生成:</p>

<p>```</p>

<h1>&ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>&ldquo;&rdquo;&ldquo;doctopt ethereum address generate tools</p>

<p>Usage:
  genaddr.py p2addr         <private>
  genaddr.py word2addr      <word></p>

<p>Options:
  -h &mdash;help                                             Show this screen.
  &mdash;version                                             Show version.</p>

<p>Example:</p>

<pre><code>genaddr.py p2addr 6bd3b27c591                                         # gen address from private 0x6bd3b27c591=&gt;1PiFuqGpG8yGM5v6rNHWS3TjsG6awgEGA1
genaddr.py word2addr 'Money is the root of all evil.'                 # gen address from private wordlist
</code></pre>

<p>&ldquo;&rdquo;"</p>

<p>from docopt import docopt</p>

<p>import os
import sys
from ethereum import utils</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>arguments = docopt(__doc__, version='1.0')

if arguments['p2addr']:
    private_key = bytes.fromhex(arguments['&lt;private&gt;'])
    passpharse = b'unknown'

elif arguments['word2addr']:
    passpharse = arguments['&lt;word&gt;'].encode('utf-8')
    private_key = utils.sha3(passpharse)

raw_address = utils.privtoaddr(private_key)
account_address = utils.checksum_encode(raw_address)
print("word:{}:private:{}:address:{}".format(passpharse.decode('utf-8'), private_key.hex(), account_address))
</code></pre>

<p>```</p>

<p>```</p>

<blockquote><p>python genaddr.py word2addr &lsquo;hello&rsquo;</p></blockquote>

<p>word:hello:private:1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8:address:0x5ccfa55C29F0522f062E3C15004E35a69dD45F6B
```</p>

<p>以太坊账户方式的一个弱点是：为了阻止重放攻击，每笔交易必须有nonce。这就使得账户需要跟踪nonce的使用情况。而且，不再使用的账户，无法从账户状态中移除。</p>

<p>关于重放攻击，我们会在后面说明。</p>

<h2>重放攻击</h2>

<p>在网络中重放攻击是一种很常见的hack方式，关于相关攻防有足够丰富的案例；但是在区块链历史上却是一个悲伤的故事；在此我们用一点点篇幅回忆一下区块链上第一次大规模的重放攻击(replay Attack)。</p>

<h4>缘起</h4>

<p>众所周知，以太坊作为<code>智能合约</code>的首创者，在区块链技术史上是继比特币之后最大的创新。在V神于2015-07-30正式推出运行后，立即吸引了众多Geek来探究如何实现白皮书中所说的去中心化程序。其中最受关注的就是2016-04-30日开始募资的<a href="https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413">The DAO</a>项目。</p>

<p>关于这个项目的始末，实在是槽点满满。即使已经两年后的今天，估计你去搜索这起著名的事件，非码农人士也很难搞明白。简而言之，就是<code>The DAO</code>作为一个去中心化的项目基金会开始募资，令人觉得神奇的是，这个项目背后没有一个控制人！即使这个项目筹到一大笔钱，也没有一个人有权利单独动用它，只能所有投资人投票才能决定资金的使用，这是写在区块链代码上的铁律，这就是去中心化的魅力！</p>

<p>但是一个没有控制人，没有开发目标，拿到了钱也不知道今后要干啥的项目组织，说要募资了，然后人们纷纷掏钱买股权，是不是很神奇！</p>

<p>咱们说传销还得有个愿景呢！但是当时<code>去中心化程序</code>的概念横空出世，官网页面美轮美奂，诸多<code>专家</code>纷纷发表晦涩难懂的高大上文章齐赞<code>The DAO</code>的历史意义，就在那种巨大的泡沫环境中，人们害怕的是错过发财的上车机会，于是根本搞不明白这是个什么东西，就慷慨解囊。</p>

<p>你可能觉得好笑，可是看看今天，那些所谓的高大上的区块链项目，所谓的伟大愿景，那些山寨币，那些要颠覆这颠覆那的各路神仙，和当时何其相似！熙熙攘攘的投资人群中，有几人能花时间去搞明白比特币和以太坊的白皮书？</p>

<p>所谓的区块链技术的发展，充斥着贪婪和诈骗。就和人性一样。</p>

<h4>崩溃</h4>

<p>同样，人类的愚蠢也是不变的，贪婪之下，BUG是无法避免的。</p>

<p>截至2016-05-15，<code>The DAO</code>项目的合约募集了大约当时价值约1.5亿美元Ether，占当时Ether发行总量的15%。讽刺的是，这个项目募集了巨大的金额，却没有一个像样的专家去做一个合约代码安全审计！</p>

<p>终于，THE DAO创始人之一Stephan Tual发现其合约代码有部分缺陷，他于6月12日宣布，他们发现了软件中存在的“递归调用漏洞”问题，不过对DAO资金来说则不会出现风险。讽刺的是还是没有多少人注意到这个问题。</p>

<p>2016-06-17，一名黑客在编码上发现了真正的漏洞，使得他可以从<code>The Dao</code>上抽走资金。在攻击的头几个小时，360万的Ether被转出，在当时价值相当于七千万美元。当时引起的混乱可想而知，社区采用紧急措施冻结了所有的币，但是只要以太坊的根基代码不变，就无法阻止黑客取现这些财富。</p>

<p>你可以想象当时那些投资人的反应，有人气急败坏要求以太坊开发团队立即采取措施，作废黑客的攻击行为，回退区块链并退回所有投资人的Ether。</p>

<p>而真正的区块链信徒认为<code>代码即正义、代码即法律</code>，传统世界中的法律不能应用到cyberpunk世界中，即使是黑客的盗窃行为，也理应收到这种正义保护！回退作废Block的行为其实就是否认区块链的技术意义，它会毁灭以太坊项目。</p>

<p>你可以想象，当你损失了几十万美元，对面的一群码农却做出这种<code>奇谈怪论</code>，肯定是想砍人的心都有了。当时的各路利益纠葛者吵了一个翻天覆地。甚至黑客本人也跳出来发表了一通公开信，先为自己的盗窃行为辩护一番，然后承诺只要社区不回退，就会返还一部分金额。整个事件好一场精彩大戏。</p>

<h4>分裂</h4>

<p>经历了无休止的利益、法律、技术等等辩论后，以太坊社区分裂了。争论的结果就是诞生了ETH Classic (即ETC)项目；一批坚持<code>代码即正义</code>者分裂出来创造了ETH Classic 网络，这个项目称自己才是真正的以太坊，并承认黑客的攻击行为且继续将这条链运行下去。而现在仍旧运行的Ethereum网络保护了投资者的利益，做出了妥协；</p>

<p>这个分叉开启于Ethereum网络Block编号为<a href="https://gastracker.io/block/0x94365e3a8c0b35089c1d1195081fe7489b528a84b22199c916180db8b28ade7f">1920000</a>区块。</p>

<p>这是世界上第一次公开的人为的区块链分叉事件。但是好戏才刚刚开始。</p>

<h4>重放攻击</h4>

<p>以太坊硬分叉出现了ETH和ETC两条链，两条链上的交易数据结构是完全一样的，因此一笔交易在ETH上是有效的， 那它在ETC上同样会被接受，反之亦然。 因为当时所有人都认为ETC将不会再存在，所以分叉前没人意识到两条链会产生相互重放问题。 后来还有许多矿工继续在维持ETC链时， 大家发现在ETH链上的交易拿到ETC链继续重放（广播）仍然是有效的。</p>

<p>因为没经验，以太坊分叉时几乎所有交易所也都没意识到这个问题，更没有提前做ETH和ETC分离， 这时候只要有人从交易所提取ETH币，就有可能得到同等数量的ETC币。许多人利用这个漏洞，不断在交易所充币和提币（ETH）， 从而获取额外的ETC。 当时云币、BTC-E等交易所发布说自己被重放攻击了，被骗取了几乎所有ETC。“重放攻击”也就此闻名于币圈。</p>

<p>解决这个问题也很简单，或者就是两边的原始交易数据要有所区别:</p>

<ul>
<li>或者地址前缀做一下改动</li>
<li>或者交易数据签名增加一个标志</li>
</ul>


<p>因为以太坊地址没有像比特币一样的前缀，ETC和ETH社区经过讨论，简单的提出了<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">EIP-155</a> 作为解决方案。简而言之，就是判断分叉的区块编号，引入一个CHAIN ID新值来解决这个问题。</p>

<p>耐人寻味的是，Ethereum团队此时对于ETC分叉的态度是支持的。就像中本聪早期提到的那样，没有一个人可以集权控制一条链，算力说话。因此ETC活了下来。也因为以太坊的创始人Vitalik Buterin是个非常年轻的天才，整个开发团队洋溢着一种骑士精神;他们对于自由竞争出生的ETC非常包容，不管将来结果如何，我认为这种态度是非常了不起的。</p>

<p>当然，个人感情的说一下。此事说明了投资所谓的区块链项目，究竟有多大的风险！以太坊基础代码有许多人审核，有一定的安全保证，但是形形色色的智能合约就不好说了。后来像DAO一样的hack事件数不胜数！</p>

<p>我得说，当你想要投资一个所谓<code>未来项目</code>时，除了你自己的知识和判断，没有任何一个人是可信的！我是说，只能靠自己，其他任何人，甚至创始者的意见也不可信。</p>

<h2>Bitcoin Cash地址生成</h2>

<p>关于Bitcoin Cash的诞生，其过程之离奇曲折，胜过ETH分叉百倍。这是一个比最精彩的侦探小说还要反转反转再反转的故事。</p>

<p>不过我们就不要讲故事了，总之Bitcoin Cash分叉诞生后，为了和传统的Bitcoin地址相区别，自己又做了一下改动。</p>

<p>快速看看BCH新老地址的对比：</p>

<ol>
<li><p>新地址是和老地址一一对应的，它们对应了同一个私钥，只是换了种写法</p></li>
<li><p>新地址可以发送余额给老地址，老地址可以发送余额到新地址</p></li>
<li><p>新地址是大小写不敏感的，可以全部转成大写，也可以全部转成小写，优先小写格式，同一地址不能大小写混用</p></li>
<li><p>新地址的前缀可写可不写，老地址没有前缀，通过首字符来标识类型</p></li>
<li><p>新地址用base32编码，老地址用base58编码</p></li>
</ol>


<p>官方文档描述参见<a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md">这里</a>，让我们从seed <code>satoshi</code> 生成一个bitcoin cash 地址演示一遍。</p>

<h4>规范</h4>

<p>新的bitcoin cash地址是由：</p>

<ul>
<li>能够表示该地址有效的网络的前缀，一般为主网(bitcoincash)、测试网(bchtest)、回归测试网(bchreg)三种。</li>
<li>一个分隔符：<code>:</code></li>
<li>一个base32编码的payload，表示这个地址的目的地和包含的checksum（校验和）。</li>
</ul>


<h4>Payload</h4>

<p>payload是base32编码的数据流，由三个元素组成:</p>

<ul>
<li>指示地址字节的版本类型</li>
</ul>


<p>共8bits, 1bit(0) + 4bits (地址类型：Type bits) + 3bits (hash长度：Size bits)</p>

<table>
<thead>
<tr>
<th>Type bits (二进制) </th>
<th> 地址类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 </td>
<td> P2PKH</td>
</tr>
<tr>
<td>1000 </td>
<td> P2SH</td>
</tr>
<tr>
<td>0000 </td>
<td> P2PKH-TESTNET</td>
</tr>
<tr>
<td>1000 </td>
<td> P2SH-TESTNET</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th>Size bits (二进制) </th>
<th> 代表hash长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>000 </td>
<td> 160</td>
</tr>
<tr>
<td>001 </td>
<td> 192</td>
</tr>
<tr>
<td>010 </td>
<td> 224</td>
</tr>
<tr>
<td>011 </td>
<td> 256</td>
</tr>
<tr>
<td>100 </td>
<td> 320</td>
</tr>
<tr>
<td>101 </td>
<td> 384</td>
</tr>
<tr>
<td>110 </td>
<td> 448</td>
</tr>
<tr>
<td>111 </td>
<td> 512</td>
</tr>
</tbody>
</table>


<ul>
<li>一个hash值</li>
</ul>


<p>hash含义取决于版本字段。它是表示数据的hash，即P2KH的pubkey hash和P2SH的reedemScript哈希。这个可以直接从BTC地址里面推出，这个hash值导出后需要用40Bits的BCH码来表示，这样做之后，地址大小写不敏感。</p>

<ul>
<li>一个40字节的校验和</li>
</ul>


<p>这个校验和的计算比较繁琐，它是在GF（2 ^ 5）上定义的40bits的BCH码，校验和根据以下代码计算：</p>

<p>```
uint64_t PolyMod(const data &amp;v) {</p>

<pre><code>uint64_t c = 1;
for (uint8_t d : v) {
    uint8_t c0 = c &gt;&gt; 35;
    c = ((c &amp; 0x07ffffffff) &lt;&lt; 5) ^ d;

    if (c0 &amp; 0x01) c ^= 0x98f2bc8e61;
    if (c0 &amp; 0x02) c ^= 0x79b76d99e2;
    if (c0 &amp; 0x04) c ^= 0xf33e5fb3c4;
    if (c0 &amp; 0x08) c ^= 0xae2eabe2a8;
    if (c0 &amp; 0x10) c ^= 0x1e4f43e470;
}

return c ^ 1;
</code></pre>

<p>}
```
具体的规则可以详细参考<a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md">这里</a>。</p>

<h4>地址转换生成</h4>

<ul>
<li>1.取<code>satoshi</code> 生成的非压缩地址<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code></li>
<li>2.这个地址是一个主网地址，前缀为<code>bitcoincash:xxxxx</code></li>
<li>3.这个地址类型为<code>P2PKH</code>，version_bits为0000</li>
<li>4.<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>进行base58 Decode，去掉末尾的4字节checksum，得到的hash值用list表示
<code>
payload = [101, 13, 4, 151, 224, 20, 230, 13, 70, 128, 252, 230, 153, 125, 64, 93, 226, 100, 240, 66]
</code></li>
<li>5.加入version前缀
<code>
payload = [0, 101, 13, 4, 151, 224, 20, 230, 13, 70, 128, 252, 230, 153, 125, 64, 93, 226, 100, 240, 66]
</code></li>
<li>6.将hash进行8bits->5bits BCH码的转换
<code>
payload = [0, 1, 18, 16, 26, 1, 4, 23, 28, 0, 10, 14, 12, 3, 10, 6, 16, 3, 30, 14, 13, 6, 11, 29, 8, 1, 14, 30, 4, 25, 7, 16, 8, 8]
</code></li>
<li>7.计算校验和
<code>
checksum=[24, 25, 19, 1, 12, 3, 18, 8]
</code></li>
<li>8.对payload + checksum进行base32编码，得到<code>qpjs6pyhuq2wvr2xsr7wdxtagpw7ye8sggcenpvrjg</code></li>
<li>9.加入前缀<code>bitcoincash:</code>，组合得到最后地址<code>bitcoincash:qpjs6pyhuq2wvr2xsr7wdxtagpw7ye8sggcenpvrjg</code></li>
</ul>


<p>有许多在线转换工具可以验证，比如:</p>

<p><a href="https://bch.btc.com/tools/address-converter">https://bch.btc.com/tools/address-converter</a></p>

<h2>总结</h2>

<p>以上长篇大论了比特币系统的地址是如何生成的，当然我们也略过了许多细节，比如钱包如何加salt，如何加passphrase等等，这些直接去读BIP 规范更为精确；但是一个完整的钱包，可不仅仅是要解决地址生成这个问题，还要能方便的管理私钥。</p>

<p>在比特币早期，私钥的管理是非常粗暴的，就是每次创建新钱包时，系统自动随机生成100个私钥，然后随着用户交易增多用光之后，再生成100个私钥；钱包文件就是一个二进制文件，即使加了密码保护，也很容易暴力破解泄密；</p>

<p>这导致了无穷多的hack事件；不管你信不信，初期很多从事比特币交易的网站，其wallet.dat文件就明晃晃的放在服务器上，管理员粗心大意，完全可以形容为 <code>没头脑+不高兴</code>，很多人连个最基本的密码保护也不设置；另外也发生过很多悲剧的<code>rm -rf</code>事件，我认为由于这样的失误导致的比特币丢失至少在100w+ 币的级别；换算今天的汇率，你能相信有个银行将数亿美元现金的保险柜不加锁，明晃晃的摆在大堂上摆阔吗？</p>

<p>在一连串的悲剧事件中(具体是哪些悲剧可以写一本书哦)，作为登峰造极者，mtgox当之无愧！ 80多万个比特币的丢失，史上独一份。这个交易所的老板也是心大，80w+币的钱包密码也不设置一个，就在那里任由黑客予取予求；还不是一天两天哦，是持续好几周的hack事件！</p>

<p>mtgox是比特币历史上巨大的迷雾，他不光牵扯到许多比特币的早期玩家，还有BTC-E, FBI牵涉其中，我认为这是仅次于<code>中本聪到底何方神圣</code>的谜题。所幸法胖还活着，我希望有生之年能读到这个事件的完整披露。</p>

<p>好了，假如你是一个交易所的老板，你会很快发现自己面临着以下问题：</p>

<ul>
<li>不需要给每个用户的账户都建立一个钱包文件，我希望能有一个总的账户管理方案</li>
<li>可能交易所有1000个大户，你希望他们的钱包是冷存储的，提币的时候他们可以耐心等一段时间，但是剩下的100000个普通用户的账户就要存放到一个热钱包上，只留有部分资产来应付流动性</li>
<li>有很多部门需要批准获取一些资金，比如研发要用来做测试，市场部门要用来搞活动等等</li>
<li>最后，私钥最好只能由少数人，最好只有我本人来掌握，不然私钥的传播过程中，随便一个人就能让你万劫不复</li>
<li>我如果有一些合伙人的话，肯定也希望能掌管一部分资金</li>
<li>如果有突发情况，我能迅速把公司账上所有的币都转移到另外一个安全的账户上，这有可能是要迅速完成上万笔的交易转移</li>
<li>最后，我希望所有的交易，签署和广播是在不同的机器上进行的，存有私钥的机器不能联网，这台机器签名完毕后，调用远端的服务端广播交易，这样完全实现钱包的冷隔离</li>
</ul>


<p>好啦，假如我们现在只有前面那种一个wallet.dat钱包的管理方案，要怎么做呢？</p>

<p>很明显的，这种管理太粗糙了。社区们经过不断的探索，提出了BIP-32，BIP-39，BIP-44等规范，以绝妙的办法解决了这些问题。这就是比特币HD钱包的由来。同时这些规范不仅仅适用于比特币系统，还适用于所有的电子货币方案，也许今后，你可以同时在一个钱包里管理你的ETH, BTC, 支付宝余额等等~~~</p>

<p>那到底要怎么做呢？</p>

<p>我们已经探索了这么远，估计你也不耐烦了，但是我们还要说，这还早的很呢！那么下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoin-cli Cheat]]></title>
    <link href="https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat/"/>
    <updated>2018-10-26T16:28:23+08:00</updated>
    <id>https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat</id>
    <content type="html"><![CDATA[<p>今天踩了一个巨坑。</p>

<p>我一直以为<code>bitcoin-cli sendfrom</code>命令是可以花费uncomfirmed UTXO的。</p>

<!-- more -->


<p>然后今天发现bitcoin-core 0.17版本已经开始废弃这个命令和<code>bitcoin account</code>的支持了。于是去修改万年之前的一个脚本。</p>

<p>然后我切换到TESTNET里面发了几笔交易，惊奇的发现sendfrom并不能花费uncomfirmed UTXO。执行:</p>

<p>```</p>

<blockquote><p>bitcoin-cli sendfrom &ldquo;&rdquo; &ldquo;1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd&rdquo; 0.01 0
```</p></blockquote>

<p>明明我已经发给测试账户0.1BTC过去了，getwalletinfo可以看到这个币了，我也把minconf设为0了，却在执行sendfrom的时候总是提示我<code>Account has insufficient funds</code>；</p>

<p>我一路代码追下去，在这里:</p>

<p><a href="https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915">https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915</a></p>

<p>惊奇的发现只有自己的找零才会在uncomfirmed的情况下被计入credit fund，震惊了。我这个脚本运行了半年了，才发现这个坑。</p>

<p>没办法，自己又封装了一遍<code>createrawtransaction</code>，<code>signrawtransaction</code>, <code>sendrawtransaction</code>，来代替sendfrom的功能。</p>

<p>找这个问题我在TESTNET里面发了不下一百笔交易，wallet部分的代码已经翻遍了，我深深为之感叹bitcoin core实现wallet这部分的精巧，好多地方的细节已经不是人类能理解的了；太可怕了。</p>

<p>另外记一下远程调用bitcoind rpc接口的套路:</p>

<p>```</p>

<blockquote><p>bitcoin_cli &mdash;rpcconnect=192.168.2.7 &mdash;rpcpassword=&ldquo;xxxxx&rdquo; &mdash;rpcuser=test getwalletinfo
```</p></blockquote>

<p>相应的，bitcoin.conf也要允许远端调用rpc接口的权限:</p>

<p>```
rpcuser=test
rpcpassword=xxxxx
rpcallowip=192.168.2.0/255.255.255.0
rpcport=8332
rpcthreads=10
server=1</p>

<p>```</p>

<p>ps: bitcoin.conf 可以直接放到blockchain的数据目录，反正我看0.15的代码，已经把这个路径默认加到path搜索里面了。</p>
]]></content>
  </entry>
  
</feed>
