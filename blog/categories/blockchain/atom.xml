<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2018-11-23T20:11:31+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币的交易-1]]></title>
    <link href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/"/>
    <updated>2018-11-23T18:48:39+08:00</updated>
    <id>https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1</id>
    <content type="html"><![CDATA[<p>在我们前面的文章中，我们提到，从建设银行转账到工商银行10w元，过程其实是这样的:</p>

<ol>
<li>建设银行发送报文到人行CNAPS系统</li>
<li>人行CNAPS发送转账报文到工商银行</li>
<li>工商银行发送响应报文给人行CNAPS</li>
<li>人行发送响应报文给建设银行</li>
<li>转账成功，建设银行、人行、工商银行各自更新账本</li>
</ol>


<p>整个过程中，有几个很有趣的事实：</p>

<!-- more -->


<ol>
<li>所谓的转账交易，不过是账本上数字的加加减减</li>
<li>我们的账户，除了各自在工行、建行开设的户头之外，在人行还有一个总账；人行是所有银行的妈，你在任何银行开设的账户，人行都有一个总账；所以打印征信的时候我们要到人行打印</li>
<li>建设银行和工商银行间的转账需要人行做清算，人行提供了信用；建行和工行相信人行不会造假</li>
<li>我们需要信任三个机构：人行、工行、建行，我们相信他们不会造假</li>
<li>人行是所有账目的中心节点，人行的账本对不上了，中国的金融系统就乱套了</li>
</ol>


<p>然后作为对比，我们来看看比特币是怎样设计的。</p>

<p>中本聪创造比特币之初，在<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis Block</a>里面付了一句有名的话:&ldquo;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"。在白皮书中他很自豪的宣称:"We have proposed a system for electronic transactions without relying on trust. &rdquo; 去中心化一直是比特币的指导纲领，那么问题来了，如果让我们来设计一个去中心化的账本，将会面临哪些技术问题，又该如何解决呢？</p>

<p>很自然的，我们设想的是一个类似于分布式数据库的系统，整个系统维护着唯一的账本，每个节点（node）都是一个副本（Replica Set），每个副本保有完全的账本数据，并且节点间相互同步数据，如果部分节点挂掉，不影响整个系统的运行。</p>

<p>用户转账的行为，其实就是这个分布式账本的增删查改。当然，为了简化设计，我们这个账本可以只支持账目写入，不支持删改。</p>

<p>我们开始思考这个分布式账本要解决的两个核心问题：</p>

<h4>什么样的交易是一笔合法的交易</h4>

<ul>
<li>一笔交易中，如何保证交易账户的完全所有权；如果保证用户A的资金不会被用户B盗用</li>
<li>用户A本来有1000元，如何保证他不会转出2000元？</li>
</ul>


<h4>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</h4>

<ul>
<li>如果有部分节点是不诚实的，它就会有动机去伪造不存在的交易来获取利益，如何识别并排除不诚实的节点？(拜占庭将军问题)</li>
<li>如果A的账户有1000元，发送了1000元给B，由于是分布式系统，部分节点收到了这笔交易，这时候A又发送了1000元给C，另一部分收到了这笔交易，这时候该如何处理？如何保证一笔钱不会被花两次？ (双重支付问题)</li>
</ul>


<p>为了解决这两个问题，比特币引入了三个核心技术：UTXO交易模型、POW工作量证明、blockchain数据结构组织。且让我们一一道来。</p>

<h2>初版交易设计</h2>

<p>如果读了之前我们的&lt;比特币HD钱包>系列文章；天然的，我们意识到非对称加密方法是在分布式账本中建立账户的天选之术；</p>

<h4>存款</h4>

<p>用户A想要建立一个账户，只要在帐目中增加一笔 <code>公钥+金额</code> 的记录就可以了。我们用一个表格表示整个账本，用户A以及用户B各存入50个币的动作可以记作:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50)</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50)</td>
</tr>
</tbody>
</table>


<p>这个原始存入的资金我们先不去纠结怎么来的，总之此时账本中有两笔交易，代表着A以及B各自有50个币</p>

<h4>验证</h4>

<p>在账目1中，如何验证A确实是这笔资金的拥有者呢？非常简单，就是账户资金增加的时候，A对这笔交易数据的摘要用私钥做一个签名，然后再把公钥附在后面就可以了，这样账目就变成了这样:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
</tbody>
</table>


<p>任何一个要验证账户A的节点或第三方，对其所有权证明用公钥解密，然后对照摘要(digest)即可。</p>

<h4>转账</h4>

<p>如果A要向B转账20个币呢，我们最简单的设计，就是构造Trans1 &ndash; 20，然后同样的方法构造签名即可，这样账本如下:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
<tr>
<td>3 </td>
<td> Trans3:Trans1-20 &ndash;> B</td>
<td> signature(digest(Trans1 &ndash; 20 &ndash;> B))+A公钥</td>
</tr>
<tr>
<td>4 </td>
<td> Trans4:存入(B公钥+20) </td>
<td> signature(digest(Trans4))+B公钥</td>
</tr>
</tbody>
</table>


<p>看起来一切还好，但是这个时候我们发现了一些缺点</p>

<ol>
<li>收到汇款的时候因为要添加所有权证明，账户拥有者得一直在线监控自己的账户地址</li>
<li>收款人还得验证汇款人的合法性，感觉都点怪；我收钱就好了，还得去管这个钱合不合法？</li>
<li>如果多重转账，或者一对多，或多对一，这个记录格式就复杂了</li>
<li>用户B要验证一笔交易合法性的时候，可能要回溯到账本非常深的位置，因为上一笔交易可能发生在很久之前，这种交易记录的存储设计很难高效查询</li>
<li>最后，这个账目设计中，所有账户的公钥是暴漏在外的；虽然椭圆曲线算法目前看来牢不可破，但是整个安全体系只依赖一个非对称加密算法，比较脆弱</li>
</ol>


<p>解决方法其实也简单，换个思路，就是A转账给B，B是不需要验证的，只要A提供账户所有权的证明就好了，想想我们平时转账，不也是这样的吗？</p>

<p>那么最简洁的设计，就是借鉴现实世界。每一笔交易都看作是硬币的流转，硬币其实没有特征，它只是从A的保险箱转移到了B的保险箱而已，那么，采用什么办法来表示：<code>这是A的保险箱中的一笔资金币</code>这个譬喻呢？</p>

<h2>进阶交易设计</h2>

<h4>UTXO 模型</h4>

<p>比特币的账本世界，构筑在UTXO (Unspent Transaction Output)之上；其实每个UTXO代表着未花费的一笔硬币(数额可大可小，没有限制)；一个账户的资金，其实就是一堆UTXO的集合；转账交易，就是一个或多个UTXO的输入再输出为另外的UTXO而已。你可以想象成现实世界中金银铸币的流通。</p>

<p>那么一个UTXO中包含什么呢？如何作为输入呢？如何构造输出呢？这就是比特币交易的核心技术。</p>

<ul>
<li>我们用下面一张图来表示<code>A保险箱里面的50个硬币</code> 这件事：</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg1.jpg" alt="img" /></p>

<p>把它想象成一个邮筒构造的保险箱，在不打开的前提下，投币是只进不出的。可以注意到，我们并没有直接将Public Key明晃晃暴露在外面，而是先HASH一下，然后贴到保险箱子上面，想要存币的人，只要知道这个HASH值，作为保险箱的ID，就可以直接投币进去啦。</p>

<p>但是保险箱的锁在哪里呢？</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg2.jpg" alt="img" /></p>

<ul>
<li>这张图中，我们引入了一个脚本，称之为 <code>Pubkey Script</code>；具体内容是:</li>
</ul>


<p><code>
OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></p>

<p>呵呵，像天书吧，不要怕；这是我们特有的保险锁构造。细节会在后面讲到。这里你可以这样简单理解：</p>

<p>为了锁住这个保险箱里的资金，比特币系统设置了一个谜题作为锁。解开这个谜题，才能转移里面的资金。</p>

<p>这个谜题是这样构造的:</p>

<ol>
<li>记录了A的公开的<code>Public key hash</code>值，开锁的人，需要提供A的<code>full public key</code>，同时验证 <code>hash160(public key) == Public key hash</code></li>
<li>需要提供A的私钥基于这笔交易的签名Signature, 这样系统可以用<code>full public key</code>来验证公私钥是否匹配</li>
</ol>


<p>这个过程是通过上面的脚本指令通过入栈出栈执行的，这也为比特币系统验证更复杂的交易逻辑提供了基础，甚至能作为一个简单的虚拟机执行更复杂的组合指令。</p>

<p>整个过程组织如下图：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg3.jpg" alt="img" /></p>

<p>当我提供一个signature以及full public key的时候，就可以开锁了，开锁下一步自然就是转移资金啦。我们给B汇款50个币，而B的保险箱又是怎么表示的呢？和A保险箱是一样的。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg4.jpg" alt="img" /></p>

<ul>
<li><p>带有<code>public key hash</code> ID的保险箱是一个UTXO，这个保险箱用<code>public key hash</code>上锁，而提供<code>signature</code>和<code>full public key</code>开锁，转移资金的过程，就是花费UTXO的过程，其实就是把A的UTXO转移到B的UTXO的过程，这就是比特币最简单的一笔交易</p></li>
<li><p>我们可以继续拓展下去，可以1对多支付，多对1支付，多对多支付，更复杂的多签名支付，延迟支付等等，今后我们会详细介绍</p></li>
</ul>


<p>这个系统有如下优点:</p>

<ol>
<li>所有的交易都抽象为了UTXO的转移，你可以想象一下，一堆硬币在几个保险箱之间转移的样子</li>
<li>用户其实可以不检查交易的合法性，只要运行分布式账本的所有节点检查通过合法后，确保写入账本就保证资金的安全转移了</li>
<li>每个账户的拥有者在真正花费UTXO之前，是不用暴露公钥的</li>
<li>验证UTXO交易合法行的函数，抽象为几个指令的集合，这个验证行为指令通用化，为智能合约编写创造了条件</li>
<li>这样的交易记录非常容易组织，我们以后可以看到；把这些交易批量打包，组织成名为blockchain的精巧数据结构，有许多优点</li>
<li>一个用户A可以用一个私钥加密多个保险箱，或者多个私钥加密多个保险箱，非常灵活</li>
</ol>


<h2>小结</h2>

<p>好啦，看到这里，我们对比特币的最简单的交易构造已经有感性认识了。但是俗话说得好: <code>光说不练假把式</code>，下篇文章我们就会手工构造一笔完整的交易，让你搞明白其中细节。</p>

<p>另外，我们前面提出了好几个问题:</p>

<ul>
<li>原始资金从何处来？</li>
<li>节点如何解决拜占庭将军问题？</li>
<li>节点如何解决双重支付问题？</li>
</ul>


<p>后面我们会一一解答，那么，下次再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币、支付、清算漫谈]]></title>
    <link href="https://happy123.me/blog/2018/11/19/huo-bi-%2C-zhi-fu-%2C-qing-suan-man-tan/"/>
    <updated>2018-11-19T16:55:29+08:00</updated>
    <id>https://happy123.me/blog/2018/11/19/huo-bi-,-zhi-fu-,-qing-suan-man-tan</id>
    <content type="html"><![CDATA[<p>又看了一遍 <a href="https://book.douban.com/subject/26802686/">The book of Satoshi</a> 这本书，果然常读常新啊；又有很多想法冒出来，结合最近的BCH分叉事件，我不禁又开始思考金融系统的两大环节：清算和支付，究竟会如何发展？</p>

<p>我从事银行业务系统监控很长时间，结合咱的职业生涯所学，再重新梳理一遍支付和清算的发展史吧。</p>

<!-- more -->


<p>除了支付和清算，还有一个拓展概念，即结算。看一下权威机构的定义:</p>

<p>按照国际清算银行支付结算委员会的定义，所有涉及到资金转移的行为，都可视作支付行为，支付的概念最大，清算和结算属于支付过程中的特定环节，其中，清算是发生在结算前的支付环节，该环节的功能主要是为了提高结算的标准化水平和结算的效率。</p>

<ul>
<li><p>支付：完成付款人向收款人转移可以接受的货币债权的过程，包括交易过程、清算过程和结算过程等三个过程。</p></li>
<li><p>清算：包含了在收付款人金融机构之间交换支付工具以及计算金融机构之间待结算的债权，支付工具的交换也包括交易撮合、交易清分、数据收集等。</p></li>
<li><p>结算：该过程是完成债权最终转移的过程，包括收集待结算的债权并进行完整性检验、保证结算资金具有可用性、结清金融机构之间的债券债务以及记录和通知各方。</p></li>
</ul>


<h2>史前阶段</h2>

<p>支付清算的历史其实要比货币历史久远的多，但货币的演变是支付清算体系发展的原动力。</p>

<p>在货币产生前，物物交换其实就是一种支付行为，比如原始人甲有桃子，但喜欢苹果，而此时刚好碰到原始人乙，乙有苹果，但喜欢桃子，这样两个人就刚好满足双方的需求，甲向乙支付桃子，得到苹果，乙向甲支付苹果，得到桃子。这就是最原始的“支付”。随着持有香蕉的原始人丙也加入上述交易，那么必须形成需求的闭环，而且随着交易的物品数量、种类逐渐增多，就需要再找一个不参与交易的原始人丁专门做交易的分类、计数和记录，并且甲乙丙在丁面前都作出承诺：一是手里的桃子、苹果、香蕉都是真实存在的。二是交易的意愿都是真实的，不会拿了人家的东西却不给出自己的东西。那么丁做的事情就是最原始的“清算”。之后，桃子、苹果、香蕉交割到了新的主人手中，此时丁宣布交易成功结束，甲乙丙三方各不相欠&mdash;最原始的“结算”。</p>

<p>此时丁付出信用，承担了清算的网关。当然，这种清算是非常粗糙的，作为一个支付行为的环节不明显。</p>

<p>后来随着商品交换规模的扩大，统一的支付媒介就出现了。从最原始的贝壳，到铁铜铸币，再到金银物品，形成了人们统一承认的货币媒介。实物货币如金银货币的出现极大地提升了商品交易的成功率，形成了以货币为核心和交易媒介的支付清算体系雏形，极大地推动了贸易和经济社会发展。</p>

<p>此时的清算其实和支付行为频率差不多的，因为当时的贸易市场并不繁荣，货币媒介还很粗笨，可以说每一笔支付就伴随着一笔清算，清算如此重要，以至于此时的货币市场上最重要的并不是货币本身，而是记账的权力，最经典的例子就是我们前面文章中提到的雅浦岛的石币故事。</p>

<h2>纸币阶段</h2>

<p>但随着商品交易规模和范围的不断扩大，金银货币越来越不能更好地满足贸易经济大规模发展的需要，人们就开始尝试以收兑金银之后的收据代替金银实物进行流通，随着这种收据广为人们接受，纸币就此诞生了&mdash;这是货币发展史上的一个重要突破。当然，纸币是要与其背后的金银货币的成色、数量挂钩的，也就是金银本位制，而且发行纸币的单位是多样的，可以是国家，也可以是有实力有信誉的金银铸造商等等。这时的纸币仅仅只是一种“表征货币”。纸币的出现极大地提升了支付的便利性，但由于纸币的伪造难度和成本比金银货币低太多，如何避免收到假冒伪劣的纸币甚至防止纸币超发成为突出的难题。自此，支付的便利性与安全性因为支付工具（如纸币）从交易媒介（如金银货币）分离独立而始终成为一对矛盾。</p>

<p>纸币阶段其实和金银实体是并存的，这个时候的清算行为其实更好分辨；拿我们熟悉的晋商作为例子：</p>

<blockquote><p>早在清道光（1823年）年间，山西平遥商人就创立了“日升昌”等专门办理汇款业务的票号（古代的票号、钱庄就是现代银行的雏形）。
著名的红顶商人胡雪岩就是做票号生意起家的。
当时的票号支持异地汇款业务：客户来日升昌汇款，交了银子之后，票号就开出汇票给客户。
跟银行一样，票号也有总号和分号，客户可以携带汇票或者把票寄给亲人，只要凭票就可以到日升昌全国各地的分号兑出银子，分号给客户兑换之后先记内部账，日后再和总号清算债务。
从此之后，商人在城市之间贸易可以不用携带大量的银子。而汇票在不同城市的各个分号之间流转也形成了很多债务，有大量的银子需要周转，镖局就专为票号来运送银子以及为商人运送票据，有点类似于现在为银行押钞的威豹，不过镖局的手续费可是高达5%！</p></blockquote>

<p>整个过程中，每个月或年底各个分号之间周转银子，轧平账目的过程就是清算。虽然清算是整个支付环节的一部分，但是清算的频率比较低，平均下来多笔支付可能才发生一笔清算，所以此时表面上看货币是非常活跃的，清算作为一种记账行为默默引申到了后台。</p>

<h2>信用阶段</h2>

<p>牛顿爵士开创了金本位，其实在整个货币史上不过短短一段时间，然后我们现在就飞速的跳跃到了信用货币阶段，信用货币发展的技术基础，就是越来越完善普及的电子设备。可以想象，将来即使在非洲，持有一个智能电子钱包(不一定是手机)的成本也会小于持有纸币的成本，所以货币电子化的趋势不可逆转。</p>

<p>铸币信用化，表现形式电子化之后，最明显的一个改变，就是<code>清算</code>这个行为，夹杂在整个支付过程中越来越频繁了；</p>

<ul>
<li>原来钱庄分号之间轧账，周期可能半年一年记</li>
<li>金银铸币时代，两国之间的轧账，也可能持续几周</li>
<li>纸币化之后，可能国际汇兑、债券市场之间的清算，通过电报以及联行信件，就缩短到几天了</li>
<li>到了今天，跨行汇款，已经缩短到分钟级别了；移动支付，都可以到秒级了</li>
</ul>


<p>此时清算的次数又大致跟支付行为一个量级了，记账的技术又开始一轮飞跃；</p>

<p>放到我国来，伴随着改革开放，我们的金融市场30年走完了欧美100年的历史，其中支付清算系统的发展就是经典的代表，这段历史我比较熟悉，下面就我国的支付清算系统建设流水账一番;</p>

<h3>全国手工联行系统 (1949-1990)</h3>

<p>建国初期的银行是比较LOW的，那个时候的银行是沿袭历史发展过来的。因此银行之间的资金往来(通存通兑)，其实跟晋商时代的票号差不多，每个银行都和其它大行之间签订协议，开设备付金账户，实现互兑。</p>

<p>比如三家银行： 工行、建行、招行，他们每家银行都要在另外两家银行开设账户，存入准备金，不同银行间的业务往来像票号一样定期轧账。</p>

<p>此时，每家银行都是一个清算机构，为银行间的资金往来做清算。</p>

<p>这种清算方式无疑是低效的，每成立一家银行，要开启业务，都得一家家的在同行那里开设账户，费时费力。所幸那个时候的银行少，而且计划经济金融业务少，这么多年就凑合过来了。</p>

<p>一直到1984年中国人民银行专门行使中央银行职能之后，我们国家确立了法定存款准备金制度。央行的备付金系统正式确立。此时，银行跨行的资金清算有两种选择：</p>

<ul>
<li>用老办法，在所有有往来的银行开立清算账户清算</li>
<li>所有金融机构都在央行开立清算账户，由央行为商业银行统一清算</li>
</ul>


<p>显然大家都想用第二个方案。然而在那个时代，央行能承担的职责是很有限的，各银行内部数据还没有集中，没有电子化的记账系统，国内甚至都还没有银行卡，客户要转账也没有满大街的ATM。总之一句话，国内的金融环境还没有达到让央行推行全国统一结算制度的客观条件。</p>

<p>为了满足跨行结算的需求，央行当时提出商业银行要“自成联行系统，跨行直接通汇，相互发报移卡，及时清算资金”。也就是说同一家银行的总行及分支机构称为“联行系统”。同一联行内的资金结算，由联行总行自己做。这样，建行深圳分行和建行北京分行之间的资金清算由建行自己内部解决。跨银行之间要能支持直接汇款。跨行业务可以由央行清算，也可以由商业银行自己清算。</p>

<p>这是个各家银行系统很不智能，体验很差的时期，我们称为“全国手工联行”时期。于是，每家银行都可以接受跨行的汇款，银行每天自行轧差，各种交易汇总计算后，需要告知其他行的交易信息写成一张张特定的公文，加盖印鉴后在银行间送来送去。这种公文叫做联行信件，而收发联行信件就是当时邮电局的重要业务。</p>

<h3>全国电子联行系统EIS (1989-2005)</h3>

<p>随着银行业的不断发展，银行每天处理各类跨行业务的数量增多，各家银行之间的债权债务关系变得非常复杂，由各家银行自行轧差进行清算变得非常困难。这种状况要求央行必须承担起一个全国清算中心的角色。于是，央行在1989年12月6日，发布了“关于改革联行清算制度的通知”。</p>

<p>随后在1990年，中国人民银行清算中心建成，专门为金融机构提供支付清算服务。这个清算中心包括NPC和CCPC：</p>

<ul>
<li>NPC（National Process Center，国家金融清算总中心）</li>
<li>CCPC（City Clearing Processing Center，城市处理中心）</li>
</ul>


<p>1991年4月1日，基于金融卫星通讯网的应用系统——全国电子联行系统（EIS）开始试运行。EIS是人民银行专门用于处理异地（包括跨行和行内）资金清算和资金划拨的系统。它连接了商业银行、央行、NPC和CCPC。</p>

<p>假设客户在深圳建行汇款给北京工行，通过EIS处理一次跨行汇款的流程如下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg1.png" alt="img" /></p>

<p>可以看到，清算中心在各地建立了一个个分站，分站和总中心通过卫星网络互联，总站和分站共同构成了清算网络，为其它接入EIS的各家商业银行提供清算服务。</p>

<p>从此之后，各个银行之间的跨行汇款，以及同一银行的异地分行，就可以直接通过这样的电子化操作来完成了，客户的资金在途时间缩短到了一两天，这也算是中国金融系统的一大里程碑了。</p>

<p>PS: 直到2015年，我都在一些银行的老系统中见过EIS，这个东东真的很经典，生命力很顽强啊。</p>

<h3>现代支付系统CNAPS (1991-现在)</h3>

<p>1991年EIS试运行后，又发生了两件大事：</p>

<ul>
<li><p>各大银行核心系统投产，各家商业银行的内部联网系统纷纷建成投产</p>

<p>  银行内部资金划转都可以通过自己的核心系统解决了。这意味着各大行都可以做电子化的行内清算了，行内异地转账就不用再依赖EIS。笔者跑过许多银行，见识了许多核心系统的投产，几乎所有的核心系统设计都是一个套路，将来有时间可以再有一篇文章细说一下。</p></li>
<li><p>中国现代化支付系统（CNAPS）开始设计</p>

<p>  1991年10月，中国开始着手建设中国国家金融通信网（CNFN）和中国现代化支付系统（CNAPS，China National Automatic Payment System）。从此，全国电子联行（EIS）系统逐步向CNAPS过渡。到了二十一世纪，IT技术飞速发展，央行的CNAPS一代系统（大小额支付系统）也开始走上历史舞台。中国的支付清算步入了现代化支付系统CNAPS的时代。</p></li>
</ul>


<p>CNAPS值得我们大说特说，今天银行的主力业务都跑在它的基础上，它的发展历史上有几件大事:</p>

<ol>
<li>2002年，央行大额实时支付系统（HVPS）投产，用于处理同城和异地的商业银行跨行之间（也包括行内一定金额以上的）大额贷记业务。</li>
<li>2005年，央行小额批量支付系统（BEPS）投产，用来处理同城和异地纸凭证截留的借记支付业务以及每笔金额在5万以下的小额贷记支付业务。</li>
</ol>


<p>这两个业务统称为大小额系统，我们平时的跨行转账，走的就是这两个系统，他们之间有如下区别:</p>

<ul>
<li>首先，大小额的开放时间不同</li>
</ul>


<p>大额系统是工作日的 8:30 ~ 17:00，所以在节假日经常会收到银行通知说某些业务暂停了经常就是因为央行在节假日对大额系统做维护。小额系统全年无休，7*24小时工作。</p>

<ul>
<li>业务处理上不同</li>
</ul>


<p>大额是每笔交易都实时发送，实时清算的，所以基本上能实时到账，跨行资金零在途。小额系统是在收集若干笔交易后打一个包统一处理，定时清算。所以，用小额系统转账经常要几分钟甚至半个小时才能到账，银行间头寸交割也是非实时的。尽管理论上跨行转账业务不管用大额还是小额，一般在几分钟内都能到账，但是因为要经过央行，所以在这一时期基本没有银行敢向客户承诺资金多久能到账。比如我们早期银行卡转账，一半会发现一个<code>两小时内到账</code>的提醒，这就说明他走的是小额支付系统。</p>

<ul>
<li>金额不同</li>
</ul>


<p>大额系统没有金额限制，小额系统支持的单笔金额上限是5万元。从用途上讲，大额系统侧重于资金转移的时效性，主要用于资本市场、货币市场交易和大额贸易资金结算。小额系统对数据吞吐量要求较高，主要用于小额贸易支付和个人消费服务。</p>

<p>下面一张图就说明了CNAPS大小额的业务实现:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg3.png" alt="img" /></p>

<p>目前大部分手机网银跨行转账都没有手续费。所以如果你在晚上10点想跨行转账10万元，此时大额转账系统已经关闭了，建议你分成两个5万并且用加急方式来转账。</p>

<p>不管怎么说，现在我们的跨行汇款速度总算提高到小时级别了。</p>

<p>PS: 大小额支付的协议细节非常复杂，协议规范有上千页文档，是我去现场部署监控系统时永远的痛啊~~~</p>

<h3>第二代现代支付系统CNAPS2 (2013-现在)</h3>

<p>大小额系统已经很好用了，但是随着金融市场发展，业务需求是无穷无尽的；2013年10月6日，央行的第二代支付系统(CNAPS2)正式投产运行，其中包括2010年就推出的网上支付跨行清算系统（俗称“超级网银”）。超级网银是对大小额支付系统的一个补充，有两大亮点：</p>

<ul>
<li><p>接入机构不再限于银行</p>

<p>  支付宝、财付通等第三方支付也可以接入，所以有的第三方支付给商户提供的提现代发功能就是基于超级网银做的。</p></li>
<li><p>7*24小时实时到账，单笔上限5万元</p>

<p>  这就相当于在非工作日非营业时间增加了一种大额支付系统特性的渠道了。只不过金额限制是跟小额系统一致的。</p></li>
</ul>


<p>最后来一张总体架构图:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg2.jpg" alt="img" /></p>

<p>PS: 现场协议监控部署，<code>人行二代支付</code>是我听了上万遍的词汇啊，睡觉都无法摆脱~~~</p>

<h3>三方支付渠道</h3>

<p>人行的CNAPS2为不同银行间提供了清算服务，银行内部的核心系统为自己不同的分行间提供了清算服务。这两块已经覆盖了大多数的银行业务场景，包括:</p>

<ul>
<li>银行柜台&mdash;直接大小额转账</li>
<li>手机网银&mdash;大小额转账+超级网银</li>
</ul>


<p>但是还有一部分商业市场没有涉及到，就是我们常说的三方支付。我把它又分为两个场景:</p>

<ol>
<li>ATM 刷卡取款和POS机刷卡</li>
<li>网银支付</li>
</ol>


<p>在支付宝普及之前，POS机刷卡以及ATM取款都是我们日常生活中比较常见的资金流转渠道。相信大家都有不少储蓄卡及信用卡有着<code>银联</code>标识。这个银联又是何方神圣？</p>

<p>银联全称<code>中国银联银行卡跨行支付系统</code>，英文缩写为CUPS；我们说支付市场是很大而且油水很足的，人行作为银行的妈，建设清算系统主要是政治考量，而商业银行进军支付领域是要挣钱，所以2002年3月26日，经中国人民银行批准,各大发卡行的商业银行参股，成立了银联。</p>

<p>银联的目的就是提供人行二代支付之外的资金清算渠道，在支付场景捞油水。我们看一下ATM刷卡和POS机业务中，银联发挥的作用。</p>

<h4>POS机刷卡</h4>

<p>POS机刷卡的参与方比较多。以你在星巴克刷卡为例：</p>

<ul>
<li>持卡人——你</li>
<li>发卡行——你办这张卡的银行，我们假设是工行</li>
<li>商户——星巴克，我们假设星巴克的账户开在建行</li>
<li>收单行——星巴克的刷卡机的归属银行，假设也是建行</li>
<li>转接机构——银联</li>
<li>清算机构——银联和人行</li>
</ul>


<p>于是，当你用工行卡在星巴克消费的时候，资金流和现金流是这样发生的：</p>

<ol>
<li>你在收单行（建行）的POS机上刷卡消费</li>
<li>建行将消费报文发送给银联</li>
<li>银联交易系统记录交易数据，将消费报文给你的发卡行（工行）</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行的POS机</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
<li>银联通过小额支付系统或当地票据交换系统，完成建行和星巴克结算账户的资金划拨（收单清算）</li>
</ol>


<p>在这个过程中，银联提供两种清算：</p>

<p>1.建行和工行的清算叫“跨行清算”；
2.建行和星巴克的建行账户之间的清算叫“收单清算”；</p>

<p>无论是跨行清算还是收单清算，银联都是作为CNAPS的一个特许参与者，使用大小额支付清算系统，完成银行卡业务的资金划拨。本质上，银联提供交易转接、清分和对账，人行提供结算。</p>

<h4>ATM跨行取款</h4>

<p>你拿着一张工行卡去建行的ATM取了100元，这个跨行业务在CNAPS体系中的过程如下：</p>

<ol>
<li>你在建行ATM上输入100元按下取款按钮</li>
<li>建行将报文信息发送给银联</li>
<li>银联交易系统记录交易数据，将报文给你的发卡行(工行)</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行ATM</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
</ol>


<p>我们看到，ATM和POS渠道，是由银联的CUPS来对接各大商业银行做支付转接，解决信息流问题；银联同时提供清分和对账服务，对完账之后再调用央行大小额系统解决资金流问题；</p>

<p>当央行系统升级的时候，通过银行柜台和手机银行是不能做跨行转账的，但是通过ATM和POS却可以跨行取款和跨行支付，这是因为银联暂且处理了清分和对账，等到央行系统升级完毕后，他们才进行清算；</p>

<p>所以一般央行挑放假的日子升级系统，这个时候一般没有对公业务，但是我们平常的刷卡消费可以正常进行。</p>

<p>另外，我们说，资金跨行清算的发展中，出现了一位豪杰，就是三方支付的大佬：支付宝</p>

<h4>支付宝等势力的发展</h4>

<p>支付宝早期为了服务淘宝客户和商家，不可避免的要跟银联抢生意，对接各大银行的支付接口。</p>

<p>银联作为既得利益者，绝不会开放接口给支付宝的。所以当时支付宝拿到支付牌照之后，苦逼的一家一家跟跟银行洽谈对接，值得注意的是，支付宝对接的各机构间跨行转账，没有走人行的大小额系统，而是走的支付宝内部资金池。</p>

<p>支付宝积硅步以至千里，慢慢的接入的银行多了，服务竟然能叫板银联了。</p>

<p>印象特别深刻的是，有一年国庆节人行系统升级，当时的小额转账竟然有大多数交易走的支付宝渠道，这时候支付宝已经有能力作为第三大清算网关服务大众了;</p>

<p>另外举一个有趣的例子，因为支付宝早期转账有免费的短信留言服务，所以有人用每笔1分钱的转账服务聊天！而发条短信都1毛钱呢，这跟如今的bitmessage、memocash记录信息何其相似。</p>

<p>我后来工作走了不少地方性的小银行，因为供应商不一样，他们每家的对接方案都不同，支付宝竟然有耐心一家一家的啃下来了，不得不佩服他们下的苦功夫。</p>

<p>当然，后来微信支付也异军突起，三方支付平台各路神仙纷纷跳出来分蛋糕，银联节节败退之后，祭出杀手锏；找央妈诉苦。于是为了平衡各方利益，一纸文件下来，决定建立网联平台，大家之前的自留地接入废除，各方统一接入网联，利益均沾。支付宝之前的平台建设就完成历史使命了。</p>

<p>网联平台的建设由于有阿里和腾讯的研发力量加入，开发异常顺利。2017年开始逐步上线，2018年双十一，就在前几天，官方号称TPS超过了9万笔。实在了得。不得不承认，我国的交易金融系统处理能力在世界上已经是单独一档了。</p>

<h4>小结</h4>

<p>上面长篇大论了我国支付清算系统的建设和发展，无非说明几个问题:</p>

<ol>
<li>金融越发达，支付行为越多，清算所占的比例也水涨船高</li>
<li>清算的速度越来越快，处理效率越来越高</li>
<li>虽然清算接入的机构越来越多，但是清算网关呈现大一统的趋势</li>
<li>清算的交易笔数指数级增长，中国支付清算协会发布《中国支付清算行业运行报告（2018）》称，2017年，国内商业银行共处理移动支付业务375多亿笔，非银行支付机构共处理移动支付业务2390多亿笔，这之中大部分都包含有清算行为</li>
</ol>


<h2>区块链时代</h2>

<p>我认为区块链技术诞生后，清算技术又是一个进化。但是这个进化过程初期表现十分笨拙，以至于看起来像是退化。</p>

<p>在比特币诞生之前，Ripple网络其实已经在传统清算网关的基础上，基于中心化的共识，提出了新的清算网关方案。他们的技术其实很有意思，也非常创新。我们打算放到其它篇章来介绍。目前我们单独谈谈比特币的技术方案。</p>

<h4>容量</h4>

<p>首先比特币由于是去中心化的网络，处理能力是非常低的；即使引入了Segwit附带一点扩容效果，目前也不过是3~4 TPS，和中心化的清算网关相比，简直可怜。</p>

<p>但是比特币系统的特殊之处就在于，他没有集中的账户管理节点，这意味着网络中的每个全节点都承担清算网关的职能，每一笔支付必然带有一笔清算，清算率100%。</p>

<p>这实在是像极了早期雅浦岛上的石头货币系统，我们一再强调这个寓言故事，因为它和比特币如此相像；比特币系统简直是雅浦岛的石币系统的电子版！连处理能力也是如此相似的性能低下！</p>

<p>值得庆幸的是，雅浦岛上的居民限于物理条件，系统性能提升有极限；而现代的电子设备性能提升，横向扩展的话，几乎是无穷尽的。</p>

<p>当前比特币的扩容方案主要是两大流派，经济利益夹杂着技术讨论，是是非非就不评说了，我们撇开矿霸、专利、以及阴谋论，只是整理一下他们目前的发展状况</p>

<h5>闪电网络链下扩容</h5>

<p>主要路线是Segwit 解决交易延展性问题，然后在此基础上实现二层闪电网络。目前来看，Segwit已经占了主网交易的半壁江山，估计最终能扩容到4-8 TPS，这当然不够用。所以二层网络的闪电网络至关重要。</p>

<p>闪电网络目前还是处于试验阶段，虽然推出了一些应用，但总体还是和比特币早期发展一样，只是部分Geek在使用。</p>

<p>优点:</p>

<ol>
<li>中转节点越多，处理能力越强</li>
<li>如果两个节点间能形成比较短的支付路径，理论上它的处理能力会很惊人的，至少是比现在几个数量级的提升</li>
<li>微支付通道里面的交易记录不上主网，这样跑全节点的开销只会线性增长，有利于比特币的去中心化</li>
</ol>


<p>缺点:</p>

<ol>
<li>收款需要保持在线</li>
<li>形成微支付通道需要双方缴纳保证金</li>
<li>建立和销毁微支付通道都需要主网广播，如果支付笔数少，建立通道的得不偿失；因为这个原因，目前来看闪电网络的实际应用不多</li>
<li>闪电网络的中转节点需要大量的保证金，会天然的会向大公司、集权化发展，这也是区块扩容党最诟病的一点</li>
</ol>


<h5>大区快链上扩容</h5>

<p>优点:</p>

<ol>
<li>代码简单，即刻扩容</li>
<li>技术方面来讲，扩容到32M-128M其实开销也不大；根据硬件设备的发展，长远来看，1GB的大区快可能也行得通</li>
<li>有人认为Segwit引入了复杂度，原本的交易格式更改了，技术上有洁癖的人接受不了，大区快扩容没有技术债</li>
</ol>


<p>缺点：</p>

<ol>
<li>有人认为今天32MB，明天更多，扩容起来无穷无尽，早晚只有矿场才会运行全节点，这样去中心化吃枣药丸</li>
<li>交易延展性问题早晚得解决，目前来看Segwit解决方案还是比较成功的，扩容党只是嘴硬，早晚得上</li>
<li>扩容再多，性能也比上闪电网络</li>
</ol>


<h4>总结</h4>

<p>近日BCH社区又经历了一场硬分叉斗争，有利益相争的地方就有恩怨，有恩怨就有江湖；很有可能大家搞来搞去，Bitcoin就搞死了，很正常。</p>

<p>其实看到最后，最核心的分歧其实就是Bitcoin 主网是否每个节点该继续承担清算的工作，这其实和现实中的货币发展十分相似：</p>

<ol>
<li>市场初期不是那么繁荣，即使交易一次清算一次，货币的物理特性也能顶住，这和bitcoin初期很相似，每个全节点都是清算网关，每笔交易都有一笔清算，安安稳稳跑了十年</li>
<li>市场爆发，原有的清算体系扛不住了，这个时候需要升级技术方案解决；有分歧了，需要把全部交易都上主网吗？买杯咖啡需要记录到主链上吗？毕竟今天区块链还是非常金贵的资源，这个系统每天消耗的电力资金数以亿计了，在上面画画写诗实在是有点浪费；从历史来看，引入闪电网络，小笔交易不再并入主网，变成两个特殊清算节点之间的轧账比较合适</li>
<li>分歧就在这里，有人觉得硬件性能增长完全可以让主网记录人类所有的交易；有人说扯犊子，买咖啡不应该上主网</li>
</ol>


<p>目前的情况来看：</p>

<ol>
<li>闪电网络还是处于实验阶段，有力使不上，主网一直满负荷</li>
<li>扩容派各种斗争，要上位还很远</li>
</ol>


<p>看不清未来方向；其实历史是波浪式前进的，如果顶层设计，我可能倾向于:</p>

<p>先区块扩容一点(提高清算能力)&ndash;>Segwit+闪电网络(集中清算)&ndash;>硬件性能跟上了，继续扩容(再分布式清算)</p>

<p>但是现实斗争就是这么残酷哦，技术最优不代表市场最优，技术市场最优不代表拳头最大~~~所以说历史发展是随机的；像基督教分为犹太教、新教、天主教等等，佛教搞成藏传、南派北派等等，人类就是折腾中前进，比特币出来以后，一度把清算技术搞成了教派斗争，这挺有意思的</p>

<h4>更丰富的商业场景</h4>

<p>不管怎么说，我对于技术的前进还是乐观的，不管是传统的清算中心，还是区块链，如果将来我们的清算能力再有一个指数级飞升，我觉得又会有新的商业模式出现</p>

<ul>
<li>现在的保险行业，比如车险，保险的时段只能一整块时段，同样买了一辆车，有的几个司机合伙24*365天天在外跑，有的上下班每周就几个小时的使用时间，交一样的钱其实不公平；未来可能只有你的引擎发动之后，真正在路上跑了，按照分钟收费，你的钱要一点一点打到保险公司账户上，这样比较合理</li>
<li>娱乐消费行业，目前也是整段时间收费，未来你听一首歌，可能按照 0.0000001元/秒的速度慢慢付款给音乐公司</li>
<li>公益行业: 真正的贫困人口可以开设经过认证的账号，这样土豪捐款的时候可以绕过红十字会，平均账户发放救济金之类，而且可以有各种算法监控，比如每个月固定发个100元，这个账户之后走的是哪个清算单元，进行了什么消费，杜绝骗子的不正当用途</li>
<li>资金审计: 将来的所有公益和对公账户，审计不再是一个问题了，因为你可以追踪所有的清算单元，用智能算法来判断资金最终的流向和目的，财务造假的难度大大增加</li>
</ul>


<h4>引用：</h4>

<p><a href="http://www.gongxiangcj.com/posts/1478">http://www.gongxiangcj.com/posts/1478</a></p>

<p><a href="https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf">https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf</a></p>

<p><a href="https://www.zhihu.com/question/22148261">https://www.zhihu.com/question/22148261</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BCH分叉承担的风险--51%攻击者概率问题]]></title>
    <link href="https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti/"/>
    <updated>2018-11-17T18:42:09+08:00</updated>
    <id>https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>2018-11-16 01:40(UTC+8)发生的BCH分叉实在好看，转载一下进程说明:</p>

<!-- more -->


<blockquote><p>  “分叉前夕：
  BCH硬分叉过程中：第一个区块由澳本聪阵营svpool爆出，区块大小为51.385KB，区块高度为556761。BCH硬分叉连续爆出6个区块才会正式开始分叉。</p>

<p>  BCH硬分叉过程中：第二个区块由澳本聪阵营coingeek爆出，区块大小为8.24kB，区块高度为556762。</p>

<p>  BCH硬分叉过程中：第三个区块由澳本聪阵营SVPool爆出，区块大小为29.44kB，区块高度为556763。</p>

<p>  在BCH硬分叉过程中，ABC阵营开始反击，比特大陆旗下第一大矿池BTC.com已经获得部分客户同意，切换算力支援BCH ABC。ABC阵营Bitcoin.com矿池的BCH算力在分叉前24小时大增1593.09%，超过澳本聪阵营的Coingeek矿池，排名第一。</p>

<p>  BCH硬分叉过程中：第四个区块由吴忌寒阵营Bitcoin.com挖出。区块大小为57.11 kB，区块高度为556764。</p>

<p>  BCH硬分叉过程中：第五个区块由吴忌寒阵营ViaBTC爆出，区块大小为315.40 kB，区块高度为556765。</p>

<p>  BCH硬分叉过程中：第六个区块由澳本聪阵营SVPool爆出，区块大小为2597.76 kB，区块高度为556766。</p>

<p>  区块高度556766：正式分叉。算力大战正式开始。随后比特大陆阵营率先出两个块，并保持持续领先。”</p></blockquote>

<p>Bitcoin.com矿池临时集了4000P的算力，巅峰时Bitcoin ABC的算力达到了8500P，而Bitcoin SV始终没有超过5000P。分叉当晚，实力差距明显。</p>

<p><a href="https://cash.coin.dance/blocks/hashrate">https://cash.coin.dance/blocks/hashrate</a></p>

<p>但是Bitcoin SV目前没有放弃的意思，而且Bitcoin.com抽调的算力会慢慢撤回去，因为SV链没有重放保护，如果一直烧钱维护下去，现在还不能称胜负已分。</p>

<p>Bitcoin SV作为进攻方，按照现在1T算力0.1元/小时的价格计算，每天SV要烧掉$200W 维持这场战争。而且目前在BCH链上挖矿收益绝对小于BTC链，如此烧钱确实是土豪行径。如果CSW始终不加重放保护跟Bitcoin ABC死磕，确实是下决心了。但是如果怂了开始炒作Bitcoin SV，那就说明他也不过是个出来割韭菜的。</p>

<p>但是群众其实也不关心鹿死谁手，反正分叉明朗之前不动就可以了。看戏之余，不妨回顾一下中本聪白皮书中关于51%攻击的计算:</p>

<p>(参考第十一章:计算)</p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p>这个计算过程还是很有意思的，我们天天听各种媒体讲<code>51%攻击</code>，那么现实世界中，现在确实发生了两方争霸的情况，我们定义几个变量:</p>

<ul>
<li>P = 诚实节点制造下一个节点的概率</li>
<li>Q = 攻击者制造下一个节点的概率</li>
<li>Qz = 攻击者追上诚实节点z个区块的差距</li>
</ul>


<p>目前(2018-11-17 17:00 UTC+8)Bitcoin SV链算力4278PH，Bitcoin ABC链算力5677PH，Bitcoin SV落后7个Block。Bitcoin ABC为防守方，Bitcoin SV为进攻方，假如Bitcoin SV就这么死磕到底的话，算力保持不变的情况下，有多大机率能51%攻击呢？如果要提高攻击成功的概率，Bitcoin SV又需要多大的算力呢？</p>

<p>我们又要复习一下概率论里面的ABC了，搬来小方凳，数学课开始~~~~</p>

<h2>酒鬼漫步问题</h2>

<p>当一个喝大了的酒鬼在路上摇摇晃晃时，你是否会担心他还有能力避开一切障碍，成功找到家门而不是掉到某个下水沟里吗？</p>

<p>实际上，这正是非常有趣的酒鬼漫步问题，不妨让这个酒鬼的处境更夸张一些，设想他站在悬崖边，面前就是万丈深渊。如果他往后退一步远离悬崖的概率是 2/3 , 向前一步靠近悬崖的概率则是 1/3。那他摔下悬崖的概率是多少?</p>

<p>答案肯定不会是简单的 1/3。那不如先来看看酒鬼最初的几步会发生什么。下图是对这个酒鬼最初几步所有可能的轨迹的枚举。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg1.png" alt="img" /></p>

<p>从图中可以看到，达到<code>0</code> 即意味着跌落悬崖。所以在 <code>0</code> 的那些概率的和便是酒鬼前六步掉下悬崖的概率。这个图可以无限推演下去。</p>

<p>所以让我们把这个场景放到数轴上，换一种方式来看。如此一来醉鬼悬崖边漫步就相当于质点沿轴心运动这类问题了。酒鬼在这个数轴上随意地左右走动， 走到 x = 0 的位置意味着被吸收 ，也就是摔下了悬崖。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg2.png" alt="img" /></p>

<p>假设他向右一步的概率为 <code>p</code>，向左的概率为 <code>1－p</code>。当他在 <code>x = n（n&gt;0）</code> 的位置的时候，不是向右就是向左。记 <code>P（n）</code>为从 <code>x = n</code> 的位置出发，最后到达 <code>x = 0</code> 被吸收的概率。酒鬼一开始在 <code>x = 1</code> 的位置，我们要求的就是他到 0 的概率。</p>

<p>当酒鬼走完第一步后，他要么到了 <code>x = 0</code>（此事件发生的概率是 1－p），要么到了 <code>x = 2</code> 的位置（此事件发生的概率是 p），他再从 <code>x = 2</code> 出发最终走到 <code>x = 0</code> 被吸收的概率就是 <code>P（2）</code>。这时我们可以得到方程1:</p>

<p><code>
P(1) = 1 - p + p * P(2)
</code></p>

<p>而自 <code>x =2</code> 走出并最终到达 <code>x = 0</code> 的情况可以分解为两个阶段：先从 <code>x = 2</code> 到 <code>x = 1</code>（可以走任意步）, 然后从 <code>x = 1</code>到 <code>x = 0</code>（同样可以走任意步）。我们知道后一个的概率是 P（1）,那么前一个呢？其实是一样的，也是 P（1），它可以看作后一种情况的平移。又因为这两个事件相互独立，所以得到方程2:</p>

<p><code>
P(2) = P(1)²
</code></p>

<p>将方程2代入方程1，得到一个简单的一元二次方程:</p>

<p><code>
P(1) = 1 - p + p* P(1)²
</code></p>

<p>解得  <code>P(1) = 1</code>  或者   <code>P(1) = (1-p)／p</code></p>

<p>注意到这里 p 表示的是酒鬼每次向x轴正方向前进一步的概率，也就是他站在悬崖边上向后退的概率。我们不妨根据这个概率的取值情况来对酒鬼悬崖漫步这个问题做个总结。</p>

<p>当 p 等于 0 或 1 时，这显然就成了必然事件，酒鬼一定掉下悬崖或者一定能安全地离开。</p>

<p>但有趣的是，即便当 p 不是 0，在它小于等于 &frac12; 时，这个酒鬼一样难逃失足的厄运。</p>

<p>当 <code>p = 1/2</code>时， P(1) = 1</p>

<p>众所周知，一个事件发生的概率不会超过 1。所以从上面可以看出，当 <code>p ≤  1/2</code>时，也就是这个酒鬼每步选择向后退的概率不足一半时，不管他能离开悬崖有多远，最终都必将粉身碎骨。</p>

<p>而如果 p 在 （1/2 , 1） 这个区间里，这时候酒鬼摔落悬崖的概率实际上是一个关于 p 的连续函数。我们可以做出 P(1) 的图像如下</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg3.png" alt="img" /></p>

<p>现在让我们回答最初的问题，当酒鬼向后走的概率为2/3时，他摔下悬崖的概率为 &frac12; 。 很违背直觉的结果，保持一半清醒是不够的，最少要2/3的清醒。</p>

<h2>从酒鬼漫步到赌徒破产</h2>

<p>把酒鬼徘徊应用到赌博中会得到一个不可思议的结论。假设一个赌徒的赌金是 n，每次的下注金额是 1，而每盘赌局输赢概率各是 1／2。如果一直赌下去的话，赌徒输光的概率是多少呢？</p>

<p>由前面的分析可知，他破产的概率就是前面定义的 <code>P（n）</code>。 <code>P（n）</code>是 <code>P（1）</code> 的 n 次方，而 <code>P（1）</code> 在酒鬼等概率地向两个方向迈步的时候等于 1,所以 <code>P（n）＝1</code> ！这告诉我们，即使是公平赌局，你跟赌场玩，最后也一定会输光的！</p>

<p>这就是著名的赌徒破产问题（Gambler’s ruin）。</p>

<p>显然，赌徒的钱越多，输光需要的局数也越多。当赌徒的赌金是 n 时，我们记输光的概率为 p(n)。因为每次赌局有一半的可能赢，一半的可能输，赢的时候赌金变成 <code>n + 1</code>，输的时候变成 <code>n - 1</code>，所以 <code>p(n) = (p(n + 1) + p(n - 1))／2</code>。当 <code>n = 0</code> 的时候，即使不用赌，所有东西也都输光了，所以 <code>p(0) = 1</code>。</p>

<p>由此，p 可以看作一个满足下列递推关系的数列</p>

<p>```
p(0) = 1</p>

<p>p(n+1) = 2 * p(n) &ndash; p(n-1)，</p>

<p>```</p>

<p>也就是
<code>
p(n+1) - p(n) = p(n) - p(n-1)
</code></p>

<p>容易验证 <code>p(n) = n * p(1) - (n-1)</code> 正好符合上面的递推关系。</p>

<p>又因为<code>p(n) ≥ 0</code>，所以对于任意的 n，必定有 <code>p(1) ≥ 1 - 1／n</code>。因此 <code>p(1) = 1</code>。那么对于所有的 n，则有 <code>p(n) = 1</code>。这意味着，在无限次的赌博中，赌徒在某一次赌博中输光的概率是 1。</p>

<p>这个发现其实和经典的赌徒谬误异曲同工。上帝创造这个世界的一些规则真是意味深长啊，当你要赌的时候，50%的胜率是不够的，一定要有>50%的把握!</p>

<h2>从赌徒破产到算力攻击</h2>

<p>将上面两个例子映射到区块链算力争霸的过程中，发现有惊人的相似点。</p>

<h4>情况1</h4>

<p>当两条分叉从同一起点开始竞争时，就是一个酒鬼漫步问题；攻击者一方相当于不断的要逼近诚实者一方挖出的区块高度；</p>

<ul>
<li>诚实节点：block1&mdash;&mdash;&mdash;block2&mdash;&mdash;&mdash;block3&mdash;&mdash;&mdash;block4&mdash;&mdash;&mdash;</li>
<li>攻击节点：block1&mdash;&mdash;&mdash;block2A&mdash;&mdash;-block3A&mdash;&mdash;&ndash;</li>
</ul>


<p>攻击节点从block2开始攻击，尝试双花其中的交易，并挖出区块block2A。攻击节点挖出的链要比诚实节点挖出的链长——在本例中，它至少要挖到block5——才算攻击成功。我们把诚实节点的链长度减去攻击节点的链长度，得到的差记为n。诚实节点每挖出一个块则n+1；攻击节点每挖出一个块则n-1。我们把n放到数轴上<code>n-1  ←  n  → n+1</code>；攻击节点挖出一个块，相当于酒鬼向左移一步；诚实节点挖出一个块，相当于酒鬼向右移一步。设诚实节点领先n个块，如果攻击节点的算力达到或超过了全网的50%，那么它一定能把n减到0。而如果攻击者算力小于50%，则n越大，也就是确认数越多越安全。从这里你们也可以看出来，我们通常所说的51%攻击，是一个没看懂白皮书的人定下的名词。其实应该定名为50%攻击，攻击者不需要大于50%的算力就能成功。</p>

<p>在BCH的分叉战中，如果有一条链的算力一开始能达到算力的50%并保持下去，就可以杀死另外一条链；</p>

<h4>情况2</h4>

<p>但是随着链的延长，两边的算力便会拉开差距，挖出的快总是有多有少；算力战预测的初始条件变成了这样:</p>

<p>从交易被收录进区块的时候开始，诚实矿工出了z个块。攻击矿工在此期间出块数记为k，只要攻击者不广播别人就不知道，k可能等于0、1、2……直到无穷大。</p>

<ul>
<li>若k>z，攻击直接成功；若k&lt;=z，攻击者仍有可能追上，其成功的可能性即赌徒破产问题。因为攻击失败的情况有限，所以计算成功概率改为计算等价的<code>1-攻击失败的概率</code>。</li>
</ul>


<p>首先研究k，假定诚实矿工以均匀的速度出块，则k近似服从泊松分布：<code>P(k, λ)</code>；</p>

<p>就是“在一个指定长度的固定区间内有k个点（事件）”的概率。诚实矿工出z块的时间即“指定长度的固定区间”，攻击矿工出块次数k即“事件”，每种k出现的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg4.png" alt="img" /></p>

<p>其中λ是攻击矿工出块的期望，假设比特币的算力简化计算为:</p>

<p>速度 * 时间 = 工作量。</p>

<p>z是防御者的工作量，p是防御者的速度，z/p是防御者消耗的时间。防御者的时间=攻击者的时间。攻击者的速度=q；</p>

<p><code>攻击者的工作量期望 = 攻击者的速度 * 攻击者的时间 = q * z / p</code>。 即 <code>λ = z*q/p</code>。</p>

<p>根据赌徒破产问题，在落后了z-k个块之后仍旧能追上的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg5.png" alt="img" /></p>

<p>追不上的概率为:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg6.png" alt="img" /></p>

<p>每种k (k&lt;=z)出现的概率，乘以它追不上的概率，就是这个k的失败率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg7.png" alt="img" /></p>

<p>1-所有攻击失败情况的概率之和，就是攻击成功的概率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg8.png" alt="img" /></p>

<h2>总结</h2>

<p>当前Bitcoin SV算力占总算力的43%，落后7个block，取q=0.43, p=0.57, 计算成功率已然小于10%了。</p>

<p>那么，Bitcoin SV要把算力提高到多少，才能有50%的希望追上Bitcoin ABC呢？ 这是个复杂的问题啊，首先从分叉一晚的算力战来看，目前BitcoinABC可以调动的算力总量为8500P，所以Bitcoin SV目前一定要调动>8500P的算力，才能有翻盘的机会，至于需要多大才能把翻盘机会搞到50%，课后作业计算吧。</p>

<blockquote><p>PS:有个小漏洞，因为BCH的难度计算和BTC是不一样的，我不是很确定情况2的计算是否可以假设为泊松分布。</p></blockquote>

<p>当然，这是一个模拟，真实情况是，发生危机时，bitmain会不断的从BTC那边调集算力过来；这其实是BCH在吸血BTC的算力；</p>

<p>目前来看，BTC的算力有46EH，目前市场上所有的SHA256算力可能总共>60EH；如果算力占再升级，都可以看成是BCH链对BTC链的攻击了。而且只要Bitcoin SV一天不加重放保护，那么交易所就不太可能开放冲提币，这样BCH 链上的交易就会继续停滞，表面上来看是Bitcoin SV一方在烧钱，其实是BCH整条链都在烧钱。现在真正是考验信仰的时候，短期来看，输家会一无所有。赢家也未必能赚到什么。非常残酷的算力战。这真是难得一见，再过10年，真的像中本聪预测的那样，比特币广泛应用后，这种算力战出现的概率极小。某种意义上来说，这个热闹真好看啊:</p>

<p>每天投入$200W的豪赌!</p>

<p>这也进一步验证了，同一个POW算法，最多只能存在一条链，因为即使加了重放保护分叉，还是无法逃脱算力威胁；BCH是一条非常非常特殊的链，它是由bitmain大算力保证的小算力链；这么说可能有点绕口，可以看成BTC和BCH的战争会持续下去，我认为一定会有一方死亡！至于持续多长时间就不好说了，但是我认为这种平衡不可能无限保持下去，必然会发生黑天鹅事件。</p>

<p>另外，像PPC等SHA256 POW币，或者ETC之于ETH，也是同样的情况；我抱持一种观点：</p>

<blockquote><p>同样的POW算法，如果有大算力存在的情况下，一定归于一条链；
中间可能会多链并存很长时间，但总会发生黑天鹅事件将其它链清零</p></blockquote>

<h4>引用:</h4>

<p><a href="https://www.guokr.com/article/59575/?page=3">https://www.guokr.com/article/59575/?page=3</a></p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p><a href="https://www.zhihu.com/question/263764571">https://www.zhihu.com/question/263764571</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bicoin Cash分叉在即]]></title>
    <link href="https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji/"/>
    <updated>2018-11-15T15:08:32+08:00</updated>
    <id>https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji</id>
    <content type="html"><![CDATA[<p>Bitcoin Cash 将于UNIX时间1542300000 (即北京时间2018年11月16日00：40)发生硬分叉;</p>

<p>分叉两派是比特大陆为首支持的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc">Bitcoin ABC</a>实现，以及Craig Steven Wright为首的<a href="https://github.com/bitcoin-sv/bitcoin-sv">BItcoin SV</a>实现。</p>

<p>两派的恩恩怨怨政治斗争无心吐槽，咱也没有明确的倾向；但是作为码农咱要黑一黑；</p>

<!-- more -->


<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/2ab7775797a5a37ab311ab9a067771e5c1bfe22a">这里</a>是bitcoin SV 从Bitcoin ABC项目里面开始folk出来的修改；截至他们发布Bitcoin SV Beta1.0；最后提交的代码是<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/d9b12a23dbf0d2afc5f488fa077d762b302ba873">d9b12a23dbf0d2afc5f488fa077d762b302ba873</a></p>

<p>执行 <code>git diff 802629f d9b12a --stat</code> 瞄一眼:</p>

<p><code>
699 files changed, 11634 insertions(+), 197401 deletions(-)
</code></p>

<p>看起来改了不少，但是从头review一遍，他们从2018-08-22搞到现在，啥实质改动都没有，就开了几个操作码，改了几个测试；原本MAXBLOCKSIZE就变成可配置的了，他们不过是稍稍改了一下判断条件而已，改动最大的反而是README和release notes文件，最值得吐槽的就是这个提交：</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d">https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d</a></p>

<p>好吧，也不能无脑黑你，你还是修掉了一个比较重要的BUG的:</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86</a></p>

<p>凭良心说，Bitcoin ABC的开发比不上Bitcoin Core的活跃，但起码Bitcoin Core有什么更新，人家能及时Merge过来啊！</p>

<p>曾经，像Bitcoin Gold之流，改个POW算法就出来割韭菜了，大家还愤愤不平；</p>

<p>Litecoin和Dogcoin还是改了改币数上限和出块时间的，这是在早期，咱们也忍了~~</p>

<p>如今Bitcoin SV的代码库让我见识了什么叫任性！</p>

<p>如果不赞成升级，原版代码运行就是；现在哥们，你们倒是放开了操作码！但是操作码执行实现的部分好好测试过了吗，对应的测试在哪里？就两天时间开放出来不怕出BUG吗？</p>

<p>同样的一个<a href="https://bitcoincore.org/en/2018/09/20/notice/">重要BUG处理</a>:</p>

<p>Bitcoin ABC的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc/commit/7e20479893089b2b80f81cc2e7e5712a2d4158ba">重构+修正</a>，BitcoinSV的<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">修正</a>; 态度啊~~</p>

<p>我觉得数字货币这个场子没啥正义公理权威可言，就是中本聪重现人间，相信说话也没多大分量了；但是代码质量是没办法靠嘴炮提升的；长久来看，占据市场还是要靠产品质量啊。</p>

<p>但是不管怎么样，接下来的战争是一场明刀明枪的较量，没有重放保护，双方都是投入真金白银维护自己的立场，这比空气币收割韭菜实诚多了；</p>

<p>比特币这个社会实验已然十年，终于出现了白皮书所描写的第一场大规模算力战争，值得期待啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-3]]></title>
    <link href="https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3/"/>
    <updated>2018-11-07T19:59:04+08:00</updated>
    <id>https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3</id>
    <content type="html"><![CDATA[<p>通过前面两篇文章，我们认识到比特币的所有权是通过私钥来确定的。</p>

<p>那么我们就在此基础上研究比特币钱包的构成。广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，比特币钱包的核心就是对私钥的管理。</p>

<p>在比特币的历史发展中，钱包大致经过了三次进化:</p>

<ol>
<li><p>非确定性（随机）钱包</p></li>
<li><p>确定性（种子）钱包</p></li>
<li><p>分层确定性钱包（HD Wallets (BIP-32/BIP-44)）</p></li>
</ol>


<p>下面我们就好好说说钱包的历史发展轨迹</p>

<!-- more -->


<h2>非确定性（随机）钱包</h2>

<p>在比特币刚诞生时，Bitcoin Core客户端实现了第一个钱包功能，当时因为早期的用户并不多且都是专业人士，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。具体的实现细节就是:
比特币核心客户端预先生成100个随机私钥，每个密钥只使用一次；用完之后再生成100个；</p>

<p>这样做的缺点十分明显：</p>

<p>如果你生成很多私钥，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址重复使用将多个交易和地址关联在一起，这会减少隐私。</p>

<p>当比特币用户群逐渐扩大时，不少人因为随机生成的100个私钥用完后，没有备份老钱包，生成新的私钥后原先的钱包弃用，造成了未花费币的丢失。现在看看是个不可思议的幼稚的BUG，但是在比特币蛮荒时代，这种漫不经心的错误导致的丢币比比皆是。</p>

<h2>确定性（种子）钱包</h2>

<p>比特币私钥可以用任意方法生成，自然也可以通过一个随机短语进行多次hash得到不同的私钥。这种思路下，社区提出了确定性（种子）钱包的方案。</p>

<p>确定性，或者“种子”钱包包含通过使用HASH函数而可从公共的种子生成的私钥。种子是随机生成的数字。在确定性钱包中，种子足够恢复所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包导入或者导出。这就很容易允许使用者的私钥在钱包之间轻松转移。</p>

<p>比如，我们上一篇文章中用<code>satoshi</code>作为种子，得到SHA256(&lsquo;satoshi&rsquo;)作为私钥，完全可以继续用SHA256(SHA256(&lsquo;satoshi&rsquo;))&hellip;这样推导下去得出更多的私钥，同时，只需要记住<code>satoshi</code>这个种子，就可以方便的导入导出私钥。更进一步，可以加入password和更多的混淆短语，提高私钥生成的健壮性。</p>

<p>这种方案提出后，因为简单易行，多个轻钱包都做了自己的实现；虽然原理相似，但是他们之间并不通用，所以不同的钱包私钥导入导出还有一些不方便。社区就在此基础上继续探索，最终整理形成了BIP32、BIP39、BIP43，BIP44等规范，创造了我们今天通用的HD钱包。</p>

<h2>分层确定性钱包（Hierarchical Deterministic wallet&mdash;HD Wallet）</h2>

<p>首先用一张经典的图来描述HD钱包的私钥生成:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg1.jpg" alt="img" /></p>

<p>分层钱包说白了，就是将<code>seed-&gt;私钥</code>的过程变成了，<code>助记词-&gt;seed-&gt;一级私钥-&gt;二级私钥-&gt;三级私钥....</code>，即多层树状私钥生成的方案。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。HD钱包有两个主要的优势。</p>

<ol>
<li><p>树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。</p></li>
<li><p>它可以允许使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要存储私钥。</p></li>
</ol>


<p>再来一个在线工具用于验证:</p>

<p><a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a></p>

<p>最初的私钥seed来源于一个助记词（又称为Mnemonic Code），为了便于在不同的钱包中转移、导出和导入，社区对助记词的长度，范围，变换标准等等做了详尽的描述，最终形成了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>规范。这个规范由Trezor硬件钱包背后的公司提出，已经成为事实上的行业标准。</p>

<p>BIP-39定义了助记符码和种子的创建， 为了清楚起见，该过程分为两部分：</p>

<p>先是创建助记词，然后是从助记词到种子。下面我们从一个<code>ffffffffffffffffffffffffffffffff</code> 的128bits 熵开始，演示HD钱包是如何生成、管理私钥的。让我们一步一步解释。</p>

<h3>先看看创建助记词的部分</h3>

<h4>生成步骤</h4>

<ul>
<li><p>1、创建一个128到256位的随机序列（熵）。我们取<code>ffffffffffffffffffffffffffffffff</code>，称之为原始熵。</p></li>
<li><p>2、用SHA256 HASH原始熵，就可以创造一个随机序列的校验和。代码如下</p></li>
</ul>


<p><code>
from binascii import unhexlify
from hashlib import sha256
data = 'f' * 32
data_unhexlify = unhexlify(data)
h = hashlib.sha256(data_unhexlify)
checksum = bin(int(h, 16))[2:].zfill(256)[:len(data) * 8 // 32]
</code></p>

<p>得到checksum为<code>0101</code></p>

<ul>
<li>3、首先求得原始熵的二进制表示，然后将校验和添加到随机序列的末尾。代码如下:</li>
</ul>


<p><code>
from binascii import unhexlify, hexlify
data = 'f' * 32
data_unhexlify = unhexlify(data)
body = bin(int(hexlify(data), 16))[2:].zfill(len(data) * 8)
final_result = body + checksum
</code>
得出的结果为</p>

<p><code>
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101
</code></p>

<ul>
<li>4、将序列划分为包含11位的不同部分。</li>
</ul>


<p><code>
11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111110101
</code></p>

<ul>
<li>5、将每个包含11位部分的值作为下标索引，与一个已经预先定义2048个单词的字典做对应。BIP39中对应的字典文件可以参考这里:</li>
</ul>


<p><a href="https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist">https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist</a></p>

<p>以上二进制表示的下标值为:</p>

<p><code>
2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2037
</code></p>

<p>为什么单词数目是2048呢？ 其实seed可以有12-24个单词，所有的组合可能性为 2048<sup>12</sup> &mdash; 2048<sup>24</sup>；</p>

<p>还记得我们之前的文章吗？比特币公钥->地址的倒数第二步是RIPEMD160，他一共有2<sup>160</sup>可能性，上面seed的生成空间覆盖了RIPEMD160的生成空间。</p>

<ul>
<li>6、生成的有顺序的单词组，就是助记码(Mnemonic Code)。在咱们的例子中如果采用英文字典，对应的结果为:</li>
</ul>


<p><code>
zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong
</code></p>

<p>一张图展示熵如何生成助记词:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg2.jpg" alt="img" /></p>

<p>在上面这个例子中，我们选取了128Bits 原始熵，BIP39规范中，用户有128bits, 160bits, 192bits, 224bits, 256bits多个选择;下面的表格说明了熵数据的大小和助记词的长度之间的关系:</p>

<table>
<thead>
<tr>
<th>Entropy(bits) </th>
<th> Checksum(bits)</th>
<th> Entropy + checksum(bits) </th>
<th> Mnemonic length(words)</th>
</tr>
</thead>
<tbody>
<tr>
<td>128</td>
<td>4</td>
<td>132</td>
<td>12</td>
</tr>
<tr>
<td>160</td>
<td>5</td>
<td>165</td>
<td>15</td>
</tr>
<tr>
<td>192</td>
<td>6</td>
<td>198</td>
<td>18</td>
</tr>
<tr>
<td>224</td>
<td>7</td>
<td>231</td>
<td>21</td>
</tr>
<tr>
<td>256</td>
<td>8</td>
<td>264</td>
<td>24</td>
</tr>
</tbody>
</table>


<p>目前最流行的实现还是跟我们上面的例子一样，选取128bits->12words 的Mnemonic code生成。</p>

<h3>从助记词生成种子</h3>

<p>现在我们已经从<code>ffffffffffffffffffffffffffffffff</code>随机熵得到了助记码<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>，现在需要从助记码再生成种子。</p>

<h4>PBKDF2函数</h4>

<p>这里我们需要先介绍一个函数:PBKDF2(Password-Based Key Derivation Function)，它是一个用来导出密钥的函数，常用于生成加密的密码。</p>

<p>它的基本原理是通过一个伪随机函数（例如HMAC函数），把明文和一个salt值作为输入参数，然后重复进行运算，并最终产生密钥。</p>

<p>如果重复的次数足够大，破解的成本就会变得很高。而salt值的添加也会增加“彩虹表”攻击的难度。</p>

<p>嗯，我们还要稍微解释一下HMAC的意义:</p>

<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>

<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p>

<p>采用不同的hash算法时如何混入salt，可能大家八仙过海各显神通；后来为了统一化，有人提出了Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把salt混入计算过程中。</p>

<p>简而言之，HMAC提供了标准的在HASH过程中混入salt的方法。 HMAC方法适用于任意HASH函数。</p>

<p>而比特币私钥生成过程中采用的PBKDF2算法，大量使用HMAC-SHA512算法，使用2048次 HASH来延伸助记符和salt参数，产生一个512位的值作为其最终输出。</p>

<p>这个512位的值就是种子。</p>

<h4>利用PBKDF2从助记词得到种子步骤</h4>

<p>1、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符(<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>)。</p>

<p>2、PBKDF2密钥延伸函数的第二个参数是salt。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成 (<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code> + <code>test</code>)。</p>

<p>3、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和salt参数，产生一个512位的值作为其最终输出。 这个512bits的值就是种子:</p>

<p>```</p>

<blockquote><p>import hashlib
import hmac
from pbkdf2 import PBKDF2
from binascii import hexlify
PBKDF2_ROUNDS = 2048
mnemonic = &ldquo;zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong&rdquo;
passphrase = &ldquo;test&rdquo;
seed = PBKDF2(mnemonic, &lsquo;mnemonic&rsquo; + passphrase, iterations=PBKDF2_ROUNDS, macmodule=hmac, digestmodule=hashlib.sha512).read(64)
print(hexlify(seed))</p></blockquote>

<p>b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'
```</p>

<h3>从种子中创造HD钱包</h3>

<p>我们已经得到了一个512bits的种子，我们把这个种子称之为<code>根种子</code>(root seed)。这个根种子是下面一切私钥产生的源泉。</p>

<p>让我们再回忆一下最开始的一张示意图：所有的私钥是成树状结构的。树的每一层都有无限分支，然后每一个分支都可以派生出下一层，这个结构该如何从根种子来构建呢？</p>

<p>这是一个精妙的设计。下面我们还是采用步步为营的方法来演示一遍:</p>

<h4>私有子密钥的衍生</h4>

<ul>
<li>1、 首先我们需要安装一个BIP32 Python解析库<code>pip install bip32utils</code>:</li>
</ul>


<p><a href="https://pypi.org/project/bip32utils/">https://pypi.org/project/bip32utils/</a></p>

<ul>
<li>2、 根种子输入到HMAC-SHA512中，得到一个512bits的输出:</li>
</ul>


<p>```</p>

<blockquote><p>import binascii
import hmac
seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'
entropy = binascii.hexlify(seed)
I = hmac.new(b"Bitcoin seed", entropy, hashlib.sha512).digest()
```</p></blockquote>

<ul>
<li>3、 这个512bits的<code>I</code>可以分为两个部分，左边的256bits用作Master Private Key，右边的256bits用作Master Chain Code。Master Private Key又可以推导出Master Public Key。整个表示如下:</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg3.jpg" alt="img" /></p>

<ul>
<li><p>4、 这样我们从一个512bits的输出里面分成了两个变量: Master Pirvate Key以及Master  Chain Code；下面分别说说他们的作用</p>

<ul>
<li><p>Master Private Key: 又被称作母私钥，很明显的，它可以衍生出公钥以及地址；但是我们的需求是生成多个公私钥对，所以我们又引入了一个索引号(32 bits)的概念，这样，一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，因为另一半是为特定类型的推导而保留的，我们将在稍后讨论。</p></li>
<li><p>Master Chain Code: 有了Master Private Key，可以在这一层生成2<sup>31</sup>个子私钥，但是这样无法得到我们想要的分层结构；于是就需要Master Chain Code的帮忙。这样上面的步骤我们需要三个输入：将Master Chain Code和Master Private Key以及索引号作为HMAC-SHA512的输入，又可以得到一个512bits的输出，左边的256bts就是我们需要的子私钥；重复这个过程，我们就得到了一个分层的私钥结构</p></li>
</ul>
</li>
<li><p>5、让我们总结一下这个过程:</p>

<ul>
<li>每次HMAC-SHA512，都得到一对Master Private Key以及Master Chain Code，再加上引入一个索引号，我们就能在这一层生成2<sup>31</sup>个私钥</li>
<li>用这一层的Master Chain Code和Master Chain Code以及选取一个固定的索引号作为HMAC-SHA512的输入，又可以得到下一层的Master Private Key以及Master Chain Code，</li>
<li>重复这个递归的过程就可以构造一棵私钥树状结构</li>
<li>这个递归构造的函数我们称之为CKD（child key derivation)函数</li>
</ul>
</li>
<li><p>6、 CKD (子密钥衍生函数): 这个函数有三个输入</p>

<ul>
<li>一个母私钥(Master Private Key 256bits)</li>
<li>一个链码(Master Chain code 256 bits)</li>
<li>一个索引号 (32 bits)</li>
</ul>
</li>
</ul>


<p>这三个输入可以得到一个512bits的输出，在得到一个私钥的同时，也可以作为一棵树的根节点，从而衍生出无数个子密钥。</p>

<p>叶子节点衍生出的子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。</p>

<h4>扩展密钥</h4>

<p>正如我们之前看到的，CKD函数可以被用来创造密钥树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key）。术语“extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p>

<p>引入我们之前的例子，这里我们第一层的扩展密钥为:
```</p>

<blockquote><p>from bip32utils import BIP32Key
from binascii import hexlify
seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870d
root = BIP32Key.fromEntropy(hexlify(seed))
print(root.ExtendedKey())</p></blockquote>

<p>xprv9s21ZrQH143K35KaAEjp6RjB4LoeCR3prWBv6vmX7HuGnPFygragV39uDC24D3UZvMnWbhame5nykoXCcfy1Rbgg8uqSzmwoQgFEqt2bUNy
```</p>

<p>第一层的扩展私钥也被称之为<code>BIP32 Root Key</code>；</p>

<p>得到了一个扩展私钥，就代表得到了树状结构中某个层级的完全控制权，这个扩展密钥可以创造出子密钥并且作为根节点能创造出密钥树结构中的整个分支。分享扩展密钥就可以访问整个分支。</p>

<h4>公共子密钥推导</h4>

<p>再审视一下前面的CKD函数，第一个输入是<code>一个母私钥(Master Private Key 256bits)</code>，这让我们思考，如果不是输入私钥，而是输入公钥会发生什么呢？</p>

<p>通过母公钥衍生子私钥为分层确定性钱包带来的一个很有用的特点，就是可以不通过私钥而直接从公共母密钥派生出公共子密钥的能力。</p>

<p>因此，扩展密钥可以在HD钱包结构的分支中，被用来衍生所有的公钥（且只有公钥）。</p>

<p>这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。</p>

<p>这种方案的常见应用是安装扩展公钥电商的网络服务器上。网络服务器可以使用这个公钥衍生函数去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公钥。</p>

<p>这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包），与此同时扩展公钥可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如 Trezor）签署交易。下图阐述了扩展母公钥来衍生子公钥的传递机制。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg4.jpg" alt="img" /></p>

<h4>硬化子密钥的衍生</h4>

<p>从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。</p>

<p>为了应对这种风险，HD钱包使用一种叫做硬化衍生(hardened derivation）的替代衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥，如图所示。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg5.jpg" alt="img" /></p>

<p>当强化私钥衍生函数被使用时，得到的子私钥以及链码与使用一般衍生函数所得到的结果完全不同。得到的密钥“分支”可以被用来生产不易被攻击的扩展公钥，因为它所含的链码不能被用来开发或者暴露任何私钥。强化衍生也因此被用在上一层级，使用扩展公钥的密钥树中创造“间隙”。</p>

<p>简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层级的子密钥最好使用强化衍生。</p>

<h4>正常衍生和强化衍生的索引号码</h4>

<p>还记得我们前面说:一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，另一半是做什么的呢？</p>

<p>用在衍生函数中的索引号码是32位的整数。为了区分密钥是从正常衍生函数中衍生出来还是从强化衍生函数中产出，这个索引号被分为两个范围。索引号在0和2<sup>31</sup>–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2<sup>31</sup>和2<sup>32</sup>– 1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生。因此，索引号小于2<sup>31</sup>就意味着子密钥是常规的，而大于或者等于2<sup>31</sup>的子密钥就是强化型的。</p>

<p>为了让索引号码更容易被阅读和展示，强化子密钥的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0'。第二个强化密钥依序有了索 引号0x80000001，且被显示为1'，以此类推。当你看到HD钱包索引号i'，这就意味着 2<sup>31</sup>+i。</p>

<h3>HD钱包密钥识别符</h3>

<p>我们看到，一个树状的私钥组织，命名就成了一个问题，如何快速的表示<code>这是一个由第三层的第n个扩展子私钥衍生的主密钥</code>呢？</p>

<p>答案是类似于文件路径的命名规则。</p>

<p>每个级别之间用斜杠（/）字符来表示。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。</p>

<p>密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。</p>

<h4>HD钱包树状结构的导航</h4>

<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及子分支的可能性是无穷的。</p>

<p>两个比特币改进建议（BIPs）提供了这个复杂问题的解决办法——通过创建几个HD钱包树的提议标准。BIP-43提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP-43，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i'/是 为了表明那个被索引号“i”定义的特殊为目地。</p>

<p>在BIP-43标准下，为了延长的那个特殊规范，BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m/44'/。 BIP-44指定了包含5个预定义树状层级的结构：</p>

<p><code>
m / purpose' / coin_type' / account' / change / address_index
</code></p>

<p>第一层的purpose总是被设定为44'。</p>

<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44'/0'、Bitcoin Testnet is m/44'/1'，以及 Litecoin is m/44'/2', Ethereum 是 60'。</p>

<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性子账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m/44'/0'/0' 和 m/44'/0'/1'。每个账户都是它自己子树的根。</p>

<p>第四层级就是“change”。每一个HD钱包有两个子树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>

<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44'/0'/0'/0/2。</p>

<h2>几个BIP规范</h2>

<p>到这里为止，我们已经了解到了比特币HD钱包的绝大部分构造知识。如果能完全理解了上述内容，我们已经是<code>专家</code>了。让我们再简要回顾一下过程:</p>

<ol>
<li>生成一个随机序列作为原始熵</li>
<li>通过一系列变换操作得到了一个Mnemonic Code，这些操作需要大量的HASH过程，抵御了暴力碰撞。同时，生成的Mnemonic Code作为人类易读的助记词，可以轻易的抄写备份，导入导出，这个Mnemonic  Code代表着钱包的完全控制权</li>
<li>从Mnemonic得到了一个root seed，进而转化为 BIP32 Root Key，这可以构造一棵私钥树的根节点</li>
<li>从BIP32 Root Key开始，可以构造更多的公共子密钥，或者公共密钥；根据使用场景的不同，可以构造出完全控制的HD钱包，或者离线签署的只读钱包。</li>
</ol>


<p>这上面一系列的操作细节，被社区总结到了几个BIP规范当中。</p>

<h4>BIP32</h4>

<p>定义 Hierarchical Deterministic wallet (简称 &ldquo;HD Wallet&rdquo;)，是一个系统可以从单一个 seed 产生一树状结构储存多组 keypairs（私钥和公钥）。好处是可以方便的备份、转移到其他相容装置（因为都只需要 seed），以及分层的权限控制等。</p>

<h4>BIP39</h4>

<p>将 seed 用方便记忆和书写的单字表示。一般由 12 个单字组成，称为 mnemonic code(phrase)，中文称为助记词或助记码。例如：</p>

<p><code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code></p>

<h4>BIP43</h4>

<p>提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”</p>

<h4>BIP44</h4>

<p>基于 BIP32和BIP43 的定义，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支持多币种、多帐户等。各层定义如下：</p>

<p><code>
m / purpose' / coin_type' / account' / change / address_index
</code></p>

<p>其中的 purporse' 固定是 44'，代表使用 BIP44。而 coin_type' 用来表示不同币种，例如 Bitcoin 就是 0'，Ethereum 是 60'。</p>

<h4>BIP49，BIP84, BIP141</h4>

<p>加入隔离验证后的账户方案</p>

<h2>总结</h2>

<p>呼，漫长的一顿操作之后；我们终于拥有了一个完整的HD钱包，它有下面几个特性:</p>

<ol>
<li>只要记住seed，即12-24个单词，就可以在不同得系统中导入/导出这个钱包，并掌有完全的控制权，除了知道seed的人，世界上没有任何一个组织能操作这个账户</li>
<li>这个钱包拥有衍生无数个账户的能力，并通过树状层次组织</li>
<li>这棵树的任意一个节点都可以衍生出一棵子树，适用于大型组织的财务处理；比如国王拥有根seed的绝对掌控权，他分配了几个一级扩展私钥给总理大臣，而这几个一级扩展私钥又可以作为根节点衍生出二级扩展私钥分配给更多的人&hellip;..依次衍生下去无穷无尽，每一级的扩展私钥掌控者都拥有下级的资金调度权力，而同级别的私钥掌控者互不可见；</li>
<li>通过一个类似于文件系统命名的路径方式，扩展私钥的拥有者可以掌管任意一个子节点的账户，比如将来全家共享一个钱包，父母对子女的零花钱流水账有完全的掌控</li>
<li>可以构造出一个完全离线的只用来收款而不能付款的钱包账户，用于海量用户的电子商户系统</li>
<li>可以汇聚多个公私钥体系的电子货币；可以想象，未来所有的电子货币系统都聚集在一个钱包之中</li>
</ol>


<p>是不是非常神奇的感觉；呼呼，写到这里，我们已经将电子货币系统的钱包设计完全探究了一番；</p>

<p>其实这么长篇大论下来，我想要探讨的真正题目是比特币的交易构成，而不是什么钱包构造。</p>

<p>这个文章3年前就想写了，但是无穷尽的前置知识实在是让人望而却步；目前我们总算是对于比特币的账户系统有所了解了，反正我搞明白之后只能发出感叹：<code>设计的实在是太精巧了</code>；</p>

<p>但是比特币的交易构造之精巧，又胜过钱包十倍。走了这么远的路，还是那句话，还早得很呢。</p>

<p>那么，比特币的交易构造又是怎样的呢？我们下次文章再见。</p>
]]></content>
  </entry>
  
</feed>
