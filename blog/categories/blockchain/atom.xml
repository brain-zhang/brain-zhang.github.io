<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-04-24T22:54:16+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谈谈比特币的地址安全问题]]></title>
    <link href="http://happy123.me/blog/2018/04/24/cryptocurrency-security/"/>
    <updated>2018-04-24T21:38:13+08:00</updated>
    <id>http://happy123.me/blog/2018/04/24/cryptocurrency-security</id>
    <content type="html"><![CDATA[<h4>比特币的地址生成过程分为以下几个步骤:</h4>

<ol>
<li><p>随机生成一个32字节(256bits)的私钥k</p></li>
<li><p>采用椭圆曲线算法，以私钥k为起点，将其与曲线上预定的生成点G相乘以获得曲线上的另一点，也就是相应的公钥 K</p></li>
<li><p>进一步SHA256=>RIPEMD160 得到地址原始值A: A = RIPEMD160(SHA256(K))</p></li>
<li><p>对A进行Base58Check编码，添加前置版本号后Double SHA256取最后四个字节作为校验位，最后 Base58Check(前缀+Base58Check(A)+校验)得到最终地址</p></li>
</ol>


<p>整个过程中，私钥的生成空间有256bits，由私钥推出地址过程中，由于用到了RIPEMD160散列，所以生成空间共有160bits。</p>

<p>也就是说，去除版本号变化，某一类型的比特币地址最多有 2<sup>160</sup>个。</p>

<p>为什么有步骤3呢，不光增加了地址复杂度，还降低了HASH碰撞空间(从256bits降到160bits)。</p>

<p>所以中本聪的选择只是带来了不必要的复杂度和浪费吗？最后证明，答案是否定的。有另外一个非常好的理由去使用这个"公钥的哈希值"的地址结构：量子加密技术。量子计算机可以破解椭圆曲线数字签名算法（也就是说，给定一个公钥，量子计算机可以相当快速的找到对应的私钥），但它们不能相类似的逆转哈希算法（或者说他们可以，但是将需要花掉280个步骤来完成一个比特币地址的破解，这仍然是相当不可行的）。因此，如果你的比特币资金存放在一个你没有支出过的地址里（这意味着公钥是没有公开的），它们在量子计算机面前也就是安全的，至少在你把它们花掉之前。有理论上的途径可以让比特币完全免于量子计算机的威胁，但一个地址只是一个公钥的哈希值的事实，意味着一旦量子计算机真的出现了，在我们全面切换之前攻击者可以造成的损失要小得多。</p>

<p>请参考:</p>

<p><a href="http://www.8btc.com/satoshis-genius-unexpected-ways-in-which-bitcoin-dodged-some-cryptographic-bullet">http://www.8btc.com/satoshis-genius-unexpected-ways-in-which-bitcoin-dodged-some-cryptographic-bullet</a></p>

<!-- more -->


<h4>那么是不是我们就此可以高枕无忧了呢?</h4>

<p>2<sup>160</sup> 的散列空间，也足够对抗HASH碰撞了。现在计算机普遍的频率为GH/s的量级，假设我们有1EH/s的算力来碰撞，2<sup>160</sup>/2<sup>60</sup>=2<sup>100</sup>，换算成年单位大概是10<sup>24</sup>年，假设宇宙年龄为100亿年，那么我们碰撞出一个私钥的时间为10<sup>24</sup>/10<sup>10</sup>=10<sup>14</sup> 个宇宙轮回，就是宇宙毁灭重生100,000,000,000,000次，我们有可能破解一个比特币私钥。</p>

<p>那么有人质疑比特币的安全性，我们大可以傲娇的说："没错，比特币在数学上不是绝对安全的。但我可以保证，它比这个宇宙安全的多。你相信明天宇宙就会爆炸吗？不相信的话，就相信比特币，洗洗安心睡吧。^_^"</p>

<h4>事实果真如此吗?</h4>

<p>让我们看一下<a href="https://lbc.cryptoguru.org/">Large Bitcoin Collider</a>这个项目。</p>

<p>该项目被称为大型比特币对撞机（LBC）。大型比特币对撞机尝试进行加密碰撞，它本质上证明了一个据称独特且随机的数字字符串可以重复。一路上爱好者们都在利用该项目的强大计算能力来尝试和破灭比特币的算法规则，最后打开其他人所拥有的比特币钱包，并有可能在里面拿走这些比特币。</p>

<p>是的，他们就是简单粗暴，他们试图从1穷举碰撞到2<sup>160</sup>来"打捞"比特币私钥。</p>

<p>我猜你肯定会说：哇咔咔，这帮傻小子，打捞到宇宙末日也不会有啥的</p>

<p>这个项目已经被贴上了很多标签：不可能，违法，毫无意义等等。</p>

<h4>一些让人惊奇的事情</h4>

<p>这个项目从2016年4月份开始运作，算力逐渐壮大到1GH/s的碰撞强度，到目前(2018-04)为止，发现了什么？</p>

<p>事实上他们刚刚碰撞到2<sup>54</sup>级别，按照道理来说他们离发现第一个私钥还相隔了xxxxxxx个宇宙轮回，事实呢？</p>

<p>他们共发现了16个有效的私钥，其中有4个地址是真实有效并且有余额的，共打捞了1个多BTC。当然，他们花费的成本可能已经远远超过了所得，但是毕竟这对人们信奉的"比特币安全牢不可破"产生重击。</p>

<h4>他们骗人，用事先生成的地址来发送交易，然后蒙蔽世人</h4>

<p>事实上只要在bitcointalk.org论坛上仔细追踪一下这个帖子，就会发现这个项目完全是可信的，发起人十分严谨，记录了每次碰撞成功的结果，并且时间点上并无伪造的可能</p>

<p><a href="https://bitcointalk.org/index.php?topic=1573035.0">https://bitcointalk.org/index.php?topic=1573035.0</a></p>

<h4>哇，比特币被攻破了，我要赶紧卖卖卖</h4>

<p>事实上我们还是要强调比特币的设计比起这个星球上所有的银行和金融机构要安全的多，比起担心你的币，还是多担心一下你在人行总账上的资产账户吧。</p>

<h4>那这种事情怎么解释呢？</h4>

<ol>
<li><p>不是所有人的私钥都是那么"随机"，有理由相信，早期的一些玩家或者说一些钱包生成私钥的机制并不是那么完善，他们采用的熵源不够随机，造成私钥的值太小，被碰撞机发现了</p></li>
<li><p>总有一些人们，对于随机字符有莫名的恐惧，他们采用"脑钱包"来让自己更有控制感，相信我，大部分"脑钱包"的生成密语并不是多好，可能你会拿到一个被碰撞概率大得多的私钥。那些手头有大量"社工库"的坏小子们，是无法抵挡去碰撞攻击你的私钥的诱惑的</p></li>
<li><p>也许，我是说也许。数字货币的安全性设计是如此的健壮，健壮到人们忽视了最基本的问题：历史上从来没有哪一个系统能把所有东西都暴露在外，让人们随意碰撞攻击。这种时候，安全性最薄弱的环节还是在于人们的意识</p></li>
</ol>


<h4>那我们要如何保护自己呢？</h4>

<ol>
<li><p>尽量采用最新的，社区公认的健壮的钱包</p></li>
<li><p>如果你要用脑钱包，确认你明白其中的风险，并且自己最好对生成的私钥做一个安全评估</p></li>
<li><p>一个地址发送一笔转账后就更换地址</p></li>
</ol>


<h4>一些后续</h4>

<p>LBC这个项目遭受了很多人的误解和攻击。有的人认为这是一种偷盗行为。我得说，现有的法律在这里的确是盲点。</p>

<p>我在街上捡了一个钱包，大家都知道送去警局。</p>

<p>我在数字世界里面碰到了宇宙洪荒岁月亿万年一次的大奖，尽管这个奖励可能是从别的一个什么倒霉蛋那里拿来的，不过也没其他人知道，为什么不能看作是无主物品呢？为什么不看成是上天的眷顾呢？</p>

<h4>数字货币世界还是处于蛮荒狂野时代，不是那么多事情都是理所当然的;乔帮主的训诫要时时温习:饥渴求知，虚怀若愚(Stay Hungry, Stay Foolish)</h4>

<h4>少年，祝你好运</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get Pubkey From a Transaction]]></title>
    <link href="http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction/"/>
    <updated>2018-04-22T20:42:49+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction</id>
    <content type="html"><![CDATA[<p>比如<code>1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD</code>，这个地址，有转出过，如何得到公钥</p>

<p>原理很简单，但是实践起来比较烦：</p>

<!-- more -->


<p>首先我们找一下这个地址的随便一笔花费，比如这个:</p>

<p><a href="https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33">https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33</a></p>

<p>然后需要一个工具通过交易hash解析一下这笔交易</p>

<p>推荐用这个 <a href="https://github.com/libbitcoin/libbitcoin-explorer/wiki/Download-BX">libbitcoin/libbitcoin-explorer</a></p>

<p>执行</p>

<pre><code>bx-windows-x64-icu.exe fetch-tx 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
</code></pre>

<p>得到了这笔交易解析后的完整输出:</p>

<p>```
transaction
{</p>

<pre><code>hash 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
inputs
{
    input
    {
        address_hash b4a5d3960471568c3883046eec3b41b4953d61a1
        previous_output
        {
            hash 5fb9f0e7f520163e4afe0baa440fe93999273e95d9e345e0488a0802ed62674f
            index 0
        }
        script "[3045022100e4a4695ecbe6f507ec7181a2f321f489c7a3bd7eea032c75e4e1eba89174183c022019555aa917be6191db14da72e5c234a4b628f321b917ea334bcf9c122296cd5901] [044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b]"
        sequence 4294967295
    }
}
lock_time 0
outputs
{
    output
    {
        address_hash c621cbfd778e6109e26046d96738c7af75e7b78b
        script "dup hash160 [c621cbfd778e6109e26046d96738c7af75e7b78b] equalverify checksig"
        value 43103
    }
}
version 1
</code></pre>

<p>}
```</p>

<p>注意script那一段，就是分成了两部分，前面一个中括号里面是签名，后面是公钥。</p>

<p>然后仔细看看这还是个老钱包生成的地址，没有压缩;</p>

<p>写个小脚本parse一下这个公钥，就可以看看是不是和地址对应啦:</p>

<p>```</p>

<h1>!/usr/bin/env python</h1>

<p>from hashlib import *
from base58 import *</p>

<p>def SHA256D(bstr):</p>

<pre><code>return sha256(sha256(bstr).digest()).digest()
</code></pre>

<p>def ConvertPKHToAddress(prefix, addr):</p>

<pre><code>data = prefix + addr
return b58encode(data + SHA256D(data)[:4])
</code></pre>

<p>def PubkeyToAddress(pubkey_hex):</p>

<pre><code>pubkey = bytearray.fromhex(pubkey_hex)
round1 = sha256(pubkey).digest()
h = new('ripemd160')
h.update(round1)
pubkey_hash = h.digest()
return ConvertPKHToAddress(b'\x00', pubkey_hash)
</code></pre>

<p>pubkey = &ldquo;044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b&rdquo;
print(len(pubkey))
print(&ldquo;Address: %s&rdquo; % PubkeyToAddress(pubkey))
```</p>

<p>输出是这样的:</p>

<p><code>
130
Address: 1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD
</code></p>

<p>OK，打完收工。</p>

<p>如果一个地址只收币，从来没消费币，公钥是不会广播到网上的，所以这种地址拿不到公钥。一定要有花费，才能得到公钥。</p>

<p>所以有人推荐每次花费币之后就不要再用老地址了，每次交易都用新地址，避免将来出现什么黑科技（比如量子计算机之类的）穷举破解。 其实我觉的无所谓，大不了有人喊ECDSA挂了我再转移一下就行了，人家富豪榜里面都有好几个大佬也不在乎这点事。</p>

<p>PS:更新自打脸一下，我还是觉得每次交易用新地址是一定要做的，理论上HASH碰撞的概率有2<sup>160</sup>，但是我现在觉得这个量级不能简单的推算为1/2<sup>160</sup>；毕竟不是所有的钱包实现熵值都足够大。尽可能每次交易用新地址会增加碰撞库更新的难度。</p>

<h4>再强调一遍，每次交易用新地址是一个必须养成的习惯。</h4>

<p>另外公钥有两种形式：压缩与非压缩。一把私钥其实可以搞出两个地址哈。早期比特币均使用非压缩公钥，现大部分客户端已默认使用压缩公钥。早期openssl库的文档写的比较糙，导致Satoshi以为必须使用非压缩的完整公钥，后来大家发现其实公钥的左右两个32字节是有关联的，左侧(X)可以推出右侧(Y)的平方值，有左侧(X)就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Satoshi Craig Wright Is Being Sued for $10 Billion]]></title>
    <link href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/"/>
    <updated>2018-04-22T19:31:24+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion</id>
    <content type="html"><![CDATA[<p>啥也不说了，涉及百亿美元的案子，估计在人类历史上都能排前排了。</p>

<p>而且作为Bitcoin粉，我估计这个案子有可能在历史上空前绝后。涉及悬疑，天才，欺诈，巨额金钱，先知等等元素~~</p>

<p>留名之。</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>另外我对这篇<a href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">文章</a>用press.one进行了<a href="https://press.one/file/v?s=60db2f3ea40a25d28781c900af248523eb3c17024ce3ca18a42433035aff55524e4b2df76cfcef1466d38c4e23e4ab770d42359835b66d159cd5dd5099e0be260&amp;h=a93f5a68189ff4a9b14d9e592c4dd0a8a1b649d0191b58740d93ce10c0d055ec&amp;a=7e32e3deba87efcd35bc6d1ab355d85c50aa60bd&amp;v=2&amp;f=P1">签名:</a></p>

<!-- more -->


<h4>PS:附一下之前的总结</h4>

<p>2016-05更新:</p>

<p>=========================</p>

<p>参考<a href="http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:">http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:</a></p>

<p>为什么说这个中本聪是假的</p>

<p>Craig Wright 又在声明他是”中本聪”了.</p>

<p>“中本聪”给出的签名是：</p>

<p>```</p>

<pre><code>MEUCIQDBKn1Uly8m0UyzETObUSL4wYdBfd4ejvtoQfVcNCIK4AIgZmMsXNQWHvo6KDd2Tu6euEl13VTC3ihl6XUlhcU+fM4=
</code></pre>

<p>```</p>

<p>我们先对信息串进行base64解码，再转换成hex是：</p>

<p>```</p>

<pre><code>3045022100c12a7d54972f26d14cb311339b5122f8c187417dde1e8efb6841f55c34220ae0022066632c5cd4161efa3a2837764eee9eb84975dd54c2de2865e9752585c53e7cce
</code></pre>

<p>```</p>

<p>很遗憾，我们可以在交易ID：</p>

<p>```</p>

<pre><code>828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe
</code></pre>

<p>```</p>

<p>中找出这个签名。可通过：</p>

<p><a href="https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex">https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex</a></p>

<p>找到十六进制串的交易内容</p>

<p>然后搜索一下hex样子的签名，遗憾地发现，能在这个交易中找到这个签名。</p>

<p>但是令人疑惑的是GAVIN ANDRESEN为这位”中本聪”背书:</p>

<p><a href="http://gavinandresen.ninja/satoshi">http://gavinandresen.ninja/satoshi</a></p>

<p>Gavin不是一个无的放矢的人,他肯定是见到了更多的证据.</p>

<p>但是Craig Wright 又不对其他给定的文本签名来证明自己是中本聪,反而老是用这种神神遭遭的签名来忽悠大家……</p>

<p>卫平布莱恩特老师说,这球有意思啊…….</p>

<p>最后, 如果Craig Wright这个人是为了某种目的假冒的话,只能说他真是煞费苦心啊. 我不认为一个签名造假如此low的家伙能有这种能力.</p>

<p>但是他的一些行为如果算恶作剧的话,又未免太高段了,参考这里:</p>

<p><a href="https://www.zhihu.com/question/22199390/answer/76083139">https://www.zhihu.com/question/22199390/answer/76083139</a></p>

<p>不负责任的YY一下, Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>

<p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>

<p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p>

<p>呵呵, 绝佳的侦探小说体裁啊.</p>

<p>2017-12-24更新</p>

<p>================</p>

<p>我在比特币开发论坛的早期帖子上发现了一个线索，在bitcoin release 0.1版本的时候，satoshi曾经自称自己:</p>

<pre><code>"The design supports a tremendous variety of possible transaction types that I designed years ago.  Escrow transactions, bonded contracts, third party arbitration, multi-party signature, etc.  If Bitcoin catches on in a big way, these are things we'll want to explore in the future, but they all had to be designed at the beginning to make sure they would be possible later."
</code></pre>

<p>这代表satoshi早期的职业生涯和金融、保险以及法务方面联系很紧密，同时看他的代码风格是老派C++的写法，有MS的味道 ：），然后看看 David Kleiman的个人主页，浮想联翩啊。</p>

<p>2018-04-22更新</p>

<p>==================</p>

<p>Craig Wright的案宗已经出来了:</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>我觉得基本上可以确定猜测是对的，但是除了Craig Wright本人，真相的细节可能永远不会有人知道了。</p>

<p>现在最大的疑问就是100w币的私钥是谁控制着？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Do Cryptic Github Comments Mean?]]></title>
    <link href="http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean/"/>
    <updated>2018-02-17T16:35:55+08:00</updated>
    <id>http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean</id>
    <content type="html"><![CDATA[<p>在Github的Issue里面经常见到一堆<code>ACK</code>，原来知道肯定不是TCP的ACK，估计是acknowledge之类的缩写，但是一直不求甚解。</p>

<!-- more -->


<p>今天心血来潮搜了一下，嗯，猜的也差不多:</p>

<ul>
<li><p>LGTM—looks good to me</p></li>
<li><p>ACK—acknowledgement, i.e. agreed/accepted change</p></li>
<li><p>NACK/NAK —negative acknowledgement, i.e. disagree with change and/or concept</p></li>
<li><p>RFC—request for comments, i.e. I think this is a good idea, lets discuss</p></li>
<li><p>WIP—work in progress, do not merge yet</p></li>
<li><p>AFAIK/AFAICT—as far as I know / can tell</p></li>
<li><p>IIRC—if I recall correctly</p></li>
<li><p>IANAL—“I am not a lawyer”, but I smell licensing issues</p></li>
</ul>


<p>像比特币代码仓库里还经常见到:</p>

<ul>
<li><p>Concept ACK—agree with the concept, but haven’t reviewed the changes</p></li>
<li><p>utACK (aka. Untested ACK)—agree with the changes and reviewed them, but didn’t test</p></li>
<li><p>Tested ACK—agree with the changes, reviewed and tested</p></li>
</ul>


<p>资料来源:</p>

<p><a href="https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4">https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4</a></p>

<p><a href="https://github.com/dear-github/dear-github">https://github.com/dear-github/dear-github</a></p>

<p><a href="http://www.catb.org/jargon/html/index.html">http://www.catb.org/jargon/html/index.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币POW难度调节分析]]></title>
    <link href="http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/"/>
    <updated>2018-02-12T20:50:34+08:00</updated>
    <id>http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi</id>
    <content type="html"><![CDATA[<p>比特币白皮书在工作量证明章节中解释了工作量证明（PoW）的方式：</p>

<blockquote><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p></blockquote>

<p>那这个随机数难度值是怎么产生的呢？</p>

<!-- more -->


<p>原理是简单的，但是细节总是需要穷根究底。</p>

<h2>比特币难度值Difficulty</h2>

<p>难度值在区块中并不记录，仅仅是为了人类直观感受解题难度而演变出的一个浮点数。难度每2016个区块改变一次，公式如下：</p>

<p>```</p>

<pre><code>diffculty = difficulty_1_target / currentTarget
</code></pre>

<p>```</p>

<p>此处的 difficulty_1_target 为一个常数，非常大的一个数字。表示矿池挖矿最大难度。目标值越小，区块生成难度越大。区块中存储的是这个名为target的值。</p>

<h2>难度值如何存储在区块中的</h2>

<p>在区块中存储的是Target，但是将Target经类似于浮点数的一种压缩表示法，字段为nbits。例如，如果区块bits记录为0x1b0404cb，那么他表示的十六进制的Target值为：</p>

<p>```</p>

<pre><code>0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000
</code></pre>

<p>```</p>

<h3>在计算时，后面3个字节0x0404cb作为底，前面1字节0x1b表示次方数。具体压缩过程如下：</h3>

<ul>
<li><p>将数字转换为256进制数</p></li>
<li><p>如果第一位数字大于127(0x7f),则前面添加0</p></li>
<li><p>压缩结果中的第一位存放该256进制数的位数</p></li>
<li><p>后面三个数存放该256进制数的前三位，如果不足三位，则后面补零</p></li>
</ul>


<h4>例如，将数字1000压缩，先转换为256进制数</h4>

<p>```</p>

<pre><code>1000 = 0x03 * 256 + 0xe8 * 1
</code></pre>

<p>```</p>

<p>那么是由两个数字构成：</p>

<p><code>
03   e8
</code></p>

<p>第一个数未超过0x7f,则不需填0，但长度两位低于三位，在后面补零，最终表示为：0x0203e800</p>

<h3>等等，我有点晕了，为什么要采取这种绕弯的存储方式呢?</h3>

<ul>
<li><p>比特币的工作量证明本质是计算一个256bits的hash值，并保证这个值小于target，表示为公式如下:</p>

<p>  <code>
  SHA256(SHA256(区块头)) &lt; Target
 </code></p></li>
<li><p>初始Target，即difficulty_1_target设置为<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>，此时难度为1</p></li>
<li><p>Target是一个256位的很大的数，对这个数进行乘除运算需要特殊的库来处理，所以中本聪考虑用一个32位的数来近似表示Target</p></li>
<li><p>256 / 32 = 8, 2<sup>8</sup> = 256，因此我们需要用256进制来表示Target，256进制的运算规则如上所述</p></li>
<li><p>那么初始Target其实可以表示为0x1D00FFFFFF，解压验证一下:</p>

<p>  <code>
      0x00ffff *256** (0x1d - 3)  = ff ff 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 </code></p></li>
<li><p>0x1D00FFFFFF 这个值可以称为nbits，就是存储在区块中的原始值，通过nbits可以推算当前Target，通过当前Target及初始Target可以推算当前难度</p></li>
</ul>


<h2>难度如何调节</h2>

<p>目标值计算公式如下，但在实际计算时有些特别处理，将目标值控制在一定范围内。</p>

<p><code>
新目标值= 当前目标值 * 实际2016个区块出块时间 / 理论2016个区块出块时间(2周)。
</code></p>

<ol>
<li><p>判断是否需要更新目标值(2016的整数倍)，如果不是则继续使用最后一个区块的目标值</p></li>
<li><p>计算前2016个区块出块用时</p></li>
<li><p>如果用时低于半周，则按半周计算。防止难度增加4倍以上。</p></li>
<li><p>如果用时高于8周，则按8周计算。防止难度降低到4倍以下。</p></li>
<li><p>用时乘以当前难度, 再除以2周</p></li>
<li><p>如果超过最大难度限制，则按最大难度处理</p></li>
</ol>


<p>代码参考这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857">https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857</a></p>

<h2>知道nbits，如何推算全网算力</h2>

<ul>
<li><p>nbits为0x1b0404cb时，难度为：</p>

<p>  <code>
  0x00000000FFFF0000000000000000000000000000000000000000000000000000 / 0x00000000000404CB000000000000000000000000000000000000000000000000 = 16307.420938523983
 </code></p></li>
<li><p>为了找到新区块，该区块的target值必须小于目标target值，实际上是一个在0到2<sup>256</sup>-1之间的随机数，难度1的偏移量是：</p>

<p> <code>
 0xffff * 2^208
</code></p></li>
<li><p>难度D的偏移量是</p>

<p> <code>
 (0xffff * 2^208)/D
</code></p></li>
<li><p>在难度D下，为了找到新区块，我们预期要计算的HASH数量是</p>

<p> <code>
 D * 2^256 / (0xffff * 2^208)
</code></p></li>
<li><p>难度的设定，是为了以每10分钟一个区块的产生速度产生2016个区块，因而我们在600秒内计算 (D * 2<sup>48</sup> / 0xffff) 个HASH，这就意味着产生2016个区块的网络HASH速率(算力)是</p>

<p> <code>
 D * 2^48 / 0xffff / 600
</code></p>

<p> 可以进一步简化为：</p>

<p> <code>
 D * 2^32 / 600
</code></p></li>
<li><p>2018-02-12 21:00:00(UTC+8), 难度值D为2,874,674,234,415; 此时全网算力为20.75EH/S</p></li>
<li><p>如果我有一台蚂蚁S9，算力13T/S，那么一个区块周期(10分钟)的期望BTC收益为12.5 * 13T / 20.75EH</p></li>
</ul>


<h2>一点小TIPS</h2>

<ul>
<li>难度为1时，目标target在比特币客户端中表示为</li>
</ul>


<p><code>
0x00000000FFFF0000000000000000000000000000000000000000000000000000
</code></p>

<p>但是在绝大部分矿池里面表示为</p>

<p><code>
0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</code></p>

<p>这样挖矿的时候，挖矿软件显示的难度和比特币客户端api调用算出来的难度有微小差别，可以忽略。这个其实时早期矿池实现的时候找方便造成的不统一，因为比特币客户端判断HASH合法性的时候用的是nbits来判断，所以不影响最终计算结果</p>

<ul>
<li>现有的算法中，难度值每2016个区块调整一次，但新的难度值不需要与难度“1”进行比较运算，而是根据前2015个块的出块时间来计算，所以严谨的计算公式为:</li>
</ul>


<p><code>
difficulty = [prev_target] * 【前2015个区块生成所用的时间】 / 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数）
</code></p>

<p>为啥？就是中本聪早期的代码比较糙，他在循环的时候因为还有一个genius block要处理，可能为了代码干净起见就不去特殊处理了，其实也没啥影响</p>
]]></content>
  </entry>
  
</feed>
