<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-04-24T19:26:42+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Get Pubkey From a Transaction]]></title>
    <link href="http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction/"/>
    <updated>2018-04-22T20:42:49+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction</id>
    <content type="html"><![CDATA[<p>比如<code>1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD</code>，这个地址，有转出过，如何得到公钥</p>

<p>原理很简单，但是实践起来比较烦：</p>

<!-- more -->


<p>首先我们找一下这个地址的随便一笔花费，比如这个:</p>

<p><a href="https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33">https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33</a></p>

<p>然后需要一个工具通过交易hash解析一下这笔交易</p>

<p>推荐用这个 <a href="https://github.com/libbitcoin/libbitcoin-explorer/wiki/Download-BX">libbitcoin/libbitcoin-explorer</a></p>

<p>执行</p>

<pre><code>bx-windows-x64-icu.exe fetch-tx 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
</code></pre>

<p>得到了这笔交易解析后的完整输出:</p>

<p>```
transaction
{</p>

<pre><code>hash 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
inputs
{
    input
    {
        address_hash b4a5d3960471568c3883046eec3b41b4953d61a1
        previous_output
        {
            hash 5fb9f0e7f520163e4afe0baa440fe93999273e95d9e345e0488a0802ed62674f
            index 0
        }
        script "[3045022100e4a4695ecbe6f507ec7181a2f321f489c7a3bd7eea032c75e4e1eba89174183c022019555aa917be6191db14da72e5c234a4b628f321b917ea334bcf9c122296cd5901] [044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b]"
        sequence 4294967295
    }
}
lock_time 0
outputs
{
    output
    {
        address_hash c621cbfd778e6109e26046d96738c7af75e7b78b
        script "dup hash160 [c621cbfd778e6109e26046d96738c7af75e7b78b] equalverify checksig"
        value 43103
    }
}
version 1
</code></pre>

<p>}
```</p>

<p>注意script那一段，就是分成了两部分，前面一个中括号里面是签名，后面是公钥。</p>

<p>然后仔细看看这还是个老钱包生成的地址，没有压缩;</p>

<p>写个小脚本parse一下这个公钥，就可以看看是不是和地址对应啦:</p>

<p>```</p>

<h1>!/usr/bin/env python</h1>

<p>from hashlib import *
from base58 import *</p>

<p>def SHA256D(bstr):</p>

<pre><code>return sha256(sha256(bstr).digest()).digest()
</code></pre>

<p>def ConvertPKHToAddress(prefix, addr):</p>

<pre><code>data = prefix + addr
return b58encode(data + SHA256D(data)[:4])
</code></pre>

<p>def PubkeyToAddress(pubkey_hex):</p>

<pre><code>pubkey = bytearray.fromhex(pubkey_hex)
round1 = sha256(pubkey).digest()
h = new('ripemd160')
h.update(round1)
pubkey_hash = h.digest()
return ConvertPKHToAddress(b'\x00', pubkey_hash)
</code></pre>

<p>pubkey = &ldquo;044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b&rdquo;
print(len(pubkey))
print(&ldquo;Address: %s&rdquo; % PubkeyToAddress(pubkey))
```</p>

<p>输出是这样的:</p>

<p><code>
130
Address: 1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD
</code></p>

<p>OK，打完收工。</p>

<p>如果一个地址只收币，从来没消费币，公钥是不会广播到网上的，所以这种地址拿不到公钥。一定要有花费，才能得到公钥。</p>

<p>所以有人推荐每次花费币之后就不要再用老地址了，每次交易都用新地址，避免将来出现什么黑科技（比如量子计算机之类的）穷举破解。 其实我觉的无所谓，大不了有人喊ECDSA挂了我再转移一下就行了，人家富豪榜里面都有好几个大佬也不在乎这点事。</p>

<p>PS:更新自打脸一下，我还是觉得每次交易用新地址是一定要做的，理论上HASH碰撞的概率有2<sup>160</sup>，但是我现在觉得这个量级不能简单的推算为1/2<sup>160</sup>；毕竟不是所有的钱包实现熵值都足够大。尽可能每次交易用新地址会增加碰撞库更新的难度。</p>

<h4>再强调一遍，每次交易用新地址是一个必须养成的习惯。</h4>

<p>另外公钥有两种形式：压缩与非压缩。一把私钥其实可以搞出两个地址哈。早期比特币均使用非压缩公钥，现大部分客户端已默认使用压缩公钥。早期openssl库的文档写的比较糙，导致Satoshi以为必须使用非压缩的完整公钥，后来大家发现其实公钥的左右两个32字节是有关联的，左侧(X)可以推出右侧(Y)的平方值，有左侧(X)就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Satoshi Craig Wright Is Being Sued for $10 Billion]]></title>
    <link href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/"/>
    <updated>2018-04-22T19:31:24+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion</id>
    <content type="html"><![CDATA[<p>啥也不说了，涉及百亿美元的案子，估计在人类历史上都能排前排了。</p>

<p>而且作为Bitcoin粉，我估计这个案子有可能在历史上空前绝后。涉及悬疑，天才，欺诈，巨额金钱，先知等等元素~~</p>

<p>留名之。</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>另外我对这篇<a href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">文章</a>用press.one进行了<a href="https://press.one/file/v?s=60db2f3ea40a25d28781c900af248523eb3c17024ce3ca18a42433035aff55524e4b2df76cfcef1466d38c4e23e4ab770d42359835b66d159cd5dd5099e0be260&amp;h=a93f5a68189ff4a9b14d9e592c4dd0a8a1b649d0191b58740d93ce10c0d055ec&amp;a=7e32e3deba87efcd35bc6d1ab355d85c50aa60bd&amp;v=2&amp;f=P1">签名:</a></p>

<!-- more -->


<h4>PS:附一下之前的总结</h4>

<p>2016-05更新:</p>

<p>=========================</p>

<p>参考<a href="http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:">http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:</a></p>

<p>为什么说这个中本聪是假的</p>

<p>Craig Wright 又在声明他是”中本聪”了.</p>

<p>“中本聪”给出的签名是：</p>

<p>```</p>

<pre><code>MEUCIQDBKn1Uly8m0UyzETObUSL4wYdBfd4ejvtoQfVcNCIK4AIgZmMsXNQWHvo6KDd2Tu6euEl13VTC3ihl6XUlhcU+fM4=
</code></pre>

<p>```</p>

<p>我们先对信息串进行base64解码，再转换成hex是：</p>

<p>```</p>

<pre><code>3045022100c12a7d54972f26d14cb311339b5122f8c187417dde1e8efb6841f55c34220ae0022066632c5cd4161efa3a2837764eee9eb84975dd54c2de2865e9752585c53e7cce
</code></pre>

<p>```</p>

<p>很遗憾，我们可以在交易ID：</p>

<p>```</p>

<pre><code>828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe
</code></pre>

<p>```</p>

<p>中找出这个签名。可通过：</p>

<p><a href="https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex">https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex</a></p>

<p>找到十六进制串的交易内容</p>

<p>然后搜索一下hex样子的签名，遗憾地发现，能在这个交易中找到这个签名。</p>

<p>但是令人疑惑的是GAVIN ANDRESEN为这位”中本聪”背书:</p>

<p><a href="http://gavinandresen.ninja/satoshi">http://gavinandresen.ninja/satoshi</a></p>

<p>Gavin不是一个无的放矢的人,他肯定是见到了更多的证据.</p>

<p>但是Craig Wright 又不对其他给定的文本签名来证明自己是中本聪,反而老是用这种神神遭遭的签名来忽悠大家……</p>

<p>卫平布莱恩特老师说,这球有意思啊…….</p>

<p>最后, 如果Craig Wright这个人是为了某种目的假冒的话,只能说他真是煞费苦心啊. 我不认为一个签名造假如此low的家伙能有这种能力.</p>

<p>但是他的一些行为如果算恶作剧的话,又未免太高段了,参考这里:</p>

<p><a href="https://www.zhihu.com/question/22199390/answer/76083139">https://www.zhihu.com/question/22199390/answer/76083139</a></p>

<p>不负责任的YY一下, Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>

<p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>

<p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p>

<p>呵呵, 绝佳的侦探小说体裁啊.</p>

<p>2017-12-24更新</p>

<p>================</p>

<p>我在比特币开发论坛的早期帖子上发现了一个线索，在bitcoin release 0.1版本的时候，satoshi曾经自称自己:</p>

<pre><code>"The design supports a tremendous variety of possible transaction types that I designed years ago.  Escrow transactions, bonded contracts, third party arbitration, multi-party signature, etc.  If Bitcoin catches on in a big way, these are things we'll want to explore in the future, but they all had to be designed at the beginning to make sure they would be possible later."
</code></pre>

<p>这代表satoshi早期的职业生涯和金融、保险以及法务方面联系很紧密，同时看他的代码风格是老派C++的写法，有MS的味道 ：），然后看看 David Kleiman的个人主页，浮想联翩啊。</p>

<p>2018-04-22更新</p>

<p>==================</p>

<p>Craig Wright的案宗已经出来了:</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>我觉得基本上可以确定猜测是对的，但是除了Craig Wright本人，真相的细节可能永远不会有人知道了。</p>

<p>现在最大的疑问就是100w币的私钥是谁控制着？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Do Cryptic Github Comments Mean?]]></title>
    <link href="http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean/"/>
    <updated>2018-02-17T16:35:55+08:00</updated>
    <id>http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean</id>
    <content type="html"><![CDATA[<p>在Github的Issue里面经常见到一堆<code>ACK</code>，原来知道肯定不是TCP的ACK，估计是acknowledge之类的缩写，但是一直不求甚解。</p>

<!-- more -->


<p>今天心血来潮搜了一下，嗯，猜的也差不多:</p>

<ul>
<li><p>LGTM—looks good to me</p></li>
<li><p>ACK—acknowledgement, i.e. agreed/accepted change</p></li>
<li><p>NACK/NAK —negative acknowledgement, i.e. disagree with change and/or concept</p></li>
<li><p>RFC—request for comments, i.e. I think this is a good idea, lets discuss</p></li>
<li><p>WIP—work in progress, do not merge yet</p></li>
<li><p>AFAIK/AFAICT—as far as I know / can tell</p></li>
<li><p>IIRC—if I recall correctly</p></li>
<li><p>IANAL—“I am not a lawyer”, but I smell licensing issues</p></li>
</ul>


<p>像比特币代码仓库里还经常见到:</p>

<ul>
<li><p>Concept ACK—agree with the concept, but haven’t reviewed the changes</p></li>
<li><p>utACK (aka. Untested ACK)—agree with the changes and reviewed them, but didn’t test</p></li>
<li><p>Tested ACK—agree with the changes, reviewed and tested</p></li>
</ul>


<p>资料来源:</p>

<p><a href="https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4">https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4</a></p>

<p><a href="https://github.com/dear-github/dear-github">https://github.com/dear-github/dear-github</a></p>

<p><a href="http://www.catb.org/jargon/html/index.html">http://www.catb.org/jargon/html/index.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币POW难度调节分析]]></title>
    <link href="http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/"/>
    <updated>2018-02-12T20:50:34+08:00</updated>
    <id>http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi</id>
    <content type="html"><![CDATA[<p>比特币白皮书在工作量证明章节中解释了工作量证明（PoW）的方式：</p>

<blockquote><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p></blockquote>

<p>那这个随机数难度值是怎么产生的呢？</p>

<!-- more -->


<p>原理是简单的，但是细节总是需要穷根究底。</p>

<h2>比特币难度值Difficulty</h2>

<p>难度值在区块中并不记录，仅仅是为了人类直观感受解题难度而演变出的一个浮点数。难度每2016个区块改变一次，公式如下：</p>

<p>```</p>

<pre><code>diffculty = difficulty_1_target / currentTarget
</code></pre>

<p>```</p>

<p>此处的 difficulty_1_target 为一个常数，非常大的一个数字。表示矿池挖矿最大难度。目标值越小，区块生成难度越大。区块中存储的是这个名为target的值。</p>

<h2>难度值如何存储在区块中的</h2>

<p>在区块中存储的是Target，但是将Target经类似于浮点数的一种压缩表示法，字段为nbits。例如，如果区块bits记录为0x1b0404cb，那么他表示的十六进制的Target值为：</p>

<p>```</p>

<pre><code>0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000
</code></pre>

<p>```</p>

<h3>在计算时，后面3个字节0x0404cb作为底，前面1字节0x1b表示次方数。具体压缩过程如下：</h3>

<ul>
<li><p>将数字转换为256进制数</p></li>
<li><p>如果第一位数字大于127(0x7f),则前面添加0</p></li>
<li><p>压缩结果中的第一位存放该256进制数的位数</p></li>
<li><p>后面三个数存放该256进制数的前三位，如果不足三位，则后面补零</p></li>
</ul>


<h4>例如，将数字1000压缩，先转换为256进制数</h4>

<p>```</p>

<pre><code>1000 = 0x03 * 256 + 0xe8 * 1
</code></pre>

<p>```</p>

<p>那么是由两个数字构成：</p>

<p><code>
03   e8
</code></p>

<p>第一个数未超过0x7f,则不需填0，但长度两位低于三位，在后面补零，最终表示为：0x0203e800</p>

<h3>等等，我有点晕了，为什么要采取这种绕弯的存储方式呢?</h3>

<ul>
<li><p>比特币的工作量证明本质是计算一个256bits的hash值，并保证这个值小于target，表示为公式如下:</p>

<p>  <code>
  SHA256(SHA256(区块头)) &lt; Target
 </code></p></li>
<li><p>初始Target，即difficulty_1_target设置为<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>，此时难度为1</p></li>
<li><p>Target是一个256位的很大的数，对这个数进行乘除运算需要特殊的库来处理，所以中本聪考虑用一个32位的数来近似表示Target</p></li>
<li><p>256 / 32 = 8, 2<sup>8</sup> = 256，因此我们需要用256进制来表示Target，256进制的运算规则如上所述</p></li>
<li><p>那么初始Target其实可以表示为0x1D00FFFFFF，解压验证一下:</p>

<p>  <code>
      0x00ffff *256** (0x1d - 3)  = ff ff 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 </code></p></li>
<li><p>0x1D00FFFFFF 这个值可以称为nbits，就是存储在区块中的原始值，通过nbits可以推算当前Target，通过当前Target及初始Target可以推算当前难度</p></li>
</ul>


<h2>难度如何调节</h2>

<p>目标值计算公式如下，但在实际计算时有些特别处理，将目标值控制在一定范围内。</p>

<p><code>
新目标值= 当前目标值 * 实际2016个区块出块时间 / 理论2016个区块出块时间(2周)。
</code></p>

<ol>
<li><p>判断是否需要更新目标值(2016的整数倍)，如果不是则继续使用最后一个区块的目标值</p></li>
<li><p>计算前2016个区块出块用时</p></li>
<li><p>如果用时低于半周，则按半周计算。防止难度增加4倍以上。</p></li>
<li><p>如果用时高于8周，则按8周计算。防止难度降低到4倍以下。</p></li>
<li><p>用时乘以当前难度, 再除以2周</p></li>
<li><p>如果超过最大难度限制，则按最大难度处理</p></li>
</ol>


<p>代码参考这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857">https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857</a></p>

<h2>知道nbits，如何推算全网算力</h2>

<ul>
<li><p>nbits为0x1b0404cb时，难度为：</p>

<p>  <code>
  0x00000000FFFF0000000000000000000000000000000000000000000000000000 / 0x00000000000404CB000000000000000000000000000000000000000000000000 = 16307.420938523983
 </code></p></li>
<li><p>为了找到新区块，该区块的target值必须小于目标target值，实际上是一个在0到2<sup>256</sup>-1之间的随机数，难度1的偏移量是：</p>

<p> <code>
 0xffff * 2^208
</code></p></li>
<li><p>难度D的偏移量是</p>

<p> <code>
 (0xffff * 2^208)/D
</code></p></li>
<li><p>在难度D下，为了找到新区块，我们预期要计算的HASH数量是</p>

<p> <code>
 D * 2^256 / (0xffff * 2^208)
</code></p></li>
<li><p>难度的设定，是为了以每10分钟一个区块的产生速度产生2016个区块，因而我们在600秒内计算 (D * 2<sup>48</sup> / 0xffff) 个HASH，这就意味着产生2016个区块的网络HASH速率(算力)是</p>

<p> <code>
 D * 2^48 / 0xffff / 600
</code></p>

<p> 可以进一步简化为：</p>

<p> <code>
 D * 2^32 / 600
</code></p></li>
<li><p>2018-02-12 21:00:00(UTC+8), 难度值D为2,874,674,234,415; 此时全网算力为20.75EH/S</p></li>
<li><p>如果我有一台蚂蚁S9，算力13T/S，那么一个区块周期(10分钟)的期望BTC收益为12.5 * 13T / 20.75EH</p></li>
</ul>


<h2>一点小TIPS</h2>

<ul>
<li>难度为1时，目标target在比特币客户端中表示为</li>
</ul>


<p><code>
0x00000000FFFF0000000000000000000000000000000000000000000000000000
</code></p>

<p>但是在绝大部分矿池里面表示为</p>

<p><code>
0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</code></p>

<p>这样挖矿的时候，挖矿软件显示的难度和比特币客户端api调用算出来的难度有微小差别，可以忽略。这个其实时早期矿池实现的时候找方便造成的不统一，因为比特币客户端判断HASH合法性的时候用的是nbits来判断，所以不影响最终计算结果</p>

<ul>
<li>现有的算法中，难度值每2016个区块调整一次，但新的难度值不需要与难度“1”进行比较运算，而是根据前2015个块的出块时间来计算，所以严谨的计算公式为:</li>
</ul>


<p><code>
difficulty = [prev_target] * 【前2015个区块生成所用的时间】 / 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数）
</code></p>

<p>为啥？就是中本聪早期的代码比较糙，他在循环的时候因为还有一个genius block要处理，可能为了代码干净起见就不去特殊处理了，其实也没啥影响</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coincheck被盗5亿个XEM]]></title>
    <link href="http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem/"/>
    <updated>2018-02-02T21:16:43+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem</id>
    <content type="html"><![CDATA[<p>2018-01-26,Coincheck 被盗 5 亿个 XEM, 这个数目估计是史上最大了，hacker 的账户地址是这里:</p>

<p><a href="http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG">http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG</a></p>

<p>按照 coinmarketcap 的市场价来算，现在 5 亿个 XEM 价值大概 4 亿美元</p>

<p>另外可能是 coincheck 自己的防护，他们的 Ripple 钱包也有一笔大额的转账:</p>

<p><a href="https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8">https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8</a></p>

<p>有将近 1 亿个 xrp 转账到了一个地址，这个地址貌似有 30 亿个 xrp.</p>

<p>这笔转账可能是 coincheck 正在审计，不是 hack 行为。</p>

<p>除去 MTGOX 那次，Coincheck 的这次悲剧不论数量还是市场价格估计都是史上最强了</p>

<p>2018-01-28, Coincheck公布了补偿措施</p>

<p><a href="http://corporate.coincheck.com/2018/01/28/30.html">http://corporate.coincheck.com/2018/01/28/30.html</a></p>

<p>共损失 52300,0000 个 XEM，按照被偷时的币值返还，每个币 88 日元</p>

<p>额，貌似总额超过 25 亿人民币了</p>

<p>最奇怪的是，直到2018-02-01，市场才起了反应，开始下跌。</p>

<p>这个赌博的场子越来越让人看不懂了。</p>
]]></content>
  </entry>
  
</feed>
