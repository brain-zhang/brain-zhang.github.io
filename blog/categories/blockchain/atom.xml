<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-01-18T10:42:51+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一种提高比特币私钥碰撞机率的思路]]></title>
    <link href="https://happy123.me/blog/2019/01/18/%5B%3F%5D-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu/"/>
    <updated>2019-01-18T10:41:40+08:00</updated>
    <id>https://happy123.me/blog/2019/01/18/[?]-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu</id>
    <content type="html"><![CDATA[<p>之前的文章里面我们提到了一个名为<a href="https://lbc.cryptoguru.org">LBC</a>的项目；它采用了遍历所有比特币私钥，bloomfilter所有未花费的币的地址来碰撞比特币私钥。</p>

<p>这个项目本身详尽<a href="https://lbc.cryptoguru.org/stats">计算了这种碰撞成功的几率</a>，目前碰撞空间大概在 2<sup>136</sup> 级别。</p>

<p>目前在一台最顶级的AWS GPU计算节点上面的碰撞效率是这样的:</p>

<p><code>
AWS p2.8xlarge  32 vCores Xeon v4, 8x K80 GPUs (50% each)   ~80-88M/s
</code></p>

<p>每秒钟大概碰撞8000w次；目前LBC这个项目最顶峰的时候，算力到了1G的级别，这样计算下来:
<code>
2^136 / 2^30 = 2 ^106
</code></p>

<p>2<sup>106</sup> 级别的碰撞效率还是遥遥无期啊；</p>

<!-- more -->


<p>如果通读我们之前的文章就知道，比特币地址的生成，主要花费在ECDSA、SHA256, RIPEMD 这三个算法的操作之上，但其实用GPU计算，这三个步骤花费的时间是很少的，在整个碰撞过程中，其实大部分时间是耗费在bloomfilter上面的；</p>

<p>而bloomfilter的原理，采用的是多级HASHMAP，常理来看，这已经是判断一个元素是否存在某集合的极限效率了；</p>

<p>但是有一点我们不要忘记，比特币的地址采用base58编码，他的地址空间是有规律的，简单来说，就是所有比特币地址的前缀分布，是有规律可循的，他应该在base58的编码范围内成正态分布；而bloomfilter的HASHMAP是没有这种条件优化的，所以说bloomfilter的算法我们可以再改进一下，提升效率。</p>

<p>我分析了截至2018-12以前的所有比特币地址，简便起见，提取了所有的P2PKH地址(共
377059211个地址)，取其前4个字符地址前缀；执行:</p>

<p><code>
sort 4prefix.addr|uniq -c|sort -nr
</code></p>

<p>得到了所有地址前缀的分布列表，差不多是个正态分布。</p>

<p>列举一下最常用的地址前缀TOP10:</p>

<p><code>
  23600 1bit
  23086 1btc
  21895 13vs
  21329 1gbx
  21267 1gbt
  21267 1gba
  21210 1gbb
  21206 1gbf
  21196 1gbu
  21189 1gbr
</code></p>

<p>最常见的是1bit和1btc这两个前缀，各比第三名多出了10000个左右，这多出来20000个地址应该是Geek们自己生成的虚荣地址。</p>

<p>所有的比特币P2PKH地址，4字母前缀共有42877种组合。</p>

<p>好了，这就是我们可以优化的地方，把bloomfilter的第一级HASHMAP，采用这些前缀组合先来一把过滤，再去执行常规的Bloomfilter，碰撞效率会再提高一个数量级。</p>

<p>我在自己机器上实验了一下，在GTX750Ti 2G显卡上面，最终效率可以达到 10M/s。</p>

<p>瓶颈现在又变成了genaddress环节，我估计在一块RX480卡上面，可以达到和AWS顶配GPU一样的效率；</p>

<p>不过，效率提升十倍，也不过是 2<sup>100</sup> 的碰撞范围，还是遥遥无期啊。</p>

<h4>更深入的分析</h4>

<p>早期在bitcointalk.org论坛上，Laszlo Hanyecz曾经有过一个想法，就是随着硬件性能的发展，最终碰撞比特币私钥的收益会不会超过挖矿的收益？</p>

<p>中本聪当时的回答是，要达到这个碰撞算力很远很远。</p>

<p>我们来仔细分析一下：</p>

<p>比特币的地址生成是很容易硬件ASIC化的，如果用这种前缀过滤法，也不需要多少内存，所以可以近似认为：如果硬件化，比特币私钥碰撞的效率和挖矿效率是差不多的。</p>

<p>目前比特币全网算力在40EH左右，就是2<sup>62</sup>，这已经是相当于400w台蚂蚁S9的机器同时24X365 运行了；消耗的电力估计已经超过了上海市的居民用电，比特币矿机的能源消耗，完全可以说是抵得上一个小型国家的能源消耗了。</p>

<p>如果私钥碰撞达到2<sup>62</sup>级别，那么毛估估，碰撞几率就能减小到 &frac12;<sup>60</sup> 级别了；</p>

<p>但是这个概率还是太低了。</p>

<p>而且另外一个无法预测的情况就是，将来人们的安全意识加强，一般一个地址只要用过就会丢弃掉，所以最终bloomfilter的条目变化会非常频繁，还要考虑一个数量级的损耗。</p>

<p>目前测算，随着手续费用的提高，即使多次减半，将来挖矿的收益估计很长期稳定1-10btc/block级别，在如果将来以1年时间碰撞一个私钥的概率期望测算的话，一年大概是2<sup>30</sup> 秒，这样碰撞效率至少要提高到 2<sup>90</sup> 级别，才能达到<code>破解私钥得利</code>><code>挖矿得利</code> 的效果；</p>

<p>算力提高到2<sup>90</sup>，不管用什么技术，即使是量子计算，也很难想象能到这个量级啊；</p>

<p>而且，即使到了这一天，把RIPEMD替换成一种碰撞空间更大的算法就OK了。</p>

<p>这样看来，bitcoin的安全性还是无懈可击。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-7]]></title>
    <link href="https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7/"/>
    <updated>2019-01-06T17:34:55+08:00</updated>
    <id>https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7</id>
    <content type="html"><![CDATA[<p>比特币的交易网络最为人诟病的一点便是交易性能：全网每秒 7 笔左右的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认将导致约 1 个小时的最终确认时间。</p>

<p>为了提升性能，社区提出了闪电网络等创新的设计。</p>

<p>闪电网络的主要思路十分简单——将大量交易放到比特币区块链之外进行，只把关键环节放到链上进行确认。该设计最早于 2015 年 2 月在论文《The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments》中提出。</p>

<p>闪电网络需要单独部署，没有包含在bitcoin core实现里面。闪电网络是一个开放的协议，任何人都能自由的实现它，目前比较流行的版本有:</p>

<p><a href="https://github.com/lightningnetwork/">https://github.com/lightningnetwork/</a></p>

<p><a href="https://github.com/mit-dci/lit">https://github.com/mit-dci/lit</a></p>

<p><a href="https://github.com/ElementsProject/lightning">https://github.com/ElementsProject/lightning</a></p>

<!-- more -->


<p>让我们先自己思考一下，A和B之间频繁有多次交易，最自然，最直接的建立链下交易的办法是什么？</p>

<p>一个假想的场景，就是在没有网络，没有通信的环境中，两个人面对面各自手持私钥签名，证明自己的账户上有多少资金，然后签订一份合同，每次交易记录签名之后不广播，只写在合同上面，等到大批交易做完之后，再统一轧账清算；如果中间有人耍赖，就拿着写满签名交易的合同去法院仲裁。这个过程中间他们唯一的信息渠道就是有人单向传真给他们每笔交易的资金变动；</p>

<p>当然这是一种异想天开，而且依赖于中心化的法院裁决的方式，在现实世界中是行不通的；但是我们可以将这个方案作为起点，代入到电子化的解决方案里面：</p>

<ol>
<li>首先，两个人面对面，一是为了通过验证签名检查账户资金，二是防止第三者窃听；映射到电子方案中，就是通过两个人建立一个加密的通信信道来传递信息</li>
<li>另外，两个人的每一笔交易打印到合同上，就是为了防止某一方作假诈骗，而且两个人面对面互相监督，就防止有一方私自广播对方的交易然后闪人，但是放到网络中，没有法官裁决的威慑，没有相互监督，怎么才能信任对方最终一定会根据所有的历史交易来清算呢？</li>
</ol>


<p>第一个问题的解决方案称之 HTLC（Hashed Timelock Contract），解决了支付通道(资金池)的问题；</p>

<p>第二个问题的解决方案称之为RSMC (Recoverable Sequence Maturity Contract)，解决了链下交易的确认问题。</p>

<h2>RSMC</h2>

<h4>概述</h4>

<p>Recoverable Sequence Maturity Contract，即“可撤销的顺序成熟度合约”。这个词很绕，其实主要原理很简单，类似资金池机制。</p>

<p>再想一下我们之前的问题，为什么A和B每次交易都要记在合同上，最后一把清算呢？既然是双方账户的加加减减，为什么不是每发生一笔新交易，立即对交易后产生资金分配结果共同进行确认，然后作废之前一笔交易呢？</p>

<p>Yes! 这样做之后，在双方的资金池通道中，不管之前双方进行了多少笔交易，永远只存在一笔清算交易，这笔交易就是当前的轧账结果，不管什么时候，直接广播这笔交易，对双方都是公平的。</p>

<p>那么，该如何防止一方做了一笔付款之后，没有广播，就抢先把资金池里面的自有资金提现呢？</p>

<ol>
<li>A和B各拿出1BTC放入了资金池通道中，这时候资金池里面共有2BTC</li>
<li>A和B发生了数笔交易之后，A与B的资金变为1.5:0.5BTC，这个时候通道中留着一笔清算交易没有广播，但是任何一方都可以直接广播把这个状态做实</li>
<li>这个时候A又向B发送了1BTC，但是在B广播清算交易之前，A要把资金全部提走，也就是1.5BTC；这样B就损失了1BTC，怎么预防这种情况呢？</li>
</ol>


<p>解决方法就是提现一定要双方都签名承认才可以：任何一方在任何时候都可以提出提现，提现时需要提供一个双方都签名过的资金分配方案（意味着肯定是某次交易后的结果，被双方确认过，但未必是最新的结果）。在上面的那种情况下，B是无论如何也不会同意的。这就阻止了A的提现。</p>

<p>另外，为了威慑A这种行为，在一定时间内，如果另外一方拿出证明表明这个方案其实之前被作废了（非最新的交易结果），则资金罚没给质疑方；否则按照提出方的结果进行分配。罚没机制可以确保了没人会故意拿一个旧的交易结果来提现。</p>

<p>最后，即使双方都确认了某次提现，首先提出提现一方的资金到账时间要晚于对方，这就鼓励大家尽量都在链外完成交易。通过RSMC，可以实现大量中间交易发生在链外。</p>

<p>那么如果有一方耍小心眼，就是损人不利己，死活不签名来阻止另一方的提现呢？也没关系，在这个模型中，有了惩罚机制，提现的一方可以直接拿最后一笔清算交易的状态来广播(这笔交易是双方都签名承认的)，代价就是晚一点得到资金而已。</p>

<ul>
<li>整个过程里面，最重要的就是惩罚机制的实现，我如何认定跟我交易的对方也遵从这个惩罚机制呢？这是用多重签名来保证的。因为多重签名实际上是个合约，所以这个方案被命名为RSMC。</li>
</ul>


<h4>让我们详细的描述这个过程</h4>

<p>内容引自： <a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<h4>RSMC 创建</h4>

<p>Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入通道中，便于业务往来。解释一下下方RSMC交易的结构，左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg1.jpg" alt="img" /></p>

<ol>
<li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时， Funding    Tx未签名，更不广播。</li>
<li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li>
<li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li>
<li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li>
<li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li>
<li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。上述过程以及结构图的描述，就是创建RSMC的全部过程。</li>
</ol>


<p>C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p>

<p>这个过程的精巧之处，就在于构造了一个被动机制，将自己的资金放入到一个嵌套多重签名的地址里面，任何一方想要提现，一定要先归还另一个人的资金。并且这个机制构造完成之后，我们才真正在支付通道中充值。</p>

<h4>交易更新</h4>

<p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。</p>

<p>于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg2.jpg" alt="img" /></p>

<p>交易更新时的交易结构此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？</p>

<p>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2  的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg3.jpg" alt="img" /></p>

<p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。</p>

<p>若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。</p>

<p>Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。</p>

<p>引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p>

<h4>交易关闭</h4>

<p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p>

<h2>HTLC 中转交易</h2>

<p>RSMC要求交易的双方一定要都缴纳一笔保证金，我每天都跟不同的商家打交道，不能跟每个人都去建立RSMC，存入一笔资金吧。而且通道的建立和关闭都是需要链上广播的，如果要建立多个支付通道，交易费用也不容小觑，这有点本末倒置了吧。</p>

<p>为了解决这个问题，闪电网络又引入了HTLC ( Hashed Timelock Contract )，中文意思是“哈希的带时钟的合约”。这个其实就是限时转账。理解起来也很简单，通过智能合约，双方约定转账方先冻结一笔钱，并提供一个哈希值，如果在一定时间内有人能提出一个字符串，使得它哈希后的值跟已知值匹配（实际上意味着转账方授权了接收方来提现），则这笔钱转给接收方。</p>

<p>推广一步，甲想转账给丙，丙先发给甲一个哈希值。甲可以先跟乙签订一个合同，如果你在一定时间内能告诉我一个暗语，我就给你多少钱。乙于是跑去跟丙签订一个合同，如果你告诉我那个暗语，我就给你多少钱。丙于是告诉乙暗语，拿到乙的钱，乙又从甲拿到钱。最终达到结果是甲转账给丙。这样甲和丙之间似乎构成了一条完整的虚拟的“支付通道”。而乙就做了中转节点。</p>

<p>Alice想要支付0.5BTC给Bob，但她并没有一个渠道来和他进行交易。幸运的是，她和Charlie有一个交易渠道，而Charlie正好和Bob有一个交易渠道。这样Alice就能借助Charlie的交易渠道，通过哈希时间锁定合约（HTLC）来和Bob进行交易了。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg4.png" alt="img" /></p>

<p>为了完成这次交易，Alice就会给Bob发短信说：“嘿！我要给你付笔款。”这时Bob自己将收到一个随机数字（R），接着Bob便会回一个被哈希的数字（H）（你可以认为被哈希的数字R是随机数字的一种加密形式）给Alice。</p>

<p>然后Alice的钱包紧接着就会联系Charlie说：“嘿，Charlie。如果你给我生成（H）的未加密值（R），那么我就同意更新我们渠道的支付分配，这样你就可以得到的就会比0.5BTC多一点，我得的比0.5少一点。”</p>

<p>尽管Charlie并不知道R，但他也会同意。之后Charlie便会去找Bob说：“嘿，Bob。如果你给我那个能生成H的未加密的值R，我将同意更新我们渠道的支付分配，这样你就可以得到的会比0.5BTC多一点，我得到的比0.5少一点。”因为R就是从Bob这里生成的，所以他肯定知道。接着他马上将R告诉Charlie，并更新了其渠道的支付分配。然后Charlie将R告诉给了Alice之后也更新他们的渠道，最后交易完成，Alice以脱链的形式付给Bob0.5BTC。</p>

<h4>扩展</h4>

<p>HTLC给了任意两个点之间，通过路由转发达到支付的目标。这样用户无需打开过多的通道，只需要存入一笔资金跟一个比较大的中介机构建立通道就好了。之后所有的支付行为，我们都期望这个中介机构能自动路由到商家。</p>

<p>在闪电网络的极大繁荣时间，可以看作是现在互联网模型的克隆。</p>

<h2>优缺点大辩论</h2>

<h4>关于支付通道建立</h4>

<ul>
<li><p>乐观： 建立的闪电网络渠道可以与现有钱包和系统内置无缝过程。当收到和支付比特币时，资金需要存到某个地方。资金可以在收到时立即进入闪电网络的通道中，因此建立该通道不需要额外的步骤或成本。</p></li>
<li><p>悲观：为了建立闪电网络渠道，用户必须手动创建一个新的昂贵的链上交易。</p></li>
</ul>


<h4>关于通道关闭</h4>

<ul>
<li><p>乐观:可能不需要关闭渠道，用户可以无限期地或长时间地将钱存放在通道中。</p></li>
<li><p>悲观:一旦支付完成，就需要透过手动创建昂贵的在线交易来关闭通道。</p></li>
</ul>


<h4>关于网络路由</h4>

<ul>
<li><p>乐观:现有的P2P网络已经需要网络拓扑和消息传递，节点通常具有八个连接。闪电网络拓扑结构只是其中的一个延伸。路由不是一个重要的问题，因为即使在大规模网络中，用户之间路径的平均步数也是很小的。即使路由有问题，也可以简单地在链上进行支付，而用户甚至感觉不到两者的差异。少数大型渠道运营商可以防止路由发生任何问题。</p></li>
<li><p>悲观:路由可能是一个较大的问题，因为找到各方之间最短的路径对于演算法来说是个难题。如果找不到清晰的路线，则用户和商户将不得不通过繁琐的过程来手动改变并选择在链上交易的过程。</p></li>
</ul>


<h4>关于支付通道的中心化</h4>

<ul>
<li><p>乐观:有些经济奖励措施是用来对抗这种中心化的，任何人都可以设立节点，因为进入门槛低。除此之外，还可以通过收取较低的费用来削减其他节点对网络的影响力。即使网络集中在几个大型交易枢纽上，闪电网络仍然提供了一个有用而有趣的系统。比特币已经有一些像 Coinbase 这样的大机构来管理大量的资金。在闪电网络下，这些机构没有资金保管权，只是用来传递用于支付的数据。</p></li>
<li><p>悲观:   网络将集中围绕在几个大型交易枢纽，因为这是最有效的模式。这种集中化增加了系统性渠道失效的风险，即少数大渠道出现故障，导致支付渠道同时大量外流，造成连锁拥堵，使部分资金在到期前无法退出渠道。</p></li>
</ul>


<h4>关于流动性</h4>

<ul>
<li><p>乐观:将有机制激励用户运行闪电网络节点，并提供流动性，以收取费用，网络便可以用于小额支付，支付额度可以远小于最大渠道容量，确保有足够的流动性。</p></li>
<li><p>悲观:支付渠道流动性不足，因此其规模将受到限制。任何较具规模的支付几乎可以立即消耗掉整个渠道的流动性，瘫痪闪电网络的支付渠道。</p></li>
</ul>


<h4>关于要求收款人在收款时在线</h4>

<ul>
<li><p>乐观:虽然收件人必须在线才能收到付款，但这与大多数在线支付系统没有显着不同，因为如果收款人不在线上，他们不知道或无法验证收款。直接收款的用户或设备也不需要存储私钥。例如，商店 PoS 终端或加密 ATM 机可以在收款前通过互联网从公司的总部确认签署回收交易，因为无论如何双方在收款时都需要沟通。</p></li>
<li><p>悲观:通过链上交易，发件人需要的是收款地址，而收件人不需要在线。与此相反，收款人在接收付款之前需要签署收回交易。这是一个重大的限制，意味着收件人必须将私钥暴露在热钱包中。这使得闪电网络在下列许多情况下便的不切实际，例如在 ATM 上，在商店 PoS 系统上进行大额支付，或者支付给那些难以连上互联网的收款人。</p></li>
</ul>


<h4>闪电网络较大的安全风险</h4>

<ul>
<li><p>在收款时必须在线的要求：如上所述，在收款之前，收款人需要签署收回交易，以便汇款人知道如果渠道不正常的关闭或拒绝签署的情况发生，他们可以收回资金。因此，收钱需要一个热钱包，这意味着如果发生安全事件，私钥可能被暴露。</p></li>
<li><p>监督渠道的要求：可能需要闪电网络参与者或瞭望塔主动监督网络渠道。这可能给用户或瞭望塔带来负担，并且与存储在区块链上的比特币相比，潜在地降低了渠道内的资金安全性。未能适当监督渠道或由在线网络造成的拥塞可能增加用户错过了回收交易截止日期的风险。</p></li>
<li><p>矿工可以审查渠道关闭交易：作为不属于交易双方的矿工可以通过审查渠道关闭交易，一旦他们具有 51％ 的哈希率便可能有能力从闪电网络用户窃取资金。虽然这种类型的攻击就算在没有应用闪电网络的情况下已经具有破坏性的后果，但闪电网络的应用可能会提供一个更大的攻击面。</p></li>
</ul>


<h2>小结</h2>

<p>RSMC 保障了两个人之间的直接交易可以在链下完成，HTLC保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。闪电网络整合这两种机制，就可以实现任意两个人之间的交易都在链下完成了。</p>

<p>在整个交易中，智能合约起到了中介的重要角色，而区块链网络则确保最终的交易结果被确认。</p>

<p>闪电网络似乎可以在整体网络交易规模上带来重大改进。从而导致交易速度提高和交易费用大幅下降，而整体又不会影响核心基础安全性。然而，至关重要的是，闪电网络自身在安全性上的不足可能使闪电网络不适合用于大额支付（或者至少用其进行大额支付的行为可能是不负责任的）。投机和投资等行为是需要大额支付的，而这些行为目前看来是加密货币领域的主要的交易推动力，相比之下，零售小额支付的数量相对较小。</p>

<p>最后附赠一个技术讲解比较好但是旗帜鲜明反对闪电网络的视频教程：</p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p>当然再为闪电网络声援一下，闪电网络的思想发源于微支付通道，Satoshi实际上早期对微支付通道已经有了基本的设想：</p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p>孰对孰错，是非只能自己判断。</p>

<h2>架设一个闪电网络节点，完成一笔交易</h2>

<p>光说不练假把式，增加一把实战</p>

<h4>运行一个bitcoind全节点</h4>

<p>我们选用bitcoind运行一个testnet模式的全节点，配置文件如下:</p>

<p>bitcoin.conf:</p>

<p>```
rpcuser=xxxx
rpcpassword=xxxx
rpcallowip=192.168.2.1/16
rpcport=8332
test.rpcport=18332
rpcthreads=10
server=1
rest=1
testnet=1</p>

<h1>for lnd</h1>

<p>server=1</p>

<h1>daemon=1</h1>

<p>zmqpubrawblock=tcp://192.168.2.1:28332
zmqpubrawtx=tcp://192.168.2.1:28333
```</p>

<p>启动bitcoind:</p>

<p><code>
bitcoind --conf=/opt/blockdata/testnet3/bitcoin.conf --datadir=/opt//blockdata/ --deprecatedrpc=signrawtransaction &gt;&gt; test.log 2&gt;&amp;1
</code></p>

<h4>建立闪电网络节点</h4>

<p>我们采用lightningnetwork这个Go版本的实现(全程需要翻墙)：</p>

<p><a href="https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md">https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md</a></p>

<ul>
<li>安装go环境</li>
</ul>


<p><code>
sudo apt-get install golang-1.11-go
</code></p>

<ul>
<li>设置环境变量</li>
</ul>


<p><code>
export GOPATH=~/gocode
export PATH=$PATH:$GOPATH/bin
</code></p>

<ul>
<li>Clone &amp;&amp; 编译</li>
</ul>


<p><code>
go get -d github.com/lightningnetwork/lnd
cd $GOPATH/src/github.com/lightningnetwork/lnd
make &amp;&amp; make install
</code></p>

<ul>
<li>启动lnd</li>
</ul>


<p><code>
lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxx --bitcoind.rpcpass=xxxx --bitcoind.zmqpubrawblock=tcp://192.168.2.1:28332 --bitcoind.zmqpubrawtx=tcp://192.168.2.1:28333
</code></p>

<h4>建立一个新钱包，充值</h4>

<p><code>
lncli --network=testnet create
</code>
之后按照提示一路回车下去，建立一个新钱包，然后执行下列命令得到一个新地址</p>

<p><code>
lncli --network=testnet newaddress np2wkh
</code></p>

<ul>
<li>去下面这几个网址列表领取一些免费的TestNet Bitcoin:</li>
</ul>


<p><a href="https://lnroute.com/testnet-faucets/">https://lnroute.com/testnet-faucets/</a></p>

<ul>
<li>执行下面命令看看余额</li>
</ul>


<p><code>
lncli --network=testnet walletbalance
</code></p>

<h4>连接通道</h4>

<ul>
<li>首先执行下面命令确认我们的节点的同步状态</li>
</ul>


<p><code>
lncli --network=testnet getinfo
</code>
确认<code>synced_to_chain</code>字段已经变成true，代表区块头同步完毕。</p>

<ul>
<li>然后去下面的网址找一个可用的闪电节点:</li>
</ul>


<p><a href="https://explorer.acinq.co/">https://explorer.acinq.co/</a></p>

<ul>
<li>我们选一个channel数比较多的然后连接这个节点：cosmicApotheosis</li>
</ul>


<p><code>
lncli --network=testnet connect 03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028@138.229.205.237:9735
</code></p>

<ul>
<li>下一步建立通道，这里我们存0.1btc到通道里:</li>
</ul>


<p><code>
lncli --network=testnet openchannel --node_key=03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028 --local_amt=10000000
</code></p>

<ul>
<li>查看节点连接状态：</li>
</ul>


<p><code>
lncli --network=testnet listpeers
</code></p>

<p>这里我们还需要等待3次确认，通道才能建立成功，记住刚才建立完的transaction id，去网上查询等待3次确认。</p>

<ul>
<li>检查通道的状态：</li>
</ul>


<p><code>
lncli --network=testnet listchannels
</code>
当通道打开的时候，就可以用闪电网络支付啦！</p>

<h4>支付</h4>

<ul>
<li>我们去<a href="https://testnet.satoshis.place/">satoshi.place</a> 随便来几笔涂鸦，得到一个支付地址:</li>
</ul>


<p><code>
lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d
</code></p>

<ul>
<li>在命令行里支付：</li>
</ul>


<p><code>
lncli  --network=testnet sendpayment --pay_req  lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d
</code></p>

<p>顺利的话，瞬间支付成功。</p>

<h4>小结</h4>

<p>看起来是不是很麻烦，相信我，实际做一遍的话坑也不少。</p>

<p>目前有小部分钱包实现了闪电网络支付；但是拍脑袋想想就知道钱包里面无法包含闪电节点的全部功能：因为收款需要时时刻刻的监控，所以不可避免的需要一个类似于<code>瞭望塔</code>式的服务，最合理的办法就是将这个功能的实现剥离出来，单独部署到一台服务器上。</p>

<p>electrum轻钱包在<a href="https://github.com/spesmilo/electrum/issues/2557">这里</a>讨论了典型的实现方式。</p>

<p>可以预见到将来，实现闪电网络的钱包除了要自建全节点之外，还需要建立稳定的闪电网络节点实现类似<code>瞭望塔</code>的功能，当闪电网络极大繁荣的时候，钱包服务商实际上会占据及其有利的地位，闪电网络的发展，需要比特币钱包软件的进化，这是一个非常大的商机。</p>

<h2>参考资料:</h2>

<p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html">https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html</a></p>

<p><a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<p><a href="https://www.8btc.com/article/92887">https://www.8btc.com/article/92887</a></p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p><a href="https://blog.bitmex.com/zh_cn-the-lightning-network/">https://blog.bitmex.com/zh_cn-the-lightning-network/</a></p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p><a href="https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/">https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy 10th Birthday Bitcoin]]></title>
    <link href="https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin/"/>
    <updated>2019-01-03T21:12:12+08:00</updated>
    <id>https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin</id>
    <content type="html"><![CDATA[<p>自 <a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a>在2009-01-03 诞生以来，bitcoin 已经运行十年了。从一个个人项目，成长为世界话题，一段不可思议的旅程。</p>

<p>有人在&lt;纽约时报>上面为其庆生：</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/">https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/</a></p>

<p>我在2013年初次读到白皮书的时候申请了一个域名:</p>

<p><a href="http://20090103.com/">http://20090103.com/</a></p>

<p>出于好玩的心态一直维护着，看看下一个十年会是怎样。</p>

<h4>Hi, Happy 10th birthday bitcoin!</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-6]]></title>
    <link href="https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6/"/>
    <updated>2019-01-01T20:10:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6</id>
    <content type="html"><![CDATA[<p>好啦，这篇文章中，我们要来探讨大名鼎鼎的Segwit(Segregated Witness)。</p>

<p>这个词一说起来就头疼啊，他牵扯到旷日持久的扩容大战，无穷尽的争论以及分裂。我们的立场就是不去站队任何组织，单纯从技术的角度去理解这个东西。</p>

<!-- more -->


<p>首先澄清一个误解，其实Segwit跟扩容没关系，它最初提出来，只是为了解决交易延展性的问题，顺便有一点扩容效果，但这个扩容效果只是附带的；</p>

<p>另外，其实Segwit的技术原理非常简单，但是要考虑兼容性的问题，导致从设计到实施都有点复杂。</p>

<h2>缘起</h2>

<p>嗯哼，又要涉及到大量的数学知识；先声明下，我至今还没有从数学原理上完全理解椭圆曲线算法，所以下面讲的都是码农派的API理解&mdash;搞明白接口，但里面的细节还需要更多时间去探究。</p>

<p>上一篇文章我们提到，当交易被签名时，签名并没有覆盖交易中所有的数据 (因为签名是不可能对自身签名的)，而交易中所有的数据又会被用来生成交易的哈希值来作为该交易的唯一标示。</p>

<p>如果签名向常见的HASH算法一样，碰撞机率极小的话也没有问题；但是椭圆曲线算法存在一个看起来比较弱的特性：</p>

<blockquote><p>ECDSA算法生成两个大整数r和s并组合起来作为签名, 可以用来验证交易。而r和BN-s 也同样可以作为签名来验证交易(BN＝0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141). 这样，攻击者拿到一个交易，将其中inputSig 的r, s 提取出来， 使用 r, BN-s 生成新的inputSig, 然后组成新的交易，拥有同样的input和output，但是不同的TXID. 攻击者能在不掌握私钥的情况下几乎无成本地成功地生成了合法的交易。</p></blockquote>

<p>让我们再用码农能理解的语言描述一遍:</p>

<ol>
<li>前面的交易中，scriptSig脚本可以提取出sig签名</li>
<li>sig是由两个值组成的，Sig=(R,S)</li>
<li>sig是嵌入在scriptSig中，用一种名为<code>DER-encoded ASN.1 octet representation</code>的编码方式编码的。OpenSSL并没有强制要求每个签名编码结果只能有一个值。</li>
<li>对于每一个 ECDSA <code>signature(R,S)</code>，还存在相同消息的另外一个有效签名: <code>signature(R,-S(mod N))</code></li>
<li>一个恶意攻击者得到Sig之后，可以手工构造另外一个<code>signature(R,-S(mod N))</code>嵌入到scriptSig中，这和之前的scriptSig不一样，所以TX ID也会发生变化</li>
<li>这笔新的交易输入输出跟原来的交易完全一样，也是合法的，但是TX ID不同了。</li>
</ol>


<h4>危害</h4>

<ol>
<li>Alice通过在线钱包给Bob发送了一笔交易，并把TXID发送给Bob说，看我给你发了多少比特币</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>Bob 通过Alice发来的TXID搜索了以下，并没有发现这笔交易</li>
<li>Bob说，Alice是个骗子</li>
</ol>


<h4>对于交易所的威胁</h4>

<ol>
<li>黑客向交易所发起来一笔资金提现</li>
<li>交易所自动处理，广播了交易，并发送给黑客TX ID</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>黑客对交易所说，我没有收到资金，那笔交易不存在</li>
<li>交易所验证了下，因为原来得交易已经被黑客替换掉了，所以原始交易果然不存在了</li>
<li>交易所只能又构造了一笔交易再次广播</li>
<li>黑客最后得到了两笔资金</li>
<li>这种情况下的解决方法是，遇到交易无法确认就停止，报错误并等待手动处理，或者，我们可以自己生成一个延展性交易，然后获取新的TXID,查找是否发送成功。能生成的TXID数量有多少呢？一共有exp(2, input数量)个，因为每个input都有改签名或者不改两种可能， 通常不是一个大数目。</li>
<li>但是这不能阻挡脚本小子的恶意攻击，他们通常会<code>损人不利己</code>的构造大笔延展性交易来攻击网络</li>
</ol>


<h2>讨论</h2>

<p>社区为了解决这个问题进行了大量的讨论：以下是一些材料和社区进行的努力：</p>

<h4>BIP0062</h4>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki</a></p>

<h4>BIP66</h4>

<p>在 363742 区块高度处，BIP66 软分叉强制区块链中所有新交易遵循 DER-encoded ASN.1 标准。仍然需要进一步的努力来关闭 DER 签名其它可能的延展性问题。
签名仍然是可以被拥有相应私钥的人改变的。</p>

<h2>解决</h2>

<p>2015年12月，Bitcoin Core开发团队的<a href="https://github.com/sipa">Pieter Wuille</a>提出了一个解决方案，称之为隔离见证 (Segregated Witness）。隔离见证由以下BIPs定义：</p>

<ol>
<li>BIP-141:隔离见证的主要定义</li>
<li>BIP-143:版本0见证程序的交易签名验证</li>
<li>BIP-144对等服务——新的网络消息和序列化格式</li>
<li>BIP-145隔离见证（对于矿工）的 getblocktemplate 升级</li>
</ol>


<p>最主要的描述在BIP141中:</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</a></p>

<h2>原理</h2>

<p>其实说白了原理非常简单，就是把vin的scriptSig挪到交易的末尾去。</p>

<p>每一个比特币交易，其实可以分为两部份。第一部份是说明结余的进出，第二部份是用来证明这个交易的合法性 (主要是签署)。第一部份可称为「交易状态」，第二部份就是所谓的「见证」(witness)。如果你只关心每个账户的结馀，其实交易状态资料就已经足够。只有部份人(主要是矿工)才有必要取得交易见证。</p>

<p>那么我们再来复习下一笔P2PKH交易的结构:</p>

<p>```
{</p>

<pre><code>"result": {
    "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
    "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
    "version": 1,
    "size": 233,
    "vsize": 233,
    "locktime": 0,
    "vin": [
        {
            "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
            "vout": 0,
            "scriptSig": {
                "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
                "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
            },
            "sequence": 4294967295
        }
    ],
    "vout": [
        {
            "value": 0.00007000,
            "n": 0,
            "scriptPubKey": {
                "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
                "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
                "reqSigs": 1,
                "type": "pubkey",
                "addresses": [
                    "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
                ]
            }
        }
    ],
    "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
    "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
    "confirmations": 85331,
    "time": 1494823668,
    "blocktime": 1494823668
},
"error": null,
"id": null
</code></pre>

<p>}
```</p>

<p>在整笔交易里面，输入输出信息以及金额大小属于第一部分，scriptSig属于第二部分。</p>

<p>只有矿工以及全节点需要进行scriptSig的验证；如果是普通的SPV轻钱包只需要验证所在区块的合法行就可以了。所以可以把scriptSig 部分挪到交易的尾部。这样带签名的原始数据就固定了，也不会有更改TX ID的机会。这部分数据称之为witness:</p>

<p>每个witness都由一个var_int打头，代表接下来的数据长度。如果某个输入没有见证，那么其witness就是一个0x00。</p>

<p>让我们代入各种例子，来看看Segwit是如何工作的？</p>

<h4>P2WPKH (Pay-to-Witness-Public-Key-Hash)</h4>

<p>首先回顾下P2PKH的锁定脚本(scriptPubKey)与解锁脚本(scriptSig)内容</p>

<ul>
<li>P2PKH
<code>
scriptSig:    &lt;signature&gt; &lt;pubkey&gt;
scriptPubKey: OP_DUP OP_HASH160 &lt;20-byte hash of Pubkey&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></li>
</ul>


<p>再来看一下P2WPKH的脚本内容</p>

<ul>
<li>P2WPKH<br/>
<code>
scriptSig:    (empty)
scriptPubKey: 0 &lt;20-byte hash of Pubkey&gt;
witness:      &lt;signature&gt; &lt;pubkey&gt;
</code></li>
</ul>


<p>P2WPKH的锁定脚本较P2PKH要精简不少，第一位的数字0是版本号，有了版本号，未来脚本升级就能更容易的向前兼容。</p>

<p>P2WPKH的解锁脚本为空，而真正的解锁脚本内容被移到了原交易之外的witness部分。</p>

<h4>P2WSH(Pay-to-Witness-Script-Hash)</h4>

<ul>
<li>P2SH</li>
</ul>


<p><code>
  scriptSig:    0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;
  scriptPubKey: HASH160 &lt;20-byte hash of redeem script&gt; EQUAL
</code></p>

<ul>
<li>P2WSH<br/>
<code>
scriptSig:    (empty)
scriptPubKey: 0 &lt;32-byte hash of redeem script&gt;
witness:      0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;
</code></li>
</ul>


<p>P2WSH锁定脚本与P2WPKH类似，第一位是版本号，第二位是赎回脚本(Redeem script)的Hash值。</p>

<p>值得注意的是P2WSH锁定脚本中的Hash值是256位(32字节)的，是使用SHA256(pubkey)计算得到；而P2WPKH中的Hash值是160位(20字节)的，是使用RIPEMD160(SHA256(pubkey))计算得到的。</p>

<p>这样做的目的是让钱包可以根据Hash值的长度区分交易使用的是P2WPKH还是P2WSH。</p>

<p>在P2SH交易中常常会有多重签名验证，所以验证信息会占用更多空间，将这些信息移到原交易之外能更大程度的降低交易大小。</p>

<h4>锁定脚本版本号</h4>

<p>仔细观察之后，我们发现scriptSig以及scriptPubKey都以一个<code>0</code>开头；这代表着一个版本号。开发团队对于这个字段还有更远大的愿景，锁定脚本(Locking script)加上版本号，从而使脚本语言的升级更容易向前兼容，这种不造成太大影响的脚本语言修改方式将加快比特币的创新。</p>

<p>这个字段的精巧之处就在于，老节点看到这种交易也是合法的，虽然不能正确parse这种交易，但是当作为交易被打包到一个新区块，然后被支持segwit的矿工挖出来这个块，其它不支持segwit的老节点也是承认这个块的！</p>

<p>为什么呢？复习一下我们之前的文章，在一笔交易结构里面，这种交易是合法的 (是的，真相其实更复杂，但是我懒得详细介绍了，也许之后更闲的时候会仔细说说吧)！</p>

<p>虽然不能正确解析，但格式合法。有的人觉得这种技术忒精巧了，甚至精巧到了一种可怕的程度，是一种杂耍式的开发。很多人对于这种<code>啊哈</code>式的适配吓坏了。</p>

<p>现在Segwit已成事实，是非曲直只能留给你自己去判断了。</p>

<h4>交易标识符</h4>

<p>从上面看，其实实施Segwit之后，数据结构反而变得更清晰简单了。如果中本聪一开始就采用这样的结构，我相信也没有多少人会质疑。</p>

<p>但是已有的老的交易格式及相关系统已经运行了这么长时间，我们希望能尽可能的兼容以前的系统。最麻烦的适配就是原来传统交易的ID只有一个txid。现在见证数据挪到后面了，HASH的时候就不包括这一块数据了，怎么办？</p>

<p>传统交易的txid是以下序列 double sha256的结果:</p>

<p><code>
[nVersion][txins][txouts][nLockTime]
</code></p>

<p>最后开发者们又引入了另外一个id，称之为wtxid；它是对整个交易double sha256的结果:</p>

<p><code>
[nVersion][marker][flag][txins][txouts][witness][nLockTime]
</code></p>

<p>我们知道，每笔交易的txid是临时计算的，并不入块。但是整个Block是以所有交易的txid以Merkle Tree的形式组织的(这部分知识我们还没讲，需要到后面将bitcoin blockchain的时候提到)；现在多了一个wtxid，该怎么办呢？</p>

<p>解决办法又让人有点无语，就是将wtxid按照同样的组织方法算出Merkle Tree根节点，放到Block块中。</p>

<p>但是原有的Block格式都固定下来了，这个根节点放哪里呢？</p>

<p>还有coinbase的100个字节是可以利用的嘛，就是你了。</p>

<p>这<del>~，在有洁癖的人看来，完全又是一种码农修修补补式的FIX；相信众多技术人员这个时候已经开始内心无数吐槽了；但是真实世界就是这样无奈啊，又想要兼容性，又想要代码干净，又想要性能</del></p>

<p>你是太阳吗！？地球都绕着你转吗？！</p>

<p>拿着吧，这就不少了！！</p>

<p>最后附上这段龌龊的代码：</p>

<p>```
std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock&amp; block, const CBlockIndex* pindexPrev,</p>

<pre><code>                                                  const Consensus::Params&amp; consensusParams)
</code></pre>

<p>{</p>

<pre><code>std::vector&lt;unsigned char&gt; commitment;
int commitpos = GetWitnessCommitmentIndex(block);  //从币基交易的输出中寻找承诺项，没找到就返回-1
std::vector&lt;unsigned char&gt; ret(32, 0x00);
if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {
    if (commitpos == -1) {  //没有找到，就开始创建承诺，先生成见证版Merkle树根
        uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);
        CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());
        CTxOut out;  //构建一个币基交易的输出
        out.nValue = 0;  //金额是0
        out.scriptPubKey.resize(38);  //公钥脚本长度38，前6个字节固定为0x6a24aa21a9ed
        out.scriptPubKey[0] = OP_RETURN;  //0x6a
        out.scriptPubKey[1] = 0x24;  //36，即后面的总长度
        out.scriptPubKey[2] = 0xaa;  //0xaa21a9ed，固定不变的承诺头
        out.scriptPubKey[3] = 0x21;
        out.scriptPubKey[4] = 0xa9;
        out.scriptPubKey[5] = 0xed;
        memcpy(&amp;out.scriptPubKey[6], witnessroot.begin(), 32);  //插入见证版Merkle树根
        commitment = std::vector&lt;unsigned char&gt;(out.scriptPubKey.begin(), out.scriptPubKey.end());
        CMutableTransaction tx(*block.vtx[0]);
        tx.vout.push_back(out);  //币基交易中添加这个输出
        block.vtx[0] = MakeTransactionRef(std::move(tx));  //写回区块
    }
}
UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);  //更新区块其他结构
return commitment;
</code></pre>

<p>}</p>

<p>```</p>

<h4>隔离见证新的签名算法</h4>

<p>原来的签名验证需要大量的HASH操作；我们知道比特币是一个分布式系统，同时运行着上万个节点，如果一个操作每个节点都执行一遍，浪费的操作加起来很惊人的。</p>

<p>而隔离验证是个软分叉，为啥不能顺便再搞一点优化呢？毕竟软分叉的机会不多啊。于是开发者们顺便修改了四个签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG和CHECKMULTISIGVERIFY）的语义，改变了交易承诺散列的计算方式。</p>

<p>下面的说明引用自 Master Bitcoin:</p>

<blockquote><p>比特币交易中的签名应用于交易哈希，交易数据计算，锁定数据的特定部分，表明签名者对这些值的承诺。例如，在简单的SIGHASH_ALL类型签名中，承诺哈希包括所有的输入和输出。</p>

<p>不幸的是，计算承诺哈希的方式引入了验证签名的节点可能被迫执行大量哈希计算的可能性。具体而言，散列运算相对于交易中的签名操作的数量增加O（n<sup>2</sup>）。因此，攻击者可以通过大量的签名操作创建一个交易，导致整个比特币网络不得不执行数百或数千个哈希操作来验证交易。</p>

<p>Segwit代表了通过改变承诺散列计算方式来解决这个问题的机会。对于segwit版本0见证程序，使用BIP-143中规定的改进的承诺哈希算法进行签名验证。</p>

<p>新算法实现了两个重要目标。首先，散列操作的数量比签名操作的数量增加了一个更加渐进的O（n），减少了用过于复杂的交易创建拒绝服务攻击的机会。其次，承诺散列现在还包括作为承诺的一部分的每个输入的值（金额）。这意味着签名者可以提交特定的输入值，而不需要“获取”并检查输入引用的前一个交易。在离线设备（如硬件钱包）的情况下，这极大地简化了主机与硬件钱包之间的通信，消除了对以前的交易流进行验证的需要。硬件钱包可以接受不可信主机“输入”的输入值。由于签名是无效的，如果输入值不正确，硬件钱包在签名输入之前不需要验证该值。</p></blockquote>

<p>总之就是一句话，提升了验证签名的性能！！</p>

<h2>实施</h2>

<p>隔离见证（segwit）是一次比特币共识规则和网络协议的升级，其提议和实施将基于BIP-9，是一个软分叉。</p>

<p>2017年8月24日，区块高度481,824，隔离见证正式激活。</p>

<p>2015年提出，2017年激活；想想就知道这中间经历了多少曲折！！</p>

<p>隔离见证最终是全网95%的算力投票赞成才激活的，即使如此，网络中还是有一些不支持隔离见证的老节点在运行，同时，周边的钱包等软件也有不少还不支持隔离见证交易；此时的情况就比较复杂:</p>

<h4>付款人的客户端支持隔离见证，而收款人不支持</h4>

<p>如果收款人不支持隔离见证，那最终发布的地址将会是普通地址（P2PKH或P2SH），那所有交易按照原有的规则进行即可。</p>

<h4>付款人的客户端不支持隔离见证，而收款人支持</h4>

<p>聪明的社区开发者想出了一个过渡方案，即将P2WPKH或P2WSH植入P2SH。</p>

<p>是的！！作为有洁癖的开发者，你又会要吐槽了，这是什么操作！？</p>

<p>P2WPKH植入P2SH后，交易信息如下：</p>

<p><code>
  scriptSig:    0 &lt;20-byte hash of Pubkey&gt;
  scriptPubKey: HASH160 &lt;20-byte hash of script&gt; EQUAL
  witness:      &lt;signature&gt; &lt;pubkey&gt;
</code></p>

<p>此处的脚本Hash值为RIPEMD160(SHA256(0 &lt;20-byte hash of Pubkey>))的结果，将该脚本Hash转换为P2SH地址，就是一个兼容segwit的地址，不支持隔离见证的客户端可以正常支付比特币给这种P2SH地址。
而对于支持隔离见证的客户端，仍可以将验证信息放在witness结构中，当然这种过渡方案的交易会较完全形态的方案稍大一些，但比无隔离见证的情况要小。</p>

<p>这样就引入了另外一个混乱之处，我们前面的文章提到过，以<code>3</code>开头的地址是P2SH交易专用的，而P2SH交易一般包含的脚本逻辑比较复杂，现在又要判断一种情况，这笔交易是不是一笔隔离见证交易呢？</p>

<p>还有普通小白也很疑惑，比特币网络中开始出现大量以<code>3</code>开头地址的交易，之前这种交易很少，小白们甚至都没有见过这种地址。</p>

<p>为了解决这个问题，开发者们很快又提出了bech32地址格式(去参考我们之前的文章)，小白们很快就被搞得晕头转向。而此时社区正处于分裂状态，Bitcoin Cash作为硬分叉出来的江湖搅局者，虽然加入了重放保护，但是地址和Bitcoin的规则是一样的，但是Bitcoin Cash是不支持Segwit的！</p>

<p>很快，就有大量的小白在Bitcoin Cash里面发送交易给Segwit地址，这种混乱场景不忍卒见。</p>

<p>然后，Bitcoin Cash也搞出了自己的另外一套地址规则；好吧，你应该去找找我们早期的关于比特币钱包的文章，好好温习一下了。</p>

<h4>一些吐槽</h4>

<p>令人惊奇的是，这段混乱时期，在全网交易纷纷堵死，隔离见证升级、Bitcoin Cash分叉的混乱局面中，比特币的价格不合常理的大涨、暴涨，涨到大家怀疑人生。颇有一点狂风暴雨雷霆霹雳之下，大家在泰坦尼克号中末日狂欢的意味。</p>

<p>Bitcoin这个东西，实在不能以常理来琢磨啊。</p>

<h2>优点</h2>

<p>说了这么多，当然Segwit的升级还是又非常多的好处的~~~</p>

<h4>可以用软分叉增加最大区块容量:</h4>

<p>因为旧有节点根本看不到这些被隔离的见证，即使真实的区块已超过1MB，它们仍会以为没有超过限制而会接受区块。</p>

<p>比特币的区块大小限制为1000000bytes，由于witness数据不包含在这个限制中，为了防止witness数据被滥用，仍然对总的区块大小做了限制。引入了一个新概念叫块重量(Block weight):</p>

<p><code>
Block weight = Base size * 3 + Total size
Base size是不包含witness数据的块大小
Total size是包含了witness数据的总大小
</code></p>

<p>隔离见证限制Block weight &lt;= 4000000</p>

<p>这就是隔离见证扩容说的来由，这样实际上确实有一定的扩容效果，如果全网交易都迁移到隔离见证上来，大概扩容1.7倍吧。</p>

<p>但是!!! 注意，实际的区块链大小其实比原来更大，这一点一定要搞清楚。</p>

<h4>解决了交易延展性问题</h4>

<p>从此以後，只有发出交易的人才可以改变交易ID，没有任何第三方可以做到。如果是多重签名交易，就只有多名签署人同意才能改变交易ID。这可以保证一连串的未确认交易的有效性，是双向支付通道或闪电网络所必须的功能。有了双向支付通道或闪电网络，二人或多人之间就可以实际上进行无限次交易，而无需把大量零碎交易放在区块链，大为减低区块空间压力。</p>

<h4>轻量钱包可以变得更轻量，因为它们无需再接收见证数据</h4>

<h4>可以大幅改善签署结构</h4>

<p>在区块链上，曾经有一个超过5000个输入的交易，因为签署设计缺憾，需要半分钟才能完成检查。在建议中的SW软分叉会把这个问题解决掉。</p>

<p>而在该次软分叉完成後，核心开发者们已有计划进一步完善整个系统的可用性和安全性:</p>

<ol>
<li><p>全节点可以为轻量钱包提供很简洁的证明，以检查交易是否合法。以後的节点就不再局限於完全验证和完全不验证，而是可以按个人的资源作部份验证，也就是说一台手机也可以参与保障系统安全。这可以大为降低系统对全节点的依赖，即使以後区块容量提升了，我们仍能保持安全。</p></li>
<li><p>将会推出全新的交易脚本语言，例如可以把数以千计的不同脚本通过MAST技术压缩至只有32字节;亦可以把不同签署合并检查，令检查交易的速度再以倍数上升。</p></li>
</ol>


<h4>为闪电网络的实施铺平了道路</h4>

<p>闪电网络应该是继中本聪创造比特币之后最重量级的创新，支持者和反对者为其吵了一个天翻地覆，这个值得我们后面写文章大书特书，还是那句话，后文再见吧。</p>

<h2>副作用</h2>

<h4>复杂性</h4>

<p>是的，如果你看到这里；就会发现我到了大量的<code>吐槽</code>字眼；为了达成共识，隔离见证采用了软分叉升级，为了兼容老系统，不可避免的修修补补；另外虽然说起来是单独的一项技术，同时解决的问题可不少，在洁癖者眼里，这是屌丝码农的瞎折腾，就增加了出Bug的可能性；如果是个硬分叉，所有技术问题能干净利落解决，就没有这么多争吵了。</p>

<p>总之一句话，隔离验证留下的技术债不少，升级之后落子无悔，如果之后发现问题，可没机会回退了。</p>

<p>这次升级也是一次经典的技术、政治、利益交杂的各方博弈，如果将来比特币大成，这段历史值得仔细研究。</p>

<h4>Block Size</h4>

<p>前面已经在优点里面说过了。隔离见证有扩容效果的。但这个效果只是一个副作用，只是当时提出隔离见证的时候社区正就扩容问题吵得不可开交，莫名其妙的这个技术就卷入扩容斗争里面了。</p>

<p>再说一遍：关于隔离见证，网上一个很大的误解就是：认为witness被隔离走了，witness数据不在Block里，所以一个Block能装更多的Transaction。</p>

<p>其实不是，witness数据仍然在Block里面。并且对于1个Transaction来说，如果把witness数据也算上的话，其raw byte size其实是变大了，而不是变小了！！！
既然Transaction还变大了，那为什么1个Block可以装更多的Transaction呢？？</p>

<p>因为隔离见证是软分叉，不是硬分叉。下面就分别来分析一下，为什么对于老版本节点、新版本节点，1个Block都可以装更多的Transaction呢？</p>

<p>对于老版本节点：
Block Limit Size = 1M，但由于你把witness数据移到了所有Transaction的外面，放在了整个Block的尾部。老版本在计算一个Block大小的时候，只计算了
Block Header + 所有Transaction的数据（witness数据，老版本看不见！！！相当于老版本被欺骗了。）</p>

<p>所以呢，其实整个Block的物理大小(raw block size)已经超过了1M，但老版本的节点不认识尾部的witness数据，所以认为总大小还是 &lt; 1M。</p>

<p>对于新版本节点：
Block的size的计算方式做了调整，引入了Block weight的概念。
block weight = base_size * 4 + witness_size
block weight &lt;= 4M</p>

<p>其中，base_size就是block的前2部分数据（header + 没有witness的所有交易数据）</p>

<p>通过上面的分析，我们会发现，数据还是那么多数据，没有减少，只是重新排布了一下，却变相的把区块链扩容了！！！</p>

<h4>安全性</h4>

<p>有人提出来说，中本聪之前把交易信息和见证数据放在一块是有意的；因为一笔交易带有所有者的签名是天经地义的语义；隔离见证把witness独立出来，降低了比特币系统的安全性。另外~~~~</p>

<p>老实说，这个论据仔细读读还是蛮有道理的，但是实在说的太深刻太哲理了，码农对这种东西天生无感，我就不啰嗦了，大家感兴趣可以自己去搜索这方面资料。</p>

<h2>小结</h2>

<p>以上就是对隔离见证这个东东最简单的描述，我尽力做到简洁中立；但是实际上我觉得整个过程写一本书也不为过；</p>

<p>那么，隔离见证实施之后；就是闪电网络的崛起了，我们下篇文章再见。</p>

<h2>参考</h2>

<h4>四份有关隔离见证的比特币改善方案:</h4>

<ul>
<li>隔离见证软分叉</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki">https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki</a></p>

<ul>
<li>隔离见证通信层</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki">https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki</a></p>

<ul>
<li>隔离见证交易地址</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki">https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki</a></p>

<ul>
<li>隔离见证签署检查</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki">https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki</a></p>

<h4>系统扩展常见问题解答:</h4>

<p><a href="https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq">https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq</a></p>

<h4>需要30秒检查的交易:</h4>

<p><a href="https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08">https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08</a></p>

<h4>其它资料</h4>

<p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md">https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-5]]></title>
    <link href="https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5/"/>
    <updated>2018-12-28T21:08:25+08:00</updated>
    <id>https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5</id>
    <content type="html"><![CDATA[<p>我们还是拿<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517</a>做例子。</p>

<p>这篇文章需要结合<a href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/">比特币的交易-3</a>这篇文章来理解，我们在这里也直接复用TransA、TransB的说法。</p>

<!-- more -->


<h2>准备工作</h2>

<h4>私钥-公钥</h4>

<p>在<a href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/">比特币的HD钱包-2</a>中，我们已经算出来私钥的WIF表示:</p>

<p><code>
5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
</code></p>

<p>以及公钥:</p>

<p><code>
0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341
</code></p>

<h4>交易body</h4>

<p>这笔交易有1个vin，1个vout；然后再把我们之前的结构分析图拿来，看看具体需要哪些参数传入:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h4>需要手工构造input</h4>

<ol>
<li>指定上一笔vout的txid，是已知参数(outputTransactionHash):<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code></li>
<li>指定上一笔vout的index，是已知参数(sourceIndex):<code>00000000</code></li>
<li>构造scriptSig，即对这个UTXO签名。我们需要用私钥签名，这个是难点，我们后面来计算</li>
</ol>


<h4>需要手工构造output</h4>

<ol>
<li>设置矿工费用，从而计算输出值</li>
<li>构造scriptPubKey</li>
</ol>


<h4>最后组合成为一笔交易</h4>

<ol>
<li>增加version字段：<code>01000000</code></li>
<li>增加inputCount字段: <code>01</code></li>
<li>增加outputCount字段: <code>01</code></li>
<li>增加block lock time字段: <code>00000000</code></li>
</ol>


<h4>然后我们实现一个函数，将这些变量组合，最后得到原始交易值(对应bitcoin-cli的createrawTransaction)</h4>

<p>```</p>

<h1>Makes a transaction from the inputs</h1>

<h1>outputs is a list of [redeemptionSatoshis, outputScript]</h1>

<p>def makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs):</p>

<pre><code>def makeOutput(data):
    redeemptionSatoshis, outputScript = data
    return (struct.pack("&lt;Q", redeemptionSatoshis).encode('hex') +
    '%02x'.format(len(outputScript.decode('hex'))) + outputScript)
formattedOutputs = ''.join(map(makeOutput, outputs))
return (
    "01000000" + # 4 bytes version
    "01" + # varint for number of inputs
    outputTransactionHash.decode('hex')[::-1].encode('hex') + # reverse outputTransactionHash
    struct.pack('&lt;L', sourceIndex).encode('hex') +
    '%02x'.format(len(scriptSig.decode('hex'))) + scriptSig +
    "ffffffff" + # sequence
    "%02x".format(len(outputs)) + # number of outputs
    formattedOutputs +
    "00000000" # lockTime
    )
</code></pre>

<p>```</p>

<h4>outputs构造</h4>

<p>在构造一笔完整的交易之前，我们需要手工做两件事情：</p>

<ol>
<li>构造一个output输出</li>
<li>对vin中的UTXO签名，构造scriptSig</li>
</ol>


<p>outputs的构造比scriptSig简单一点，我们先来解决这个问题。</p>

<p>outputs是包含多个output的数组。在这个例子中，我们打算只构造一个output。结合我们之前的文章，就是构造一个bitcoin scriptPubKey，设置一把新锁。</p>

<p>这个scriptPubkey是这样子的:</p>

<p><code>
&lt;pubkey&gt;  OP_CHECKSIG
</code></p>

<p>PubKeyHash其实就是收币的地址，其它操作符都是现成的。</p>

<h2>如何构造一笔output</h2>

<p>一笔output的构造是简单的，所有东西都是现成的，而且这笔交易是个P2PK交易，输出非常简化，我们仅仅需要构造<code>&lt;pubkey&gt;  OP_CHECKSIG</code>即可:</p>

<p>```
def makeOutput(value,  index, pubkey):</p>

<pre><code>OP_CHECKSIG =  'ac'
value = "{:0&lt;16x}".format(int(struct.pack('&lt;I', int(value)).hex(), 16))
index = "{:02x}".format(int(index))
pubkey = pubkey
pubkey_length = "{:02x}".format(len(pubkey)/2)
return value + index = pubkey_length + pubkey + OP_CHECKSIG
</code></pre>

<blockquote><p>print(makeOutput(7000, 0, &lsquo;2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac&rsquo;))
581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac
outputs = [&lsquo;581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac&rsquo;]</p></blockquote>

<p>```</p>

<h2>如何对一笔交易签名(scriptSig)</h2>

<p>在构造一笔交易的过程中，签署交易是一个非常麻烦的过程。其基本思想是使用ECDSA椭圆曲线算法和私钥生成交易的数字签名，但细节比较复杂。</p>

<p>我们可以先通过验证签名的过程来理解以下，验证签名过程的通过10个步骤描述。下面的缩略图说明了详细的流程。</p>

<p><img src="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png" alt="img" /></p>

<p>这张图出自于<a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">这里</a>，里面的TX ID是不同的，但基本步骤一样。</p>

<h4>一些约定:</h4>

<ol>
<li>TransA代表TxPrev，TransB代笔TxNew</li>
</ol>


<h4>步骤:</h4>

<ol>
<li>首先解析TransB涨vin中的scriptSig，得到sigStr以及pubkeyStr</li>
<li>从TransA中拿出对应的vout ，从scriptPub脚本中截取需要的部分(subScript)：即 <code>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</code>；截取规则就是检索最后一个<code>OP_CODESEPARATOR</code>的位置，在这之后的脚本段就是我们要截取的对象</li>
<li>如果subScript中包含了签名，移除掉(在scriptPub中包含签名是很特殊的情况，一般出现在P2SH交易中，普通交易不需要这一步)</li>
<li>如果脚本中有<code>OP_CODESEPARATORS</code>操作符，移除</li>
<li>检测一步解析出来的scriptSig最后一个字节的HashType，扩展为4字节(小端排序)备用</li>
<li>将TransB 复制一份，变为TransBCopy</li>
<li>将TransBCopy中所有的Vin以及Vout 移除，同时将length字段置为0</li>
<li>将第4步中的subScript根据vin sequence填充到TransBCopy对应的位置</li>
<li>最后将交易TransBCopy序列化(采用DER编码)，并在末尾添加第5步中得到的HashType，得到签名的原始数据</li>
<li>最后执行签名验证过程: ECDSA_CheckSignature(pubkeyStr, sigStr, double_sha256(TransBCopy))</li>
</ol>


<h4>疑点解惑</h4>

<h5>为什么这么麻烦，不能直接对TransB签名吗？</h5>

<p>因为最终的签名是包含在TransB当中的，签名是不能对自身来签名的；所以要签名的原始数据不能包含签名本身；</p>

<p>说句题外话，由于ECDSA的签名算法的局限，这个结构组织方式最终导致了一个顽疾，即交易延展性问题，也被翻译为交易可锻性（Transaction Malleability）。</p>

<p>简单来说，就是攻击者可以生成不同但是合法的scriptSig，这样虽然vin，vout金额和地址不变，但是TX ID会发生变化，从而导致用户找不到发送的交易。</p>

<p>这对于交易所是一个威胁，某个居心不良的用户可能充值了一笔资金，然后重新生成scriptSig又广播了一笔交易，然后欺骗交易所，说第一笔交易没收到，交易所检查以下果然如此，于是又发送了一笔资金给用户，这样用户就实现了double withdraw，白赚了一笔。MTGOX早期就是这么被坑的，后来也出现过一些损人不利己的脚本小子们公然利用这个漏洞攻击比特币网络；为了解决这个问题，core开发者提出了segwit解决方案(即隔离见证)，后来随着政治斗争、市场斗争的激化，一个技术问题最终演化成了扩容派的分裂。</p>

<p>总之还是那句话，关于segwit, 闪电网络，期待我们后面的文章吧。</p>

<h5>为什么要用上一笔交易vout来填充这个位置呢？</h5>

<p>我们说验证签名的过程，其实有三个作用:</p>

<ol>
<li>签名证明私钥的所有者，即资金所有者，已经授权支出这些资金</li>
<li>授权证明是不可否认的（不可否认性）</li>
<li>签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改</li>
</ol>


<p>我们提供签名、私钥即承诺了第1点，对TransBCopy 签名承诺了第2点，但是要做到第3点，就需要对于引用UTXO的信息做承诺；</p>

<p>我们会问，单纯的prev TX ID和vout sequence no不能证明我要花费的哪一笔UTXO吗？</p>

<p>是的，这还是不够的，我们需要另外的信息熵的引入，就是这个UTXO的scriptPub。具体为什么，是ECDSA的数学特性决定的。请参考:</p>

<p><a href="https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/">https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/</a></p>

<p>老实说，关于ECDSA的签名验证，我在学习了很长时间以后，还是非常担心，因为签名生成算法使用随机密钥k作为临时私有-公钥对的基础，这个K值的随机性一定要人工保证，比特币的每笔交易验证，离不开签名验证，而这个签名验证如此复杂，确实让人心生忐忑。</p>

<h5>这个OP_CODESEPARATORS是什么东东？</h5>

<p>哈，到目前为止，我们接触到的都是比特币最简单、最基本、当然也是应用最广泛的交易类型，但是比特币还支持P2SH的高级交易，在这种交易中，vout里面可能会嵌入非常复杂的脚本，所以系统引入了OP_CODESEPARATORS作为复杂脚本的分隔符，以后的文章我们会详细讲解；</p>

<p>OP_CODESEPARATOR属于一种看起来<code>过度设计</code>的特性，老实说，我没有在比特币主网上发现像样的使用这个特性的交易，我也需要更多时间的学习才能搞明白这个东西，以下是一些参考资料：</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=164655.0">https://bitcointalk.org/index.php?topic=164655.0</a></p>

<h5>这个HashType是什么东东？</h5>

<p>嗯哼，又是一个非常棘手但是有意思的问题。</p>

<p>我们说比特币有了script之后，功能是非常非常丰富的，不仅仅局限于支付场景，他可以应用到许多非常复杂的场景中。</p>

<p>比如现在让我们考虑一个外贸公司的业务，这个公司的对公账户每天都要接受许多客户的付款，处于安全考虑，我作为公司的CEO，希望能跟财务主管共同管理公司的对公账户，当需要支出时，一定要我跟财务主管都签字同意才可以。</p>

<p>这就衍生出了所谓的M-N交易类型，即多重签名交易。</p>

<p>在多重签名交易中，要花费一笔UTXO，可能需要多个签名，或者有这种语义："一定要CEO的签名，如果没有CEO的签名，需要COO和CFO的联合签名"，为了表示这些，引入了SIGHASH这个字段，就是我们所说的HashType啦。</p>

<p>要考虑SIGHASH，实际上已经牵涉到了bitcoin的高级交易类型(P2SH)，还是那句话，关注后面的文章吧。</p>

<h4>反向代码</h4>

<p>嗯哼，把验证签名的步骤反向来一遍，就是签名的过程了。</p>

<p>代码表示如下:</p>

<p>```</p>

<p>def makeSignedTransaction(privateKey, outputTransactionHash, sourceIndex, scriptPubKey, outputs):</p>

<pre><code>myTxn_forSig = (makeRawTransaction(outputTransactionHash, sourceIndex, scriptPubKey, outputs)
     + "01000000") # hash code

s256 = hashlib.sha256(hashlib.sha256(myTxn_forSig.decode('hex')).digest()).digest()
sk = ecdsa.SigningKey.from_string(privateKey.decode('hex'), curve=ecdsa.SECP256k1)
sig = sk.sign_digest(s256, sigencode=ecdsa.util.sigencode_der) + '\01' # 01 is hashtype
pubKey = keyUtils.privateKeyToPublicKey(privateKey)
scriptSig = utils.varstr(sig).encode('hex') + utils.varstr(pubKey.decode('hex')).encode('hex')
signed_txn = makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs)
verifyTxnSignature(signed_txn)
return signed_txn
</code></pre>

<p>```</p>

<h2>广播交易</h2>

<p>好啦，构造了vin, vout，以及组合成一笔完整的交易，剩下的就是广播出去啦：</p>

<p>比特币的网络协议非常简单，设置好一个Magic Number就可以加入，以下时广播代码：</p>

<p>```
magic = 0xd9b4bef9</p>

<p>def makeMessage(magic, command, payload):</p>

<pre><code>checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]
return struct.pack('L12sL4s', magic, command, len(payload), checksum) + payload
</code></pre>

<p>def getVersionMsg():</p>

<pre><code>version = 60002
services = 1
timestamp = int(time.time())
addr_me = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
addr_you = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
nonce = random.getrandbits(64)
sub_version_num = utils.varstr('')
start_height = 0
</code></pre>

<p>def getTxMsg(payload):
  return makeMessage(magic, &lsquo;tx&rsquo;, payload)</p>

<p>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
HOST_IP =&ldquo;x.x.x.x&rdquo;
sock.connect(HOST_IP, 8333)</p>

<p>sock.send(msgUtils.getVersionMsg())
sock.recv(1000) # receive version
sock.recv(1000) # receive verack
sock.send(msgUtils.getTxMsg(&ldquo;01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000&rdquo;.decode(&lsquo;hex&rsquo;)))
```</p>

<p>HOST IP 怎么获取呢？</p>

<p>如果你有一个全节点，可以直接调用RPC接口的getpeers函数。或者你直接执行:</p>

<p><code>
nslookup bitseed.xf2.org
</code></p>

<p>从公共服务器里面检索nodes，里面随便挑一个IP 吧。</p>

<h2>小结</h2>

<p>以上就是一笔完整交易的构造过程。</p>

<p>这笔交易结构非常简单，只有一个vin，一个vout。</p>

<p>如果有多个vin, 多个vout的情况，就需要每个vin都签署一遍。</p>

<p>我们发现，一笔比特币交易的构造过程，最复杂的，就是签名以及验证的过程。它的步骤极其繁琐，而且椭圆曲线的签名算法极其复杂。如果在更高级的比特币交易中，比如P2SH，或者多重签名交易，或者Segwit交易，包含了更复杂的脚本和执行逻辑，事情很快就变得不可控制起来。</p>

<p>这是我在学习比特币知识时遇到的最大的恐惧，我认为如果将来比特币系统出现什么致命BUG，很大可能就在这里暴雷。</p>

<p>也许早期的开发者也觉得不放心，于是禁用了不少操作符。而目前Bitcoin SV和Bitcoin Cash的发展方向，是将这些操作符一一解放出来。</p>

<p>更强大的功能？还是更稳妥的基础设施？究竟怎样的做法是正确的，我也没有定论，只是告诉大家现在社区的发展方向就好了，大家自己做判断。</p>

<h2>参考资料:</h2>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>
]]></content>
  </entry>
  
</feed>
