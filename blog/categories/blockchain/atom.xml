<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Blockchain | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2018-12-05T16:05:18+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-4]]></title>
    <link href="https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4/"/>
    <updated>2018-12-05T16:04:29+08:00</updated>
    <id>https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4</id>
    <content type="html"><![CDATA[<p>之前我们学习了比特币的HD钱包的技术部分，写着写着我都觉得太无聊了，其实我觉得比特币归根结底还是一个很Geek的东西，初期被它吸引的人估计心底里都有一个独立自由的梦，甚至很多人都想要独立建国；它的技术发展史上也出现过很多有意思的事情，于是增加一篇娱乐性文章；</p>

<h3>让我们好好八卦一下比特币历史上那些有意思的地址</h3>

<!-- more -->


<h4>satoshi的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a></p>

<p>该地址属于比特币创始人中本聪，是比特币的创世地址，地址内的比特币从未移动过，其中的50币因为技术上的设计原因也无法进行移动。(卖个关子，具体啥原因关注我们后续的文章哦)</p>

<p>具体请参考:<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a></p>

<p>直到今天，还有源源不断的小额转账给这个地址，纪念satoshi。</p>

<h4>Hal Finney的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3">1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3</a></p>

<p>比特币历史上第一笔交易发生在<a href="https://www.blockchain.com/btc/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16">f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16</a>；是中本聪发送给我们熟知的<a href="https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist">Hal Finney</a>)先生的。这笔交易发送了10个BTC，被收录在第<a href="https://www.blockchain.com/zh/btc/block-height/170">170 Block</a>中。</p>

<p>可以肯定，第170 block之前所有的地址都是中本聪本人的钱包地址，如果有人再跳出来说自己是中本聪的话，我们什么都不相信，只会问他两个问题：</p>

<ul>
<li>您能花费一笔第170 block之前的比特币吗？</li>
<li>或者您能出示 <code>I am xxx, happy bitcoiner guys, and today is 2xxx/xx/xx, i prove i am satoshi</code> 这句话的签名，并让我们用早期的公钥来验证一下吗？</li>
</ul>


<h4>Laszlo Hanyecz 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1XPTgDRhN8RFnzniWCddobD9iKZatrvH4">1XPTgDRhN8RFnzniWCddobD9iKZatrvH4</a></p>

<p>没错，这就是著名的<a href="http://link.zhihu.com/?target=https%3A//bitcointalk.org/index.php%3Ftopic%3D137.0">比特币披萨日</a>事件中的主人公。</p>

<p>当时<a href="https://www.blockchain.com/btc/tx/a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d">这笔2010-05-22的交易</a>中，Laszlo Hanyecz花费了10000个币买了两个pizza；造就了比特币历史上第二个节日：披萨日。撒花~~~ (PS:我把比特币的第一个节日归为比特币的生日，<a href="https://20090103.com">2009/01/03</a>)</p>

<p>后来比特币价格不断波动，人们就不断的调侃史上最贵的pizza，史上价格变化最快的pizza等等~~~</p>

<p>Laszlo Hanyecz是个真正的Geek，他应该是已知的显卡挖矿第一人，在这个地址上，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p>

<p>当年买了Laszlo一万个比特币的Jercos当然也是这次历史时刻的另一个主角。他在去年的时候接受了一家媒体的访问，并漏出了自己的真实身份。</p>

<p>原来Jercos非常的年轻，现在也只有25岁（买10000个比特币那年仅仅19岁）。他告诉记者说自己在bitcoin刚创世的2009年就关注了这项技术，并成为了出入各大极客论坛的一员。他与卖披萨的Laszlo并不认识，但是总是在同一个IRC（聊天室）出入，在当时算是对ID比较相熟。</p>

<p>谈到一万个比特币的去向时，他表示在第二年他把这一万枚比特币以400美金的价格出售了，回报率在十倍。（虽然十倍但是还是很可惜了。。）如今他对区块链的技术还是十分看好，对以太坊也十分看好。</p>

<p>Laszlo Hanyecz与Jercos的比特币经历可谓是大风大浪了，以后可以跟后来人好好说说<code>当年~~~</code>；</p>

<p>如果你这样想，那就Out了，真正的Geek永远是站在潮流前头的，同样的，2018-02-05，闪电网络运行后，Laszlo Hanyecz又花费了0.00649枚比特币通过闪电网络买了两块披萨，续写了比特币披萨的传奇；</p>

<p>少年，当你在为所谓<code>10000个比特币买披萨是不是很后悔</code>这种问题纠结时，人家早就又一次站在潮头浪尖了；所以~~~</p>

<h5>让我们努力学习吧。</h5>

<p>这个地址至今仍然非常活跃，Laszlo Hanyecz仍然是比特币世界中的Geek先锋，并且他用自己的乐观幽默为全世界的bitcoiner创造了一个节日，Hi, Laszlo Hanyecz，谢谢你！</p>

<h4>Bitcoin Faucet donation的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC?offset=0&amp;filter=6">15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC</a></p>

<p>这个地址属于比特币先驱<a href="https://en.bitcoinwiki.org/wiki/Gavin_Andresen">Gavin Andresen</a>在2010年建立的一个网站:</p>

<p><a href="https://freebitcoins.appspot.com/">https://freebitcoins.appspot.com/</a></p>

<p>当时Gavin Andresen作为中本聪之后的主力开发者，非常希望普及比特币，于是建立了<a href="https://bitcointalk.org/index.php?topic=183.0">Bitcoin Faucet donation</a>这个项目，免费发送比特币给人们，这个地址总共免费发放了超过10000个币；</p>

<p>Gavin Andresen为比特币的开发，普及做出了巨大的贡献，Hi, 了不起Gavin，向你致敬！</p>

<h4>Andreas M. Antonopoulos 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1andreas3batLhQa2FawWjeyjCqyBzypd">1andreas3batLhQa2FawWjeyjCqyBzypd</a></p>

<p>Andreas M. Antonopoulos是比特币社区里令人肃然起敬的人物，他从非常非常早期(2012)就开始比特币相关知识的布道；我得说，凡是有严肃的学习比特币、区块链知识愿望的人们，观看Andreas M. Antonopoulos的讲演视频是绝佳途径，他的Yotube主页：</p>

<p><a href="https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ">https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ</a></p>

<p>Andreas M. Antonopoulos对比特币布道激励了非常多的人，但是作为先驱，他却没有收到多少报酬，这完全是<a href="https://twitter.com/aantonop/status/938147200978374662?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E938147200978374662&amp;ref_url=https%3A%2F%2Fqz.com%2F1151233%2Fandreas-antonopoulos-got-1-5-million-in-bitcoin-donations-after-roger-ver-bitshamed-him%2F">公益的工作</a>。怎么能让真正输出价值的人受到冷落呢？为了感谢他，在2017-12，粉丝们为他的地址发送了近100个bitcoin的捐款。但是我们这里很高兴的引用一句俗语：<code>黄金有价，知识无价</code>；Hi, Antonopoulos，<code>比特有价，知识无价</code>，期待收到你更多的教诲。</p>

<h4>美国法警局的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55">1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55</a></p>

<p>所有者为美国法警局，该地址内的比特币来自被查获的丝绸之路，后在第一次拍卖会中将币转移给中标人<a href="https://www.blockchain.com/btc/tx/9e95c3c3c96f57527cdc649550bf8e92892f7651f718d846033798aee333b0c3">29,658BTC交易</a>。</p>

<p>2018年这个地址还有小额的零星收入，不知转入者是谁。</p>

<h4>Tim Draper的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi">1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi</a></p>

<p>这个哥们是bitcoin的铁杆粉丝；它是风险投资公司Draper Fisher Jurvetson的创始人，作为硅谷投资教父，投资了SpaceX、Tesla、Thumbtack，Baidu，Hotmail，Skype等耳熟能详的公司；</p>

<p>这个地址就是当时他购买美国法警局拍卖丝绸之路BTC的转移地址；</p>

<p>作为bitcoin铁粉，这个老哥早期投资了蝴蝶矿机，最著名的故事就是在Mt.Gox事件中损失惨重后仍然多次买买买，即使去年的大涨风潮中也一币不卖；他对于比特币的信心估计就是中本聪本人也不及，如果你去google <code>Tim Draper</code>，估计排在前面的就是$250K， 即他相信2022年一币250000$，让我们祝福这位老哥。</p>

<h4>Carl M. Force的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB">14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB</a></p>

<p>该地址属于“法国女仆”，又名Carl M. Force，是美国联邦缉毒局的一名探员，在参与调查丝绸之路时，Force化名“法国女仆”利用职务之便勒索罗斯乌布利希，并将赃款汇入该地址内，但Force最终被抓住并遭到起诉。</p>

<p>这应该是有据可查的第一起比特币偷盗破获案件。Hi, Carl M. Force，不要沮丧哦，你已经青史留名了。</p>

<p>不过悲伤的是，之后发生的偷盗事件数不胜数，却没有多少案件能被破获。</p>

<h4>真土豪的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv">1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv</a></p>

<p>该地址发生了一笔历史上最大额的交易，一次性转移了500,000 BTC，创历史之最，虽然是发生在2011年的事情，但是按币本位算，估计这个数额很难打破了。</p>

<p>这个地址2017年还被使用过，观看它的交易记录，我严重怀疑这是国内某一个大佬的地址，并且与Mt.Gox有牵连。</p>

<h4>wiki的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v">1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v</a></p>

<p>这是维基解密用来接受比特币捐赠的地址，维基解密的创始人，阿桑奇，也是比特币社区最早的支持者；我得说，这位阿桑奇，真是一条汉子；</p>

<p>希望能看到你收到更多的捐赠，wikileaks！</p>

<h4>Bitstamp被盗地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf">1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf</a></p>

<p>Bitstamp遭窃的热钱包地址，黑客在2015年1月5日时陆续从该地址内盗取了大约19,000BTC 。</p>

<p>事件调查可以参考这里:</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/">https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/</a></p>

<p>这个地址非常奇怪，之后还陆陆续续有交易发生；并且在2017年，有人考证一币Tether的hack事件和Bitstamp被盗事件是同一个黑客：</p>

<p><a href="https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/">https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/</a></p>

<p>一个疑问重重的故事。</p>

<h4>Bitfinex被盗地址</h4>

<p><a href="https://gist.github.com/MrChrisJ/4a959a51a0d2be356cc2e89566fc1d87">地址列表</a></p>

<p>2016-08-03，<a href="https://www.reddit.com/r/Bitcoin/comments/5vr8xg/confirmed_120000_bitcoins_from_the_bitfinex_hack/">reddit</a>上面已经有人确认，Bitfinex被盗119756个btc.</p>

<p>查看黑客的接收地址，有些币至今未动。</p>

<p>bitfinex后来通过发行USDT起死回生，这种神操作说起来好像是天方夜谈，呵呵，比最诡异的侦探小说还诡异的故事。</p>

<h4>NiceHash被盗地址</h4>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>2017-12-06，Nicehash 被盗 4700+币</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>呵呵，说下去都不好意思了；黑客的黄金年代啊</p>

<h4>mtbox</h4>

<p><a href="https://www.cryptoground.com/mtgox-cold-wallet-monitor/">https://www.cryptoground.com/mtgox-cold-wallet-monitor/</a></p>

<p>作为史上之最，Mtgox事件聚集了一切传奇侦探小说都有的元素，就等着将来一位福尔摩斯来为我们排疑解惑了；期待着那一天的到来</p>

<h4>官方土豪</h4>

<p><a href="https://www.blockchain.com/btc/address/1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX">1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX</a></p>

<p>之前我们说50w币转账的土豪毕竟是萌芽时期，只能说是个野生土豪。来来来，让我们活捉一位官方土豪。</p>

<p>就在前几天，2018-12-03，发生了<a href="https://www.blockchain.com/btc/tx/244c71c790eb327eb8bbf66aa2d0a75bac7c1fe7b55d1161c316c6f93292d376">一笔66233比特币的转账</a>。以当前的币价来算，可谓是天文数字了。这笔交易主要是将老地址的币逐步迁移到bech32地址上去。(什么是bech32地址？复习我们之前的文章哦)</p>

<p>这个地址的土豪还关联着9个地址，总币量加起来大概55w币。</p>

<p>有人推测这是coinbase.com的冷钱包。</p>

<p>嗯哼，应该是继中本聪之后最大的壕。</p>

<p>&hellip;&hellip;</p>

<h4>好像一篇文章列举下去远远不够哈，实在是写累了，我们以后心情好的时候继续更新</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-2]]></title>
    <link href="https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2/"/>
    <updated>2018-12-03T18:06:46+08:00</updated>
    <id>https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2</id>
    <content type="html"><![CDATA[<p>之前的文章我们说过，比特币的所有交易抽象成了UTXO的转移。所谓转移，可以这么理解：</p>

<ul>
<li>有M个UTXO作为输入 (M >= 0)</li>
<li>有N个UTXO作为输出 (N > 0)</li>
<li>输入的UTXO总额==输出的UTXO总额</li>
<li>输入的UTXO来源于支付方控制的私钥账户</li>
<li>输出的UTXO流向收款方的公钥地址</li>
</ul>


<p>那么具体是怎么转移的？怎样手工的构造一笔交易呢？我们就在这篇文章里面详细的演示一遍。</p>

<p>首先科普一下常见的交易类型:</p>

<!-- more -->


<h4>Generation TX</h4>

<p>这种交易我们称之为是产量交易(Generation TX)，即矿工挖出一个新的Block时，系统允许这个矿工在块头构造一笔奖励自己的交易，这笔奖励金额被称之为Coinbase奖励，最初一个block挖出的奖励是50BTC，后来就是我们大家所熟知的四年减半原则啦。这样大家明白比特币整个账本里面的初始资金是怎么来的啦。就是系统通过Generation TX向矿工发放奖励产生的BTC。</p>

<p>矿工们计算随机数，竞争打包Generation TX的权力，就是挖矿。具体的细节我们会在以后的文章中介绍。</p>

<p>现在每笔Generation TX的奖励金额是12.5BTC，预计下个减半周期在2020年年中。</p>

<p>注意：Generation TX中的BTC是无中生有的，所以只有输出的UTXO，没有输入的UTXO。</p>

<p>PS:Coinbase作为一个很经典的技术名词，其<code>coinbase.com</code>域名被现在美国著名的交易所coinbase Pro 注册持有。</p>

<h4>Script Hash TX</h4>

<p>也被成为P2SH（Pay-to-Script-Hash）交易。</p>

<p>该类交易目前不是很常见，大部分人可能没有听说过，但是非常有意义。未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义的地址，而是一个合成地址，以<code>3</code>开头 (Segwit交易其实也可以看成是Script Hash TX)。比如三对公私钥，可以生成一个合成地址。在生成过程时指定n of 3中的n，n范围是[1, 3]，若n=1，则仅需一个私钥签名即可花费该地址的币，若n=3，则需要三把私钥依次签名才可以。 这种类型的交易适合比较复杂的保险、证券场景。</p>

<h4>Pubkey Hash TX</h4>

<p>也被称为P2PKH（Pay-to-Public-Key-Hash）交易。该类是最常见的交易类型，由N个输入、M个输出构成。交易地址都是以<code>1</code>开头。这种交易也是目前比特币网络中最典型的交易类型，也最简明，容易分析。下面我们就先拿它作为例子，开始探究一笔比特币交易的细节。</p>

<h2>数据结构</h2>

<h3>输入输出</h3>

<p>简单来看，一笔完整的P2PKH交易包含有两个部分:输入UTXO &ndash;> 输出UTXO，而每一个输入UTXO其实是上一笔交易的输出UTXO，这么说可能有点绕口，来张图解释一下：</p>

<p><img src="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/en-tx-overview.svg" alt="img" /></p>

<p>首先最前面的字段是版本号，每一个交易具有一个四字节的交易版本号，它告知比特币节点和矿工应使用哪一套规则来验证它。这使得开发者在为未来的交易创建新规则时可以不验证之前的交易。</p>

<p>接着就是输入的M个UTXO和输出的N个UTXO，代表着我要把一堆UTXO转移(支付)给谁。</p>

<p>最后是一个字段是锁定事件(Locktime)。Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。</p>

<p>如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>一笔交易中，构造的输出UTXO会完全花费掉输入的UTXO，注意：是完全花费掉。如果输出UTXO的总额小于输入UTXO的话，那么差值就会被系统作为矿工费奖励打包到Generation TX当中。所以所有的比特币钱包实现中，如果你有10BTC的UTXO集合，想要花掉9BTC，那么输出UTXO中，除了支付给收款方的UTXO，还一定要构造发送给自己的找零UTXO。曾经有人构造交易时忘记找零，发生了<a href="https://blockchain.info/tx/4ed20e0768124bc67dc684d57941be1482ccdaa45dadb64be12afba8c8554537">支付 200 BTC 的矿工费</a>的惨案，所幸的是收录该笔交易的Block由著名挖矿团队“烤猫（Friedcat）”挖得，该团队非常厚道的<a href="https://blockchain.info/tx/b18abce37b48a5f434f108ae7ce34f22aa2bfbd9eb9310314029e4b9e3c7cf95">退回了多余费用</a>。</p>

<p>早期Geek们比较作死，特别喜欢命令行构造发送交易，像是忘记构造找零而当了冤大头的人数不胜数，那么为什么是这么奇葩的设计呢？为什么一笔交易中，一定要花费所有的输入UTXO呢？</p>

<p>大家还记得我们的上一篇文章吧，一个分布式的账本，最容易的设计就是只支持<code>append</code>这个动作，诸如<code>update</code>、<code>delete</code>这种操作在区块链账本的设计中会引入额外的复杂性，尤其是后面我们讲述blockchain的组织的时候，你就会理解，这种设计的必要性。</p>

<h3>细节</h3>

<p>一笔完整的P2PKH 交易是这样的：</p>

<p><img src="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/en-tx-overview-spending.svg" alt="img" /></p>

<p>我们用之前文章中，利用<code>satoshi</code>生成的地址(<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>)做例子，来研究它花费的<a href="https://www.blockchain.com/btc/tx/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517">一笔交易</a>。</p>

<p>用<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">在线getrawtransaction工具</a> 解码一下这笔交易，得到输出：</p>

<p>```
{</p>

<pre><code>"result": {
    "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
    "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
    "version": 1,
    "size": 233,
    "vsize": 233,
    "locktime": 0,
    "vin": [
        {
            "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
            "vout": 0,
            "scriptSig": {
                "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
                "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
            },
            "sequence": 4294967295
        }
    ],
    "vout": [
        {
            "value": 0.00007000,
            "n": 0,
            "scriptPubKey": {
                "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
                "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
                "reqSigs": 1,
                "type": "pubkey",
                "addresses": [
                    "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
                ]
            }
        }
    ],
    "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
    "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
    "confirmations": 85331,
    "time": 1494823668,
    "blocktime": 1494823668
},
"error": null,
"id": null
</code></pre>

<p>}
```</p>

<h4>字段说明</h4>

<ul>
<li>txid (hash)</li>
</ul>


<p>Tx Hash (3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517)，俗称交易ID，由hex得出：Tx Hash = SHA256(SHA256(hex))。由于每个交易只能成为下一个的输入，有且仅有一次，那么不存在输入完全相同的交易。因为SHA256碰撞的概率极小，所以理论上存在相同的Tx Hash 的概率非常小。</p>

<p>即便如此，在系统里依然产生了相同的Tx Hash，是不知道哪位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<ul>
<li>vin (输入UTXO)</li>
</ul>


<p>vin是一个数组，里面即M个输入UTXO，每个UTXO都来自上一笔交易的一个UTXO输出，这笔交易的vin只有一个UTXO，它由以下几个字段组成</p>

<pre><code>- txid: 上一笔关联交易的hash值
- vout: 上一笔交易输出的N个UTXO里面的序号
- scriptSig: 对这笔UTXO的签名，还记得我们之前的文章吗？只有对一个UTXO签名才能证明其所有权，才能花费它
- sequence: 序列号。这个序列号来源比较复杂；还记得上面讲的locktime有所关联：
</code></pre>

<blockquote><p>Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。
如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>Bitcoin Core 的早期版本提供了一个可以防止签名者使用上述方法取消locktime 交易的功能。 后来为了防止大量的延时交易攻击网络，这个功能被禁用了。但是该系统还留下了这样的设置，每个输入会分配一个四字节的序列号。序列号的目的旨在允许多个签名者同意更新交易。</p>

<p>如果sequence number设置为0，就按照locktime执行入块操作，如果出现一笔新的交易，sequence大于原来的sequence，这笔新交易就会取代原来的交易；所以一般为了即刻入块，交易的sequence number一般设置为四字节的的无符号最大值(0xffffffff),使得交易的locktime 仍然有效的情况下，打包交易进块。</p>

<p>即使今天，如果所有的input 的sequence number都是最大值，locktime锁就会失效。所以如果想使用locktime，至少一个input的sequence number要小于最大值。由于sequence number不用于其他目的，任何sequence number 为零的交易都会启动locktime 功能。后面我们会看到，sequence number会在闪电网络中发挥作用</p></blockquote>

<p>vin的所有UTXO 余额相加，就是这笔交易的转账总额。</p>

<ul>
<li><p>vout (输出UTXO)</p>

<ul>
<li>value: 转账金额</li>
<li>n: 作为第N个UTXO输出</li>
<li>scriptPubKey: 这是设置的谜题，后来人想要花费这笔UTXO，必须提供scriptSig来解答这个谜题才可以</li>
</ul>
</li>
<li><p>vin 的总额 &ndash; vout的总额 == 打包费用 &ndash;> 奖励给打包矿工</p></li>
</ul>


<h4>交易十六进制解析</h4>

<p>spec规范在<a href="https://en.bitcoin.it/wiki/Protocol_documentation#tx">这里</a></p>

<p>这笔交易的vin及vout中各有一个UTXO，我们解析下它的十六进制原始数据:</p>

<p><code>
01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000
</code></p>

<ul>
<li>version (4字节): 刚开始的4个字节是version，小端排序(Little Endian)，因此version为<code>0x00000001</code></li>
</ul>


<blockquote><p>ps:关于小端排序的设计，社区里面还有过小争论，见<a href="https://bitcointalk.org/index.php?topic=4278.0">这里</a></p></blockquote>

<ul>
<li><p>flag (2字节，可选): 如果是<code>0001</code>，代表是witness交易；如果不是，就代表没有这个flag字段；这是一笔普通的交易，因此没有flag字段</p></li>
<li><p>vin count (>=1字节): vin数目，此交易为<code>01</code>，采用的是<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer">var_int</a>表示法，这样我们能方便的测算它的长度</p></li>
<li><p>vin (>=41字节): 所有的输入tx，是一个数组；这里只有一个tx，数据是:
<code>
3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff
</code></p></li>
</ul>


<p>简单说下vin中一笔tx内部结构:</p>

<pre><code>- previous_output (32字节): 上一笔交易的HASH值，即这个花费的输入交易ID: 

3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0
-&gt; 转为大端排序  
b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b

- previous output index: 表示花费的是 previous_output 交易的第n个vout输出，这里是`00000000`

- script length (var_int变长，代表script的长度): 这里是`0x8a`，表示script长度为138字节

- criptSig (整个解密脚本)： 这个结构我们之后会具体分析
</code></pre>

<p><code>
47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5
</code></p>

<pre><code>- sequence no (4个字节): `ffffffff`
</code></pre>

<ul>
<li><p>vout count (>=1字节): vout数目，此处为<code>01</code></p></li>
<li><p>vout (>=9字节): 所有的输出tx，是一个数组；这里只有一个tx，数据是:
<code>
581b0000000000002103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac
</code></p></li>
</ul>


<p>简单说下vout中一笔tx内部结构:</p>

<pre><code>- value (8字节): 转账到这个地址上的金额， 这里是`581b000000000000`小端排序，十六进制为`00000000000000581b`，即转账7000 satoshis
- scriptPubKey length (&gt;=1, var_int类型): 输出脚本的长度，这里是`0x21`，代表33字节长度
- scriptPubKey: 输出脚本，其实就是包含转账地址的脚本，这里是`03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac`
</code></pre>

<ul>
<li>locktime: 最后4个字节是locktime，这笔交易设置为0；就是立即打包</li>
</ul>


<h3>总览</h3>

<p>最后一张表格说明问题：</p>

<p><img src="https://ws1.sinaimg.cn/large/893d6e9dly1fxtq1vq3b1j20pc0e3gma.jpg" alt="img" /></p>

<h3>scriptSig与scriptPubKey</h3>

<p>目前为止，我们还没有解析vin中的scriptSig，以及vout中的scriptPubKey；这两个东东才是交易的核心，他们有什么作用呢？</p>

<p>~~ 待续</p>

<h2>参考资料:</h2>

<p><a href="https://en.bitcoin.it/wiki/Protocol_documentation">https://en.bitcoin.it/wiki/Protocol_documentation</a></p>

<p><a href="http://learnmeabitcoin.com/">http://learnmeabitcoin.com/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>

<p><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html">https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html</a></p>

<p><a href="https://www.8btc.com/article/24637">https://www.8btc.com/article/24637</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-stream,一次可怕的社工]]></title>
    <link href="https://happy123.me/blog/2018/11/27/event-stream/"/>
    <updated>2018-11-27T16:06:38+08:00</updated>
    <id>https://happy123.me/blog/2018/11/27/event-stream</id>
    <content type="html"><![CDATA[<p>几天前有人在github创建了一个issue:</p>

<p><a href="https://github.com/dominictarr/event-stream/issues/116">https://github.com/dominictarr/event-stream/issues/116</a></p>

<p>标题为："I don&rsquo;t know what to say.&ldquo;，翻译过来大概就是“我无语了”。因为 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p>

<!-- more -->


<p>event-stream 被很多的前端流行框架和库使用，每月有几千万的下载量。作为最流行的前端框架之一，在 Vue 的官方脚手架 vue-cli 中也使用了这个依赖，作为最流行的前端框架之一，这个影响还是挺大的，这个影响还是挺大的。而 React 则躲过了。</p>

<p>flatmap-stream 中的恶意代码会扫描用户的 nodemodules 目录，因为所有从 npm 下载的模块都会放在此目录。如果发现了在 nodemodules 存在特定的模块，则将恶意代码注入进去，从而盗取用户的数字货币。</p>

<p>COPAY钱包因为引用了event-stream库，它在今年9、10、以及11月27日之前发布的所有版本都受到了感染，COPAY是bitpay旗下的开源钱包，市场占有率不可小觑；下面这个链接进行了分析，使用被感染钱包的用户很有可能被窃取私钥:</p>

<p><a href="https://github.com/bitpay/copay/issues/9346">https://github.com/bitpay/copay/issues/9346</a></p>

<p>COPAY紧急发布了5.2.2修正版本：</p>

<p><a href="https://github.com/bitpay/copay/pull/9348">https://github.com/bitpay/copay/pull/9348</a></p>

<h2>使用COPAY钱包的人，请立即升级新版本，并且生成新的钱包，把老钱包里面的币转走。</h2>

<p>这个恶意模块更可怕之处，在于背后的骇客是个深谋远虑、精于社工的人。</p>

<p>这个人的github账号叫做<a href="https://github.com/right9ctrl">right9ctrl</a>，他应该是精心分析了COPAY引用的所有模块，发现event-stream有机可乘。于是给event-stream的创始人-<code>dominictarr</code>发去了邮件，承诺会自愿维护这个项目。</p>

<p><code>dominictarr</code>是一个高产的开发者，他维护着多个NPM包，有人能自愿分担他的工作，他自然是高兴之至，于是将这个模块的仓库控制权移交给了<code>right9ctl</code>。</p>

<p>刚开始的时候，<code>right9ctl</code>非常小心的进行着常规的维护。一段时间后，即在 3 个月前，黑客在 GitHub 上新建了一个 flatmap-stream 仓库（内含恶意代码），并在这个项目中引用了自己的仓库。</p>

<p>直到几天前这个有漏洞的仓库才被发现，然后 npm 紧急将这个含有恶意代码的 flatmap-stream 模块删除了。</p>

<p>这个模块的攻击行为也很隐蔽，首先他只有引用了 event-stream 这个库，并且依赖引用了 flatmap-stream，用户在编译自己的项目时，才会感染恶意代码。</p>

<p>感染恶意代码的程序，也不会全部发作。只有COPAY钱包运行时，他才会悄悄的窃取用户信息，并发送到下面这几台服务器：</p>

<p><code>
copayapi.host
51.38.112.212
145.249.104.239
111.90.151.134
</code></p>

<p>我不知道截止到现在黑客获取了多少币，但整个事件非常惊悚。而且这个漏洞刚刚被发现，我认为还会持续有消息不灵通的受害者。</p>

<p>另外，如果想查看自己的项目是否受到影响，可以运行：</p>

<p><code>
$ npm ls event-stream flatmap-stream...flatmap-stream@0.1.1...
</code></p>

<p>如果在输出里面包含了 flatmap-stream 则说明你也可能被攻击。</p>

<p>如果使用 yarn 则可以运行：</p>

<p><code>
$ yarn why flatmap-stream
</code></p>

<h2>区块链历史中的传奇HACK手段</h2>

<p>我在以前的文章中多次感叹所谓的区块链技术出来后，简直是黑客的黄金年代！大概从2011年开始，精彩的HACK事件层出不穷，如果要全部整理出来，可能会是一部让所谓的<code>区块链专家</code>和<code>区块链投资者</code>冷汗直流，后怕不已的手册。</p>

<p>撇开这几天的市场动荡，币价大跌不提，单单从技术上评估，能有多少人意识到他们所谓的投资的技术风险！</p>

<p>我随意的说几件印象非常深刻的HACK事件。</p>

<h4>整个国家DNS 流量劫持事件</h4>

<p>我记得大概是2015年，巴西的骨干网DNS整个被黑客劫持了，导致当时的blockchain.info 在线钱包有几个小时的流量完全被导向了钓鱼网站，这次事件导致的丢币数目不可统计。</p>

<p>但是给你一个启示，当利益足够大的时候，任何设施，包括国家设施都是不可信、不安全的。结合这两天发现的jd.com流量返利劫持，你就知道：网络世界里，有的组织或者个人，完全可以劫持一个国家的网络流量，这不是天方夜谭。</p>

<h4>官方域名劫持事件</h4>

<p>今年二月份的时候，有人花大价钱买了"electrumltc.org"这个域名，仿照"<a href="https://electrum-ltc.org/">https://electrum-ltc.org/</a>&ldquo;官网，精心炮制了一个以假乱真的网站，然后把下载链接改成了恶意钱包，并且做了Google SEO，把自己的骗子网站搜索结果推到了第一名；有人因此丢了2399个LTC，那个时候可是不少钱。</p>

<p>很讽刺的是，恰恰是因为真正的开发者买不起这个域名，才搞了一个山寨的域名发布自己的软件，让骇客有机可乘。</p>

<p>讽刺吧，原作者辛辛苦苦开发，却因为没钱买域名不得已搞个屌丝网站，骇客财大气粗，直接买下第一官方域名然后钓鱼，并且真的获取巨大收益。</p>

<p>这种钓鱼手法在多个钱包、多个网站上面一再重演，受害小白不计其数！</p>

<p><code>杀人放火金腰带，修桥补路无尸骸。</code>这个世界就是这样。</p>

<p>整个事件回顾：</p>

<p><a href="https://github.com/pooler/electrum-ltc/issues/176">https://github.com/pooler/electrum-ltc/issues/176</a></p>

<h4>~~~~</h4>

<p>这么罗列下去，我可以轻易列举出更多的涉及上亿美元的hack事件。每个事件说起来好像天方夜谭一样，不明技术的小白可能会惊叹：怎么可能有这种事情？！</p>

<p>但是事实就是这样，而且将来这样的悲剧会一再重复下去，说再多也没用，人的安全意识总敌不过懒惰、贪婪等等等等，可悲的人性啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoind Conf Template]]></title>
    <link href="https://happy123.me/blog/2018/11/26/bitcoind-conf-template/"/>
    <updated>2018-11-26T14:51:43+08:00</updated>
    <id>https://happy123.me/blog/2018/11/26/bitcoind-conf-template</id>
    <content type="html"><![CDATA[<p>bitcoin core 0.17版本开始废弃了不少RPC调用，另外RPC配置增加了test.rpcport参数，存一份模板:</p>

<!-- more -->


<p><code>
rpcuser=xxxx
rpcpassword=xxxx
rpcallowip=127.0.0.1
rpcport=18332
test.rpcport=8332
rpcthreads=10
server=1
rest=1
walletnotify=/usr/bin/python3 /xxx.py
</code></p>

<p>另外<code>getaddressesbyaccount</code>即将废弃，可以使用<code>getaddressesbylabel</code>代替</p>

<p><code>signrawtransaction</code>即将废弃，实在要用的话只能在启动命令行中加deprecatedrpc指定。</p>

<p><code>
bin/bitcoind --conf=/xxx/bitcoin.conf --datadir=/xxx/blockdata/mainnet --deprecatedrpc=signrawtransaction
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-1]]></title>
    <link href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/"/>
    <updated>2018-11-23T18:48:39+08:00</updated>
    <id>https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1</id>
    <content type="html"><![CDATA[<p>在我们前面的文章中，我们提到，从建设银行转账到工商银行10w元，过程其实是这样的:</p>

<ol>
<li>建设银行发送报文到人行CNAPS系统</li>
<li>人行CNAPS发送转账报文到工商银行</li>
<li>工商银行发送响应报文给人行CNAPS</li>
<li>人行发送响应报文给建设银行</li>
<li>转账成功，建设银行、人行、工商银行各自更新账本</li>
</ol>


<p>整个过程中，有几个很有趣的事实：</p>

<!-- more -->


<ol>
<li>所谓的转账交易，不过是账本上数字的加加减减</li>
<li>我们的账户，除了各自在工行、建行开设的户头之外，在人行还有一个总账；人行是所有银行的妈，你在任何银行开设的账户，人行都有一个总账；所以打印征信的时候我们要到人行打印</li>
<li>建设银行和工商银行间的转账需要人行做清算，人行提供了信用；建行和工行相信人行不会造假</li>
<li>我们需要信任三个机构：人行、工行、建行，我们相信他们不会造假</li>
<li>人行是所有账目的中心节点，人行的账本对不上了，中国的金融系统就乱套了</li>
</ol>


<p>然后作为对比，我们来看看比特币是怎样设计的。</p>

<p>中本聪创造比特币之初，在<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis Block</a>里面付了一句有名的话:&ldquo;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"。在白皮书中他很自豪的宣称:"We have proposed a system for electronic transactions without relying on trust. &rdquo; 去中心化一直是比特币的指导纲领，那么问题来了，如果让我们来设计一个去中心化的账本，将会面临哪些技术问题，又该如何解决呢？</p>

<p>很自然的，我们设想的是一个类似于分布式数据库的系统，整个系统维护着唯一的账本，每个节点（node）都是一个副本（Replica Set），每个副本保有完全的账本数据，并且节点间相互同步数据，如果部分节点挂掉，不影响整个系统的运行。</p>

<p>用户转账的行为，其实就是这个分布式账本的增删查改。当然，为了简化设计，我们这个账本可以只支持账目写入，不支持删改。</p>

<p>我们开始思考这个分布式账本要解决的两个核心问题：</p>

<h4>什么样的交易是一笔合法的交易</h4>

<ul>
<li>一笔交易中，如何保证交易账户的完全所有权；如果保证用户A的资金不会被用户B盗用</li>
<li>用户A本来有1000元，如何保证他不会转出2000元？</li>
</ul>


<h4>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</h4>

<ul>
<li>如果有部分节点是不诚实的，它就会有动机去伪造不存在的交易来获取利益，如何识别并排除不诚实的节点？(拜占庭将军问题)</li>
<li>如果A的账户有1000元，发送了1000元给B，由于是分布式系统，部分节点收到了这笔交易，这时候A又发送了1000元给C，另一部分收到了这笔交易，这时候该如何处理？如何保证一笔钱不会被花两次？ (双重支付问题)</li>
</ul>


<p>为了解决这两个问题，比特币引入了三个核心技术：UTXO交易模型、POW工作量证明、blockchain数据结构组织。且让我们一一道来。</p>

<h2>初版交易设计</h2>

<p>如果读了之前我们的&lt;比特币HD钱包>系列文章；天然的，我们意识到非对称加密方法是在分布式账本中建立账户的天选之术；</p>

<h4>存款</h4>

<p>用户A想要建立一个账户，只要在帐目中增加一笔 <code>公钥+金额</code> 的记录就可以了。我们用一个表格表示整个账本，用户A以及用户B各存入50个币的动作可以记作:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50)</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50)</td>
</tr>
</tbody>
</table>


<p>这个原始存入的资金我们先不去纠结怎么来的，总之此时账本中有两笔交易，代表着A以及B各自有50个币</p>

<h4>验证</h4>

<p>在账目1中，如何验证A确实是这笔资金的拥有者呢？非常简单，就是账户资金增加的时候，A对这笔交易数据的摘要用私钥做一个签名，然后再把公钥附在后面就可以了，这样账目就变成了这样:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
</tbody>
</table>


<p>任何一个要验证账户A的节点或第三方，对其所有权证明用公钥解密，然后对照摘要(digest)即可。</p>

<h4>转账</h4>

<p>如果A要向B转账20个币呢，我们最简单的设计，就是构造Trans1 &ndash; 20，然后同样的方法构造签名即可，这样账本如下:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
<tr>
<td>3 </td>
<td> Trans3:Trans1-20 &ndash;> B</td>
<td> signature(digest(Trans1 &ndash; 20 &ndash;> B))+A公钥</td>
</tr>
<tr>
<td>4 </td>
<td> Trans4:存入(B公钥+20) </td>
<td> signature(digest(Trans4))+B公钥</td>
</tr>
</tbody>
</table>


<p>看起来一切还好，但是这个时候我们发现了一些缺点</p>

<ol>
<li>收到汇款的时候因为要添加所有权证明，账户拥有者得一直在线监控自己的账户地址</li>
<li>收款人还得验证汇款人的合法性，感觉都点怪；我收钱就好了，还得去管这个钱合不合法？</li>
<li>如果多重转账，或者一对多，或多对一，这个记录格式就复杂了</li>
<li>用户B要验证一笔交易合法性的时候，可能要回溯到账本非常深的位置，因为上一笔交易可能发生在很久之前，这种交易记录的存储设计很难高效查询</li>
<li>最后，这个账目设计中，所有账户的公钥是暴漏在外的；虽然椭圆曲线算法目前看来牢不可破，但是整个安全体系只依赖一个非对称加密算法，比较脆弱</li>
</ol>


<p>解决方法其实也简单，换个思路，就是A转账给B，B是不需要验证的，只要A提供账户所有权的证明就好了，想想我们平时转账，不也是这样的吗？</p>

<p>那么最简洁的设计，就是借鉴现实世界。每一笔交易都看作是硬币的流转，硬币其实没有特征，它只是从A的保险箱转移到了B的保险箱而已，那么，采用什么办法来表示：<code>这是A的保险箱中的一笔资金币</code>这个譬喻呢？</p>

<h2>进阶交易设计</h2>

<h4>UTXO 模型</h4>

<p>比特币的账本世界，构筑在UTXO (Unspent Transaction Output)之上；其实每个UTXO代表着未花费的一笔硬币(数额可大可小，没有限制)；一个账户的资金，其实就是一堆UTXO的集合；转账交易，就是一个或多个UTXO的输入再输出为另外的UTXO而已。你可以想象成现实世界中金银铸币的流通。</p>

<p>那么一个UTXO中包含什么呢？如何作为输入呢？如何构造输出呢？这就是比特币交易的核心技术。</p>

<ul>
<li>我们用下面一张图来表示<code>A保险箱里面的50个硬币</code> 这件事：</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg1.jpg" alt="img" /></p>

<p>把它想象成一个邮筒构造的保险箱，在不打开的前提下，投币是只进不出的。可以注意到，我们并没有直接将Public Key明晃晃暴露在外面，而是先HASH一下，然后贴到保险箱子上面，想要存币的人，只要知道这个HASH值，作为保险箱的ID，就可以直接投币进去啦。</p>

<p>但是保险箱的锁在哪里呢？</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg2.jpg" alt="img" /></p>

<ul>
<li>这张图中，我们引入了一个脚本，称之为 <code>Pubkey Script</code>；具体内容是:</li>
</ul>


<p><code>
OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></p>

<p>呵呵，像天书吧，不要怕；这是我们特有的保险锁构造。细节会在后面讲到。这里你可以这样简单理解：</p>

<p>为了锁住这个保险箱里的资金，比特币系统设置了一个谜题作为锁。解开这个谜题，才能转移里面的资金。</p>

<p>这个谜题是这样构造的:</p>

<ol>
<li>记录了A的公开的<code>Public key hash</code>值，开锁的人，需要提供A的<code>full public key</code>，同时验证 <code>hash160(public key) == Public key hash</code></li>
<li>需要提供A的私钥基于这笔交易的签名Signature, 这样系统可以用<code>full public key</code>来验证公私钥是否匹配</li>
</ol>


<p>这个过程是通过上面的脚本指令通过入栈出栈执行的，这也为比特币系统验证更复杂的交易逻辑提供了基础，甚至能作为一个简单的虚拟机执行更复杂的组合指令。</p>

<p>整个过程组织如下图：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg3.jpg" alt="img" /></p>

<p>当我提供一个signature以及full public key的时候，就可以开锁了，开锁下一步自然就是转移资金啦。我们给B汇款50个币，而B的保险箱又是怎么表示的呢？和A保险箱是一样的。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg4.jpg" alt="img" /></p>

<ul>
<li><p>带有<code>public key hash</code> ID的保险箱是一个UTXO，这个保险箱用<code>public key hash</code>上锁，而提供<code>signature</code>和<code>full public key</code>开锁，转移资金的过程，就是花费UTXO的过程，其实就是把A的UTXO转移到B的UTXO的过程，这就是比特币最简单的一笔交易</p></li>
<li><p>我们可以继续拓展下去，可以1对多支付，多对1支付，多对多支付，更复杂的多签名支付，延迟支付等等，今后我们会详细介绍</p></li>
</ul>


<p>这个系统有如下优点:</p>

<ol>
<li>所有的交易都抽象为了UTXO的转移，你可以想象一下，一堆硬币在几个保险箱之间转移的样子</li>
<li>用户其实可以不检查交易的合法性，只要运行分布式账本的所有节点检查通过合法后，确保写入账本就保证资金的安全转移了</li>
<li>每个账户的拥有者在真正花费UTXO之前，是不用暴露公钥的</li>
<li>验证UTXO交易合法行的函数，抽象为几个指令的集合，这个验证行为指令通用化，为智能合约编写创造了条件</li>
<li>这样的交易记录非常容易组织，我们以后可以看到；把这些交易批量打包，组织成名为blockchain的精巧数据结构，有许多优点</li>
<li>一个用户A可以用一个私钥加密多个保险箱，或者多个私钥加密多个保险箱，非常灵活</li>
</ol>


<h2>小结</h2>

<p>好啦，看到这里，我们对比特币的最简单的交易构造已经有感性认识了。但是俗话说得好: <code>光说不练假把式</code>，下篇文章我们就会手工构造一笔完整的交易，让你搞明白其中细节。</p>

<p>另外，我们前面提出了好几个问题:</p>

<ul>
<li>原始资金从何处来？</li>
<li>节点如何解决拜占庭将军问题？</li>
<li>节点如何解决双重支付问题？</li>
</ul>


<p>后面我们会一一解答，那么，下次再见。</p>
]]></content>
  </entry>
  
</feed>
