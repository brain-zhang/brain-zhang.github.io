<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-08-03T20:24:38+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->


<p>```
import ctypes
import logging</p>

<p>try:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</code></pre>

<p>except Exception:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</code></pre>

<p>def check_result(val, func, args):</p>

<pre><code>if val == 0:
    raise ValueError
else:
    return ctypes.c_void_p(val)
</code></pre>

<h1>ssl_library.EC_KEY_new.restype = ctypes.c_void_p</h1>

<p>ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result</p>

<p>k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)</p>

<p>if ssl_library.EC_KEY_generate_key(k) != 1:</p>

<pre><code>raise Exception("internal error")
</code></pre>

<p>ssl_library.EC_KEY_free(k)
```</p>

<p>这段代码在多线程的时候会出现segmentation fault error； 是openssl1.0.0的实现问题，参考:</p>

<p><a href="https://bugs.python.org/issue29340">https://bugs.python.org/issue29340</a></p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒LXC技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->


<h2>文档操作</h2>

<h4>增加一条记录</h4>

<p><code>
PUT /website/_doc/1
{
  "title": "My 2 blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}
</code></p>

<h4>修改</h4>

<p>```
POST /website/_update/1
{
   &ldquo;doc&rdquo; : {</p>

<pre><code>  "tags" : [ "testing..." ],
  "views": 0
</code></pre>

<p>   }
}
```</p>

<h4>查询</h4>

<p>```
GET /website/_search</p>

<p>GET /website/_source/1</p>

<p>GET /website/_mget
{</p>

<pre><code>"ids" : [ "2", "1" ]    
</code></pre>

<p>}</p>

<p>GET /_search
{</p>

<pre><code>"query": YOUR_QUERY_HERE
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /website/_doc/1
</code></p>

<h2>文档功能API</h2>

<h4>获取映射信息</h4>

<p><code>
GET /website/_mapping
</code></p>

<h4>测试分析器</h4>

<p><code>
GET /website/_analyze
{
  "field": "tweet",
  "text": "Black-cats"
}
</code></p>

<h4>多层级对象用扁平化的方法来存储，比如</h4>

<p>```
{
  &ldquo;gb&rdquo;: {</p>

<pre><code>"tweet": { 
  "properties": {
    "tweet":            { "type": "string" },
    "user": { 
      "type":             "object",
      "properties": {
        "id":           { "type": "string" },
        "gender":       { "type": "string" },
        "age":          { "type": "long"   },
        "name":   { 
          "type":         "object",
          "properties": {
            "full":     { "type": "string" },
            "first":    { "type": "string" },
            "last":     { "type": "string" }
          }
        }
      }
    }
  }
}
</code></pre>

<p>  }
}</p>

<p>```
会被转换为如下内部对象:</p>

<p>```
{</p>

<pre><code>"tweet":            [elasticsearch, flexible, very],
"user.id":          [@johnsmith],
"user.gender":      [male],
"user.age":         [26],
"user.name.full":   [john, smith],
"user.name.first":  [john],
"user.name.last":   [smith]
</code></pre>

<p>}
```</p>

<h4>内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2>查询</h2>

<h4>查询语句的结构</h4>

<ul>
<li><p>一个查询语句 的典型结构：
<code>
{
  QUERY_NAME: {
      ARGUMENT: VALUE,
      ARGUMENT: VALUE,...
  }
}
</code></p></li>
<li><p>如果是针对某个字段，那么它的结构如下：
<code>
{
  QUERY_NAME: {
      FIELD_NAME: {
          ARGUMENT: VALUE,
          ARGUMENT: VALUE,...
      }
  }
}
</code></p></li>
<li><p>一条复合语句
<code>
{
  "bool": {
      "must": { "match":   { "email": "business opportunity" }},
      "should": [
          { "match":       { "starred": true }},
          { "bool": {
              "must":      { "match": { "folder": "inbox" }},
              "must_not":  { "match": { "spam": true }}
          }}
      ],
      "minimum_should_match": 1
  }
}
</code></p></li>
</ul>


<h4>实战查询</h4>

<ul>
<li><p>精确查询
<code>
GET /website/_search
{
"query": {
  "constant_score" : {
    "filter":{
      "term": {
        "title": "helloworld"
      }
    }
  }
}
}
</code></p></li>
<li><p>多词组合
<code>
GET /website/_search
{
  "query": {
      "match": {
          "title": {      
              "query":    "BROWN DOG!",
              "operator": "and"
          }
      }
  }
}
</code></p></li>
<li><p>短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": "quick brown fox"
      }
  }
}
</code></p></li>
<li><p>混合短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": {
              "query": "quick fox",
              "slop":  1
          }
      }
  }
}
</code></p></li>
<li><p>正则查询 (性能慢)
<code>
GET /my_index/_search
{
  "query": {
      "wildcard": {
          "postcode": "W?F*HW"
      }
  }
}
</code></p></li>
<li><p>智能匹配
<code>
GET /my_index/_search
{
  "query": {
      "match_phrase_prefix" : {
          "brand" : {
              "query":          "johnnie walker bl",
              "max_expansions": 50
              }
      }
  }
}
</code></p></li>
<li><p>控制精度
```
GET /website/_search
{
&ldquo;query&rdquo;: {
  &ldquo;match&rdquo;: {
    &ldquo;title&rdquo;: {
      &ldquo;query&rdquo;:                &ldquo;quick brown dog&rdquo;,
      &ldquo;minimum_should_match&rdquo;: &ldquo;75%&rdquo;
    }
  }
}
}</p></li>
</ul>


<p>GET /website/_search
{
  &ldquo;query&rdquo;: {</p>

<pre><code>"bool": {
  "should": [
    { "match": { "title": "brown" }},
    { "match": { "title": "fox"   }},
    { "match": { "title": "dog"   }}
  ],
  "minimum_should_match": 2 
}
</code></pre>

<p>  }
}
```</p>

<ul>
<li>按受欢迎度提升权重
```
GET /blogposts/post/_search
{
&ldquo;query&rdquo;: {
  &ldquo;function_score&rdquo;: {
    &ldquo;query&rdquo;: {
      &ldquo;multi_match&rdquo;: {
        &ldquo;query&rdquo;:    &ldquo;popularity&rdquo;,
        &ldquo;fields&rdquo;: [ &ldquo;title&rdquo;, &ldquo;content&rdquo; ]
      }
    },
    &ldquo;field_value_factor&rdquo;: {
      &ldquo;field&rdquo;: &ldquo;votes&rdquo;
    }
  }
}
}</li>
</ul>


<p>微调:
<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html</a>
```</p>

<h4>排障</h4>

<p>```
GET /website/_validate/query?explain
{
   &ldquo;query&rdquo;: {</p>

<pre><code>  "match" : {
     "text" : "really powerful"
  }
</code></pre>

<p>   }
}
```</p>

<h4>结果排序</h4>

<p>```
GET /website/_search
{</p>

<pre><code>"query" : {
    "bool" : {
        "filter" : { "term" : { "_id" : 1 }}
    }
},
"sort": { "date": { "order": "desc" }}
</code></pre>

<p>}
```</p>

<h2>索引操作</h2>

<h4>增加</h4>

<p>```
PUT /my_index
{</p>

<pre><code>"settings": { ... any settings ... },
"mappings": {
    "type_one": { ... any mappings ... },
    "type_two": { ... any mappings ... },
    ...
}
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /my_index
DELETE /index_one,index_two
DELETE /index_*
DELETE /_all
</code></p>

<h4>配置</h4>

<ul>
<li>number_of_shards</li>
</ul>


<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
<li>number_of_replicas</li>
</ul>


<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4>重新索引</h4>

<p>```
POST _reindex
{
  &ldquo;source&rdquo;: {</p>

<pre><code>"index": "twitter"
</code></pre>

<p>  },
  &ldquo;dest&rdquo;: {</p>

<pre><code>"index": "new_twitter"
</code></pre>

<p>  }
}</p>

<p>```</p>

<h4>释放空间</h4>

<p><code>
POST /_all/_forcemerge?only_expunge_deletes=true
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python捕获所有异常]]></title>
    <link href="https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang/"/>
    <updated>2019-06-24T12:31:08+08:00</updated>
    <id>https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang</id>
    <content type="html"><![CDATA[<p>摘自 &ndash; Python cookbook</p>

<p>老生常谈了，但是在Pyflake检查出E722错误时有时候又犯老毛病。人年纪大了越来越有老年痴呆倾向  &ndash;_&ndash; &hellip;..</p>

<h2>怎样捕获代码中的所有异常？</h2>

<!-- more -->


<h4>想要捕获所有的异常，可以直接捕获 Exception 即可：</h4>

<p><code>
try:
   ...
except Exception as e:
   ...
   log('Reason:', e)       # Important!
</code>
这个将会捕获除了 <code>SystemExit</code> 、 <code>KeyboardInterrupt</code> 和 <code>GeneratorExit</code> 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。</p>

<h4>讨论</h4>

<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>

<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>

<p>```
def parse_int(s):</p>

<pre><code>try:
    n = int(v)
except Exception:
    print("Couldn't parse")
</code></pre>

<p>```      <br/>
试着运行这个函数，结果如下：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>parse_int(&lsquo;n/a&rsquo;)
Couldn&rsquo;t parse
parse_int(&lsquo;42&rsquo;)
Couldn&rsquo;t parse</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>

<p>```
def parse_int(s):</p>

<pre><code>try:
    n = int(v)
except Exception as e:
    print("Couldn't parse")
    print('Reason:', e)
</code></pre>

<p>```</p>

<p>这时候你能获取如下输出，指明了有个编程错误：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>parse_int(&lsquo;42&rsquo;)
Couldn&rsquo;t parse
Reason: global name &lsquo;v&rsquo; is not defined</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>很明显，你应该尽可能将异常处理器定义的精准一些。</p>

<p>不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>

<h4>最可怕的例子是我们在处理临时文件的时候，用</h4>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>因为碍人的E722, 有人会自作聪明的改成:</p>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except Exception:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>正确的办法是:</p>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except BaseException:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>或者更确定的语义之下，每次都清理临时文件，这样更明确，处理更好一点:
```
try:</p>

<pre><code>....
</code></pre>

<p>except BaseException:</p>

<pre><code>logger.error(....)
</code></pre>

<p>finally:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>参考:</p>

<p><a href="https://github.com/PyCQA/pycodestyle/issues/703">https://github.com/PyCQA/pycodestyle/issues/703</a></p>

<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go包管理工具]]></title>
    <link href="https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju/"/>
    <updated>2019-05-01T15:25:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju</id>
    <content type="html"><![CDATA[<p>真的，Go的包管理工具之发展过程充分体现了什么叫<code>折腾</code>。 (叹气~~~)</p>

<!-- more -->


<p>想想Java的Maven， Nodejs的NPM，还有我们赞颂一万遍也不过分的Python包管理，为什么生命总要浪费在这些事情上面呢？ 陷入了深深的沉思~~</p>

<p>从Go1.11版本发布Go MODULE之后，我希望这是最后一次折腾<code>包管理</code>这件事情，神呐，诚心诚意的祈祷中~~</p>

<p>摘抄备忘下：</p>

<h2>GO111MODULE</h2>

<p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。
按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，GO111MODULE 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p>

<ul>
<li><p>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</p></li>
<li><p>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</p></li>
<li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:

<ul>
<li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li>
<li>当前目录位于包含 go.mod 文件的目录下</li>
</ul>
</li>
</ul>


<h2>go mod 命令</h2>

<p><code>
download    download modules to local cache (下载依赖的 modules 到本地 cache)
edit        edit go.mod from tools or scripts (编辑 go.mod 文件)
graph       print module requirement graph (打印模块依赖图)
init        initialize new module in current directory (再当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)
vendor      make vendored copy of dependencies (将依赖复制到 vendor 下)
verify      verify dependencies have expected content (校验依赖)
why         explain why packages or modules are needed (解释为什么需要依赖)
</code></p>

<h2>既有项目</h2>

<p>假设你已经有了一个 go 项目， 比如在$GOPATH/github.com/memoryboxes/hello下， 你可以使用go mod init github.com/memoryboxes/hello在这个文件夹下创建一个空的 go.mod (只有第一行 module github.com/memoryboxes/hello)。</p>

<p>然后你可以通过 go get ./&hellip;让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 -tags, 这样可以把 tags 的依赖都查找到)。</p>

<p>通过go mod tidy也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理tags。</p>

<p>执行上面的命令会把 go.mod 的latest版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p>

<h2>replace</h2>

<p>在国内访问golang.org/x的各个包都需要梯子，你可以在 go.mod 中使用replace替换成 github 上对应的库。</p>

<p><code>
replace (
  golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
  golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
  golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
)
</code>
依赖库中的replace对你的主 go.mod 不起作用，比如github.com/memoryboxes/hello的 go.mod 已经增加了replace, 但是你的 go.mod 虽然require了rpcx的库，但是没有设置replace的话， go get还是会访问golang.org/x。</p>

<p>所以如果想编译哪个项目，就在哪个项目中增加replace。</p>

<h2>包的版本控制</h2>

<p>下面的版本都是合法的：</p>

<p><code>
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
gopkg.in/vmihailenco/msgpack.v2 v2.9.1
gopkg.in/yaml.v2 &lt;=v2.2.1
github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
latest
</code>
版本号遵循如下规律：</p>

<p><code>
vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
vX.0.0-yyyymmddhhmmss-abcdefabcdef
vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
vX.Y.Z
</code>
也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p>

<p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p>

<h2>go get 升级</h2>

<ul>
<li>运行 go get -u 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li>
<li>运行 go get -u=patch 将会升级到最新的修订版本</li>
<li>运行 go get package@version 将会升级到指定的版本号version</li>
</ul>


<h2>go modules 与 vendor</h2>

<ul>
<li><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p></li>
<li><p>Go modules 支持通过go mod vendor命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用go build -mod=vendor即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p></li>
</ul>


<h2>参考:</h2>

<p><a href="https://roberto.selbach.ca/intro-to-go-modules/">https://roberto.selbach.ca/intro-to-go-modules/</a></p>

<p><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p>

<p><a href="https://windmt.com/2018/11/08/first-look-go-modules/">https://windmt.com/2018/11/08/first-look-go-modules/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Evolution of a Programmer]]></title>
    <link href="https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer/"/>
    <updated>2018-10-06T17:22:54+08:00</updated>
    <id>https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer</id>
    <content type="html"><![CDATA[<p>快有二十年的老段子了，最近又看到很多次，莫非是邪恶旧势力的崛起？存档一下。</p>

<!-- more -->


<h4>High School/Jr.High</h4>

<p><code>
  10 PRINT "HELLO WORLD"
  20 END
</code></p>

<h4>First year in College</h4>

<p>```
  program Hello(input, output)</p>

<pre><code>begin
  writeln('Hello World')
end.
</code></pre>

<p>```</p>

<h4>Senior year in College</h4>

<p>```
  (defun hello</p>

<pre><code>(print
  (cons 'Hello (list 'World))))
</code></pre>

<p>```</p>

<h4>New professional</h4>

<p>```
  #include &lt;stdio.h>
  void main(void)
  {</p>

<pre><code>char *message[] = {"Hello ", "World"};
int i;

for(i = 0; i &lt; 2; ++i)
  printf("%s", message[i]);
printf("\n");
</code></pre>

<p>  }
```</p>

<h4>Seasoned professional</h4>

<p>```
  #include &lt;iostream.h>
  #include &lt;string.h></p>

<p>  class string
  {
  private:</p>

<pre><code>int size;
char *ptr;
</code></pre>

<p>  string() : size(0), ptr(new char[1]) { ptr[0] = 0; }</p>

<pre><code>string(const string &amp;s) : size(s.size)
{
  ptr = new char[size + 1];
  strcpy(ptr, s.ptr);
}

~string()
{
  delete [] ptr;
}

friend ostream &amp;operator &lt;&lt;(ostream &amp;, const string &amp;);
string &amp;operator=(const char *);
</code></pre>

<p>  };</p>

<p>  ostream &amp;operator&lt;&lt;(ostream &amp;stream, const string &amp;s)
  {</p>

<pre><code>return(stream &lt;&lt; s.ptr);
</code></pre>

<p>  }</p>

<p>  string &amp;string::operator=(const char *chrs)
  {</p>

<pre><code>if (this != &amp;chrs)
{
  delete [] ptr;
 size = strlen(chrs);
  ptr = new char[size + 1];
  strcpy(ptr, chrs);
}
return(*this);
</code></pre>

<p>  }</p>

<p>  int main()
  {</p>

<pre><code>string str;

str = "Hello World";
cout &lt;&lt; str &lt;&lt; endl;

return(0);
</code></pre>

<p>  }
```</p>

<h4>Master Programmer</h4>

<p>```
  [
  uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
  ]
  library LHello
  {</p>

<pre><code>  // bring in the master library
  importlib("actimp.tlb");
  importlib("actexp.tlb");

  // bring in my interfaces
  #include "pshlo.idl"

  [
  uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
  ]
  cotype THello
</code></pre>

<p>   {
   interface IHello;
   interface IPersistFile;
   };
  };</p>

<p>  [
  exe,
  uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
  ]
  module CHelloLib
  {</p>

<pre><code>  // some code related header files
  importheader(&lt;windows.h&gt;);
  importheader(&lt;ole2.h&gt;);
  importheader(&lt;except.hxx&gt;);
  importheader("pshlo.h");
  importheader("shlo.hxx");
  importheader("mycls.hxx");

  // needed typelibs
  importlib("actimp.tlb");
  importlib("actexp.tlb");
  importlib("thlo.tlb");

  [
  uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
  aggregatable
  ]
  coclass CHello
</code></pre>

<p>   {
   cotype THello;
   };
  };</p>

<p>  #include &ldquo;ipfix.hxx&rdquo;</p>

<p>  extern HANDLE hEvent;</p>

<p>  class CHello : public CHelloBase
  {
  public:</p>

<pre><code>  IPFIX(CLSID_CHello);

  CHello(IUnknown *pUnk);
  ~CHello();

  HRESULT  __stdcall PrintSz(LPWSTR pwszString);
</code></pre>

<p>  private:</p>

<pre><code>  static int cObjRef;
</code></pre>

<p>  };</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &lt;stdio.h>
  #include &lt;stdlib.h>
  #include &ldquo;thlo.h&rdquo;
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;mycls.hxx&rdquo;</p>

<p>  int CHello::cObjRef = 0;</p>

<p>  CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
  {</p>

<pre><code>  cObjRef++;
  return;
</code></pre>

<p>  }</p>

<p>  HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
  {</p>

<pre><code>  printf("%ws
</code></pre>

<p>&ldquo;, pwszString);</p>

<pre><code>  return(ResultFromScode(S_OK));
</code></pre>

<p>  }</p>

<p>  CHello::~CHello(void)
  {</p>

<p>  // when the object count goes to zero, stop the server
  cObjRef&mdash;;
  if( cObjRef == 0 )</p>

<pre><code>  PulseEvent(hEvent);
</code></pre>

<p>  return;
  }</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;mycls.hxx&rdquo;</p>

<p>  HANDLE hEvent;</p>

<p>   int _cdecl main(
  int argc,
  char * argv[]
  ) {
  ULONG ulRef;
  DWORD dwRegistration;
  CHelloCF *pCF = new CHelloCF();</p>

<p>  hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);</p>

<p>  // Initialize the OLE libraries
  CoInitializeEx(NULL, COINIT_MULTITHREADED);</p>

<p>  CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,</p>

<pre><code>  REGCLS_MULTIPLEUSE, &amp;dwRegistration);
</code></pre>

<p>  // wait on an event to stop
  WaitForSingleObject(hEvent, INFINITE);</p>

<p>  // revoke and release the class object
  CoRevokeClassObject(dwRegistration);
  ulRef = pCF->Release();</p>

<p>  // Tell OLE we are going away.
  CoUninitialize();</p>

<p>  return(0); }</p>

<p>  extern CLSID CLSID_CHello;
  extern UUID LIBID_CHelloLib;</p>

<p>  CLSID CLSID_CHello = { /<em> 2573F891-CFEE-101A-9A9F-00AA00342820 </em>/</p>

<pre><code>  0x2573F891,
  0xCFEE,
  0x101A,
  { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</code></pre>

<p>  };</p>

<p>  UUID LIBID_CHelloLib = { /<em> 2573F890-CFEE-101A-9A9F-00AA00342820 </em>/</p>

<pre><code>  0x2573F890,
  0xCFEE,
  0x101A,
  { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</code></pre>

<p>  };</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &lt;stdlib.h>
  #include &lt;string.h>
  #include &lt;stdio.h>
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;clsid.h&rdquo;</p>

<p>  int <em>cdecl main(
  int argc,
  char * argv[]
  ) {
  HRESULT  hRslt;
  IHello        *pHello;
  ULONG  ulCnt;
  IMoniker * pmk;
  WCHAR  wcsT[</em>MAX_PATH];
  WCHAR  wcsPath[2 * _MAX_PATH];</p>

<p>  // get object path
  wcsPath[0] = &lsquo;\0&rsquo;;
  wcsT[0] = &lsquo;\0&rsquo;;
  if( argc > 1) {</p>

<pre><code>  mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
  wcsupr(wcsPath);
  }
</code></pre>

<p>  else {</p>

<pre><code>  fprintf(stderr, "Object path must be specified\n");
  return(1);
  }
</code></pre>

<p>  // get print string
  if(argc > 2)</p>

<pre><code>  mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
</code></pre>

<p>  else</p>

<pre><code>  wcscpy(wcsT, L"Hello World");
</code></pre>

<p>  printf(&ldquo;Linking to object %ws\n&rdquo;, wcsPath);
  printf(&ldquo;Text String %ws\n&rdquo;, wcsT);</p>

<p>  // Initialize the OLE libraries
  hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);</p>

<p>  if(SUCCEEDED(hRslt)) {</p>

<pre><code>  hRslt = CreateFileMoniker(wcsPath, &amp;pmk);
  if(SUCCEEDED(hRslt))
</code></pre>

<p>   hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&amp;pHello);</p>

<pre><code>  if(SUCCEEDED(hRslt)) {
</code></pre>

<p>   // print a string out
   pHello->PrintSz(wcsT);</p>

<p>   Sleep(2000);
   ulCnt = pHello->Release();
   }</p>

<pre><code>  else
</code></pre>

<p>   printf(&ldquo;Failure to connect, status: %lx&rdquo;, hRslt);</p>

<pre><code>  // Tell OLE we are going away.
  CoUninitialize();
  }
</code></pre>

<p>  return(0);
  }
```</p>

<h4>Apprentice Hacker</h4>

<p>```
  #!/usr/local/bin/perl
  $msg=&ldquo;Hello, world.\n&rdquo;;
  if ($#ARGV >= 0) {</p>

<pre><code>while(defined($arg=shift(@ARGV))) {
  $outfilename = $arg;
  open(FILE, "&gt;" . $outfilename) || die "Can't write $arg: $!\n";
  print (FILE $msg);
  close(FILE) || die "Can't close $arg: $!\n";
}
</code></pre>

<p>  } else {</p>

<pre><code>print ($msg);
</code></pre>

<p>  }
  1;
```</p>

<h4>Experienced Hacker</h4>

<p><code>
  #include &lt;stdio.h&gt;
  #define S "Hello, World\n"
  main(){exit(printf(S) == strlen(S) ? 0 : 1);}
</code></p>

<h4>Seasoned Hacker</h4>

<p><code>
  % cc -o a.out ~/src/misc/hw/hw.c
  % a.out
</code></p>

<h4>Guru Hacker</h4>

<p><code>
  % echo "Hello, world."
</code></p>

<h4>New Manager</h4>

<p><code>
  10 PRINT "HELLO WORLD"
  20 END
</code></p>

<h4>Middle Manager</h4>

<p><code>
  mail -s "Hello, world." bob@b12
  Bob, could you please write me a program that prints "Hello, world."?
  I need it by tomorrow.
  ^D
</code></p>

<h4>Senior Manager</h4>

<p><code>
  % zmail jim
  I need a "Hello, world." program by this afternoon.
</code></p>

<h4>Chief Executive</h4>

<p><code>
  % letter
  letter: Command not found.
  % mail
  To: ^X ^F ^C
  % help mail
  help: Command not found.
  % damn!
  !: Event unrecognized
  % logout
</code></p>
]]></content>
  </entry>
  
</feed>
