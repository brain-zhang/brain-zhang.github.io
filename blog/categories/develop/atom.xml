<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-09-11T10:58:27+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-2]]></title>
    <link href="https://happy123.me/blog/2019/09/11/wu-en-da-ji-qi-xue-xi-2/"/>
    <updated>2019-09-11T10:53:38+08:00</updated>
    <id>https://happy123.me/blog/2019/09/11/wu-en-da-ji-qi-xue-xi-2</id>
    <content type="html"><![CDATA[<p class="info">Logistic回归， 正则化</p>

<!-- more -->

<h2 id="logistic">1-Logistic回归</h2>

<h4 id="section">分类</h4>

<p>逻辑回归 (Logistic Regression)是分类问题的一个代表算法，这是目前最流行使用最广泛的一种学习算法。</p>

<p>我们将因变量(dependant variable)可能属于的两个类分别称为负向类（negative class）和 正向类（positive class），则因变量  𝑦∈0,1 ，其中 0 表示负向类，1 表示正向类。</p>

<p>分类问题下，可以采用逻辑回归的分类算法，这个算法的性质是：它的输出值永远在 0 到 1 之间。 它适用于标签 y 取值离散的情况，如：1 0 0 1。</p>

<h4 id="section-1">假设陈述</h4>

<p>分类问题，希望分类器的输出值在 0 和 1 之间，因此，假设函数需要满足预测值要在 0 和 1 之间。</p>

<p>回归模型的假设是：</p>

<script type="math/tex; mode=display">
h_\theta(x)=g(\theta^TX)
</script>

<p>其中：
* X 代表特征向量
* g 代表逻辑函数（logistic function）, 是一个常用的逻辑函数为 S形函数（Sigmoid function），公式为：</p>

<script type="math/tex; mode=display">
g(z) = \frac{1}{1+e^{-z}}
</script>

<ul>
  <li>python 代码实现sigmoid函数：</li>
</ul>

<p><code>
import numpy as np
def sigmoid(z):
    return 1 / (1 + np.exp(-z))
</code></p>

<p>结合起来，获得逻辑回归的假设：</p>

<script type="math/tex; mode=display">
h_\theta(x) =  \frac{1}{1+e^{-\theta^TX}}
</script>

<table>
  <tbody>
    <tr>
      <td>𝜃(𝑥) 的作用是，对于给定的输入变量，根据选择的参数计算输出变量为1 的可能性 （estimated probablity），即  ℎ𝜃(𝑥)=𝑃(𝑦=1</td>
      <td>𝑥;𝜃) 。</td>
    </tr>
  </tbody>
</table>

<h4 id="section-2">代价函数</h4>

<p>逻辑回归的代价函数为：</p>

<script type="math/tex; mode=display">
J(\theta)= \frac{1}{m}\sum^m_{i=1}Cost(h_\theta(x^{(i)}), y^{(i)})
</script>

<p>其中:</p>

<script type="math/tex; mode=display">
Cost(h_\theta(x), y)=-y\times{log(h_\theta(x))}-(1-y)\times{log(1-h_\theta(x))}
</script>

<p>代入代价函数:</p>

<script type="math/tex; mode=display">
J(\theta) = -\frac{1}{m}\sum^m_{i=1}[y^{(i)}log(h_\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]
</script>

<ul>
  <li>逻辑回归代价函数的Python代码实现：</li>
</ul>

<p><code>
import numpy as np
def cost(theta, X, y):
    theta = np.matrix(theta)
    X = np.matrix(X)
    y = np.matrix(y)
    first = np.multiply(-y, np.log(sigmoid(X * theta.T)))
    second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T)))
    return np.sum(first - second) / (len(X))
</code></p>

<h4 id="section-3">简化代价函数和梯度下降</h4>

<script type="math/tex; mode=display">
\theta_j := \theta_j - \alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j
</script>

<p>这个更新规则和之前用来做线性回归梯度下降的式子是一样的， 但是假设的定义发生了变化。即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p>

<h4 id="section-4">多分类任务 一对多</h4>

<p>邮件归类， 假如说你现在需要一个学习算法能自动地将邮件归类到不同的文件夹里，区分开来自工作的邮件、来自朋友的邮件、来自家人的邮件或者是有关兴趣爱好的邮件，那么，就有了一个四分类问题：其类别有四个，分别用 y=1、y=2、y=3、y=4 来代表。</p>

<p>多分类的关键就是构建多个逻辑分类函数；具体：</p>

<p>我们将多个类中的一个类标记为正向类（y=1），然后将其他所有类都标记为负向类，这个模型记作 ℎ(1)𝜃(𝑥)。接着，类似地第我们选择另一个类标记为 正向类（y=2），再将其它类都标记为负向类，将这个模型记作  ℎ(2)𝜃(𝑥) ,依此类推。 最后我们得到一系列的模型简记为：</p>

<script type="math/tex; mode=display">
h^{(i)_\theta(x)} = p(y=i|x;\theta)
</script>

<p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。 总之，我们已经把要做的做完了，现在要做的就是训练这个逻辑回归分类器： ℎ(𝑖)𝜃(𝑥) ， 其中 i对应每一个可能的y=i，最后，为了做出预测，我们给出输入一个新的 x 值做预测。我们要做的就是在我们三个分类器里面输入 x，然后我们选择一个让  ℎ(𝑖)𝜃(𝑥) 最大的 i，即</p>

<script type="math/tex; mode=display">
\max_ih^{(i)_\theta(x)}
</script>

<h2 id="section-5">2-正则化</h2>

<h4 id="section-6">过拟合问题</h4>

<p>就以多项式理解，x 的次数越高，拟合的越好，但相应的预测的能力就可能变差。</p>

<p>如何解决？</p>

<ul>
  <li>
    <p>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如 PCA, LDA），缺点是丢弃特征的同时，也丢弃了这些相应的信息；</p>
  </li>
  <li>
    <p>正则化。 保留所有的特征，但是减少参数的大小（magnitude），当我们有大量的特征，每个特征都对目标值有一点贡献的时候，比较有效。</p>
  </li>
  <li>
    <p>还有一个解决方式就是增加数据集,因为过拟合导致的原因就过度拟合测试数据集, 那么增加数据集就很大程度提高了泛化性了.</p>
  </li>
</ul>

<h4 id="section-7">代价函数</h4>

<p>正则化的基本方法：对高次项添加惩罚值，让高次项的系数接近于0。</p>

<p>假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：</p>

<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m} [ \sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2} + \lambda\sum_{j=1}^n\theta^2_j  ]
</script>

<p>其中 𝜆 又称为正则化参数（Regularization Parameter）</p>

<p>```
import numpy as np
def mseWithRegular(predict, y, w, lmd=0.1):
    ‘’’
        predict: 模型输出
        y: 真实标签
        w: 模型权重
        lmd: 正则化参数
    ‘’’
    constrct_loss = np.sum((predict - y) ** 2)
    experience_loss = lmd * np.sum(w ** 2)
    loss = (constrct_loss + experience_loss) / (2 * len(predict))
    return loss</p>

<p>predict = np.array([1, 1.5, 2])
y = np.array([0.9, 1.4, 2.1])
w = np.array([[1], [1], [1]])
mseWithRegular(predict, y, w)
```</p>

<p>如果选择的正则化参数 𝜆 过大，则会把所有的参数都最小化了，导致模型变成  ℎ𝜃(𝑥)=𝜃0 ，造成欠拟合。</p>

<p>所以对于正则化，我们要取一个合理的λ的值，这样才能更好的应用正则化。</p>

<h4 id="section-8">线性回归正则化</h4>
<p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程</p>

<p>正则化线性回归的代价函数为：</p>

<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m} [ \sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2} + \lambda\sum_{j=1}^n\theta^2_j ]
</script>

<ul>
  <li>梯度下降使代价函数最小化</li>
</ul>

<script type="math/tex; mode=display">
\theta_j := \theta_j (1-a\frac{\lambda}{m})- \alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j
</script>

<ul>
  <li>正规方程来求解正则化线性回归模型</li>
</ul>

<p>TODO: 暂时没有理解</p>

<h4 id="section-9">逻辑回归正则化</h4>

<p>针对逻辑回归问题，我们在之前的课程已经学习过两种优化算法：梯度下降法，更高级的优化算法需要你自己设计代价函数 𝐽(𝜃) 。</p>

<p>给代价函数增加一个正则化的表达式，得到代价函数:</p>

<script type="math/tex; mode=display">
J(\theta) = \frac{1}{m}\sum^m_{i=1}[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)}log(1-h_\theta(x^{(i)}))]+\frac{\lambda}{2m}\sum_{j=1}^n\theta^2_j
</script>

<p>代码实现:</p>

<p>```
import numpy as np
def sigmoid(x, derivative=False):
    sigm = 1. / (1. + np.exp(-x))
    if derivative:
        return sigm * (1. - sigm)
    return sigm</p>

<p>def costReg(theta, X, y, learningRate):
    theta = np.matrix(theta)
    X = np.matrix(X)
    y = np.matrix(y)
    first = np.multiply(-y, np.log(sigmoid(X * theta.T)))
    second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T)))
    reg = (learningRate / 2 * len(X)) * np.sum(np.power(theta[:,1:theta.shape[1]], 2))
    return np.sum(first - second) / (len(X)) + reg
```</p>

<p>最后，它的梯度下降看上去同正则化的线性回归一样，但是由于假设ℎ𝜃(𝑥)=𝑔(𝜃𝑇𝑋) ，所以与线性回归不同。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicode String Parse With Python and Fileinput]]></title>
    <link href="https://happy123.me/blog/2019/09/06/unicode-string-parse-with-python-and-fileinput/"/>
    <updated>2019-09-06T11:41:03+08:00</updated>
    <id>https://happy123.me/blog/2019/09/06/unicode-string-parse-with-python-and-fileinput</id>
    <content type="html"><![CDATA[<p>用fileinput模块parse数据很方便:</p>

<p>```
import fileinput</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    for line in fileinput.input():
        sys.stdout.write(line)</p>

<p>```</p>

<p>但有时候会碰到UnicodeDecodeError:</p>

<p>比如执行:</p>

<!-- more -->

<p>```
echo -e “foo\x80bar” |python3 testinput.py</p>

<p>…
UnicodeDecodeError: ‘utf8’ codec can’t decode byte 0x80 in position 3: invalid start byte
```</p>

<p>这种错误还不好用<code>try .. catch</code>忽略掉，因为它是在fileinput模块中自己parse的；</p>

<p>Python2的时候很罗嗦，需要自己用codecs去判断之后，才能parse;</p>

<p>Python3总算是引入了一个openhook参数，可以自己hook处理了；</p>

<p>最简单的处理方式:</p>

<p>```
import fileinput
import io
import sys</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    sys.stdin = io.TextIOWrapper(sys.stdin.buffer, errors=’replace’)
    for line in fileinput.input(openhook=fileinput.hook_encoded(“utf-8”)):
        sys.stdout.write(line)</p>

<p>```</p>

<p>参考:</p>

<p>https://stackoverflow.com/questions/24754861/unicode-file-with-python-and-fileinput</p>

<p>https://bugs.python.org/issue26756</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-1]]></title>
    <link href="https://happy123.me/blog/2019/09/01/wu-en-da-ji-qi-xue-xi-bi-ji/"/>
    <updated>2019-09-01T15:59:41+08:00</updated>
    <id>https://happy123.me/blog/2019/09/01/wu-en-da-ji-qi-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p class="info">这个系列教程大名鼎鼎，之前我都是用到啥就瞎试一通；最近花了两个周，认认真真把这些基础知识重新学了一遍；做个笔记；
苏老泉二十七始发愤，我这比他还落后；不过求知的旅途，上路永远不嫌晚，我一直在路上；</p>

<!-- more -->

<h2 id="supervised-learning">1-监督学习（Supervised Learning)</h2>

<p>根据训练数据是否拥有标记信息，学习任务可大致被分为两类：</p>

<ul>
  <li>
    <p>监督学习（Supervised Learning）监督学习的代表是回归和分类。</p>

    <ul>
      <li>回归:预测连续值的模型: 已知房子大小和房价数据集，预测某一房子的价格</li>
      <li>分类:预测离散值的模型: 已知肿瘤性质和大小数据集，预测肿瘤是否良性</li>
    </ul>
  </li>
  <li>
    <p>无监督学习（Unsupervised Learning） 无监督学习的代表是聚类。</p>
  </li>
</ul>

<h2 id="section">2-单变量线性回归</h2>

<h4 id="section-1">模型表示</h4>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta_{0} + \theta_{1}x
</script>

<h4 id="section-2">代价函数</h4>

<p>求两个值，使模型最为匹配当前数据集；求解匹配度的过程提炼出代价函数；代价函数值越小，匹配度越高</p>

<script type="math/tex; mode=display">
J(\theta_{0}, \theta_{1}) = \frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2}
</script>

<p>当𝜃1=0时，代价函数为一抛物线；
当𝜃0，𝜃1都不为0时，代价函数为一三维曲面；</p>

<h4 id="section-3">自动求解代价函数</h4>

<p>我们我们有函数  𝐽(𝜃0,𝜃1) , 可以不断的调整  𝜃0  和  𝜃1 , 来使得  𝐽(𝜃0,𝜃1)  , 直到  𝐽(𝜃0,𝜃1)  达到最小值为止</p>

<p>梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数 𝐽(𝜃0,𝜃1) 的最小值。</p>

<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合 (𝜃0,𝜃1,……,𝜃𝑛)  ，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到抵达一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。</p>

<p>帅气的梯度下降算法公式:</p>

<script type="math/tex; mode=display">
\theta_{j} := \theta_{j} - \alpha\frac{\partial}{\partial{\theta_{j}}}J(\theta)
</script>

<p>对 𝜃 赋值，使得  𝐽(𝜃) 按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中 𝛼 是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p>

<ul>
  <li>如果 𝛼 太小了，即我的学习速率太小，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</li>
  <li>如果 𝛼 太大，那么梯度下降法可能会越过最低点，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，最终会导致无法收敛，甚至发散。</li>
</ul>

<h2 id="section-4">3-矩阵和向量</h2>

<h4 id="x2">一个2X2矩阵</h4>

<p>```
import numpy as np
a=np.array([[1, 2], [3, 4]])</p>

<p>```</p>

<h4 id="section-5">向量是列数为1的特殊矩阵:</h4>

<p>```
b = np.array(np.zeros((3,1)))</p>

<p>```</p>

<h4 id="section-6">矩阵的加法</h4>

<p>行列数相等的才可以做加法，两个矩阵相加就是行列对应的元素相加。</p>

<p>```
import numpy as np
a = np.mat([[1,0],[2,5],[3,1]])
b = np.mat([[4,0.5],[2,5],[0,1]])
print (“a: \n”,a, “\nb: \n”,b)
print (“a+b: \n”,a+b)  # a + b，矩阵相加</p>

<p>```</p>

<h4 id="section-7">矩阵的标量乘法</h4>

<p>矩阵和标量的乘法也很简单,就是矩阵的每个元素都与标量相乘。</p>

<p>```
print (“a: \n”,a)
print (“3<em>a: \n”,3</em> a)  #矩阵标量乘法</p>

<p>```</p>

<h4 id="section-8">向量乘法</h4>
<p>m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量</p>

<p>```
import numpy as np
a = np.mat([[-1,2],[2,3]])
c = np.mat([[3],[4]])
ac = a * c</p>

<p>```</p>

<h4 id="section-9">矩阵乘法的性质</h4>
<ul>
  <li>矩阵的乘法不满足交换律： 𝐴×𝐵≠𝐵×𝐴</li>
  <li>矩阵的乘法满足结合律。即： 𝐴×（𝐵×𝐶）=（𝐴×𝐵）×𝐶</li>
  <li>在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，本讲义都用 I 代表单位矩阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0。</li>
</ul>

<h4 id="section-10">逆矩阵</h4>

<p>矩阵 A 是一个 m×m 矩阵（方阵），如果有逆矩阵，则：𝐴𝐴−1=𝐴−1𝐴=𝐼</p>

<p>没有逆矩阵的矩阵, 称为奇异 (singlar/degenerate)矩阵</p>

<p>```
import numpy as np</p>

<p>a = np.mat([[1,2],[3,4]])
print (‘a:\n’,a)
res = np.linalg.inv(a)
print(‘a inverse:\n’, res)</p>

<p>```</p>

<p>备注: 再octave中，可以用pinv函数(伪逆矩阵)对奇异矩阵求逆；</p>

<h4 id="section-11">矩阵转置</h4>

<p>设 A 为 m×n 阶矩阵（即 m 行 n 列），第 i 行 j 列的元素是 a(i,j)，即：A=a(i,j) 定义 A 的转置为这样一个 n×m 阶矩阵 B，满足 B=a(j,i)，即 b (i,j)=a (j,i)（B 的第 i 行第 j 列元素是 A 的第 j 行第 i 列元素），记  𝐴𝑇=𝐵 。</p>

<p>```
a = np.mat([[1,2],[3,4]])
print (‘a:\n’,a)
res = a.T
print(‘a transpose:\n’, res)</p>

<p>```</p>

<h2 id="section-12">4-多变量线性回归</h2>

<ul>
  <li>引入多种特征后的假设h模型</li>
</ul>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta_{0} + \theta_{1}x_{1} + \theta_{2}x_{2} + ... + \theta_{n}x_{n}
</script>

<p>此时模型中的参数是一个 n+1 维的向量，任何一个训练实例也都是 n+1 维的向量，特征矩阵 X 的维度是 m*(n+1)。 因此公式可以简化为：</p>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta^TX
</script>

<h4 id="section-13">多变量梯度下降</h4>

<p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价 函数是所有建模误差的平方和，即：</p>

<script type="math/tex; mode=display">
J(\theta_{0}, \theta_{1}...\theta_{n}) = \frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2}
</script>

<p>```
# 代价函数的python代码实现
def Cost(X, y, theta):
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))</p>

<p>```</p>

<h4 id="section-14">梯度下降 - 特征缩放</h4>

<p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这可以帮助梯度下降算法更快地收敛。</p>

<p>解决的方法是尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。</p>

<p>最简单的方法是令：</p>

<script type="math/tex; mode=display">
x_n = \frac{x_n - \mu_n}{s_n}
</script>

<p>其中,  𝜇𝑛 是平均值， 𝑠𝑛 是标准差。</p>

<h4 id="section-15">梯度下降 - 学习率</h4>

<ul>
  <li>如果学习率 𝛼 过小，则达到收敛所需的迭代次数会非常高；</li>
  <li>如果学习率 𝛼 过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</li>
</ul>

<p>通常可以考虑尝试些学习率： 0.01，0.03，0.1，0.3，1，3，10; 3倍增长</p>

<h4 id="section-16">特征与多项式回归</h4>

<p>如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。因为幂运算很容易拉大特征之间尺度的差距</p>

<h4 id="section-17">正规方程</h4>

<p>假设我们的训练集特征矩阵为 X（包含了 𝑥0=1 ）并且我们的训练集结果为向量 y， 则利用正规方程解出向量</p>

<script type="math/tex; mode=display">
\theta = (X^TX)^{-1}X^Ty
</script>

<p>只要特征变量的数目并不大，标准方程是一个很好的计算参数 𝜃 的替代方法。具体地说，只要特征变量的数量小于一万，通常使用标准方程法，而不使用梯度下降法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Flask RestAPI集成Swagger UI]]></title>
    <link href="https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui/"/>
    <updated>2019-08-18T15:38:02+08:00</updated>
    <id>https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui</id>
    <content type="html"><![CDATA[<p>花了半天时间，给<a href="https://github.com/brain-zhang/chainhorn">chainhorn</a>集成了Swagger;</p>

<p>虽然这种事情已经做过好几遍了，但是不读文档还是没辙；我把这种半吊子形容为“我认识人民币，但是画不出来…T_T”</p>

<p>还是老老实实流水账记一下吧:</p>

<!-- more -->

<h3 id="section">依赖组件</h3>

<ul>
  <li><a href="https://flask-restplus.readthedocs.io">flask-restplus</a></li>
</ul>

<p>restplus能让人很方便的通过几个decorator就可以集成很漂亮的restapi，它提供了api命名空间、Request和Response解析以及Swagger UI的集成</p>

<p>另外，flask-restplus的文档和例子写的非常简洁清晰，赞一个。</p>

<ul>
  <li><a href="https://flask-httpauth.readthedocs.io/en/latest/">flask-httpauth</a></li>
</ul>

<p>用来集成验证机制，支持基本的密码验证、Token验证；短小精悍，够用了</p>

<h3 id="section-1">起步</h3>

<p>引用官网的例子:</p>

<h4 id="api">构建api对象</h4>

<p>```
from flask import Flask
from flask_restplus import Api, Resource, fields
from werkzeug.contrib.fixers import ProxyFix</p>

<p>app = Flask(<strong>name</strong>)
app.wsgi_app = ProxyFix(app.wsgi_app)</p>

<p>api = Api(app, version=’1.0’, title=’Chainhorn API’,
    description=’A simple ChainHorn API’,
)</p>

<p>ns = api.namespace(‘node’, description=’node operations’)</p>

<p>```</p>

<p>最重要的是构建了<code>api</code>对象，这样就可以为后面的资源增加url路由、参数解析同能；</p>

<p>下面紧跟着构建了一个<code>ns</code> –<code>namespace</code>对象，作用是为不同的资源，不同的url分组，这样最后反映到界面上好看一点；</p>

<h4 id="section-2">修饰</h4>

<p>```
@ns.route(‘’)
  class NodeGetInfo(Resource):
      @ns_node.doc(‘get node info’)
      def get(self):
          ‘'’get node info’’’
          info = spv.getinfo()
          return {‘nodeinfo’: info}, 200</p>

<p>```</p>

<p>最简单的，用<code>@ns.route('')</code>，就定义了根url， 然后后面的套路都是相似的，为资源实现get方法，就直接响应 http Get请求了；</p>

<h4 id="request">Request参数处理</h4>

<p>如果直接在url后面跟参数，那么很方便的用 <code>ns.param</code>定义一下即可:
下面这个函数就直接接受一个 <code>/broadcast/tx12345</code> 这样的tx12345作为参数<code>tx</code></p>

<p>```
@ns.route(‘/broadcast/<string:tx>')
  class WalletBroadcastTx(Resource):
      @ns.doc('broadcast raw tx')
      @ns.param('tx', 'The transaction hash identifier')
      def post(self, tx):
          '''broadcast raw tx'''
          sendrawtransaction(spv, tx)
          return {'broadcast': 'ok'}, 200</string:tx></p>

<p>```</p>

<p>如果要放在FormData里面，可以用<code>ns.expect</code>来限制；它可以接受一个对象传入；比如上面的例子，要把<code>tx</code>字段放到POST请求的Form Data中，要这样做:</p>

<p>```
TxModel = {‘tx’: fields.String(required=True, description=’The hex tx’)}
@ns.route(‘/broadcast’)
  class WalletBroadcastTx(Resource):
      @ns.doc(‘broadcast raw tx’)
      @ns.expect(TxModel, 200)
      def post(self, tx):
          ‘'’broadcast raw tx’’’
          sendrawtransaction(spv, api.payload[‘tx’])
          return {‘broadcast’: ‘ok’}, 200</p>

<p>```</p>

<h4 id="response">Response参数处理</h4>

<p>同样的，如果需要返回一个对象，在界面上出现这个对象的详细描述信息，可以用<code>marshal_with</code>和<code>marshal_list_with</code>来修饰；</p>

<p>具体请参考:</p>

<p>https://flask-restplus.readthedocs.io/en/stable/parsing.html</p>

<h4 id="section-3">用户验证</h4>

<p>例如，为API加上HTTP Token Auth，要用到<code>HTTPTokenAuth</code>对象；</p>

<p>首先我们先定义验证规则:</p>

<p>```
auth = HTTPTokenAuth()
tokens = {
  ‘APIKEY’:’hello’,
  “APPID”: “chainhorn”
}</p>

<p>@auth.verify_token
def verify_token(token):
  if request.headers.get(‘APIKEY’, ‘’).strip()==tokens[‘APIKEY’] and \
     request.headers.get(‘APPID’, ‘’).strip() == tokens[‘APPID’]:
      return True
  else:
      return False</p>

<p>```</p>

<p>然后在每个url 请求处理函数前面加上修饰符<code>auth_login_required</code>；比如我们最开始的例子:</p>

<p>```
@ns.route(‘’)
class NodeGetInfo(Resource):
  @ns.doc(‘get node info’)
  @auth.login_required
  def get(self):
      ‘'’get node info’’’
      info = spv.getinfo()
      return {‘nodeinfo’: info}, 200</p>

<p>```</p>

<p>这样后台验证就有了；那么前台输入呢？</p>

<p>这个例子里面，我们需要前台输入的时候在HTTP Header里面传入两个Key: APIKEY和APPKEY；直接用用Swagger UI自带的组件实现就可以了，把api对象构造为:</p>

<p>```
AUTHORIZATIONS = {
    ‘apikey’: {
        ‘type’: ‘apiKey’,
        ‘in’: ‘header’,
        ‘name’: ‘APIKEY’
    },
    ‘appid’: {
        ‘type’: ‘apiKey’,
        ‘in’: ‘header’,
        ‘name’: ‘APPID’
    }
}
api = Api(app,
        version=’v1’,
        authorizations=AUTHORIZATIONS,
        security=list(AUTHORIZATIONS.keys()),
        title=’Chainhorn API’,
        description=’Chainhorn API’,
)</p>

<p>```</p>

<p>这样默认所有的API访问都需要 在HTTP Header中传入两个Key: APIKEY和APPKEY，如果值不对的话就会访问失败；</p>

<p>此时前台的界面是这样的:</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/201908/bg3.jpg" alt="Auth1" /></p>

<p>可以点击右上角的Authorize一次性设置所有API的访问密钥；</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/201908/bg4.jpg" alt="Auth2" /></p>

<p>也可以在每个API的右上角设置访问密钥；</p>

<p>当然，我们目前的密钥是后台写死的，你可以引入一个三方库为每个用户生成不同的密钥存到数据库里面，然后每次验证~~~</p>

<h3 id="section-4">综合例子</h3>

<p>最后，在github上面有个集大成的例子,值得推荐</p>

<p>https://github.com/frol/flask-restplus-server-example</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Requests Post for 5 Styles]]></title>
    <link href="https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles/"/>
    <updated>2019-08-09T09:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles</id>
    <content type="html"><![CDATA[<h4 id="requestspost">requests库发送post请求的五种姿势;</h4>

<!-- more -->

<h4 id="applicationx-www-form-urlencoded">1.application/x-www-form-urlencoded</h4>

<p>最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。请求类似于下面这样:</p>

<p>```
POST http://www.example.com HTTP/1.1    Content-Type:
application/x-www-form-urlencoded;charset=utf-8
title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</p>

<p>```</p>

<p>requests默认处理就是这种方式， exp:</p>

<p>```
url = ‘http://httpbin.org/post’
d = {‘key1’: ‘value1’, ‘key2’: ‘value2’}
r = requests.post(url, data=d)
print r.text</p>

<p>```</p>

<h4 id="multipartform-data">2.multipart/form-data</h4>

<p>除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。
这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值:</p>

<p>requests exp:</p>

<p>```
from requests_toolbelt import MultipartEncoder
import requests</p>

<p>m = MultipartEncoder(
    fields={‘field0’: ‘value’, ‘field1’: ‘value’,
            ‘field2’: (‘filename’, open(‘file.py’, ‘rb’), ‘text/plain’)}
    )</p>

<p>r = requests.post(‘http://httpbin.org/post’, data=m,
                  headers={‘Content-Type’: m.content_type})</p>

<p>```</p>

<h4 id="applicationjson">3.application/json</h4>

<p>application/json 这个 Content-Type作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>

<p>requests exp:</p>

<p>```
url = ‘http://httpbin.org/post’
s = json.dumps({‘key1’: ‘value1’, ‘key2’: ‘value2’})
r = requests.post(url, data=s)
print r.text</p>

<p>```</p>

<p>or</p>

<p>```
requests.post(url=’‘,data=json.dumps({‘key1’:’value1’,’key2’:’value2’}),headers={‘Content-Type’:’application/json’})</p>

<p>```</p>

<p>or</p>

<p>```
requests.post(url=’‘,json=,headers={‘Content-Type’:’application/json’})</p>

<p>```</p>

<h4 id="textxml">4. text/xml</h4>
<p>跟json类似，XML 作为编码方式的远程调用规范。</p>

<p>requests exp:</p>

<p>```
requests.post(url=’‘,data=’<?xml  ?>‘,headers={‘Content-Type’:’text/xml’})</p>

<p>```</p>

<h4 id="binary">5. binary</h4>

<p>直接二进制流数据传输，多用于上传图片</p>

<p>requests exp:</p>

<p>```
requests.post(url=’‘,files={‘file’:open(‘test.xls’,’rb’)},headers={‘Content-Type’:’binary’})</p>

<p>```</p>

<p>or</p>

<p>```
url = ‘http://httpbin.org/post’
files = {‘file’: open(‘report.txt’, ‘rb’)}
r = requests.post(url, files=files)
print r.text</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
