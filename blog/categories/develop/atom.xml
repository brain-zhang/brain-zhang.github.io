<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-08-04T09:38:56+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SSL&TLS Tips]]></title>
    <link href="https://happy123.me/blog/2019/08/04/ssl-tls-tips/"/>
    <updated>2019-08-04T09:35:42+08:00</updated>
    <id>https://happy123.me/blog/2019/08/04/ssl-tls-tips</id>
    <content type="html"><![CDATA[<p>每天的日常编码工作：就是解决一个问题的时候再创造另外一个问题 Orz&hellip;..</p>

<p>话说刚才生成一个私钥的时候， Python3绑定libssl1.1 又崩了；正在痛苦思考中~~~</p>

<!-- more -->


<p>现在有两个选择:</p>

<ol>
<li>放弃ssl动态库调用，反正我只用ECDSA，所以找个原生库来用好啦</li>
<li>死磕openssl，把它彻底搞明白</li>
</ol>


<p>利弊权衡之下我选择了1，不过当然我也在2上花了一点时间，复习了一下基础知识，在此记录下来。</p>

<h3>libssl3是个什么东东</h3>

<p>在探究libssl.so的时候，我无意发现我的系统里面还有一个libssl3.so；这个是什么东东？我印象里面openssl还只有1.x版本才对；</p>

<p>我在ubuntu16.04下查看这个so文件来源;</p>

<p><code>
~ locate libssl3.so
/usr/lib/x86_64-linux-gnu/libssl3.so
</code></p>

<p>nm看一下:</p>

<p>```
~ nm /usr/lib/x86_64-linux-gnu/libssl3.so
nm: /usr/lib/x86_64-linux-gnu/libssl3.so: no symbols</p>

<p>```</p>

<p>奇怪，没有任何符号；继续用ldd看一下：</p>

<p>```
~ ldd /usr/lib/x86_64-linux-gnu/libssl3.so
ldd /usr/lib/x86_64-linux-gnu/libssl3.so</p>

<pre><code>    linux-vdso.so.1 =&gt;  (0x00007ffe833bb000)
    libnss3.so =&gt; /usr/lib/x86_64-linux-gnu/libnss3.so (0x00007faf3cc8a000)
    libnssutil3.so =&gt; /usr/lib/x86_64-linux-gnu/libnssutil3.so (0x00007faf3ca5d000)
    libplc4.so =&gt; /usr/lib/x86_64-linux-gnu/libplc4.so (0x00007faf3c858000)
    libnspr4.so =&gt; /usr/lib/x86_64-linux-gnu/libnspr4.so (0x00007faf3c619000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf3c3fc000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf3c032000)
    libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007faf3be18000)
    libplds4.so =&gt; /usr/lib/x86_64-linux-gnu/libplds4.so (0x00007faf3bc14000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf3ba10000)
    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007faf3b808000)
    /lib64/ld-linux-x86-64.so.2 (0x00007faf3d21d000)
</code></pre>

<p>```</p>

<p>嗯，找到了一个有意思的依赖:libnss3.so</p>

<p>再用命令dpkg看一下</p>

<p><code>
~ dpkg -S /usr/lib/x86_64-linux-gnu/libnss3.so
libnss3:amd64: /usr/lib/x86_64-linux-gnu/libnss3.so
</code></p>

<p>基本上确定是libnss3这个库引入的libssl3.so了，最后再用dpkg确认一下:</p>

<p><code>
~ dpkg-query -L libnss3
/.
/usr
/usr/lib
/usr/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu/libnssutil3.so
/usr/lib/x86_64-linux-gnu/nss
/usr/lib/x86_64-linux-gnu/nss/libfreebl3.chk
/usr/lib/x86_64-linux-gnu/nss/libnssckbi.so
/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.so
/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.chk
/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.chk
/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.so
/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.chk
/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.so
/usr/lib/x86_64-linux-gnu/nss/libfreebl3.so
/usr/lib/x86_64-linux-gnu/nss/libnsssysinit.so
/usr/lib/x86_64-linux-gnu/libsmime3.so
/usr/lib/x86_64-linux-gnu/libnss3.so
/usr/lib/x86_64-linux-gnu/libssl3.so
/usr/share
/usr/share/doc
/usr/share/doc/libnss3
/usr/share/doc/libnss3/copyright
/usr/share/doc/libnss3/changelog.Debian.gz
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/libnss3
</code></p>

<h3>libnss3是个什么东东?</h3>

<p><code>
apt-cache show libnss3
</code></p>

<p>看了一下，发现是mozilla基金会搞得东东；再google一下，发现是自己孤陋寡闻了；</p>

<p>原来，SSL&amp;TSL的实现，不只是openssl一家独大，像Mozilla Firefox就用自家实现的Nss；</p>

<p>Google Chrome之前也是用Nss的，后来赚到了openssl，再后来，2014年，openssl1.0.1出现了heartbeat 漏洞，Google干脆自己开了个分支，用自己定制的openssl了；</p>

<p>至于Windows平台的，还有C++阵营的，都有自己实现的ssl库，具体可参见:</p>

<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</a></p>

<h3>nss在centos中</h3>

<p>搜素的过程中，我惊奇的发现，ubuntu和centos上面的curl，竟然链接的libssl也不一样：</p>

<p>ubuntu上的curl默认链接的是openssl，而centos上面默认链接的是libnss3；</p>

<p>耐人寻味啊，莫非redhat系的人发现了什么~~~~</p>

<p>做事要做全套，我分别切换到ubuntu16.04和centos7.2上面，看看他们官方仓库中自带的curl是如何编译的。</p>

<h4>centos7.2</h4>

<p><code>
~ rpm -q --requires curl
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.17)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libcurl = 7.29.0-51.el7
libcurl.so.4()(64bit)
libdl.so.2()(64bit)
libnspr4.so()(64bit)
libnss3.so()(64bit)
libnssutil3.so()(64bit)
libplc4.so()(64bit)
libplds4.so()(64bit)
libpthread.so.0()(64bit)
libpthread.so.0(GLIBC_2.2.5)(64bit)
libsmime3.so()(64bit)
libssl3.so()(64bit)
libz.so.1()(64bit)
rpmlib(CompressedFileNames) &lt;= 3.0.4-1
rpmlib(FileDigests) &lt;= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
rtld(GNU_HASH)
rpmlib(PayloadIsXz) &lt;= 5.2-1
</code>
用的是libcurl = 7.29.0-51.el7；</p>

<p>```
~ rpm -q &mdash;requires libcurl
/sbin/ldconfig
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.15)(64bit)
libc.so.6(GLIBC_2.16)(64bit)
libc.so.6(GLIBC_2.17)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.3.4)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libcom_err.so.2()(64bit)
libdl.so.2()(64bit)
libgssapi_krb5.so.2()(64bit)
libgssapi_krb5.so.2(gssapi_krb5_2_MIT)(64bit)
libidn.so.11()(64bit)
libidn.so.11(LIBIDN_1.0)(64bit)
libk5crypto.so.3()(64bit)
libkrb5.so.3()(64bit)
liblber-2.4.so.2()(64bit)
libldap-2.4.so.2()(64bit)
libnspr4.so()(64bit)
libnss3.so()(64bit)
libnss3.so(NSS_3.10)(64bit)
libnss3.so(NSS_3.12.1)(64bit)
libnss3.so(NSS_3.12.5)(64bit)
libnss3.so(NSS_3.2)(64bit)</p>

<p>&hellip;.
<code>
看到libnss3了,重点输出：
</code>
libnss3.so
```
那么这个包是谁提供的？输入如下命令：</p>

<p>```
~ rpm -qf /usr/lib64/libnss3.so</p>

<pre><code>nss-3.36.0-7.1.el7_6.x86_64
</code></pre>

<p>~ rpm -ql nss
/etc/pki/nss-legacy
/etc/pki/nss-legacy/nss-rhel7.config
/etc/pki/nssdb
/etc/pki/nssdb/cert8.db
/etc/pki/nssdb/cert9.db
/etc/pki/nssdb/key3.db
/etc/pki/nssdb/key4.db
/etc/pki/nssdb/pkcs11.txt
/etc/pki/nssdb/secmod.db
/usr/lib64/libnss3.so
/usr/lib64/libnssckbi.so
/usr/lib64/libsmime3.so
/usr/lib64/libssl3.so
/usr/lib64/nss/libnssckbi.so
&hellip;
```
至此水落石出，还可以看到我们熟悉的证书cert8.db文件；但其实 curl 最终使用的根证书库并不是该文件。那 curl 使用的根证书文件在哪儿呢？</p>

<p>使用 curl-config 命令行工具，能够了解更多：
<code>
~ curl-config --ca
/etc/pki/tls/certs/ca-bundle.crt
</code></p>

<h4>ubuntu16.04</h4>

<p>ubuntu16上面验证类似，不一一说明了~~~</p>

<p>```
~ dpkg-query -L libcurl3
/.
/usr
/usr/share
/usr/share/doc
/usr/share/doc/libcurl3
/usr/share/doc/libcurl3/copyright
/usr/share/doc/libcurl3/changelog.Debian.gz
/usr/share/doc/libcurl3/NEWS.Debian.gz
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/libcurl3
/usr/lib
/usr/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0
/usr/lib/x86_64-linux-gnu/libcurl.so.3
/usr/lib/x86_64-linux-gnu/libcurl.so.4</p>

<p>```</p>

<p><code>
~ apt-cache depends  libcurl3
  Depends: libc6
  Depends: libgssapi-krb5-2
  Depends: libidn11
  Depends: libldap-2.4-2
  Depends: librtmp1
  Depends: libssl1.0.0
  Depends: zlib1g
  Recommends: ca-certificates
</code></p>

<p>然后寻找libcurl的依赖库:</p>

<p><code>
~ ldd /usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0|grep ssl
libssl.so.1.0.0 =&gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fbdf8aa0000)
</code></p>

<p>验证一下:</p>

<p>```
~ apt-cache depends openssl
openssl
  Depends: libc6
  Depends: libssl1.0.0
  Suggests: ca-certificates</p>

<p>~ apt-cache rdepends  libssl1.0.0 | grep curl
  libcurl3
```</p>

<h3>总结</h3>

<p>所以这就是想要解决一个问题的中途，又被带到了另外一条小路上；该说我是还有那么一点好奇心呢？还是注意力不集中呢？</p>

<p>Orz&hellip;&hellip;&hellip;</p>

<h3>参考资料:</h3>

<p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</a></p>

<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E">https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</a></p>

<p><a href="https://www.lbbniu.com/6680.html">https://www.lbbniu.com/6680.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->


<p>```
import ctypes
import logging</p>

<p>try:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</code></pre>

<p>except Exception:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</code></pre>

<p>def check_result(val, func, args):</p>

<pre><code>if val == 0:
    raise ValueError
else:
    return ctypes.c_void_p(val)
</code></pre>

<h1>ssl_library.EC_KEY_new.restype = ctypes.c_void_p</h1>

<p>ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result</p>

<p>k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)</p>

<p>if ssl_library.EC_KEY_generate_key(k) != 1:</p>

<pre><code>raise Exception("internal error")
</code></pre>

<p>ssl_library.EC_KEY_free(k)
```</p>

<p>这段代码在多线程的时候会出现segmentation fault error； 是openssl1.0.0的实现问题，参考:</p>

<p><a href="https://bugs.python.org/issue29340">https://bugs.python.org/issue29340</a></p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒LXC技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->


<h2>文档操作</h2>

<h4>增加一条记录</h4>

<p><code>
PUT /website/_doc/1
{
  "title": "My 2 blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}
</code></p>

<h4>修改</h4>

<p>```
POST /website/_update/1
{
   &ldquo;doc&rdquo; : {</p>

<pre><code>  "tags" : [ "testing..." ],
  "views": 0
</code></pre>

<p>   }
}
```</p>

<h4>查询</h4>

<p>```
GET /website/_search</p>

<p>GET /website/_source/1</p>

<p>GET /website/_mget
{</p>

<pre><code>"ids" : [ "2", "1" ]    
</code></pre>

<p>}</p>

<p>GET /_search
{</p>

<pre><code>"query": YOUR_QUERY_HERE
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /website/_doc/1
</code></p>

<h2>文档功能API</h2>

<h4>获取映射信息</h4>

<p><code>
GET /website/_mapping
</code></p>

<h4>测试分析器</h4>

<p><code>
GET /website/_analyze
{
  "field": "tweet",
  "text": "Black-cats"
}
</code></p>

<h4>多层级对象用扁平化的方法来存储，比如</h4>

<p>```
{
  &ldquo;gb&rdquo;: {</p>

<pre><code>"tweet": { 
  "properties": {
    "tweet":            { "type": "string" },
    "user": { 
      "type":             "object",
      "properties": {
        "id":           { "type": "string" },
        "gender":       { "type": "string" },
        "age":          { "type": "long"   },
        "name":   { 
          "type":         "object",
          "properties": {
            "full":     { "type": "string" },
            "first":    { "type": "string" },
            "last":     { "type": "string" }
          }
        }
      }
    }
  }
}
</code></pre>

<p>  }
}</p>

<p>```
会被转换为如下内部对象:</p>

<p>```
{</p>

<pre><code>"tweet":            [elasticsearch, flexible, very],
"user.id":          [@johnsmith],
"user.gender":      [male],
"user.age":         [26],
"user.name.full":   [john, smith],
"user.name.first":  [john],
"user.name.last":   [smith]
</code></pre>

<p>}
```</p>

<h4>内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2>查询</h2>

<h4>查询语句的结构</h4>

<ul>
<li><p>一个查询语句 的典型结构：
<code>
{
  QUERY_NAME: {
      ARGUMENT: VALUE,
      ARGUMENT: VALUE,...
  }
}
</code></p></li>
<li><p>如果是针对某个字段，那么它的结构如下：
<code>
{
  QUERY_NAME: {
      FIELD_NAME: {
          ARGUMENT: VALUE,
          ARGUMENT: VALUE,...
      }
  }
}
</code></p></li>
<li><p>一条复合语句
<code>
{
  "bool": {
      "must": { "match":   { "email": "business opportunity" }},
      "should": [
          { "match":       { "starred": true }},
          { "bool": {
              "must":      { "match": { "folder": "inbox" }},
              "must_not":  { "match": { "spam": true }}
          }}
      ],
      "minimum_should_match": 1
  }
}
</code></p></li>
</ul>


<h4>实战查询</h4>

<ul>
<li><p>精确查询
<code>
GET /website/_search
{
"query": {
  "constant_score" : {
    "filter":{
      "term": {
        "title": "helloworld"
      }
    }
  }
}
}
</code></p></li>
<li><p>多词组合
<code>
GET /website/_search
{
  "query": {
      "match": {
          "title": {      
              "query":    "BROWN DOG!",
              "operator": "and"
          }
      }
  }
}
</code></p></li>
<li><p>短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": "quick brown fox"
      }
  }
}
</code></p></li>
<li><p>混合短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": {
              "query": "quick fox",
              "slop":  1
          }
      }
  }
}
</code></p></li>
<li><p>正则查询 (性能慢)
<code>
GET /my_index/_search
{
  "query": {
      "wildcard": {
          "postcode": "W?F*HW"
      }
  }
}
</code></p></li>
<li><p>智能匹配
<code>
GET /my_index/_search
{
  "query": {
      "match_phrase_prefix" : {
          "brand" : {
              "query":          "johnnie walker bl",
              "max_expansions": 50
              }
      }
  }
}
</code></p></li>
<li><p>控制精度
```
GET /website/_search
{
&ldquo;query&rdquo;: {
  &ldquo;match&rdquo;: {
    &ldquo;title&rdquo;: {
      &ldquo;query&rdquo;:                &ldquo;quick brown dog&rdquo;,
      &ldquo;minimum_should_match&rdquo;: &ldquo;75%&rdquo;
    }
  }
}
}</p></li>
</ul>


<p>GET /website/_search
{
  &ldquo;query&rdquo;: {</p>

<pre><code>"bool": {
  "should": [
    { "match": { "title": "brown" }},
    { "match": { "title": "fox"   }},
    { "match": { "title": "dog"   }}
  ],
  "minimum_should_match": 2 
}
</code></pre>

<p>  }
}
```</p>

<ul>
<li>按受欢迎度提升权重
```
GET /blogposts/post/_search
{
&ldquo;query&rdquo;: {
  &ldquo;function_score&rdquo;: {
    &ldquo;query&rdquo;: {
      &ldquo;multi_match&rdquo;: {
        &ldquo;query&rdquo;:    &ldquo;popularity&rdquo;,
        &ldquo;fields&rdquo;: [ &ldquo;title&rdquo;, &ldquo;content&rdquo; ]
      }
    },
    &ldquo;field_value_factor&rdquo;: {
      &ldquo;field&rdquo;: &ldquo;votes&rdquo;
    }
  }
}
}</li>
</ul>


<p>微调:
<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html</a>
```</p>

<h4>排障</h4>

<p>```
GET /website/_validate/query?explain
{
   &ldquo;query&rdquo;: {</p>

<pre><code>  "match" : {
     "text" : "really powerful"
  }
</code></pre>

<p>   }
}
```</p>

<h4>结果排序</h4>

<p>```
GET /website/_search
{</p>

<pre><code>"query" : {
    "bool" : {
        "filter" : { "term" : { "_id" : 1 }}
    }
},
"sort": { "date": { "order": "desc" }}
</code></pre>

<p>}
```</p>

<h2>索引操作</h2>

<h4>增加</h4>

<p>```
PUT /my_index
{</p>

<pre><code>"settings": { ... any settings ... },
"mappings": {
    "type_one": { ... any mappings ... },
    "type_two": { ... any mappings ... },
    ...
}
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /my_index
DELETE /index_one,index_two
DELETE /index_*
DELETE /_all
</code></p>

<h4>配置</h4>

<ul>
<li>number_of_shards</li>
</ul>


<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
<li>number_of_replicas</li>
</ul>


<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4>重新索引</h4>

<p>```
POST _reindex
{
  &ldquo;source&rdquo;: {</p>

<pre><code>"index": "twitter"
</code></pre>

<p>  },
  &ldquo;dest&rdquo;: {</p>

<pre><code>"index": "new_twitter"
</code></pre>

<p>  }
}</p>

<p>```</p>

<h4>释放空间</h4>

<p><code>
POST /_all/_forcemerge?only_expunge_deletes=true
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python捕获所有异常]]></title>
    <link href="https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang/"/>
    <updated>2019-06-24T12:31:08+08:00</updated>
    <id>https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang</id>
    <content type="html"><![CDATA[<p>摘自 &ndash; Python cookbook</p>

<p>老生常谈了，但是在Pyflake检查出E722错误时有时候又犯老毛病。人年纪大了越来越有老年痴呆倾向  &ndash;_&ndash; &hellip;..</p>

<h2>怎样捕获代码中的所有异常？</h2>

<!-- more -->


<h4>想要捕获所有的异常，可以直接捕获 Exception 即可：</h4>

<p><code>
try:
   ...
except Exception as e:
   ...
   log('Reason:', e)       # Important!
</code>
这个将会捕获除了 <code>SystemExit</code> 、 <code>KeyboardInterrupt</code> 和 <code>GeneratorExit</code> 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。</p>

<h4>讨论</h4>

<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>

<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>

<p>```
def parse_int(s):</p>

<pre><code>try:
    n = int(v)
except Exception:
    print("Couldn't parse")
</code></pre>

<p>```      <br/>
试着运行这个函数，结果如下：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>parse_int(&lsquo;n/a&rsquo;)
Couldn&rsquo;t parse
parse_int(&lsquo;42&rsquo;)
Couldn&rsquo;t parse</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>

<p>```
def parse_int(s):</p>

<pre><code>try:
    n = int(v)
except Exception as e:
    print("Couldn't parse")
    print('Reason:', e)
</code></pre>

<p>```</p>

<p>这时候你能获取如下输出，指明了有个编程错误：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>parse_int(&lsquo;42&rsquo;)
Couldn&rsquo;t parse
Reason: global name &lsquo;v&rsquo; is not defined</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>很明显，你应该尽可能将异常处理器定义的精准一些。</p>

<p>不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>

<h4>最可怕的例子是我们在处理临时文件的时候，用</h4>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>因为碍人的E722, 有人会自作聪明的改成:</p>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except Exception:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>正确的办法是:</p>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except BaseException:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>或者更确定的语义之下，每次都清理临时文件，这样更明确，处理更好一点:
```
try:</p>

<pre><code>....
</code></pre>

<p>except BaseException:</p>

<pre><code>logger.error(....)
</code></pre>

<p>finally:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>参考:</p>

<p><a href="https://github.com/PyCQA/pycodestyle/issues/703">https://github.com/PyCQA/pycodestyle/issues/703</a></p>

<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go包管理工具]]></title>
    <link href="https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju/"/>
    <updated>2019-05-01T15:25:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju</id>
    <content type="html"><![CDATA[<p>真的，Go的包管理工具之发展过程充分体现了什么叫<code>折腾</code>。 (叹气~~~)</p>

<!-- more -->


<p>想想Java的Maven， Nodejs的NPM，还有我们赞颂一万遍也不过分的Python包管理，为什么生命总要浪费在这些事情上面呢？ 陷入了深深的沉思~~</p>

<p>从Go1.11版本发布Go MODULE之后，我希望这是最后一次折腾<code>包管理</code>这件事情，神呐，诚心诚意的祈祷中~~</p>

<p>摘抄备忘下：</p>

<h2>GO111MODULE</h2>

<p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。
按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，GO111MODULE 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p>

<ul>
<li><p>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</p></li>
<li><p>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</p></li>
<li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:

<ul>
<li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li>
<li>当前目录位于包含 go.mod 文件的目录下</li>
</ul>
</li>
</ul>


<h2>go mod 命令</h2>

<p><code>
download    download modules to local cache (下载依赖的 modules 到本地 cache)
edit        edit go.mod from tools or scripts (编辑 go.mod 文件)
graph       print module requirement graph (打印模块依赖图)
init        initialize new module in current directory (再当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)
vendor      make vendored copy of dependencies (将依赖复制到 vendor 下)
verify      verify dependencies have expected content (校验依赖)
why         explain why packages or modules are needed (解释为什么需要依赖)
</code></p>

<h2>既有项目</h2>

<p>假设你已经有了一个 go 项目， 比如在$GOPATH/github.com/memoryboxes/hello下， 你可以使用go mod init github.com/memoryboxes/hello在这个文件夹下创建一个空的 go.mod (只有第一行 module github.com/memoryboxes/hello)。</p>

<p>然后你可以通过 go get ./&hellip;让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 -tags, 这样可以把 tags 的依赖都查找到)。</p>

<p>通过go mod tidy也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理tags。</p>

<p>执行上面的命令会把 go.mod 的latest版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p>

<h2>replace</h2>

<p>在国内访问golang.org/x的各个包都需要梯子，你可以在 go.mod 中使用replace替换成 github 上对应的库。</p>

<p><code>
replace (
  golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
  golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
  golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
)
</code>
依赖库中的replace对你的主 go.mod 不起作用，比如github.com/memoryboxes/hello的 go.mod 已经增加了replace, 但是你的 go.mod 虽然require了rpcx的库，但是没有设置replace的话， go get还是会访问golang.org/x。</p>

<p>所以如果想编译哪个项目，就在哪个项目中增加replace。</p>

<h2>包的版本控制</h2>

<p>下面的版本都是合法的：</p>

<p><code>
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
gopkg.in/vmihailenco/msgpack.v2 v2.9.1
gopkg.in/yaml.v2 &lt;=v2.2.1
github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
latest
</code>
版本号遵循如下规律：</p>

<p><code>
vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
vX.0.0-yyyymmddhhmmss-abcdefabcdef
vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
vX.Y.Z
</code>
也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p>

<p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p>

<h2>go get 升级</h2>

<ul>
<li>运行 go get -u 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li>
<li>运行 go get -u=patch 将会升级到最新的修订版本</li>
<li>运行 go get package@version 将会升级到指定的版本号version</li>
</ul>


<h2>go modules 与 vendor</h2>

<ul>
<li><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p></li>
<li><p>Go modules 支持通过go mod vendor命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用go build -mod=vendor即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p></li>
</ul>


<h2>参考:</h2>

<p><a href="https://roberto.selbach.ca/intro-to-go-modules/">https://roberto.selbach.ca/intro-to-go-modules/</a></p>

<p><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p>

<p><a href="https://windmt.com/2018/11/08/first-look-go-modules/">https://windmt.com/2018/11/08/first-look-go-modules/</a></p>
]]></content>
  </entry>
  
</feed>
