<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-08-18T15:40:36+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为Flask RestAPI集成Swagger UI]]></title>
    <link href="https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui/"/>
    <updated>2019-08-18T15:38:02+08:00</updated>
    <id>https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui</id>
    <content type="html"><![CDATA[<p>在我的一台服务器被数不清的脚本小子暴力尝试登陆N次后，我下定决心将所有的开发环境换成统一的ssh key；并禁止用户登陆；</p>

<p>其中最折腾的部分就是使用我的GPG Key统一所有的ssh 环境；我也很纳闷，为什么自己没有早点搞定这些事情；</p>

<p>众所周知，GPG和Openssl的key是不兼容的，所以统一环境还是花了不少时间，主要是参考了这篇文章：</p>

<p><a href="https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth">https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth</a></p>

<p>常用命令:</p>

<!-- more -->


<h3>GPG</h3>

<ul>
<li><p>生成证书
<code>
gpg --gen-key
</code></p></li>
<li><p>生成撤销证书</p></li>
</ul>


<p><code>
gpg --gen-revoke [用户ID]
</code></p>

<ul>
<li>列出所有密钥
<code>
gpg --list-keys
</code></li>
</ul>


<p>输出
```</p>

<h2>/home/brain/.gnupg/pubring.gpg</h2>

<p>pub   4096R/3ED25428 2019-08-16
uid                  brain.zhang (happy123.me) <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#98;&#x72;&#97;&#x69;&#110;&#x2e;&#122;&#x68;&#97;&#110;&#103;&#x62;&#105;&#x6e;&#64;&#x6f;&#x75;&#116;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#x6f;&#109;">&#98;&#114;&#x61;&#105;&#x6e;&#46;&#122;&#104;&#x61;&#110;&#x67;&#98;&#105;&#x6e;&#64;&#111;&#x75;&#116;&#x6c;&#x6f;&#111;&#107;&#x2e;&#x63;&#x6f;&#x6d;</a>
sub   4096R/F60CBF88 2019-08-16
```</p>

<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示"用户ID"，第四行显示subkey。</p>

<ul>
<li>输出密钥</li>
</ul>


<p><code>
gpg --armor --output public-key.txt --export [用户ID]
</code></p>

<ul>
<li><p>输出密钥时转换私钥
<code>
gpg --armor --output private-key.txt --export-secret-keys
</code></p></li>
<li><p>上传公钥
<code>
gpg --keyserver keys.gnupg.net --send-keys [pub key ID]
...
gpg --keyserver keys.gnupg.net --search-keys brain.zhang
</code></p></li>
<li><p>生成公钥指纹供别人检查
<code>
gpg --fingerprint [用户ID]
</code></p></li>
<li><p>加密文件
<code>
gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt
</code></p></li>
<li><p>解密文件
<code>
gpg --decrypt demo.en.txt --output demo.de.txt
</code></p></li>
<li><p>对文件签名
<code>
gpg --clearsign demo.txt
</code></p></li>
<li><p>获得单独的签名文件
<code>
gpg --armor --detach-sign demo.txt
</code></p></li>
<li><p>验证签名
<code>
gpg --verify demo.txt.asc demo.txt
</code></p></li>
</ul>


<h3>导入第三方公钥</h3>

<ul>
<li><p>获得公钥
<code>
gpg --keyserver keys.gnupg.net --search-keys &lt;user ID&gt;
...
gpg --keyserver hkp://subkeys.pgp.net --search-keys brain.zhang
</code></p></li>
<li><p>验证公钥
```
gpg &mdash;edit-key <key ID></p></li>
</ul>


<p><code>``
你可以键入</code>fpr<code>来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入</code>trust` 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入quit 退出。</p>

<h3>在Github中使用GPG</h3>

<ul>
<li><p>输出key id
<code>
gpg --list-secret-keys --keyid-format LONG
</code></p></li>
<li><p>设置提交
```
git config  user.signingkey <key ID></p></li>
</ul>


<p>```</p>

<ul>
<li><p>对单次提交进行签名：
<code>
git commit -S -m "-S选项表示对此次提交使用gpg进行签名"
</code></p></li>
<li><p>签名标签
<code>
git tag -s &lt;tag&gt;
</code></p></li>
</ul>


<h3>ssh server gen</h3>

<ul>
<li><p>制作密钥对
<code>
[root@host ~]$ ssh-keygen
</code></p></li>
<li><p>把生成的/root/.ssh/id_rsa.pub拷贝到在服务器上，安装公钥
<code>
[root@host ~]$ cd .ssh
[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys
[root@host .ssh]$ chmod 600 authorized_keys
[root@host .ssh]$ chmod 700 ~/.ssh
</code></p></li>
<li><p>设置 SSHD，打开密钥登录功能
编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p></li>
</ul>


<p><code>
PubkeyAuthentication yes
PermitRootLogin yes
</code></p>

<ul>
<li>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</li>
</ul>


<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>

<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>

<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection &ndash;> SSH &ndash;> Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>

<ul>
<li>验证无误，关闭密码登陆
<code>
PasswordAuthentication no
[root@host .ssh]$ service sshd restart
</code></li>
</ul>


<h3>综合例子</h3>

<p>最后，在github上面有个集大成的例子,值得推荐</p>

<p><a href="https://github.com/frol/flask-restplus-server-example">https://github.com/frol/flask-restplus-server-example</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Requests Post for 5 Styles]]></title>
    <link href="https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles/"/>
    <updated>2019-08-09T09:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles</id>
    <content type="html"><![CDATA[<h4>requests库发送post请求的五种姿势;</h4>

<!-- more -->


<h4>1.application/x-www-form-urlencoded</h4>

<p>最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。请求类似于下面这样:</p>

<p><code>
POST http://www.example.com HTTP/1.1    Content-Type:
application/x-www-form-urlencoded;charset=utf-8
title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3
</code></p>

<p>requests默认处理就是这种方式， exp:</p>

<p><code>
url = 'http://httpbin.org/post'
d = {'key1': 'value1', 'key2': 'value2'}
r = requests.post(url, data=d)
print r.text
</code></p>

<h4>2.multipart/form-data</h4>

<p>除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。
这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值:</p>

<p>requests exp:
```
from requests_toolbelt import MultipartEncoder
import requests</p>

<p>m = MultipartEncoder(</p>

<pre><code>fields={'field0': 'value', 'field1': 'value',
        'field2': ('filename', open('file.py', 'rb'), 'text/plain')}
)
</code></pre>

<p>r = requests.post(&lsquo;<a href="http://httpbin.org/post">http://httpbin.org/post</a>&rsquo;, data=m,</p>

<pre><code>              headers={'Content-Type': m.content_type})
</code></pre>

<p>```</p>

<h4>3.application/json</h4>

<p>application/json 这个 Content-Type作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>

<p>requests exp:
<code>
url = 'http://httpbin.org/post'
s = json.dumps({'key1': 'value1', 'key2': 'value2'})
r = requests.post(url, data=s)
print r.text
</code></p>

<p>or
<code>
requests.post(url='',data=json.dumps({'key1':'value1','key2':'value2'}),headers={'Content-Type':'application/json'})
</code></p>

<p>or</p>

<p><code>
requests.post(url='',json=key1,headers={'Content-Type':'application/json'})
</code></p>

<h4>4. text/xml</h4>

<p>跟json类似，XML 作为编码方式的远程调用规范。</p>

<p>requests exp:
<code>
requests.post(url='',data='&lt;?xml  ?&gt;',headers={'Content-Type':'text/xml'})
</code></p>

<h4>5. binary</h4>

<p>直接二进制流数据传输，多用于上传图片</p>

<p>requests exp:</p>

<p><code>
requests.post(url='',files={'file':open('test.xls','rb')},headers={'Content-Type':'binary'})
</code></p>

<p>or</p>

<p><code>
url = 'http://httpbin.org/post'
files = {'file': open('report.txt', 'rb')}
r = requests.post(url, files=files)
print r.text
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSL&TLS Tips]]></title>
    <link href="https://happy123.me/blog/2019/08/04/ssl-tls-tips/"/>
    <updated>2019-08-04T09:35:42+08:00</updated>
    <id>https://happy123.me/blog/2019/08/04/ssl-tls-tips</id>
    <content type="html"><![CDATA[<p>每天的日常编码工作：就是解决一个问题的时候再创造另外一个问题 Orz&hellip;..</p>

<p>话说刚才生成一个私钥的时候， Python3绑定libssl1.1 又崩了；正在痛苦思考中~~~</p>

<!-- more -->


<p>现在有两个选择:</p>

<ol>
<li>放弃ssl动态库调用，反正我只用ECDSA，所以找个原生库来用好啦</li>
<li>死磕openssl，把它彻底搞明白</li>
</ol>


<p>利弊权衡之下我选择了1，不过当然我也在2上花了一点时间，复习了一下基础知识，在此记录下来。</p>

<h3>libssl3是个什么东东</h3>

<p>在探究libssl.so的时候，我无意发现我的系统里面还有一个libssl3.so；这个是什么东东？我印象里面openssl还只有1.x版本才对；</p>

<p>我在ubuntu16.04下查看这个so文件来源;</p>

<p><code>
~ locate libssl3.so
/usr/lib/x86_64-linux-gnu/libssl3.so
</code></p>

<p>nm看一下:</p>

<p>```
~ nm /usr/lib/x86_64-linux-gnu/libssl3.so
nm: /usr/lib/x86_64-linux-gnu/libssl3.so: no symbols</p>

<p>```</p>

<p>奇怪，没有任何符号；继续用ldd看一下：</p>

<p>```
~ ldd /usr/lib/x86_64-linux-gnu/libssl3.so
ldd /usr/lib/x86_64-linux-gnu/libssl3.so</p>

<pre><code>    linux-vdso.so.1 =&gt;  (0x00007ffe833bb000)
    libnss3.so =&gt; /usr/lib/x86_64-linux-gnu/libnss3.so (0x00007faf3cc8a000)
    libnssutil3.so =&gt; /usr/lib/x86_64-linux-gnu/libnssutil3.so (0x00007faf3ca5d000)
    libplc4.so =&gt; /usr/lib/x86_64-linux-gnu/libplc4.so (0x00007faf3c858000)
    libnspr4.so =&gt; /usr/lib/x86_64-linux-gnu/libnspr4.so (0x00007faf3c619000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf3c3fc000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf3c032000)
    libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007faf3be18000)
    libplds4.so =&gt; /usr/lib/x86_64-linux-gnu/libplds4.so (0x00007faf3bc14000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf3ba10000)
    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007faf3b808000)
    /lib64/ld-linux-x86-64.so.2 (0x00007faf3d21d000)
</code></pre>

<p>```</p>

<p>嗯，找到了一个有意思的依赖:libnss3.so</p>

<p>再用命令dpkg看一下</p>

<p><code>
~ dpkg -S /usr/lib/x86_64-linux-gnu/libnss3.so
libnss3:amd64: /usr/lib/x86_64-linux-gnu/libnss3.so
</code></p>

<p>基本上确定是libnss3这个库引入的libssl3.so了，最后再用dpkg确认一下:</p>

<p><code>
~ dpkg-query -L libnss3
/.
/usr
/usr/lib
/usr/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu/libnssutil3.so
/usr/lib/x86_64-linux-gnu/nss
/usr/lib/x86_64-linux-gnu/nss/libfreebl3.chk
/usr/lib/x86_64-linux-gnu/nss/libnssckbi.so
/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.so
/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.chk
/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.chk
/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.so
/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.chk
/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.so
/usr/lib/x86_64-linux-gnu/nss/libfreebl3.so
/usr/lib/x86_64-linux-gnu/nss/libnsssysinit.so
/usr/lib/x86_64-linux-gnu/libsmime3.so
/usr/lib/x86_64-linux-gnu/libnss3.so
/usr/lib/x86_64-linux-gnu/libssl3.so
/usr/share
/usr/share/doc
/usr/share/doc/libnss3
/usr/share/doc/libnss3/copyright
/usr/share/doc/libnss3/changelog.Debian.gz
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/libnss3
</code></p>

<h3>libnss3是个什么东东?</h3>

<p><code>
apt-cache show libnss3
</code></p>

<p>看了一下，发现是mozilla基金会搞得东东；再google一下，发现是自己孤陋寡闻了；</p>

<p>原来，SSL&amp;TSL的实现，不只是openssl一家独大，像Mozilla Firefox就用自家实现的Nss；</p>

<p>Google Chrome之前也是用Nss的，后来迁移到了openssl，再后来，2014年，openssl1.0.1出现了heartbeat 漏洞，Google干脆自己开了个分支，用自己定制的openssl了；</p>

<p>至于Windows平台的，还有C++阵营的，都有自己实现的ssl库，具体可参见:</p>

<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</a></p>

<h3>nss在centos中</h3>

<p>搜素的过程中，我惊奇的发现，ubuntu和centos上面的curl，竟然链接的libssl也不一样：</p>

<p>ubuntu上的curl默认链接的是openssl，而centos上面默认链接的是libnss3；</p>

<p>耐人寻味啊，莫非redhat系的人发现了什么~~~~</p>

<p>做事要做全套，我分别切换到ubuntu16.04和centos7.2上面，看看他们官方仓库中自带的curl是如何编译的。</p>

<h4>centos7.2</h4>

<p><code>
~ rpm -q --requires curl
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.17)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libcurl = 7.29.0-51.el7
libcurl.so.4()(64bit)
libdl.so.2()(64bit)
libnspr4.so()(64bit)
libnss3.so()(64bit)
libnssutil3.so()(64bit)
libplc4.so()(64bit)
libplds4.so()(64bit)
libpthread.so.0()(64bit)
libpthread.so.0(GLIBC_2.2.5)(64bit)
libsmime3.so()(64bit)
libssl3.so()(64bit)
libz.so.1()(64bit)
rpmlib(CompressedFileNames) &lt;= 3.0.4-1
rpmlib(FileDigests) &lt;= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
rtld(GNU_HASH)
rpmlib(PayloadIsXz) &lt;= 5.2-1
</code>
用的是libcurl = 7.29.0-51.el7；</p>

<p>```
~ rpm -q &mdash;requires libcurl
/sbin/ldconfig
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.15)(64bit)
libc.so.6(GLIBC_2.16)(64bit)
libc.so.6(GLIBC_2.17)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.3.4)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libcom_err.so.2()(64bit)
libdl.so.2()(64bit)
libgssapi_krb5.so.2()(64bit)
libgssapi_krb5.so.2(gssapi_krb5_2_MIT)(64bit)
libidn.so.11()(64bit)
libidn.so.11(LIBIDN_1.0)(64bit)
libk5crypto.so.3()(64bit)
libkrb5.so.3()(64bit)
liblber-2.4.so.2()(64bit)
libldap-2.4.so.2()(64bit)
libnspr4.so()(64bit)
libnss3.so()(64bit)
libnss3.so(NSS_3.10)(64bit)
libnss3.so(NSS_3.12.1)(64bit)
libnss3.so(NSS_3.12.5)(64bit)
libnss3.so(NSS_3.2)(64bit)</p>

<p>&hellip;.
<code>
看到libnss3了,重点输出：
</code>
libnss3.so
```
那么这个包是谁提供的？输入如下命令：</p>

<p>```
~ rpm -qf /usr/lib64/libnss3.so</p>

<pre><code>nss-3.36.0-7.1.el7_6.x86_64
</code></pre>

<p>~ rpm -ql nss
/etc/pki/nss-legacy
/etc/pki/nss-legacy/nss-rhel7.config
/etc/pki/nssdb
/etc/pki/nssdb/cert8.db
/etc/pki/nssdb/cert9.db
/etc/pki/nssdb/key3.db
/etc/pki/nssdb/key4.db
/etc/pki/nssdb/pkcs11.txt
/etc/pki/nssdb/secmod.db
/usr/lib64/libnss3.so
/usr/lib64/libnssckbi.so
/usr/lib64/libsmime3.so
/usr/lib64/libssl3.so
/usr/lib64/nss/libnssckbi.so
&hellip;
```
至此水落石出，还可以看到我们熟悉的证书cert8.db文件；但其实 curl 最终使用的根证书库并不是该文件。那 curl 使用的根证书文件在哪儿呢？</p>

<p>使用 curl-config 命令行工具，能够了解更多：
<code>
~ curl-config --ca                        
/etc/pki/tls/certs/ca-bundle.crt
</code></p>

<h4>ubuntu16.04</h4>

<p>ubuntu16上面验证类似，不一一说明了~~~</p>

<p>```
~ dpkg-query -L libcurl3
/.
/usr
/usr/share
/usr/share/doc
/usr/share/doc/libcurl3
/usr/share/doc/libcurl3/copyright
/usr/share/doc/libcurl3/changelog.Debian.gz
/usr/share/doc/libcurl3/NEWS.Debian.gz
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/libcurl3
/usr/lib
/usr/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0
/usr/lib/x86_64-linux-gnu/libcurl.so.3
/usr/lib/x86_64-linux-gnu/libcurl.so.4</p>

<p>```</p>

<p><code>
~ apt-cache depends  libcurl3
  Depends: libc6
  Depends: libgssapi-krb5-2
  Depends: libidn11
  Depends: libldap-2.4-2
  Depends: librtmp1
  Depends: libssl1.0.0
  Depends: zlib1g
  Recommends: ca-certificates
</code></p>

<p>然后寻找libcurl的依赖库:</p>

<p><code>
~ ldd /usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0|grep ssl
libssl.so.1.0.0 =&gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fbdf8aa0000)
</code></p>

<p>验证一下:</p>

<p>```
~ apt-cache depends openssl
openssl
  Depends: libc6
  Depends: libssl1.0.0
  Suggests: ca-certificates</p>

<p>~ apt-cache rdepends  libssl1.0.0 | grep curl
  libcurl3<br/>
```</p>

<h3>总结</h3>

<p>所以这就是想要解决一个问题的中途，又被带到了另外一条小路上；该说我是还有那么一点好奇心呢？还是注意力不集中呢？</p>

<p>Orz&hellip;&hellip;&hellip;</p>

<h3>参考资料:</h3>

<p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</a></p>

<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E">https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</a></p>

<p><a href="https://www.lbbniu.com/6680.html">https://www.lbbniu.com/6680.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->


<p>```
import ctypes
import logging</p>

<p>try:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</code></pre>

<p>except Exception:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</code></pre>

<p>def check_result(val, func, args):</p>

<pre><code>if val == 0:
    raise ValueError
else:
    return ctypes.c_void_p(val)
</code></pre>

<h1>ssl_library.EC_KEY_new.restype = ctypes.c_void_p</h1>

<p>ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result</p>

<p>k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)</p>

<p>if ssl_library.EC_KEY_generate_key(k) != 1:</p>

<pre><code>raise Exception("internal error")
</code></pre>

<p>ssl_library.EC_KEY_free(k)</p>

<p>```</p>

<p>这段代码在多线程的时候会出现segmentation fault error； google一下发现<code>EC_KEY_generate_key</code>并不是线程安全的；于是:</p>

<p>```
openssl_locks = [threading.Lock() for _ in range(ssl_library.CRYPTO_num_locks())]
openssl_locking_function = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_int, ctypes.c_char_p, ctypes.c_int)
openssl_threadid_function = ctypes.CFUNCTYPE(ctypes.c_ulong)</p>

<p>@openssl_locking_function
def openssl_lock(mode, type, file, line):</p>

<pre><code>if (mode &amp; CRYPTO_LOCK) != 0:
    openssl_locks[type].acquire()
else:
    openssl_locks[type].release()
</code></pre>

<p>@openssl_threadid_function
def openssl_threadid():</p>

<pre><code>v = threading.current_thread().ident
return v
</code></pre>

<p>ssl_library.CRYPTO_set_id_callback(openssl_threadid)
ssl_library.CRYPTO_set_locking_callback(openssl_lock)
```</p>

<p>诡异的是还是不定时的crash掉，又一通google之后发现是openssl1.0.0的实现问题，参考:</p>

<p><a href="https://bugs.python.org/issue29340">https://bugs.python.org/issue29340</a></p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒容器技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->


<h2>文档操作</h2>

<h4>增加一条记录</h4>

<p><code>
PUT /website/_doc/1
{
  "title": "My 2 blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}
</code></p>

<h4>修改</h4>

<p>```
POST /website/_update/1
{
   &ldquo;doc&rdquo; : {</p>

<pre><code>  "tags" : [ "testing..." ],
  "views": 0
</code></pre>

<p>   }
}
```</p>

<h4>查询</h4>

<p>```
GET /website/_search</p>

<p>GET /website/_source/1</p>

<p>GET /website/_mget
{</p>

<pre><code>"ids" : [ "2", "1" ]    
</code></pre>

<p>}</p>

<p>GET /_search
{</p>

<pre><code>"query": YOUR_QUERY_HERE
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /website/_doc/1
</code></p>

<h2>文档功能API</h2>

<h4>获取映射信息</h4>

<p><code>
GET /website/_mapping
</code></p>

<h4>测试分析器</h4>

<p><code>
GET /website/_analyze
{
  "field": "tweet",
  "text": "Black-cats"
}
</code></p>

<h4>多层级对象用扁平化的方法来存储，比如</h4>

<p>```
{
  &ldquo;gb&rdquo;: {</p>

<pre><code>"tweet": { 
  "properties": {
    "tweet":            { "type": "string" },
    "user": { 
      "type":             "object",
      "properties": {
        "id":           { "type": "string" },
        "gender":       { "type": "string" },
        "age":          { "type": "long"   },
        "name":   { 
          "type":         "object",
          "properties": {
            "full":     { "type": "string" },
            "first":    { "type": "string" },
            "last":     { "type": "string" }
          }
        }
      }
    }
  }
}
</code></pre>

<p>  }
}</p>

<p>```
会被转换为如下内部对象:</p>

<p>```
{</p>

<pre><code>"tweet":            [elasticsearch, flexible, very],
"user.id":          [@johnsmith],
"user.gender":      [male],
"user.age":         [26],
"user.name.full":   [john, smith],
"user.name.first":  [john],
"user.name.last":   [smith]
</code></pre>

<p>}
```</p>

<h4>内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2>查询</h2>

<h4>查询语句的结构</h4>

<ul>
<li><p>一个查询语句 的典型结构：
<code>
{
  QUERY_NAME: {
      ARGUMENT: VALUE,
      ARGUMENT: VALUE,...
  }
}
</code></p></li>
<li><p>如果是针对某个字段，那么它的结构如下：
<code>
{
  QUERY_NAME: {
      FIELD_NAME: {
          ARGUMENT: VALUE,
          ARGUMENT: VALUE,...
      }
  }
}
</code></p></li>
<li><p>一条复合语句
<code>
{
  "bool": {
      "must": { "match":   { "email": "business opportunity" }},
      "should": [
          { "match":       { "starred": true }},
          { "bool": {
              "must":      { "match": { "folder": "inbox" }},
              "must_not":  { "match": { "spam": true }}
          }}
      ],
      "minimum_should_match": 1
  }
}
</code></p></li>
</ul>


<h4>实战查询</h4>

<ul>
<li><p>精确查询
<code>
GET /website/_search
{
"query": {
  "constant_score" : {
    "filter":{
      "term": {
        "title": "helloworld"
      }
    }
  }
}
}
</code></p></li>
<li><p>多词组合
<code>
GET /website/_search
{
  "query": {
      "match": {
          "title": {      
              "query":    "BROWN DOG!",
              "operator": "and"
          }
      }
  }
}
</code></p></li>
<li><p>短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": "quick brown fox"
      }
  }
}
</code></p></li>
<li><p>混合短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": {
              "query": "quick fox",
              "slop":  1
          }
      }
  }
}
</code></p></li>
<li><p>正则查询 (性能慢)
<code>
GET /my_index/_search
{
  "query": {
      "wildcard": {
          "postcode": "W?F*HW"
      }
  }
}
</code></p></li>
<li><p>智能匹配
<code>
GET /my_index/_search
{
  "query": {
      "match_phrase_prefix" : {
          "brand" : {
              "query":          "johnnie walker bl",
              "max_expansions": 50
              }
      }
  }
}
</code></p></li>
<li><p>控制精度
```
GET /website/_search
{
&ldquo;query&rdquo;: {
  &ldquo;match&rdquo;: {
    &ldquo;title&rdquo;: {
      &ldquo;query&rdquo;:                &ldquo;quick brown dog&rdquo;,
      &ldquo;minimum_should_match&rdquo;: &ldquo;75%&rdquo;
    }
  }
}
}</p></li>
</ul>


<p>GET /website/_search
{
  &ldquo;query&rdquo;: {</p>

<pre><code>"bool": {
  "should": [
    { "match": { "title": "brown" }},
    { "match": { "title": "fox"   }},
    { "match": { "title": "dog"   }}
  ],
  "minimum_should_match": 2 
}
</code></pre>

<p>  }
}
```</p>

<ul>
<li>按受欢迎度提升权重
```
GET /blogposts/post/_search
{
&ldquo;query&rdquo;: {
  &ldquo;function_score&rdquo;: {
    &ldquo;query&rdquo;: {
      &ldquo;multi_match&rdquo;: {
        &ldquo;query&rdquo;:    &ldquo;popularity&rdquo;,
        &ldquo;fields&rdquo;: [ &ldquo;title&rdquo;, &ldquo;content&rdquo; ]
      }
    },
    &ldquo;field_value_factor&rdquo;: {
      &ldquo;field&rdquo;: &ldquo;votes&rdquo;
    }
  }
}
}</li>
</ul>


<p>微调:
<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html</a>
```</p>

<h4>排障</h4>

<p>```
GET /website/_validate/query?explain
{
   &ldquo;query&rdquo;: {</p>

<pre><code>  "match" : {
     "text" : "really powerful"
  }
</code></pre>

<p>   }
}
```</p>

<h4>结果排序</h4>

<p>```
GET /website/_search
{</p>

<pre><code>"query" : {
    "bool" : {
        "filter" : { "term" : { "_id" : 1 }}
    }
},
"sort": { "date": { "order": "desc" }}
</code></pre>

<p>}
```</p>

<h2>索引操作</h2>

<h4>增加</h4>

<p>```
PUT /my_index
{</p>

<pre><code>"settings": { ... any settings ... },
"mappings": {
    "type_one": { ... any mappings ... },
    "type_two": { ... any mappings ... },
    ...
}
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /my_index
DELETE /index_one,index_two
DELETE /index_*
DELETE /_all
</code></p>

<h4>配置</h4>

<ul>
<li>number_of_shards</li>
</ul>


<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
<li>number_of_replicas</li>
</ul>


<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4>重新索引</h4>

<p>```
POST _reindex
{
  &ldquo;source&rdquo;: {</p>

<pre><code>"index": "twitter"
</code></pre>

<p>  },
  &ldquo;dest&rdquo;: {</p>

<pre><code>"index": "new_twitter"
</code></pre>

<p>  }
}</p>

<p>```</p>

<h4>释放空间</h4>

<p><code>
POST /_all/_forcemerge?only_expunge_deletes=true
</code></p>
]]></content>
  </entry>
  
</feed>
