<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-08-09T09:14:19+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Requests Post for 5 Styles]]></title>
    <link href="https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles/"/>
    <updated>2019-08-09T09:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles</id>
    <content type="html"><![CDATA[<h4>requests库发送post请求的五种姿势;</h4>

<!-- more -->


<h4>1.application/x-www-form-urlencoded</h4>

<p>最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。请求类似于下面这样:</p>

<p><code>
POST http://www.example.com HTTP/1.1    Content-Type:
application/x-www-form-urlencoded;charset=utf-8
title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3
</code></p>

<p>requests默认处理就是这种方式， exp:</p>

<p><code>
url = 'http://httpbin.org/post'
d = {'key1': 'value1', 'key2': 'value2'}
r = requests.post(url, data=d)
print r.text
</code></p>

<h4>2.multipart/form-data</h4>

<p>除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。
这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值:</p>

<p>requests exp:
```
from requests_toolbelt import MultipartEncoder
import requests</p>

<p>m = MultipartEncoder(</p>

<pre><code>fields={'field0': 'value', 'field1': 'value',
        'field2': ('filename', open('file.py', 'rb'), 'text/plain')}
)
</code></pre>

<p>r = requests.post(&lsquo;<a href="http://httpbin.org/post">http://httpbin.org/post</a>&rsquo;, data=m,</p>

<pre><code>              headers={'Content-Type': m.content_type})
</code></pre>

<p>```</p>

<h4>3.application/json</h4>

<p>application/json 这个 Content-Type作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>

<p>requests exp:
<code>
url = 'http://httpbin.org/post'
s = json.dumps({'key1': 'value1', 'key2': 'value2'})
r = requests.post(url, data=s)
print r.text
</code></p>

<p>or
<code>
requests.post(url='',data=json.dumps({'key1':'value1','key2':'value2'}),headers={'Content-Type':'application/json'})
</code></p>

<p>or</p>

<p><code>
requests.post(url='',json=key1,headers={'Content-Type':'application/json'})
</code></p>

<h4>4. text/xml</h4>

<p>跟json类似，XML 作为编码方式的远程调用规范。</p>

<p>requests exp:
<code>
requests.post(url='',data='&lt;?xml  ?&gt;',headers={'Content-Type':'text/xml'})
</code></p>

<h4>5. binary</h4>

<p>直接二进制流数据传输，多用于上传图片</p>

<p>requests exp:</p>

<p><code>
requests.post(url='',files={'file':open('test.xls','rb')},headers={'Content-Type':'binary'})
</code></p>

<p>or</p>

<p><code>
url = 'http://httpbin.org/post'
files = {'file': open('report.txt', 'rb')}
r = requests.post(url, files=files)
print r.text
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSL&TLS Tips]]></title>
    <link href="https://happy123.me/blog/2019/08/04/ssl-tls-tips/"/>
    <updated>2019-08-04T09:35:42+08:00</updated>
    <id>https://happy123.me/blog/2019/08/04/ssl-tls-tips</id>
    <content type="html"><![CDATA[<p>每天的日常编码工作：就是解决一个问题的时候再创造另外一个问题 Orz&hellip;..</p>

<p>话说刚才生成一个私钥的时候， Python3绑定libssl1.1 又崩了；正在痛苦思考中~~~</p>

<!-- more -->


<p>现在有两个选择:</p>

<ol>
<li>放弃ssl动态库调用，反正我只用ECDSA，所以找个原生库来用好啦</li>
<li>死磕openssl，把它彻底搞明白</li>
</ol>


<p>利弊权衡之下我选择了1，不过当然我也在2上花了一点时间，复习了一下基础知识，在此记录下来。</p>

<h3>libssl3是个什么东东</h3>

<p>在探究libssl.so的时候，我无意发现我的系统里面还有一个libssl3.so；这个是什么东东？我印象里面openssl还只有1.x版本才对；</p>

<p>我在ubuntu16.04下查看这个so文件来源;</p>

<p><code>
~ locate libssl3.so
/usr/lib/x86_64-linux-gnu/libssl3.so
</code></p>

<p>nm看一下:</p>

<p>```
~ nm /usr/lib/x86_64-linux-gnu/libssl3.so
nm: /usr/lib/x86_64-linux-gnu/libssl3.so: no symbols</p>

<p>```</p>

<p>奇怪，没有任何符号；继续用ldd看一下：</p>

<p>```
~ ldd /usr/lib/x86_64-linux-gnu/libssl3.so
ldd /usr/lib/x86_64-linux-gnu/libssl3.so</p>

<pre><code>    linux-vdso.so.1 =&gt;  (0x00007ffe833bb000)
    libnss3.so =&gt; /usr/lib/x86_64-linux-gnu/libnss3.so (0x00007faf3cc8a000)
    libnssutil3.so =&gt; /usr/lib/x86_64-linux-gnu/libnssutil3.so (0x00007faf3ca5d000)
    libplc4.so =&gt; /usr/lib/x86_64-linux-gnu/libplc4.so (0x00007faf3c858000)
    libnspr4.so =&gt; /usr/lib/x86_64-linux-gnu/libnspr4.so (0x00007faf3c619000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf3c3fc000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf3c032000)
    libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007faf3be18000)
    libplds4.so =&gt; /usr/lib/x86_64-linux-gnu/libplds4.so (0x00007faf3bc14000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf3ba10000)
    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007faf3b808000)
    /lib64/ld-linux-x86-64.so.2 (0x00007faf3d21d000)
</code></pre>

<p>```</p>

<p>嗯，找到了一个有意思的依赖:libnss3.so</p>

<p>再用命令dpkg看一下</p>

<p><code>
~ dpkg -S /usr/lib/x86_64-linux-gnu/libnss3.so
libnss3:amd64: /usr/lib/x86_64-linux-gnu/libnss3.so
</code></p>

<p>基本上确定是libnss3这个库引入的libssl3.so了，最后再用dpkg确认一下:</p>

<p><code>
~ dpkg-query -L libnss3
/.
/usr
/usr/lib
/usr/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu/libnssutil3.so
/usr/lib/x86_64-linux-gnu/nss
/usr/lib/x86_64-linux-gnu/nss/libfreebl3.chk
/usr/lib/x86_64-linux-gnu/nss/libnssckbi.so
/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.so
/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.chk
/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.chk
/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.so
/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.chk
/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.so
/usr/lib/x86_64-linux-gnu/nss/libfreebl3.so
/usr/lib/x86_64-linux-gnu/nss/libnsssysinit.so
/usr/lib/x86_64-linux-gnu/libsmime3.so
/usr/lib/x86_64-linux-gnu/libnss3.so
/usr/lib/x86_64-linux-gnu/libssl3.so
/usr/share
/usr/share/doc
/usr/share/doc/libnss3
/usr/share/doc/libnss3/copyright
/usr/share/doc/libnss3/changelog.Debian.gz
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/libnss3
</code></p>

<h3>libnss3是个什么东东?</h3>

<p><code>
apt-cache show libnss3
</code></p>

<p>看了一下，发现是mozilla基金会搞得东东；再google一下，发现是自己孤陋寡闻了；</p>

<p>原来，SSL&amp;TSL的实现，不只是openssl一家独大，像Mozilla Firefox就用自家实现的Nss；</p>

<p>Google Chrome之前也是用Nss的，后来迁移到了openssl，再后来，2014年，openssl1.0.1出现了heartbeat 漏洞，Google干脆自己开了个分支，用自己定制的openssl了；</p>

<p>至于Windows平台的，还有C++阵营的，都有自己实现的ssl库，具体可参见:</p>

<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</a></p>

<h3>nss在centos中</h3>

<p>搜素的过程中，我惊奇的发现，ubuntu和centos上面的curl，竟然链接的libssl也不一样：</p>

<p>ubuntu上的curl默认链接的是openssl，而centos上面默认链接的是libnss3；</p>

<p>耐人寻味啊，莫非redhat系的人发现了什么~~~~</p>

<p>做事要做全套，我分别切换到ubuntu16.04和centos7.2上面，看看他们官方仓库中自带的curl是如何编译的。</p>

<h4>centos7.2</h4>

<p><code>
~ rpm -q --requires curl
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.17)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libcurl = 7.29.0-51.el7
libcurl.so.4()(64bit)
libdl.so.2()(64bit)
libnspr4.so()(64bit)
libnss3.so()(64bit)
libnssutil3.so()(64bit)
libplc4.so()(64bit)
libplds4.so()(64bit)
libpthread.so.0()(64bit)
libpthread.so.0(GLIBC_2.2.5)(64bit)
libsmime3.so()(64bit)
libssl3.so()(64bit)
libz.so.1()(64bit)
rpmlib(CompressedFileNames) &lt;= 3.0.4-1
rpmlib(FileDigests) &lt;= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
rtld(GNU_HASH)
rpmlib(PayloadIsXz) &lt;= 5.2-1
</code>
用的是libcurl = 7.29.0-51.el7；</p>

<p>```
~ rpm -q &mdash;requires libcurl
/sbin/ldconfig
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.15)(64bit)
libc.so.6(GLIBC_2.16)(64bit)
libc.so.6(GLIBC_2.17)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.3.4)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libcom_err.so.2()(64bit)
libdl.so.2()(64bit)
libgssapi_krb5.so.2()(64bit)
libgssapi_krb5.so.2(gssapi_krb5_2_MIT)(64bit)
libidn.so.11()(64bit)
libidn.so.11(LIBIDN_1.0)(64bit)
libk5crypto.so.3()(64bit)
libkrb5.so.3()(64bit)
liblber-2.4.so.2()(64bit)
libldap-2.4.so.2()(64bit)
libnspr4.so()(64bit)
libnss3.so()(64bit)
libnss3.so(NSS_3.10)(64bit)
libnss3.so(NSS_3.12.1)(64bit)
libnss3.so(NSS_3.12.5)(64bit)
libnss3.so(NSS_3.2)(64bit)</p>

<p>&hellip;.
<code>
看到libnss3了,重点输出：
</code>
libnss3.so
```
那么这个包是谁提供的？输入如下命令：</p>

<p>```
~ rpm -qf /usr/lib64/libnss3.so</p>

<pre><code>nss-3.36.0-7.1.el7_6.x86_64
</code></pre>

<p>~ rpm -ql nss
/etc/pki/nss-legacy
/etc/pki/nss-legacy/nss-rhel7.config
/etc/pki/nssdb
/etc/pki/nssdb/cert8.db
/etc/pki/nssdb/cert9.db
/etc/pki/nssdb/key3.db
/etc/pki/nssdb/key4.db
/etc/pki/nssdb/pkcs11.txt
/etc/pki/nssdb/secmod.db
/usr/lib64/libnss3.so
/usr/lib64/libnssckbi.so
/usr/lib64/libsmime3.so
/usr/lib64/libssl3.so
/usr/lib64/nss/libnssckbi.so
&hellip;
```
至此水落石出，还可以看到我们熟悉的证书cert8.db文件；但其实 curl 最终使用的根证书库并不是该文件。那 curl 使用的根证书文件在哪儿呢？</p>

<p>使用 curl-config 命令行工具，能够了解更多：
<code>
~ curl-config --ca                        
/etc/pki/tls/certs/ca-bundle.crt
</code></p>

<h4>ubuntu16.04</h4>

<p>ubuntu16上面验证类似，不一一说明了~~~</p>

<p>```
~ dpkg-query -L libcurl3
/.
/usr
/usr/share
/usr/share/doc
/usr/share/doc/libcurl3
/usr/share/doc/libcurl3/copyright
/usr/share/doc/libcurl3/changelog.Debian.gz
/usr/share/doc/libcurl3/NEWS.Debian.gz
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/libcurl3
/usr/lib
/usr/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0
/usr/lib/x86_64-linux-gnu/libcurl.so.3
/usr/lib/x86_64-linux-gnu/libcurl.so.4</p>

<p>```</p>

<p><code>
~ apt-cache depends  libcurl3
  Depends: libc6
  Depends: libgssapi-krb5-2
  Depends: libidn11
  Depends: libldap-2.4-2
  Depends: librtmp1
  Depends: libssl1.0.0
  Depends: zlib1g
  Recommends: ca-certificates
</code></p>

<p>然后寻找libcurl的依赖库:</p>

<p><code>
~ ldd /usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0|grep ssl
libssl.so.1.0.0 =&gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fbdf8aa0000)
</code></p>

<p>验证一下:</p>

<p>```
~ apt-cache depends openssl
openssl
  Depends: libc6
  Depends: libssl1.0.0
  Suggests: ca-certificates</p>

<p>~ apt-cache rdepends  libssl1.0.0 | grep curl
  libcurl3<br/>
```</p>

<h3>总结</h3>

<p>所以这就是想要解决一个问题的中途，又被带到了另外一条小路上；该说我是还有那么一点好奇心呢？还是注意力不集中呢？</p>

<p>Orz&hellip;&hellip;&hellip;</p>

<h3>参考资料:</h3>

<p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</a></p>

<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E">https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</a></p>

<p><a href="https://www.lbbniu.com/6680.html">https://www.lbbniu.com/6680.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->


<p>```
import ctypes
import logging</p>

<p>try:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</code></pre>

<p>except Exception:</p>

<pre><code>ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</code></pre>

<p>def check_result(val, func, args):</p>

<pre><code>if val == 0:
    raise ValueError
else:
    return ctypes.c_void_p(val)
</code></pre>

<h1>ssl_library.EC_KEY_new.restype = ctypes.c_void_p</h1>

<p>ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result</p>

<p>k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)</p>

<p>if ssl_library.EC_KEY_generate_key(k) != 1:</p>

<pre><code>raise Exception("internal error")
</code></pre>

<p>ssl_library.EC_KEY_free(k)</p>

<p>```</p>

<p>这段代码在多线程的时候会出现segmentation fault error； google一下发现<code>EC_KEY_generate_key</code>并不是线程安全的；于是:</p>

<p>```
openssl_locks = [threading.Lock() for _ in range(ssl_library.CRYPTO_num_locks())]
openssl_locking_function = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_int, ctypes.c_char_p, ctypes.c_int)
openssl_threadid_function = ctypes.CFUNCTYPE(ctypes.c_ulong)</p>

<p>@openssl_locking_function
def openssl_lock(mode, type, file, line):</p>

<pre><code>if (mode &amp; CRYPTO_LOCK) != 0:
    openssl_locks[type].acquire()
else:
    openssl_locks[type].release()
</code></pre>

<p>@openssl_threadid_function
def openssl_threadid():</p>

<pre><code>v = threading.current_thread().ident
return v
</code></pre>

<p>ssl_library.CRYPTO_set_id_callback(openssl_threadid)
ssl_library.CRYPTO_set_locking_callback(openssl_lock)
```</p>

<p>诡异的是还是不定时的crash掉，又一通google之后发现是openssl1.0.0的实现问题，参考:</p>

<p><a href="https://bugs.python.org/issue29340">https://bugs.python.org/issue29340</a></p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒LXC技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->


<h2>文档操作</h2>

<h4>增加一条记录</h4>

<p><code>
PUT /website/_doc/1
{
  "title": "My 2 blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}
</code></p>

<h4>修改</h4>

<p>```
POST /website/_update/1
{
   &ldquo;doc&rdquo; : {</p>

<pre><code>  "tags" : [ "testing..." ],
  "views": 0
</code></pre>

<p>   }
}
```</p>

<h4>查询</h4>

<p>```
GET /website/_search</p>

<p>GET /website/_source/1</p>

<p>GET /website/_mget
{</p>

<pre><code>"ids" : [ "2", "1" ]    
</code></pre>

<p>}</p>

<p>GET /_search
{</p>

<pre><code>"query": YOUR_QUERY_HERE
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /website/_doc/1
</code></p>

<h2>文档功能API</h2>

<h4>获取映射信息</h4>

<p><code>
GET /website/_mapping
</code></p>

<h4>测试分析器</h4>

<p><code>
GET /website/_analyze
{
  "field": "tweet",
  "text": "Black-cats"
}
</code></p>

<h4>多层级对象用扁平化的方法来存储，比如</h4>

<p>```
{
  &ldquo;gb&rdquo;: {</p>

<pre><code>"tweet": { 
  "properties": {
    "tweet":            { "type": "string" },
    "user": { 
      "type":             "object",
      "properties": {
        "id":           { "type": "string" },
        "gender":       { "type": "string" },
        "age":          { "type": "long"   },
        "name":   { 
          "type":         "object",
          "properties": {
            "full":     { "type": "string" },
            "first":    { "type": "string" },
            "last":     { "type": "string" }
          }
        }
      }
    }
  }
}
</code></pre>

<p>  }
}</p>

<p>```
会被转换为如下内部对象:</p>

<p>```
{</p>

<pre><code>"tweet":            [elasticsearch, flexible, very],
"user.id":          [@johnsmith],
"user.gender":      [male],
"user.age":         [26],
"user.name.full":   [john, smith],
"user.name.first":  [john],
"user.name.last":   [smith]
</code></pre>

<p>}
```</p>

<h4>内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2>查询</h2>

<h4>查询语句的结构</h4>

<ul>
<li><p>一个查询语句 的典型结构：
<code>
{
  QUERY_NAME: {
      ARGUMENT: VALUE,
      ARGUMENT: VALUE,...
  }
}
</code></p></li>
<li><p>如果是针对某个字段，那么它的结构如下：
<code>
{
  QUERY_NAME: {
      FIELD_NAME: {
          ARGUMENT: VALUE,
          ARGUMENT: VALUE,...
      }
  }
}
</code></p></li>
<li><p>一条复合语句
<code>
{
  "bool": {
      "must": { "match":   { "email": "business opportunity" }},
      "should": [
          { "match":       { "starred": true }},
          { "bool": {
              "must":      { "match": { "folder": "inbox" }},
              "must_not":  { "match": { "spam": true }}
          }}
      ],
      "minimum_should_match": 1
  }
}
</code></p></li>
</ul>


<h4>实战查询</h4>

<ul>
<li><p>精确查询
<code>
GET /website/_search
{
"query": {
  "constant_score" : {
    "filter":{
      "term": {
        "title": "helloworld"
      }
    }
  }
}
}
</code></p></li>
<li><p>多词组合
<code>
GET /website/_search
{
  "query": {
      "match": {
          "title": {      
              "query":    "BROWN DOG!",
              "operator": "and"
          }
      }
  }
}
</code></p></li>
<li><p>短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": "quick brown fox"
      }
  }
}
</code></p></li>
<li><p>混合短语匹配
<code>
GET /website/_search
{
  "query": {
      "match_phrase": {
          "title": {
              "query": "quick fox",
              "slop":  1
          }
      }
  }
}
</code></p></li>
<li><p>正则查询 (性能慢)
<code>
GET /my_index/_search
{
  "query": {
      "wildcard": {
          "postcode": "W?F*HW"
      }
  }
}
</code></p></li>
<li><p>智能匹配
<code>
GET /my_index/_search
{
  "query": {
      "match_phrase_prefix" : {
          "brand" : {
              "query":          "johnnie walker bl",
              "max_expansions": 50
              }
      }
  }
}
</code></p></li>
<li><p>控制精度
```
GET /website/_search
{
&ldquo;query&rdquo;: {
  &ldquo;match&rdquo;: {
    &ldquo;title&rdquo;: {
      &ldquo;query&rdquo;:                &ldquo;quick brown dog&rdquo;,
      &ldquo;minimum_should_match&rdquo;: &ldquo;75%&rdquo;
    }
  }
}
}</p></li>
</ul>


<p>GET /website/_search
{
  &ldquo;query&rdquo;: {</p>

<pre><code>"bool": {
  "should": [
    { "match": { "title": "brown" }},
    { "match": { "title": "fox"   }},
    { "match": { "title": "dog"   }}
  ],
  "minimum_should_match": 2 
}
</code></pre>

<p>  }
}
```</p>

<ul>
<li>按受欢迎度提升权重
```
GET /blogposts/post/_search
{
&ldquo;query&rdquo;: {
  &ldquo;function_score&rdquo;: {
    &ldquo;query&rdquo;: {
      &ldquo;multi_match&rdquo;: {
        &ldquo;query&rdquo;:    &ldquo;popularity&rdquo;,
        &ldquo;fields&rdquo;: [ &ldquo;title&rdquo;, &ldquo;content&rdquo; ]
      }
    },
    &ldquo;field_value_factor&rdquo;: {
      &ldquo;field&rdquo;: &ldquo;votes&rdquo;
    }
  }
}
}</li>
</ul>


<p>微调:
<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html</a>
```</p>

<h4>排障</h4>

<p>```
GET /website/_validate/query?explain
{
   &ldquo;query&rdquo;: {</p>

<pre><code>  "match" : {
     "text" : "really powerful"
  }
</code></pre>

<p>   }
}
```</p>

<h4>结果排序</h4>

<p>```
GET /website/_search
{</p>

<pre><code>"query" : {
    "bool" : {
        "filter" : { "term" : { "_id" : 1 }}
    }
},
"sort": { "date": { "order": "desc" }}
</code></pre>

<p>}
```</p>

<h2>索引操作</h2>

<h4>增加</h4>

<p>```
PUT /my_index
{</p>

<pre><code>"settings": { ... any settings ... },
"mappings": {
    "type_one": { ... any mappings ... },
    "type_two": { ... any mappings ... },
    ...
}
</code></pre>

<p>}
```</p>

<h4>删除</h4>

<p><code>
DELETE /my_index
DELETE /index_one,index_two
DELETE /index_*
DELETE /_all
</code></p>

<h4>配置</h4>

<ul>
<li>number_of_shards</li>
</ul>


<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
<li>number_of_replicas</li>
</ul>


<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4>重新索引</h4>

<p>```
POST _reindex
{
  &ldquo;source&rdquo;: {</p>

<pre><code>"index": "twitter"
</code></pre>

<p>  },
  &ldquo;dest&rdquo;: {</p>

<pre><code>"index": "new_twitter"
</code></pre>

<p>  }
}</p>

<p>```</p>

<h4>释放空间</h4>

<p><code>
POST /_all/_forcemerge?only_expunge_deletes=true
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python捕获所有异常]]></title>
    <link href="https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang/"/>
    <updated>2019-06-24T12:31:08+08:00</updated>
    <id>https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang</id>
    <content type="html"><![CDATA[<p>摘自 &ndash; Python cookbook</p>

<p>老生常谈了，但是在Pyflake检查出E722错误时有时候又犯老毛病。人年纪大了越来越有老年痴呆倾向  &ndash;_&ndash; &hellip;..</p>

<h2>怎样捕获代码中的所有异常？</h2>

<!-- more -->


<h4>想要捕获所有的异常，可以直接捕获 Exception 即可：</h4>

<p><code>
try:
   ...
except Exception as e:
   ...
   log('Reason:', e)       # Important!
</code>
这个将会捕获除了 <code>SystemExit</code> 、 <code>KeyboardInterrupt</code> 和 <code>GeneratorExit</code> 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。</p>

<h4>讨论</h4>

<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>

<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>

<p>```
def parse_int(s):</p>

<pre><code>try:
    n = int(v)
except Exception:
    print("Couldn't parse")
</code></pre>

<p>```      <br/>
试着运行这个函数，结果如下：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>parse_int(&lsquo;n/a&rsquo;)
Couldn&rsquo;t parse
parse_int(&lsquo;42&rsquo;)
Couldn&rsquo;t parse</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>

<p>```
def parse_int(s):</p>

<pre><code>try:
    n = int(v)
except Exception as e:
    print("Couldn't parse")
    print('Reason:', e)
</code></pre>

<p>```</p>

<p>这时候你能获取如下输出，指明了有个编程错误：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>parse_int(&lsquo;42&rsquo;)
Couldn&rsquo;t parse
Reason: global name &lsquo;v&rsquo; is not defined</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>很明显，你应该尽可能将异常处理器定义的精准一些。</p>

<p>不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>

<h4>最可怕的例子是我们在处理临时文件的时候，用</h4>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>因为碍人的E722, 有人会自作聪明的改成:</p>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except Exception:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>正确的办法是:</p>

<p>```
try:</p>

<pre><code>....
</code></pre>

<p>except BaseException:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>或者更确定的语义之下，每次都清理临时文件，这样更明确，处理更好一点:
```
try:</p>

<pre><code>....
</code></pre>

<p>except BaseException:</p>

<pre><code>logger.error(....)
</code></pre>

<p>finally:</p>

<pre><code>os.remove(temp_file)
</code></pre>

<p>```</p>

<p>参考:</p>

<p><a href="https://github.com/PyCQA/pycodestyle/issues/703">https://github.com/PyCQA/pycodestyle/issues/703</a></p>

<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html</a></p>
]]></content>
  </entry>
  
</feed>
