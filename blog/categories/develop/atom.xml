<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-05-22T07:38:50+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go包管理工具]]></title>
    <link href="https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju/"/>
    <updated>2019-05-01T15:25:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju</id>
    <content type="html"><![CDATA[<p>真的，Go的包管理工具之发展过程充分体现了什么叫<code>折腾</code>。 (叹气~~~)</p>

<!-- more -->


<p>想想Java的Maven， Nodejs的NPM，还有我们赞颂一万遍也不过分的Python包管理，为什么生命总要浪费在这些事情上面呢？ 陷入了深深的沉思~~</p>

<p>从Go1.11版本发布Go MODULE之后，我希望这是最后一次折腾<code>包管理</code>这件事情，神呐，诚心诚意的祈祷中~~</p>

<p>摘抄备忘下：</p>

<h2>GO111MODULE</h2>

<p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。
按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，GO111MODULE 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p>

<ul>
<li><p>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</p></li>
<li><p>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</p></li>
<li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:

<ul>
<li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li>
<li>当前目录位于包含 go.mod 文件的目录下</li>
</ul>
</li>
</ul>


<h2>go mod 命令</h2>

<p><code>
download    download modules to local cache (下载依赖的 modules 到本地 cache)
edit        edit go.mod from tools or scripts (编辑 go.mod 文件)
graph       print module requirement graph (打印模块依赖图)
init        initialize new module in current directory (再当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)
vendor      make vendored copy of dependencies (将依赖复制到 vendor 下)
verify      verify dependencies have expected content (校验依赖)
why         explain why packages or modules are needed (解释为什么需要依赖)
</code></p>

<h2>既有项目</h2>

<p>假设你已经有了一个 go 项目， 比如在$GOPATH/github.com/memoryboxes/hello下， 你可以使用go mod init github.com/memoryboxes/hello在这个文件夹下创建一个空的 go.mod (只有第一行 module github.com/memoryboxes/hello)。</p>

<p>然后你可以通过 go get ./&hellip;让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 -tags, 这样可以把 tags 的依赖都查找到)。</p>

<p>通过go mod tidy也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理tags。</p>

<p>执行上面的命令会把 go.mod 的latest版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p>

<h2>replace</h2>

<p>在国内访问golang.org/x的各个包都需要梯子，你可以在 go.mod 中使用replace替换成 github 上对应的库。</p>

<p><code>
replace (
  golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
  golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
  golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
)
</code>
依赖库中的replace对你的主 go.mod 不起作用，比如github.com/memoryboxes/hello的 go.mod 已经增加了replace, 但是你的 go.mod 虽然require了rpcx的库，但是没有设置replace的话， go get还是会访问golang.org/x。</p>

<p>所以如果想编译哪个项目，就在哪个项目中增加replace。</p>

<h2>包的版本控制</h2>

<p>下面的版本都是合法的：</p>

<p><code>
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
gopkg.in/vmihailenco/msgpack.v2 v2.9.1
gopkg.in/yaml.v2 &lt;=v2.2.1
github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
latest
</code>
版本号遵循如下规律：</p>

<p><code>
vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
vX.0.0-yyyymmddhhmmss-abcdefabcdef
vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
vX.Y.Z
</code>
也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p>

<p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p>

<h2>go get 升级</h2>

<ul>
<li>运行 go get -u 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li>
<li>运行 go get -u=patch 将会升级到最新的修订版本</li>
<li>运行 go get package@version 将会升级到指定的版本号version</li>
</ul>


<h2>go modules 与 vendor</h2>

<ul>
<li><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p></li>
<li><p>Go modules 支持通过go mod vendor命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用go build -mod=vendor即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p></li>
</ul>


<h2>参考:</h2>

<p><a href="https://roberto.selbach.ca/intro-to-go-modules/">https://roberto.selbach.ca/intro-to-go-modules/</a></p>

<p><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p>

<p><a href="https://windmt.com/2018/11/08/first-look-go-modules/">https://windmt.com/2018/11/08/first-look-go-modules/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Evolution of a Programmer]]></title>
    <link href="https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer/"/>
    <updated>2018-10-06T17:22:54+08:00</updated>
    <id>https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer</id>
    <content type="html"><![CDATA[<p>快有二十年的老段子了，最近又看到很多次，莫非是邪恶旧势力的崛起？存档一下。</p>

<!-- more -->


<h4>High School/Jr.High</h4>

<p><code>
  10 PRINT "HELLO WORLD"
  20 END
</code></p>

<h4>First year in College</h4>

<p>```
  program Hello(input, output)</p>

<pre><code>begin
  writeln('Hello World')
end.
</code></pre>

<p>```</p>

<h4>Senior year in College</h4>

<p>```
  (defun hello</p>

<pre><code>(print
  (cons 'Hello (list 'World))))
</code></pre>

<p>```</p>

<h4>New professional</h4>

<p>```
  #include &lt;stdio.h>
  void main(void)
  {</p>

<pre><code>char *message[] = {"Hello ", "World"};
int i;

for(i = 0; i &lt; 2; ++i)
  printf("%s", message[i]);
printf("\n");
</code></pre>

<p>  }
```</p>

<h4>Seasoned professional</h4>

<p>```
  #include &lt;iostream.h>
  #include &lt;string.h></p>

<p>  class string
  {
  private:</p>

<pre><code>int size;
char *ptr;
</code></pre>

<p>  string() : size(0), ptr(new char[1]) { ptr[0] = 0; }</p>

<pre><code>string(const string &amp;s) : size(s.size)
{
  ptr = new char[size + 1];
  strcpy(ptr, s.ptr);
}

~string()
{
  delete [] ptr;
}

friend ostream &amp;operator &lt;&lt;(ostream &amp;, const string &amp;);
string &amp;operator=(const char *);
</code></pre>

<p>  };</p>

<p>  ostream &amp;operator&lt;&lt;(ostream &amp;stream, const string &amp;s)
  {</p>

<pre><code>return(stream &lt;&lt; s.ptr);
</code></pre>

<p>  }</p>

<p>  string &amp;string::operator=(const char *chrs)
  {</p>

<pre><code>if (this != &amp;chrs)
{
  delete [] ptr;
 size = strlen(chrs);
  ptr = new char[size + 1];
  strcpy(ptr, chrs);
}
return(*this);
</code></pre>

<p>  }</p>

<p>  int main()
  {</p>

<pre><code>string str;

str = "Hello World";
cout &lt;&lt; str &lt;&lt; endl;

return(0);
</code></pre>

<p>  }
```</p>

<h4>Master Programmer</h4>

<p>```
  [
  uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
  ]
  library LHello
  {</p>

<pre><code>  // bring in the master library
  importlib("actimp.tlb");
  importlib("actexp.tlb");

  // bring in my interfaces
  #include "pshlo.idl"

  [
  uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
  ]
  cotype THello
</code></pre>

<p>   {
   interface IHello;
   interface IPersistFile;
   };
  };</p>

<p>  [
  exe,
  uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
  ]
  module CHelloLib
  {</p>

<pre><code>  // some code related header files
  importheader(&lt;windows.h&gt;);
  importheader(&lt;ole2.h&gt;);
  importheader(&lt;except.hxx&gt;);
  importheader("pshlo.h");
  importheader("shlo.hxx");
  importheader("mycls.hxx");

  // needed typelibs
  importlib("actimp.tlb");
  importlib("actexp.tlb");
  importlib("thlo.tlb");

  [
  uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
  aggregatable
  ]
  coclass CHello
</code></pre>

<p>   {
   cotype THello;
   };
  };</p>

<p>  #include &ldquo;ipfix.hxx&rdquo;</p>

<p>  extern HANDLE hEvent;</p>

<p>  class CHello : public CHelloBase
  {
  public:</p>

<pre><code>  IPFIX(CLSID_CHello);

  CHello(IUnknown *pUnk);
  ~CHello();

  HRESULT  __stdcall PrintSz(LPWSTR pwszString);
</code></pre>

<p>  private:</p>

<pre><code>  static int cObjRef;
</code></pre>

<p>  };</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &lt;stdio.h>
  #include &lt;stdlib.h>
  #include &ldquo;thlo.h&rdquo;
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;mycls.hxx&rdquo;</p>

<p>  int CHello::cObjRef = 0;</p>

<p>  CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
  {</p>

<pre><code>  cObjRef++;
  return;
</code></pre>

<p>  }</p>

<p>  HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
  {</p>

<pre><code>  printf("%ws
</code></pre>

<p>&ldquo;, pwszString);</p>

<pre><code>  return(ResultFromScode(S_OK));
</code></pre>

<p>  }</p>

<p>  CHello::~CHello(void)
  {</p>

<p>  // when the object count goes to zero, stop the server
  cObjRef&mdash;;
  if( cObjRef == 0 )</p>

<pre><code>  PulseEvent(hEvent);
</code></pre>

<p>  return;
  }</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;mycls.hxx&rdquo;</p>

<p>  HANDLE hEvent;</p>

<p>   int _cdecl main(
  int argc,
  char * argv[]
  ) {
  ULONG ulRef;
  DWORD dwRegistration;
  CHelloCF *pCF = new CHelloCF();</p>

<p>  hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);</p>

<p>  // Initialize the OLE libraries
  CoInitializeEx(NULL, COINIT_MULTITHREADED);</p>

<p>  CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,</p>

<pre><code>  REGCLS_MULTIPLEUSE, &amp;dwRegistration);
</code></pre>

<p>  // wait on an event to stop
  WaitForSingleObject(hEvent, INFINITE);</p>

<p>  // revoke and release the class object
  CoRevokeClassObject(dwRegistration);
  ulRef = pCF->Release();</p>

<p>  // Tell OLE we are going away.
  CoUninitialize();</p>

<p>  return(0); }</p>

<p>  extern CLSID CLSID_CHello;
  extern UUID LIBID_CHelloLib;</p>

<p>  CLSID CLSID_CHello = { /<em> 2573F891-CFEE-101A-9A9F-00AA00342820 </em>/</p>

<pre><code>  0x2573F891,
  0xCFEE,
  0x101A,
  { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</code></pre>

<p>  };</p>

<p>  UUID LIBID_CHelloLib = { /<em> 2573F890-CFEE-101A-9A9F-00AA00342820 </em>/</p>

<pre><code>  0x2573F890,
  0xCFEE,
  0x101A,
  { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</code></pre>

<p>  };</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &lt;stdlib.h>
  #include &lt;string.h>
  #include &lt;stdio.h>
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;clsid.h&rdquo;</p>

<p>  int <em>cdecl main(
  int argc,
  char * argv[]
  ) {
  HRESULT  hRslt;
  IHello        *pHello;
  ULONG  ulCnt;
  IMoniker * pmk;
  WCHAR  wcsT[</em>MAX_PATH];
  WCHAR  wcsPath[2 * _MAX_PATH];</p>

<p>  // get object path
  wcsPath[0] = &lsquo;\0&rsquo;;
  wcsT[0] = &lsquo;\0&rsquo;;
  if( argc > 1) {</p>

<pre><code>  mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
  wcsupr(wcsPath);
  }
</code></pre>

<p>  else {</p>

<pre><code>  fprintf(stderr, "Object path must be specified\n");
  return(1);
  }
</code></pre>

<p>  // get print string
  if(argc > 2)</p>

<pre><code>  mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
</code></pre>

<p>  else</p>

<pre><code>  wcscpy(wcsT, L"Hello World");
</code></pre>

<p>  printf(&ldquo;Linking to object %ws\n&rdquo;, wcsPath);
  printf(&ldquo;Text String %ws\n&rdquo;, wcsT);</p>

<p>  // Initialize the OLE libraries
  hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);</p>

<p>  if(SUCCEEDED(hRslt)) {</p>

<pre><code>  hRslt = CreateFileMoniker(wcsPath, &amp;pmk);
  if(SUCCEEDED(hRslt))
</code></pre>

<p>   hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&amp;pHello);</p>

<pre><code>  if(SUCCEEDED(hRslt)) {
</code></pre>

<p>   // print a string out
   pHello->PrintSz(wcsT);</p>

<p>   Sleep(2000);
   ulCnt = pHello->Release();
   }</p>

<pre><code>  else
</code></pre>

<p>   printf(&ldquo;Failure to connect, status: %lx&rdquo;, hRslt);</p>

<pre><code>  // Tell OLE we are going away.
  CoUninitialize();
  }
</code></pre>

<p>  return(0);
  }
```</p>

<h4>Apprentice Hacker</h4>

<p>```
  #!/usr/local/bin/perl
  $msg=&ldquo;Hello, world.\n&rdquo;;
  if ($#ARGV >= 0) {</p>

<pre><code>while(defined($arg=shift(@ARGV))) {
  $outfilename = $arg;
  open(FILE, "&gt;" . $outfilename) || die "Can't write $arg: $!\n";
  print (FILE $msg);
  close(FILE) || die "Can't close $arg: $!\n";
}
</code></pre>

<p>  } else {</p>

<pre><code>print ($msg);
</code></pre>

<p>  }
  1;
```</p>

<h4>Experienced Hacker</h4>

<p><code>
  #include &lt;stdio.h&gt;
  #define S "Hello, World\n"
  main(){exit(printf(S) == strlen(S) ? 0 : 1);}
</code></p>

<h4>Seasoned Hacker</h4>

<p><code>
  % cc -o a.out ~/src/misc/hw/hw.c
  % a.out
</code></p>

<h4>Guru Hacker</h4>

<p><code>
  % echo "Hello, world."
</code></p>

<h4>New Manager</h4>

<p><code>
  10 PRINT "HELLO WORLD"
  20 END
</code></p>

<h4>Middle Manager</h4>

<p><code>
  mail -s "Hello, world." bob@b12
  Bob, could you please write me a program that prints "Hello, world."?
  I need it by tomorrow.
  ^D
</code></p>

<h4>Senior Manager</h4>

<p><code>
  % zmail jim
  I need a "Hello, world." program by this afternoon.
</code></p>

<h4>Chief Executive</h4>

<p><code>
  % letter
  letter: Command not found.
  % mail
  To: ^X ^F ^C
  % help mail
  help: Command not found.
  % damn!
  !: Event unrecognized
  % logout
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The History of X86]]></title>
    <link href="https://happy123.me/blog/2018/09/12/the-history-of-x86/"/>
    <updated>2018-09-12T10:22:01+08:00</updated>
    <id>https://happy123.me/blog/2018/09/12/the-history-of-x86</id>
    <content type="html"><![CDATA[<p>我们平时老看到<code>X86指令集</code>, <code>X86架构</code>等等词汇，很容易就猜到这个86来源于Intel那款名动天下的处理器&mdash;8086，那么8086的名字又是怎么来的呢？</p>

<!-- more -->


<p>这是一个遥远的传说，各种解释众说纷纭，挑两个有说服力的段子吧:</p>

<h4>说法1</h4>

<p>当intel发明第一颗4位的位处理器的时候，intel把他叫4004。在当时，intel也没有意识到这就是微处理器，（微处理器是后来人的说法），intel当时只是给做手持计算器的厂家来定制处理器。</p>

<p>因为4004的指令集很有限，所以又搞出来了一个升级版本4040。</p>

<p>8008是4004的8位版，8080是4040的8位版。</p>

<p>8085是8080的单5伏电压版。</p>

<p>8085升级到16位后，就叫8086了。</p>

<p>嗯，还是很有逻辑的。</p>

<h4>说法2</h4>

<p>微处理器是在70年代末发明的。 接近80年，所以，前两个数字就是这么来的;</p>

<p>当时微处理器是8位的，因此，第3个数字是8;</p>

<p>在8085和8086 cpu之前，8080处理器是需要+5-5和12v电压来工作。 随着技术的进步，只需要单一的5v供电了，因此，最后一个数字是5;</p>

<p>8085升级到16位后，就叫8086了;</p>

<p>好吧，也说得通。</p>

<h4>不管怎么说，反正Intel推出的8086在历史上的经典地位不容置疑；那我们来简单回顾一下Intel CPU发展的历史吧</h4>

<ul>
<li><p>20世纪70年代末，Intel生产了著名的16位8086处理器，之后又推出了80186与80286；</p></li>
<li><p>1985年，Intel继摩托罗拉之后，第二个研制出32位的微处理器80386；</p></li>
<li><p>8086、80286、80386等等，这一系列CPU就称作x86，正式一点称作IA-32（Intel Architecture 32-bit）。正是这个架构开启了Intel在个人PC CPU领域的无敌之路，后来的操作系统、编译器、应用软件无一不是把<code>适配X86指令</code>作为核心竞争力；</p></li>
<li><p>1989年，Intel推出80486处理器，具有浮点运算功能；</p></li>
<li><p>因为当初与Intel竞争微处理器的摩托罗拉公司是以86开头的，如68000，68010，68020，而且AMD也崭露头角，他们也搞出来AM386，AM486等等，令Intel不胜其烦；而当时的法律不允许将数字注册为商标，于是1993年，Intel推出奔腾(Pentium)处理器，不再以数字命名其产品；Pentium刚刚推出的时候，命名及其混乱，有人叫I586，有人叫P5，有人叫PI，还有人叫奔腾的芯，更别提什么梦幻神器，裸奔天下等等搞笑名词了~~不管怎么说，那时候伴随我们记忆的不只是Pentium这个名字，还有那个经典的"等等等你等"的广告音乐，Intel又凭借Pentium这个架构继续无敌并寂寞着</p></li>
<li><p>在Pentium时代，其实AMD也不是毫无作为，老一代DIY玩家们一定还对Athlon K7的传说记忆犹新，尤其是当时那些拉风的译名，什么"速龙"、"毒龙"、"钻龙"等等，我得说，这个时期的农企实在是很时髦，远远不像他们后来的市场部那么傻13</p></li>
<li><p>当然，当时最璀璨的舞者，我只献给活在DIYer心里那个最美好的名字&mdash;图拉丁赛扬；正是这款CPU成为了许多人的电脑时代的启蒙者</p></li>
<li><p>2001年开始，Intel将用于服务器以及工作站的Pentium 4 Xeon独立成全新的品牌“Xeon”（至强）)；正如这个名字所蕴含的霸气一样，这个品牌延续到了今天</p></li>
<li><p>2006年，Intel发布“Core”（酷睿）品牌，用作英特尔的旗舰级处理器系列的新品品牌； 然后，这个品牌经历了数代架构更迭，一直伴随我们到了今天</p></li>
<li><p>同样的，围绕指令集从32位跃迁到64位的过程中，AMD和Interl在这段时间还爆发了一场惊天缠斗；Intel作为CPU市场的领跑者，觉得自己理应主导32位到64位时代跃进的浪潮；早在Pentium时代，他们就制定了Intel 64计划；然而，由于一个大公司内部的种种政治斗争，市场斗争，人的本性里面悲剧的傲慢，这个过程种出现了种种败着昏棋，最终AMD64架构在IA-32上新增了64位寄存器，并兼容早期的16位和32位软件，可使现有以x86为对象的编译器容易转为AMD64版本，在2003年9月推出了AMD64；在64位时代由追随者变成领跑者</p></li>
<li><p>Intel此时如梦方醒，慌忙将AMD的指令集拿过来稍作加工推出自己的兼容产品；然后就是两个公司营销和市场人员、法律人员旷日持久的撕逼大战；中间诞生了许许多多匪夷所思的营销名词，比如A64, I64, IA32E，iAMD64，Intel64，X86-64等等等等；如果你是一个Linux爱好者，很容易看到各个软件包都会注明Amd64, X86_64等等，这是那场混乱大战的遗留物</p></li>
</ul>


<h4>总结一下现在的主流</h4>

<ul>
<li><p>32/64 位系统编译在32位系统上运行 => x86</p></li>
<li><p>32 系统上编译64位系统上运行 => x86_amd64</p></li>
<li><p>64 系统上编译在64位系统上运行 => amd64</p></li>
</ul>


<h4>看看MSDN的解释:</h4>

<blockquote><p>The following list describes the various versions of cl.exe (the Visual C++ compiler):</p>

<p>x86 on x86
Allows you to create output files for x86 machines. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.
Itanium on x86 (Itanium cross-compiler)
Allows you to create output files for Itanium. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.</p>

<p>x64 on x86 (x64 cross-compiler)
Allows you to create output files for x64. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.</p>

<p>Itanium on Itanium
Allows you to create output files for Itanium. This version of cl.exe runs as a native process on an Itanium machine.</p>

<p>x64 on x64
Allows you to create output files for x64. This version of cl.exe runs as a native process on an x64 machine.</p></blockquote>

<h4>总之CPU的历史生动说明了了计算机界的很多老梗是如何诞生的，比如很多人都疑惑为什么Windows的发布名称是Win95->W98->W98SE->Win2000(NT)&ndash;>WinXP->Vista->Win7->Win10，等等等等；这种现象是商业环境、市场营销、法律风险以及随意拍脑门的高管，放荡不羁的开发团队合力促成的~~~</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从WebAssembly说开去]]></title>
    <link href="https://happy123.me/blog/2018/08/25/cong-webassemblyshuo-kai-qu/"/>
    <updated>2018-08-25T11:14:39+08:00</updated>
    <id>https://happy123.me/blog/2018/08/25/cong-webassemblyshuo-kai-qu</id>
    <content type="html"><![CDATA[<p>科技界历史循环，轨迹无法量化预测。</p>

<p>前几天看到bellard都在浏览器里面用WebAssembly跑虚拟机了，点进去试试，竟然模拟Win2000都有模有样了。</p>

<p><a href="https://bellard.org/jslinux/index.html">https://bellard.org/jslinux/index.html</a></p>

<p>不由得感叹人折腾的能力真是无比强大。</p>

<!-- more -->


<p>有人说WebAssembly又实现了一个Flash，又实现了一个SliverLight，又造了一个JavaApplet，我都想到很久很久之前的ActiveX了，想到COM组件了~~~</p>

<p>肯定又会有人跳出来说，这回不一样了:</p>

<ol>
<li><p>谷歌、苹果、微软等公司一起来干了</p></li>
<li><p>前端拯救世界，前端用Nodejs打入后端，后端用WebAssembly征服前端~~</p></li>
<li><p>就连技术媒体都开始用吸睛标题：&lt;WebAssembly:解决 JavaScript 痼疾的一颗银色子弹？></p></li>
</ol>


<p>我得说，技术路线的发展完全是随机的，无迹可寻。</p>

<ul>
<li><p>比如当初Flash就被乔帮主活活说死了，说你不行行也不行。</p></li>
<li><p>比如Plan9搞了一堆创新之后死翘翘了，根本就没几个人去在意</p></li>
<li><p>比如苦大仇深的GUI方案，MS推出了一系列库，从MFC、WTL到所谓的WPF，从各类公司的私有解决方案，到现在还在服役的大名鼎鼎的Duilib;最后就不提历史风尘中的各类商业皮肤库了；</p>

<p>   还有开源界的各路GNome、wxWidgets、QT、TCL，到现在跨平台GUI方案的战火都烧到浏览器上了，VS Code用啥实现的，竟然是Electron；虽然效果拔群，但是总觉得哪里不对路啊；</p></li>
<li><p>从移动手机刚刚兴起的年代，就有无数种解决方案发誓要做到"一次编写，到处运行"，兼容各大主流移动平台；如今看看，口号依旧，分裂依旧，半死不活依旧</p></li>
<li><p>为什么历史选择TCP/IP而把ISO模型扫进教科书</p></li>
<li><p>为什么IE打败Netscape</p></li>
<li><p>为什么KVM逐渐压倒Xen</p></li>
</ul>


<p>历史只是偶然，成败听凭运气，没有什么道理好讲的。</p>

<p>我只能根据有限的经验来预言：任何一种号称"大一统方案"的方案最后总是失败。</p>

<p>让我们再大声诵读伟大的Fred Brooks先知的预言：没有银弹，没有银弹，没有银弹~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非烫即屯]]></title>
    <link href="https://happy123.me/blog/2018/08/25/fei-tang-ji-tun/"/>
    <updated>2018-08-25T09:34:43+08:00</updated>
    <id>https://happy123.me/blog/2018/08/25/fei-tang-ji-tun</id>
    <content type="html"><![CDATA[<p>好久没有打开过VC++了，今天为了修改一个远古控件打开了久违的VC++，DEBUG模式下又看到了久违的"烫烫烫烫烫"~~~~</p>

<!-- more -->


<p>VC runtime debug version会把stack初始化成0xcc，unicode中0xcccc(双字节)就是中文的烫。如果你开了个char[]，然后最后一个字符忘了设置成0x00，然后去printf这个字符，那么整个stack从这个局部字符数组开始都输出到console，就变成了“烫烫烫烫烫”。</p>

<p>为啥把stack初始化成0xcc而不是0x00呢？是因为0xcc在intel x86芯片指令集中代表int 3，也就是debug中断，该指令会自动把程序停在单步调试状态，然后去寻找系统中注册的调试器，如果找不到调试器，那么就会终止程序。这一开始是为了调试栈缓冲溢出错误的。如果出现溢出，并且代码尝试执行缓冲中的指令，就会进入单步调试状态。</p>

<p>这是debug version, 那么release verion呢？发布版会把栈初始化成0xcd，这个就是imm8，就是立即中断退出的意思。这时候因为运行在用户机器上，没有调试器，也不希望用户来调试你的程序。0xcdcd就是中文的“屯”字。你会看见一些写的超烂的程序经常会出现“屯屯屯屯屯屯”。的确挺屯的，</p>

<p>在今天这个芯片DEP，操作系统NX锁定双保险的时代，这种初始化已经没有啥必要了，这个烫屯还存在纯粹是历史原因。</p>

<p>所以在那个电脑还比较古早的年代，说人品不好，那叫非奸即盗。说程序写的烂，那叫非烫即屯。</p>
]]></content>
  </entry>
  
</feed>
