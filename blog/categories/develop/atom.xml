<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Develop | Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/blog/categories/develop/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-01-24T09:58:53+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Evolution of a Programmer]]></title>
    <link href="https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer/"/>
    <updated>2018-10-06T17:22:54+08:00</updated>
    <id>https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer</id>
    <content type="html"><![CDATA[<p>快有二十年的老段子了，最近又看到很多次，莫非是邪恶旧势力的崛起？存档一下。</p>

<!-- more -->


<h4>High School/Jr.High</h4>

<p><code>
  10 PRINT "HELLO WORLD"
  20 END
</code></p>

<h4>First year in College</h4>

<p>```
  program Hello(input, output)</p>

<pre><code>begin
  writeln('Hello World')
end.
</code></pre>

<p>```</p>

<h4>Senior year in College</h4>

<p>```
  (defun hello</p>

<pre><code>(print
  (cons 'Hello (list 'World))))
</code></pre>

<p>```</p>

<h4>New professional</h4>

<p>```
  #include &lt;stdio.h>
  void main(void)
  {</p>

<pre><code>char *message[] = {"Hello ", "World"};
int i;

for(i = 0; i &lt; 2; ++i)
  printf("%s", message[i]);
printf("\n");
</code></pre>

<p>  }
```</p>

<h4>Seasoned professional</h4>

<p>```
  #include &lt;iostream.h>
  #include &lt;string.h></p>

<p>  class string
  {
  private:</p>

<pre><code>int size;
char *ptr;
</code></pre>

<p>  string() : size(0), ptr(new char[1]) { ptr[0] = 0; }</p>

<pre><code>string(const string &amp;s) : size(s.size)
{
  ptr = new char[size + 1];
  strcpy(ptr, s.ptr);
}

~string()
{
  delete [] ptr;
}

friend ostream &amp;operator &lt;&lt;(ostream &amp;, const string &amp;);
string &amp;operator=(const char *);
</code></pre>

<p>  };</p>

<p>  ostream &amp;operator&lt;&lt;(ostream &amp;stream, const string &amp;s)
  {</p>

<pre><code>return(stream &lt;&lt; s.ptr);
</code></pre>

<p>  }</p>

<p>  string &amp;string::operator=(const char *chrs)
  {</p>

<pre><code>if (this != &amp;chrs)
{
  delete [] ptr;
 size = strlen(chrs);
  ptr = new char[size + 1];
  strcpy(ptr, chrs);
}
return(*this);
</code></pre>

<p>  }</p>

<p>  int main()
  {</p>

<pre><code>string str;

str = "Hello World";
cout &lt;&lt; str &lt;&lt; endl;

return(0);
</code></pre>

<p>  }
```</p>

<h4>Master Programmer</h4>

<p>```
  [
  uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
  ]
  library LHello
  {</p>

<pre><code>  // bring in the master library
  importlib("actimp.tlb");
  importlib("actexp.tlb");

  // bring in my interfaces
  #include "pshlo.idl"

  [
  uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
  ]
  cotype THello
</code></pre>

<p>   {
   interface IHello;
   interface IPersistFile;
   };
  };</p>

<p>  [
  exe,
  uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
  ]
  module CHelloLib
  {</p>

<pre><code>  // some code related header files
  importheader(&lt;windows.h&gt;);
  importheader(&lt;ole2.h&gt;);
  importheader(&lt;except.hxx&gt;);
  importheader("pshlo.h");
  importheader("shlo.hxx");
  importheader("mycls.hxx");

  // needed typelibs
  importlib("actimp.tlb");
  importlib("actexp.tlb");
  importlib("thlo.tlb");

  [
  uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
  aggregatable
  ]
  coclass CHello
</code></pre>

<p>   {
   cotype THello;
   };
  };</p>

<p>  #include &ldquo;ipfix.hxx&rdquo;</p>

<p>  extern HANDLE hEvent;</p>

<p>  class CHello : public CHelloBase
  {
  public:</p>

<pre><code>  IPFIX(CLSID_CHello);

  CHello(IUnknown *pUnk);
  ~CHello();

  HRESULT  __stdcall PrintSz(LPWSTR pwszString);
</code></pre>

<p>  private:</p>

<pre><code>  static int cObjRef;
</code></pre>

<p>  };</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &lt;stdio.h>
  #include &lt;stdlib.h>
  #include &ldquo;thlo.h&rdquo;
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;mycls.hxx&rdquo;</p>

<p>  int CHello::cObjRef = 0;</p>

<p>  CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
  {</p>

<pre><code>  cObjRef++;
  return;
</code></pre>

<p>  }</p>

<p>  HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
  {</p>

<pre><code>  printf("%ws
</code></pre>

<p>&ldquo;, pwszString);</p>

<pre><code>  return(ResultFromScode(S_OK));
</code></pre>

<p>  }</p>

<p>  CHello::~CHello(void)
  {</p>

<p>  // when the object count goes to zero, stop the server
  cObjRef&mdash;;
  if( cObjRef == 0 )</p>

<pre><code>  PulseEvent(hEvent);
</code></pre>

<p>  return;
  }</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;mycls.hxx&rdquo;</p>

<p>  HANDLE hEvent;</p>

<p>   int _cdecl main(
  int argc,
  char * argv[]
  ) {
  ULONG ulRef;
  DWORD dwRegistration;
  CHelloCF *pCF = new CHelloCF();</p>

<p>  hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);</p>

<p>  // Initialize the OLE libraries
  CoInitializeEx(NULL, COINIT_MULTITHREADED);</p>

<p>  CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,</p>

<pre><code>  REGCLS_MULTIPLEUSE, &amp;dwRegistration);
</code></pre>

<p>  // wait on an event to stop
  WaitForSingleObject(hEvent, INFINITE);</p>

<p>  // revoke and release the class object
  CoRevokeClassObject(dwRegistration);
  ulRef = pCF->Release();</p>

<p>  // Tell OLE we are going away.
  CoUninitialize();</p>

<p>  return(0); }</p>

<p>  extern CLSID CLSID_CHello;
  extern UUID LIBID_CHelloLib;</p>

<p>  CLSID CLSID_CHello = { /<em> 2573F891-CFEE-101A-9A9F-00AA00342820 </em>/</p>

<pre><code>  0x2573F891,
  0xCFEE,
  0x101A,
  { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</code></pre>

<p>  };</p>

<p>  UUID LIBID_CHelloLib = { /<em> 2573F890-CFEE-101A-9A9F-00AA00342820 </em>/</p>

<pre><code>  0x2573F890,
  0xCFEE,
  0x101A,
  { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</code></pre>

<p>  };</p>

<p>  #include &lt;windows.h>
  #include &lt;ole2.h>
  #include &lt;stdlib.h>
  #include &lt;string.h>
  #include &lt;stdio.h>
  #include &ldquo;pshlo.h&rdquo;
  #include &ldquo;shlo.hxx&rdquo;
  #include &ldquo;clsid.h&rdquo;</p>

<p>  int <em>cdecl main(
  int argc,
  char * argv[]
  ) {
  HRESULT  hRslt;
  IHello        *pHello;
  ULONG  ulCnt;
  IMoniker * pmk;
  WCHAR  wcsT[</em>MAX_PATH];
  WCHAR  wcsPath[2 * _MAX_PATH];</p>

<p>  // get object path
  wcsPath[0] = &lsquo;\0&rsquo;;
  wcsT[0] = &lsquo;\0&rsquo;;
  if( argc > 1) {</p>

<pre><code>  mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
  wcsupr(wcsPath);
  }
</code></pre>

<p>  else {</p>

<pre><code>  fprintf(stderr, "Object path must be specified\n");
  return(1);
  }
</code></pre>

<p>  // get print string
  if(argc > 2)</p>

<pre><code>  mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
</code></pre>

<p>  else</p>

<pre><code>  wcscpy(wcsT, L"Hello World");
</code></pre>

<p>  printf(&ldquo;Linking to object %ws\n&rdquo;, wcsPath);
  printf(&ldquo;Text String %ws\n&rdquo;, wcsT);</p>

<p>  // Initialize the OLE libraries
  hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);</p>

<p>  if(SUCCEEDED(hRslt)) {</p>

<pre><code>  hRslt = CreateFileMoniker(wcsPath, &amp;pmk);
  if(SUCCEEDED(hRslt))
</code></pre>

<p>   hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&amp;pHello);</p>

<pre><code>  if(SUCCEEDED(hRslt)) {
</code></pre>

<p>   // print a string out
   pHello->PrintSz(wcsT);</p>

<p>   Sleep(2000);
   ulCnt = pHello->Release();
   }</p>

<pre><code>  else
</code></pre>

<p>   printf(&ldquo;Failure to connect, status: %lx&rdquo;, hRslt);</p>

<pre><code>  // Tell OLE we are going away.
  CoUninitialize();
  }
</code></pre>

<p>  return(0);
  }
```</p>

<h4>Apprentice Hacker</h4>

<p>```
  #!/usr/local/bin/perl
  $msg=&ldquo;Hello, world.\n&rdquo;;
  if ($#ARGV >= 0) {</p>

<pre><code>while(defined($arg=shift(@ARGV))) {
  $outfilename = $arg;
  open(FILE, "&gt;" . $outfilename) || die "Can't write $arg: $!\n";
  print (FILE $msg);
  close(FILE) || die "Can't close $arg: $!\n";
}
</code></pre>

<p>  } else {</p>

<pre><code>print ($msg);
</code></pre>

<p>  }
  1;
```</p>

<h4>Experienced Hacker</h4>

<p><code>
  #include &lt;stdio.h&gt;
  #define S "Hello, World\n"
  main(){exit(printf(S) == strlen(S) ? 0 : 1);}
</code></p>

<h4>Seasoned Hacker</h4>

<p><code>
  % cc -o a.out ~/src/misc/hw/hw.c
  % a.out
</code></p>

<h4>Guru Hacker</h4>

<p><code>
  % echo "Hello, world."
</code></p>

<h4>New Manager</h4>

<p><code>
  10 PRINT "HELLO WORLD"
  20 END
</code></p>

<h4>Middle Manager</h4>

<p><code>
  mail -s "Hello, world." bob@b12
  Bob, could you please write me a program that prints "Hello, world."?
  I need it by tomorrow.
  ^D
</code></p>

<h4>Senior Manager</h4>

<p><code>
  % zmail jim
  I need a "Hello, world." program by this afternoon.
</code></p>

<h4>Chief Executive</h4>

<p><code>
  % letter
  letter: Command not found.
  % mail
  To: ^X ^F ^C
  % help mail
  help: Command not found.
  % damn!
  !: Event unrecognized
  % logout
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The History of X86]]></title>
    <link href="https://happy123.me/blog/2018/09/12/the-history-of-x86/"/>
    <updated>2018-09-12T10:22:01+08:00</updated>
    <id>https://happy123.me/blog/2018/09/12/the-history-of-x86</id>
    <content type="html"><![CDATA[<p>我们平时老看到<code>X86指令集</code>, <code>X86架构</code>等等词汇，很容易就猜到这个86来源于Intel那款名动天下的处理器&mdash;8086，那么8086的名字又是怎么来的呢？</p>

<!-- more -->


<p>这是一个遥远的传说，各种解释众说纷纭，挑两个有说服力的段子吧:</p>

<h4>说法1</h4>

<p>当intel发明第一颗4位的位处理器的时候，intel把他叫4004。在当时，intel也没有意识到这就是微处理器，（微处理器是后来人的说法），intel当时只是给做手持计算器的厂家来定制处理器。</p>

<p>因为4004的指令集很有限，所以又搞出来了一个升级版本4040。</p>

<p>8008是4004的8位版，8080是4040的8位版。</p>

<p>8085是8080的单5伏电压版。</p>

<p>8085升级到16位后，就叫8086了。</p>

<p>嗯，还是很有逻辑的。</p>

<h4>说法2</h4>

<p>微处理器是在70年代末发明的。 接近80年，所以，前两个数字就是这么来的;</p>

<p>当时微处理器是8位的，因此，第3个数字是8;</p>

<p>在8085和8086 cpu之前，8080处理器是需要+5-5和12v电压来工作。 随着技术的进步，只需要单一的5v供电了，因此，最后一个数字是5;</p>

<p>8085升级到16位后，就叫8086了;</p>

<p>好吧，也说得通。</p>

<h4>不管怎么说，反正Intel推出的8086在历史上的经典地位不容置疑；那我们来简单回顾一下Intel CPU发展的历史吧</h4>

<ul>
<li><p>20世纪70年代末，Intel生产了著名的16位8086处理器，之后又推出了80186与80286；</p></li>
<li><p>1985年，Intel继摩托罗拉之后，第二个研制出32位的微处理器80386；</p></li>
<li><p>8086、80286、80386等等，这一系列CPU就称作x86，正式一点称作IA-32（Intel Architecture 32-bit）。正是这个架构开启了Intel在个人PC CPU领域的无敌之路，后来的操作系统、编译器、应用软件无一不是把<code>适配X86指令</code>作为核心竞争力；</p></li>
<li><p>1989年，Intel推出80486处理器，具有浮点运算功能；</p></li>
<li><p>因为当初与Intel竞争微处理器的摩托罗拉公司是以86开头的，如68000，68010，68020，而且AMD也崭露头角，他们也搞出来AM386，AM486等等，令Intel不胜其烦；而当时的法律不允许将数字注册为商标，于是1993年，Intel推出奔腾(Pentium)处理器，不再以数字命名其产品；Pentium刚刚推出的时候，命名及其混乱，有人叫I586，有人叫P5，有人叫PI，还有人叫奔腾的芯，更别提什么梦幻神器，裸奔天下等等搞笑名词了~~不管怎么说，那时候伴随我们记忆的不只是Pentium这个名字，还有那个经典的"等等等你等"的广告音乐，Intel又凭借Pentium这个架构继续无敌并寂寞着</p></li>
<li><p>在Pentium时代，其实AMD也不是毫无作为，老一代DIY玩家们一定还对Athlon K7的传说记忆犹新，尤其是当时那些拉风的译名，什么"速龙"、"毒龙"、"钻龙"等等，我得说，这个时期的农企实在是很时髦，远远不像他们后来的市场部那么傻13</p></li>
<li><p>当然，当时最璀璨的舞者，我只献给活在DIYer心里那个最美好的名字&mdash;图拉丁赛扬；正是这款CPU成为了许多人的电脑时代的启蒙者</p></li>
<li><p>2001年开始，Intel将用于服务器以及工作站的Pentium 4 Xeon独立成全新的品牌“Xeon”（至强）)；正如这个名字所蕴含的霸气一样，这个品牌延续到了今天</p></li>
<li><p>2006年，Intel发布“Core”（酷睿）品牌，用作英特尔的旗舰级处理器系列的新品品牌； 然后，这个品牌经历了数代架构更迭，一直伴随我们到了今天</p></li>
<li><p>同样的，围绕指令集从32位跃迁到64位的过程中，AMD和Interl在这段时间还爆发了一场惊天缠斗；Intel作为CPU市场的领跑者，觉得自己理应主导32位到64位时代跃进的浪潮；早在Pentium时代，他们就制定了Intel 64计划；然而，由于一个大公司内部的种种政治斗争，市场斗争，人的本性里面悲剧的傲慢，这个过程种出现了种种败着昏棋，最终AMD64架构在IA-32上新增了64位寄存器，并兼容早期的16位和32位软件，可使现有以x86为对象的编译器容易转为AMD64版本，在2003年9月推出了AMD64；在64位时代由追随者变成领跑者</p></li>
<li><p>Intel此时如梦方醒，慌忙将AMD的指令集拿过来稍作加工推出自己的兼容产品；然后就是两个公司营销和市场人员、法律人员旷日持久的撕逼大战；中间诞生了许许多多匪夷所思的营销名词，比如A64, I64, IA32E，iAMD64，Intel64，X86-64等等等等；如果你是一个Linux爱好者，很容易看到各个软件包都会注明Amd64, X86_64等等，这是那场混乱大战的遗留物</p></li>
</ul>


<h4>总结一下现在的主流</h4>

<ul>
<li><p>32/64 位系统编译在32位系统上运行 => x86</p></li>
<li><p>32 系统上编译64位系统上运行 => x86_amd64</p></li>
<li><p>64 系统上编译在64位系统上运行 => amd64</p></li>
</ul>


<h4>看看MSDN的解释:</h4>

<blockquote><p>The following list describes the various versions of cl.exe (the Visual C++ compiler):</p>

<p>x86 on x86
Allows you to create output files for x86 machines. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.
Itanium on x86 (Itanium cross-compiler)
Allows you to create output files for Itanium. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.</p>

<p>x64 on x86 (x64 cross-compiler)
Allows you to create output files for x64. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.</p>

<p>Itanium on Itanium
Allows you to create output files for Itanium. This version of cl.exe runs as a native process on an Itanium machine.</p>

<p>x64 on x64
Allows you to create output files for x64. This version of cl.exe runs as a native process on an x64 machine.</p></blockquote>

<h4>总之CPU的历史生动说明了了计算机界的很多老梗是如何诞生的，比如很多人都疑惑为什么Windows的发布名称是Win95->W98->W98SE->Win2000(NT)&ndash;>WinXP->Vista->Win7->Win10，等等等等；这种现象是商业环境、市场营销、法律风险以及随意拍脑门的高管，放荡不羁的开发团队合力促成的~~~</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从WebAssembly说开去]]></title>
    <link href="https://happy123.me/blog/2018/08/25/cong-webassemblyshuo-kai-qu/"/>
    <updated>2018-08-25T11:14:39+08:00</updated>
    <id>https://happy123.me/blog/2018/08/25/cong-webassemblyshuo-kai-qu</id>
    <content type="html"><![CDATA[<p>科技界历史循环，轨迹无法量化预测。</p>

<p>前几天看到bellard都在浏览器里面用WebAssembly跑虚拟机了，点进去试试，竟然模拟Win2000都有模有样了。</p>

<p><a href="https://bellard.org/jslinux/index.html">https://bellard.org/jslinux/index.html</a></p>

<p>不由得感叹人折腾的能力真是无比强大。</p>

<!-- more -->


<p>有人说WebAssembly又实现了一个Flash，又实现了一个SliverLight，又造了一个JavaApplet，我都想到很久很久之前的ActiveX了，想到COM组件了~~~</p>

<p>肯定又会有人跳出来说，这回不一样了:</p>

<ol>
<li><p>谷歌、苹果、微软等公司一起来干了</p></li>
<li><p>前端拯救世界，前端用Nodejs打入后端，后端用WebAssembly征服前端~~</p></li>
<li><p>就连技术媒体都开始用吸睛标题：&lt;WebAssembly:解决 JavaScript 痼疾的一颗银色子弹？></p></li>
</ol>


<p>我得说，技术路线的发展完全是随机的，无迹可寻。</p>

<ul>
<li><p>比如当初Flash就被乔帮主活活说死了，说你不行行也不行。</p></li>
<li><p>比如Plan9搞了一堆创新之后死翘翘了，根本就没几个人去在意</p></li>
<li><p>比如苦大仇深的GUI方案，MS推出了一系列库，从MFC、WTL到所谓的WPF，从各类公司的私有解决方案，到现在还在服役的大名鼎鼎的Duilib;最后就不提历史风尘中的各类商业皮肤库了；</p>

<p>   还有开源界的各路GNome、wxWidgets、QT、TCL，到现在跨平台GUI方案的战火都烧到浏览器上了，VS Code用啥实现的，竟然是Electron；虽然效果拔群，但是总觉得哪里不对路啊；</p></li>
<li><p>从移动手机刚刚兴起的年代，就有无数种解决方案发誓要做到"一次编写，到处运行"，兼容各大主流移动平台；如今看看，口号依旧，分裂依旧，半死不活依旧</p></li>
<li><p>为什么历史选择TCP/IP而把ISO模型扫进教科书</p></li>
<li><p>为什么IE打败Netscape</p></li>
<li><p>为什么KVM逐渐压倒Xen</p></li>
</ul>


<p>历史只是偶然，成败听凭运气，没有什么道理好讲的。</p>

<p>我只能根据有限的经验来预言：任何一种号称"大一统方案"的方案最后总是失败。</p>

<p>让我们再大声诵读伟大的Fred Brooks先知的预言：没有银弹，没有银弹，没有银弹~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非烫即屯]]></title>
    <link href="https://happy123.me/blog/2018/08/25/fei-tang-ji-tun/"/>
    <updated>2018-08-25T09:34:43+08:00</updated>
    <id>https://happy123.me/blog/2018/08/25/fei-tang-ji-tun</id>
    <content type="html"><![CDATA[<p>好久没有打开过VC++了，今天为了修改一个远古控件打开了久违的VC++，DEBUG模式下又看到了久违的"烫烫烫烫烫"~~~~</p>

<!-- more -->


<p>VC runtime debug version会把stack初始化成0xcc，unicode中0xcccc(双字节)就是中文的烫。如果你开了个char[]，然后最后一个字符忘了设置成0x00，然后去printf这个字符，那么整个stack从这个局部字符数组开始都输出到console，就变成了“烫烫烫烫烫”。</p>

<p>为啥把stack初始化成0xcc而不是0x00呢？是因为0xcc在intel x86芯片指令集中代表int 3，也就是debug中断，该指令会自动把程序停在单步调试状态，然后去寻找系统中注册的调试器，如果找不到调试器，那么就会终止程序。这一开始是为了调试栈缓冲溢出错误的。如果出现溢出，并且代码尝试执行缓冲中的指令，就会进入单步调试状态。</p>

<p>这是debug version, 那么release verion呢？发布版会把栈初始化成0xcd，这个就是imm8，就是立即中断退出的意思。这时候因为运行在用户机器上，没有调试器，也不希望用户来调试你的程序。0xcdcd就是中文的“屯”字。你会看见一些写的超烂的程序经常会出现“屯屯屯屯屯屯”。的确挺屯的，</p>

<p>在今天这个芯片DEP，操作系统NX锁定双保险的时代，这种初始化已经没有啥必要了，这个烫屯还存在纯粹是历史原因。</p>

<p>所以在那个电脑还比较古早的年代，说人品不好，那叫非奸即盗。说程序写的烂，那叫非烫即屯。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crawler ABC]]></title>
    <link href="https://happy123.me/blog/2018/07/04/crawler-abc/"/>
    <updated>2018-07-04T19:04:58+08:00</updated>
    <id>https://happy123.me/blog/2018/07/04/crawler-abc</id>
    <content type="html"><![CDATA[<p>一个小爬虫的主要的套路就是requests, beautifulsoup, phantomjs.</p>

<!-- more -->


<h2>requests</h2>

<p>```
def get_html(url):</p>

<pre><code>headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0',
    'Accept': 'application/json, text/plain, */*',
    'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',
    'Accept-Encoding': 'gzip, deflate, br',
    'Content-Type': 'application/x-www-form-urlencoded',
}
resp = requests.get(url, headers=headers)
if resp.status_code == 200:
    return resp.content
else:
    raise ValueError("Not valid response:{}".format(resp.content))
</code></pre>

<p>```</p>

<h2>beautifulsoup</h2>

<p>```
from bs4 import BeautifulSoup
def get_username(html):</p>

<pre><code>soup = BeautifulSoup(html, 'lxml')
user_div = soup.find(id='uhd')
username = user_div.find('h2', class_='mt').get_text().strip()
return username
</code></pre>

<p>```</p>

<h2>phantomjs</h2>

<p>用法非常简单，但是每次都得去查文档，封装成一个傻瓜类比较实在</p>

<p>```
class WebClient(object):</p>

<pre><code>USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",
    "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",
    "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",
    "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
    "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",
    "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",
    "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",
    "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",
    "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
    "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",
    "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"
]

def __init__(self, phantomjs_driver_path='/usr/local/bin/phantomjs'):
    # 引入配置对象DesiredCapabilities
    dcap = dict(DesiredCapabilities.PHANTOMJS)

    # 从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器
    dcap["phantomjs.page.settings.userAgent"] = (random.choice(self.USER_AGENTS))

    # 不载入图片，爬页面速度会快很多
    dcap["phantomjs.page.settings.loadImages"] = False

    # 设置代理
    # service_args = ['--proxy=127.0.0.1:1080', '--proxy-type=http']

    # 打开带配置信息的phantomJS浏览器
    self._driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap)

    # 隐式等待5秒，可以自己调节
    self._driver.implicitly_wait(5)

    # 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项
    # 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。
    self._driver.set_page_load_timeout(10)
    # 设置10秒脚本超时时间
    self._driver.set_script_timeout(10)

@property
def driver(self):
    return self._driver
</code></pre>

<p>```</p>

<p>用起来也很简单，拿登陆163邮箱做例子:</p>

<p>```
def login_163(email, password):</p>

<pre><code>login_url = 'http://m65.mm.mail.163.com/'
driver = WebClient().driver
driver.get(login_url)
driver.implicitly_wait(10)

try:
    driver.execute_script('document.querySelector(".m-footer").querySelector("a").click();')
    driver.execute_script('document.getElementById("entryMail").click();')
except Exception as _:
    pass

time.sleep(3)
driver.find_element_by_xpath('//input[@name="username"]').send_keys(email.split('@')[0])
driver.find_element_by_xpath('//input[@name="password"]').send_keys(password)
mail_select = Select(driver.find_element_by_xpath('//select[@name="domain"]'))
mail_select.select_by_value(email.split('@')[-1])
# driver.save_screenshot(email + '.png')

# submit
driver.find_element_by_id('submit').submit()
driver.implicitly_wait(10)
time.sleep(5)
# driver.save_screenshot(email + '.login.png')

login_info = driver.find_element_by_xpath('//div[@class="fgreet"]/strong').text
driver.quit()

return login_info.strip() == email
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
