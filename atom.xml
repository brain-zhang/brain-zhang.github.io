<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-09-02T10:10:46+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-1]]></title>
    <link href="https://happy123.me/blog/2019/09/01/wu-en-da-ji-qi-xue-xi-bi-ji/"/>
    <updated>2019-09-01T15:59:41+08:00</updated>
    <id>https://happy123.me/blog/2019/09/01/wu-en-da-ji-qi-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p class="info">这个系列教程大名鼎鼎，之前我都是用到啥就瞎试一通；最近花了两个周，认认真真把这些基础知识重新学了一遍；做个笔记；
苏老泉二十七始发愤，我这比他还落后；不过求知的旅途，上路永远不嫌晚，我一直在路上；</p>

<!-- more -->

<h2 id="supervised-learning">1-监督学习（Supervised Learning)</h2>

<p>根据训练数据是否拥有标记信息，学习任务可大致被分为两类：</p>

<ul>
  <li>
    <p>监督学习（Supervised Learning）监督学习的代表是回归和分类。</p>

    <ul>
      <li>回归:预测连续值的模型: 已知房子大小和房价数据集，预测某一房子的价格</li>
      <li>分类:预测离散值的模型: 已知肿瘤性质和大小数据集，预测肿瘤是否良性</li>
    </ul>
  </li>
  <li>
    <p>无监督学习（Unsupervised Learning） 无监督学习的代表是聚类。</p>
  </li>
</ul>

<h2 id="section">2-单变量线性回归</h2>

<h4 id="section-1">模型表示</h4>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta_{0} + \theta_{1}x
</script>

<h4 id="section-2">代价函数</h4>

<p>求两个值，使模型最为匹配当前数据集；求解匹配度的过程提炼出代价函数；代价函数值越小，匹配度越高</p>

<script type="math/tex; mode=display">
J(\theta_{0}, \theta_{1}) = \frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2}
</script>

<p>当𝜃1=0时，代价函数为一抛物线；
当𝜃0，𝜃1都不为0时，代价函数为一三维曲面；</p>

<h4 id="section-3">自动求解代价函数</h4>

<p>我们我们有函数  𝐽(𝜃0,𝜃1) , 可以不断的调整  𝜃0  和  𝜃1 , 来使得  𝐽(𝜃0,𝜃1)  , 直到  𝐽(𝜃0,𝜃1)  达到最小值为止</p>

<p>梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数 𝐽(𝜃0,𝜃1) 的最小值。</p>

<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合 (𝜃0,𝜃1,……,𝜃𝑛)  ，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到抵达一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。</p>

<p>帅气的梯度下降算法公式:</p>

<script type="math/tex; mode=display">
\theta_{j} := \theta_{j} - \alpha\frac{\partial}{\partial{\theta_{j}}}J(\theta)
</script>

<p>对 𝜃 赋值，使得  𝐽(𝜃) 按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中 𝛼 是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p>

<ul>
  <li>如果 𝛼 太小了，即我的学习速率太小，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</li>
  <li>如果 𝛼 太大，那么梯度下降法可能会越过最低点，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，最终会导致无法收敛，甚至发散。</li>
</ul>

<h2 id="section-4">3-矩阵和向量</h2>

<h4 id="x2">一个2X2矩阵</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a=np.array([[1, 2], [3, 4]])
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-5">向量是列数为1的特殊矩阵:</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b = np.array(np.zeros((3,1)))
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-6">矩阵的加法</h4>

<p>行列数相等的才可以做加法，两个矩阵相加就是行列对应的元素相加。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a = np.mat([[1,0],[2,5],[3,1]])
</span><span class="line">b = np.mat([[4,0.5],[2,5],[0,1]])
</span><span class="line">print ("a: \n",a, "\nb: \n",b)
</span><span class="line">print ("a+b: \n",a+b)  # a + b，矩阵相加
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-7">矩阵的标量乘法</h4>

<p>矩阵和标量的乘法也很简单,就是矩阵的每个元素都与标量相乘。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">print ("a: \n",a)
</span><span class="line">print ("3*a: \n",3* a)  #矩阵标量乘法
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-8">向量乘法</h4>
<p>m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a = np.mat([[-1,2],[2,3]])
</span><span class="line">c = np.mat([[3],[4]])
</span><span class="line">ac = a * c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-9">矩阵乘法的性质</h4>
<ul>
  <li>矩阵的乘法不满足交换律： 𝐴×𝐵≠𝐵×𝐴</li>
  <li>矩阵的乘法满足结合律。即： 𝐴×（𝐵×𝐶）=（𝐴×𝐵）×𝐶</li>
  <li>在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，本讲义都用 I 代表单位矩阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0。</li>
</ul>

<h4 id="section-10">逆矩阵</h4>

<p>矩阵 A 是一个 m×m 矩阵（方阵），如果有逆矩阵，则：𝐴𝐴−1=𝐴−1𝐴=𝐼</p>

<p>没有逆矩阵的矩阵, 称为奇异 (singlar/degenerate)矩阵</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">
</span><span class="line">a = np.mat([[1,2],[3,4]])
</span><span class="line">print ('a:\n',a)
</span><span class="line">res = np.linalg.inv(a)
</span><span class="line">print('a inverse:\n', res)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>备注: 再octave中，可以用pinv函数(伪逆矩阵)对奇异矩阵求逆；</p>

<h4 id="section-11">矩阵转置</h4>

<p>设 A 为 m×n 阶矩阵（即 m 行 n 列），第 i 行 j 列的元素是 a(i,j)，即：A=a(i,j) 定义 A 的转置为这样一个 n×m 阶矩阵 B，满足 B=a(j,i)，即 b (i,j)=a (j,i)（B 的第 i 行第 j 列元素是 A 的第 j 行第 i 列元素），记  𝐴𝑇=𝐵 。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">a = np.mat([[1,2],[3,4]])
</span><span class="line">print ('a:\n',a)
</span><span class="line">res = a.T
</span><span class="line">print('a transpose:\n', res)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-12">4-多变量线性回归</h2>

<ul>
  <li>引入多种特征后的假设h模型</li>
</ul>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta_{0} + \theta_{1}x_{1} + \theta_{2}x_{2} + ... + \theta_{n}x_{n}
</script>

<p>此时模型中的参数是一个 n+1 维的向量，任何一个训练实例也都是 n+1 维的向量，特征矩阵 X 的维度是 m*(n+1)。 因此公式可以简化为：</p>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta^TX
</script>

<h4 id="section-13">多变量梯度下降</h4>

<p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价 函数是所有建模误差的平方和，即：</p>

<script type="math/tex; mode=display">
J(\theta_{0}, \theta_{1}...\theta_{n}) = \frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2}
</script>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># 代价函数的python代码实现
</span><span class="line">def Cost(X, y, theta):
</span><span class="line">    inner = np.power(((X * theta.T) - y), 2)
</span><span class="line">    return np.sum(inner) / (2 * len(X))
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-14">梯度下降 - 特征缩放</h4>

<p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这可以帮助梯度下降算法更快地收敛。</p>

<p>解决的方法是尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。</p>

<p>最简单的方法是令：</p>

<script type="math/tex; mode=display">
x_n = \frac{x_n - \mu_n}{s_n}
</script>

<p>其中,  𝜇𝑛 是平均值， 𝑠𝑛 是标准差。</p>

<h4 id="section-15">梯度下降 - 学习率</h4>

<ul>
  <li>如果学习率 𝛼 过小，则达到收敛所需的迭代次数会非常高；</li>
  <li>如果学习率 𝛼 过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</li>
</ul>

<p>通常可以考虑尝试些学习率： 0.01，0.03，0.1，0.3，1，3，10; 3倍增长</p>

<h4 id="section-16">特征与多项式回归</h4>

<p>如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。因为幂运算很容易拉大特征之间尺度的差距</p>

<h4 id="section-17">正规方程</h4>

<p>假设我们的训练集特征矩阵为 X（包含了 𝑥0=1 ）并且我们的训练集结果为向量 y， 则利用正规方程解出向量</p>

<script type="math/tex; mode=display">
\theta = (X^TX)^{-1}X^Ty
</script>

<p>只要特征变量的数目并不大，标准方程是一个很好的计算参数 𝜃 的替代方法。具体地说，只要特征变量的数量小于一万，通常使用标准方程法，而不使用梯度下降法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理想中的比特币全节点实现]]></title>
    <link href="https://happy123.me/blog/2019/08/18/li-xiang-zhong-de-bi-te-bi-quan-jie-dian-shi-xian/"/>
    <updated>2019-08-18T15:59:29+08:00</updated>
    <id>https://happy123.me/blog/2019/08/18/li-xiang-zhong-de-bi-te-bi-quan-jie-dian-shi-xian</id>
    <content type="html"><![CDATA[<p>虽然比特币已经运行十年，各式各样的比特币全节点实现已经很多了，但是我觉得还是有必要再增添一员；</p>

<p>我理想中的比特币全节点实现是这样的:</p>

<ul>
  <li>他的核心是模块化可拆分的</li>
  <li>他的核心不包括挖矿和钱包，可以为这两个功能提供接口作为插件来实现，但是不要耦合到核心里面</li>
  <li>他要实现BIP-157和BIP-158，不能为了导入一个新私钥就重新扫描一遍区块链</li>
  <li>他要兼容Lightning，并实现其瞭望塔功能</li>
  <li>交易存储最好用merkle-patricia-tree来实现，如此一来像ElectrumX这样的服务节点就可以去掉了</li>
  <li>他必须原生支持所有的SPV钱包调用，并形成一个BIP规范</li>
  <li>他必须可以是纯SPV，可以是全Block，也可以从一个checkpoint之后只存储需要的block</li>
  <li>最后，他最好能运行在一台1Core 1G 1M的小VPS上面</li>
</ul>

<p>我好像真贪心呢^_^</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Flask RestAPI集成Swagger UI]]></title>
    <link href="https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui/"/>
    <updated>2019-08-18T15:38:02+08:00</updated>
    <id>https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui</id>
    <content type="html"><![CDATA[<p>花了半天时间，给<a href="https://github.com/brain-zhang/chainhorn">chainhorn</a>集成了Swagger;</p>

<p>虽然这种事情已经做过好几遍了，但是不读文档还是没辙；我把这种半吊子形容为“我认识人民币，但是画不出来…T_T”</p>

<p>还是老老实实流水账记一下吧:</p>

<!-- more -->

<h3 id="section">依赖组件</h3>

<ul>
  <li><a href="https://flask-restplus.readthedocs.io">flask-restplus</a></li>
</ul>

<p>restplus能让人很方便的通过几个decorator就可以集成很漂亮的restapi，它提供了api命名空间、Request和Response解析以及Swagger UI的集成</p>

<p>另外，flask-restplus的文档和例子写的非常简洁清晰，赞一个。</p>

<ul>
  <li><a href="https://flask-httpauth.readthedocs.io/en/latest/">flask-httpauth</a></li>
</ul>

<p>用来集成验证机制，支持基本的密码验证、Token验证；短小精悍，够用了</p>

<h3 id="section-1">起步</h3>

<p>引用官网的例子:</p>

<h4 id="api">构建api对象</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from flask import Flask
</span><span class="line">from flask_restplus import Api, Resource, fields
</span><span class="line">from werkzeug.contrib.fixers import ProxyFix
</span><span class="line">
</span><span class="line">app = Flask(__name__)
</span><span class="line">app.wsgi_app = ProxyFix(app.wsgi_app)
</span><span class="line">
</span><span class="line">api = Api(app, version='1.0', title='Chainhorn API',
</span><span class="line">    description='A simple ChainHorn API',
</span><span class="line">)
</span><span class="line">
</span><span class="line">ns = api.namespace('node', description='node operations')
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最重要的是构建了<code>api</code>对象，这样就可以为后面的资源增加url路由、参数解析同能；</p>

<p>下面紧跟着构建了一个<code>ns</code> –<code>namespace</code>对象，作用是为不同的资源，不同的url分组，这样最后反映到界面上好看一点；</p>

<h4 id="section-2">修饰</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ns.route('')
</span><span class="line">  class NodeGetInfo(Resource):
</span><span class="line">      @ns_node.doc('get node info')
</span><span class="line">      def get(self):
</span><span class="line">          '''get node info'''
</span><span class="line">          info = spv.getinfo()
</span><span class="line">          return {'nodeinfo': info}, 200
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最简单的，用<code>@ns.route('')</code>，就定义了根url， 然后后面的套路都是相似的，为资源实现get方法，就直接响应 http Get请求了；</p>

<h4 id="request">Request参数处理</h4>

<p>如果直接在url后面跟参数，那么很方便的用 <code>ns.param</code>定义一下即可:
下面这个函数就直接接受一个 <code>/broadcast/tx12345</code> 这样的tx12345作为参数<code>tx</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ns.route('/broadcast/&lt;string:tx&gt;')
</span><span class="line">  class WalletBroadcastTx(Resource):
</span><span class="line">      @ns.doc('broadcast raw tx')
</span><span class="line">      @ns.param('tx', 'The transaction hash identifier')
</span><span class="line">      def post(self, tx):
</span><span class="line">          '''broadcast raw tx'''
</span><span class="line">          sendrawtransaction(spv, tx)
</span><span class="line">          return {'broadcast': 'ok'}, 200
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果要放在FormData里面，可以用<code>ns.expect</code>来限制；它可以接受一个对象传入；比如上面的例子，要把<code>tx</code>字段放到POST请求的Form Data中，要这样做:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">TxModel = {'tx': fields.String(required=True, description='The hex tx')}
</span><span class="line">@ns.route('/broadcast')
</span><span class="line">  class WalletBroadcastTx(Resource):
</span><span class="line">      @ns.doc('broadcast raw tx')
</span><span class="line">      @ns.expect(TxModel, 200)
</span><span class="line">      def post(self, tx):
</span><span class="line">          '''broadcast raw tx'''
</span><span class="line">          sendrawtransaction(spv, api.payload['tx'])
</span><span class="line">          return {'broadcast': 'ok'}, 200
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="response">Response参数处理</h4>

<p>同样的，如果需要返回一个对象，在界面上出现这个对象的详细描述信息，可以用<code>marshal_with</code>和<code>marshal_list_with</code>来修饰；</p>

<p>具体请参考:</p>

<p>https://flask-restplus.readthedocs.io/en/stable/parsing.html</p>

<h4 id="section-3">用户验证</h4>

<p>例如，为API加上HTTP Token Auth，要用到<code>HTTPTokenAuth</code>对象；</p>

<p>首先我们先定义验证规则:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">auth = HTTPTokenAuth()
</span><span class="line">tokens = {
</span><span class="line">  'APIKEY':'hello',
</span><span class="line">  "APPID": "chainhorn"
</span><span class="line">}
</span><span class="line">
</span><span class="line">@auth.verify_token
</span><span class="line">def verify_token(token):
</span><span class="line">  if request.headers.get('APIKEY', '').strip()==tokens['APIKEY'] and \
</span><span class="line">     request.headers.get('APPID', '').strip() == tokens['APPID']:
</span><span class="line">      return True
</span><span class="line">  else:
</span><span class="line">      return False
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后在每个url 请求处理函数前面加上修饰符<code>auth_login_required</code>；比如我们最开始的例子:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ns.route('')
</span><span class="line">class NodeGetInfo(Resource):
</span><span class="line">  @ns.doc('get node info')
</span><span class="line">  @auth.login_required
</span><span class="line">  def get(self):
</span><span class="line">      '''get node info'''
</span><span class="line">      info = spv.getinfo()
</span><span class="line">      return {'nodeinfo': info}, 200
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样后台验证就有了；那么前台输入呢？</p>

<p>这个例子里面，我们需要前台输入的时候在HTTP Header里面传入两个Key: APIKEY和APPKEY；直接用用Swagger UI自带的组件实现就可以了，把api对象构造为:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">AUTHORIZATIONS = {
</span><span class="line">    'apikey': {
</span><span class="line">        'type': 'apiKey',
</span><span class="line">        'in': 'header',
</span><span class="line">        'name': 'APIKEY'
</span><span class="line">    },
</span><span class="line">    'appid': {
</span><span class="line">        'type': 'apiKey',
</span><span class="line">        'in': 'header',
</span><span class="line">        'name': 'APPID'
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">api = Api(app,
</span><span class="line">        version='v1',
</span><span class="line">        authorizations=AUTHORIZATIONS,
</span><span class="line">        security=list(AUTHORIZATIONS.keys()),
</span><span class="line">        title='Chainhorn API',
</span><span class="line">        description='Chainhorn API',
</span><span class="line">)
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样默认所有的API访问都需要 在HTTP Header中传入两个Key: APIKEY和APPKEY，如果值不对的话就会访问失败；</p>

<p>此时前台的界面是这样的:</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/201908/bg3.jpg" alt="Auth1" /></p>

<p>可以点击右上角的Authorize一次性设置所有API的访问密钥；</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/201908/bg4.jpg" alt="Auth2" /></p>

<p>也可以在每个API的右上角设置访问密钥；</p>

<p>当然，我们目前的密钥是后台写死的，你可以引入一个三方库为每个用户生成不同的密钥存到数据库里面，然后每次验证~~~</p>

<h3 id="section-4">综合例子</h3>

<p>最后，在github上面有个集大成的例子,值得推荐</p>

<p>https://github.com/frol/flask-restplus-server-example</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using a GPG Key and Ssh Auth]]></title>
    <link href="https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth/"/>
    <updated>2019-08-16T16:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth</id>
    <content type="html"><![CDATA[<p>在我的一台服务器被数不清的脚本小子暴力尝试登陆N次后，我下定决心将所有的开发环境换成统一的ssh key；并禁止用户登陆；</p>

<p>其中最折腾的部分就是使用我的GPG Key统一所有的ssh 环境；我也很纳闷，为什么自己没有早点搞定这些事情；</p>

<p>众所周知，GPG和Openssl的key是不兼容的，所以统一环境还是花了不少时间，主要是参考了这篇文章：</p>

<p>https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth</p>

<p>常用命令:
<!-- more --></p>

<h3 id="gpg">GPG</h3>

<ul>
  <li>生成证书</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --gen-key
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>生成撤销证书</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --gen-revoke [用户ID]
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>列出所有密钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --list-keys
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>输出</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/home/brain/.gnupg/pubring.gpg
</span><span class="line">-------------------------------
</span><span class="line">pub   4096R/xxxxxxxx 2018-08-16
</span><span class="line">uid                  brain.zhang (happy123.me) &lt;brain.zhangbin#xxx.com&gt;
</span><span class="line">sub   4096R/yyyyyyyy 2018-08-16
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示subkey。</p>

<ul>
  <li>输出密钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --armor --output public-key.txt --export [用户ID]
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>输出密钥时转换私钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --armor --output private-key.txt --export-secret-keys
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>上传公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --keyserver keys.gnupg.net --send-keys [pub key ID] 
</span><span class="line">...
</span><span class="line">gpg --keyserver keys.gnupg.net --search-keys brain.zhang
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>生成公钥指纹供别人检查</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --fingerprint [用户ID]
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>加密文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>解密文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --decrypt demo.en.txt --output demo.de.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>对文件签名</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --clearsign demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>获得单独的签名文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --armor --detach-sign demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>验证签名</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --verify demo.txt.asc demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section">导入第三方公钥</h3>

<ul>
  <li>获得公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --keyserver keys.gnupg.net --search-keys &lt;user ID&gt;
</span><span class="line">...
</span><span class="line">gpg --keyserver hkp://subkeys.pgp.net --search-keys brain.zhang
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>验证公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> gpg --edit-key &lt;key ID&gt;
</span><span class="line">
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入quit 退出。</p>

<h3 id="githubgpg">在Github中使用GPG</h3>

<ul>
  <li>输出key id</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --list-secret-keys --keyid-format LONG
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>设置提交</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> git config  user.signingkey &lt;key ID&gt;
</span><span class="line">
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>对单次提交进行签名： </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git commit -S -m "-S选项表示对此次提交使用gpg进行签名"
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>签名标签</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git tag -s &lt;tag&gt;
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="ssh-server-gen">ssh server gen</h3>

<ul>
  <li>制作密钥对</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[root@host ~]$ ssh-keygen 
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>把生成的/root/.ssh/id_rsa.pub拷贝到在服务器上，安装公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[root@host ~]$ cd .ssh
</span><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys
</span><span class="line">[root@host .ssh]$ chmod 600 authorized_keys
</span><span class="line">[root@host .ssh]$ chmod 700 ~/.ssh
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>设置 SSHD，打开密钥登录功能
编辑 /etc/ssh/sshd_config 文件，进行如下设置：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PubkeyAuthentication yes
</span><span class="line">PermitRootLogin yes
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</li>
</ul>

<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>

<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>

<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>

<ul>
  <li>验证无误，关闭密码登陆</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PasswordAuthentication no
</span><span class="line">[root@host .ssh]$ service sshd restart
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Requests Post for 5 Styles]]></title>
    <link href="https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles/"/>
    <updated>2019-08-09T09:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles</id>
    <content type="html"><![CDATA[<h4 id="requestspost">requests库发送post请求的五种姿势;</h4>

<!-- more -->

<h4 id="applicationx-www-form-urlencoded">1.application/x-www-form-urlencoded</h4>

<p>最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。请求类似于下面这样:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST http://www.example.com HTTP/1.1    Content-Type:
</span><span class="line">application/x-www-form-urlencoded;charset=utf-8
</span><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>requests默认处理就是这种方式， exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">url = 'http://httpbin.org/post'
</span><span class="line">d = {'key1': 'value1', 'key2': 'value2'}
</span><span class="line">r = requests.post(url, data=d)
</span><span class="line">print r.text
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="multipartform-data">2.multipart/form-data</h4>

<p>除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。
这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值:</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from requests_toolbelt import MultipartEncoder
</span><span class="line">import requests
</span><span class="line">
</span><span class="line">m = MultipartEncoder(
</span><span class="line">    fields={'field0': 'value', 'field1': 'value',
</span><span class="line">            'field2': ('filename', open('file.py', 'rb'), 'text/plain')}
</span><span class="line">    )
</span><span class="line">
</span><span class="line">r = requests.post('http://httpbin.org/post', data=m,
</span><span class="line">                  headers={'Content-Type': m.content_type})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="applicationjson">3.application/json</h4>

<p>application/json 这个 Content-Type作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">url = 'http://httpbin.org/post'
</span><span class="line">s = json.dumps({'key1': 'value1', 'key2': 'value2'})
</span><span class="line">r = requests.post(url, data=s)
</span><span class="line">print r.text
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',data=json.dumps({'key1':'value1','key2':'value2'}),headers={'Content-Type':'application/json'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',json=key1,headers={'Content-Type':'application/json'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="textxml">4. text/xml</h4>
<p>跟json类似，XML 作为编码方式的远程调用规范。</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',data='&lt;?xml  ?&gt;',headers={'Content-Type':'text/xml'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="binary">5. binary</h4>

<p>直接二进制流数据传输，多用于上传图片</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',files={'file':open('test.xls','rb')},headers={'Content-Type':'binary'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">url = 'http://httpbin.org/post'
</span><span class="line">files = {'file': open('report.txt', 'rb')}
</span><span class="line">r = requests.post(url, files=files)
</span><span class="line">print r.text
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSL&TLS Tips]]></title>
    <link href="https://happy123.me/blog/2019/08/04/ssl-tls-tips/"/>
    <updated>2019-08-04T09:35:42+08:00</updated>
    <id>https://happy123.me/blog/2019/08/04/ssl-tls-tips</id>
    <content type="html"><![CDATA[<p>每天的日常编码工作：就是解决一个问题的时候再创造另外一个问题 Orz…..</p>

<p>话说刚才生成一个私钥的时候， Python3绑定libssl1.1 又崩了；正在痛苦思考中~~~</p>

<!-- more -->

<p>现在有两个选择:</p>

<ol>
  <li>放弃ssl动态库调用，反正我只用ECDSA，所以找个原生库来用好啦</li>
  <li>死磕openssl，把它彻底搞明白</li>
</ol>

<p>利弊权衡之下我选择了1，不过当然我也在2上花了一点时间，复习了一下基础知识，在此记录下来。</p>

<h3 id="libssl3">libssl3是个什么东东</h3>

<p>在探究libssl.so的时候，我无意发现我的系统里面还有一个libssl3.so；这个是什么东东？我印象里面openssl还只有1.x版本才对；</p>

<p>我在ubuntu16.04下查看这个so文件来源;</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ locate libssl3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libssl3.so
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>nm看一下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ nm /usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">nm: /usr/lib/x86_64-linux-gnu/libssl3.so: no symbols
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>奇怪，没有任何符号；继续用ldd看一下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ ldd /usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">ldd /usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffe833bb000)
</span><span class="line">        libnss3.so =&gt; /usr/lib/x86_64-linux-gnu/libnss3.so (0x00007faf3cc8a000)
</span><span class="line">        libnssutil3.so =&gt; /usr/lib/x86_64-linux-gnu/libnssutil3.so (0x00007faf3ca5d000)
</span><span class="line">        libplc4.so =&gt; /usr/lib/x86_64-linux-gnu/libplc4.so (0x00007faf3c858000)
</span><span class="line">        libnspr4.so =&gt; /usr/lib/x86_64-linux-gnu/libnspr4.so (0x00007faf3c619000)
</span><span class="line">        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf3c3fc000)
</span><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf3c032000)
</span><span class="line">        libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007faf3be18000)
</span><span class="line">        libplds4.so =&gt; /usr/lib/x86_64-linux-gnu/libplds4.so (0x00007faf3bc14000)
</span><span class="line">        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf3ba10000)
</span><span class="line">        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007faf3b808000)
</span><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007faf3d21d000)
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>嗯，找到了一个有意思的依赖:libnss3.so</p>

<p>再用命令dpkg看一下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ dpkg -S /usr/lib/x86_64-linux-gnu/libnss3.so
</span><span class="line">libnss3:amd64: /usr/lib/x86_64-linux-gnu/libnss3.so
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>基本上确定是libnss3这个库引入的libssl3.so了，最后再用dpkg确认一下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ dpkg-query -L libnss3
</span><span class="line">/.
</span><span class="line">/usr
</span><span class="line">/usr/lib
</span><span class="line">/usr/lib/x86_64-linux-gnu
</span><span class="line">/usr/lib/x86_64-linux-gnu/libnssutil3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreebl3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnssckbi.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreebl3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnsssysinit.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libsmime3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libnss3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">/usr/share
</span><span class="line">/usr/share/doc
</span><span class="line">/usr/share/doc/libnss3
</span><span class="line">/usr/share/doc/libnss3/copyright
</span><span class="line">/usr/share/doc/libnss3/changelog.Debian.gz
</span><span class="line">/usr/share/lintian
</span><span class="line">/usr/share/lintian/overrides
</span><span class="line">/usr/share/lintian/overrides/libnss3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="libnss3">libnss3是个什么东东?</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">apt-cache show libnss3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看了一下，发现是mozilla基金会搞得东东；再google一下，发现是自己孤陋寡闻了；</p>

<p>原来，SSL&amp;TSL的实现，不只是openssl一家独大，像Mozilla Firefox就用自家实现的Nss；</p>

<p>Google Chrome之前也是用Nss的，后来迁移到了openssl，再后来，2014年，openssl1.0.1出现了heartbeat 漏洞，Google干脆自己开了个分支，用自己定制的openssl了；</p>

<p>至于Windows平台的，还有C++阵营的，都有自己实现的ssl库，具体可参见:</p>

<p>https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</p>

<h3 id="nsscentos">nss在centos中</h3>

<p>搜素的过程中，我惊奇的发现，ubuntu和centos上面的curl，竟然链接的libssl也不一样：</p>

<p>ubuntu上的curl默认链接的是openssl，而centos上面默认链接的是libnss3；</p>

<p>耐人寻味啊，莫非redhat系的人发现了什么~~~~</p>

<p>做事要做全套，我分别切换到ubuntu16.04和centos7.2上面，看看他们官方仓库中自带的curl是如何编译的。</p>

<h4 id="centos72">centos7.2</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ rpm -q --requires curl
</span><span class="line">libc.so.6()(64bit)
</span><span class="line">libc.so.6(GLIBC_2.14)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.17)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.2.5)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.3)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.4)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.7)(64bit)
</span><span class="line">libcurl = 7.29.0-51.el7
</span><span class="line">libcurl.so.4()(64bit)
</span><span class="line">libdl.so.2()(64bit)
</span><span class="line">libnspr4.so()(64bit)
</span><span class="line">libnss3.so()(64bit)
</span><span class="line">libnssutil3.so()(64bit)
</span><span class="line">libplc4.so()(64bit)
</span><span class="line">libplds4.so()(64bit)
</span><span class="line">libpthread.so.0()(64bit)
</span><span class="line">libpthread.so.0(GLIBC_2.2.5)(64bit)
</span><span class="line">libsmime3.so()(64bit)
</span><span class="line">libssl3.so()(64bit)
</span><span class="line">libz.so.1()(64bit)
</span><span class="line">rpmlib(CompressedFileNames) &lt;= 3.0.4-1
</span><span class="line">rpmlib(FileDigests) &lt;= 4.6.0-1
</span><span class="line">rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
</span><span class="line">rtld(GNU_HASH)
</span><span class="line">rpmlib(PayloadIsXz) &lt;= 5.2-1
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>用的是libcurl = 7.29.0-51.el7；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ rpm -q --requires libcurl
</span><span class="line">/sbin/ldconfig
</span><span class="line">libc.so.6()(64bit)
</span><span class="line">libc.so.6(GLIBC_2.14)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.15)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.16)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.17)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.2.5)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.3)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.3.4)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.4)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.7)(64bit)
</span><span class="line">libcom_err.so.2()(64bit)
</span><span class="line">libdl.so.2()(64bit)
</span><span class="line">libgssapi_krb5.so.2()(64bit)
</span><span class="line">libgssapi_krb5.so.2(gssapi_krb5_2_MIT)(64bit)
</span><span class="line">libidn.so.11()(64bit)
</span><span class="line">libidn.so.11(LIBIDN_1.0)(64bit)
</span><span class="line">libk5crypto.so.3()(64bit)
</span><span class="line">libkrb5.so.3()(64bit)
</span><span class="line">liblber-2.4.so.2()(64bit)
</span><span class="line">libldap-2.4.so.2()(64bit)
</span><span class="line">libnspr4.so()(64bit)
</span><span class="line">libnss3.so()(64bit)
</span><span class="line">libnss3.so(NSS_3.10)(64bit)
</span><span class="line">libnss3.so(NSS_3.12.1)(64bit)
</span><span class="line">libnss3.so(NSS_3.12.5)(64bit)
</span><span class="line">libnss3.so(NSS_3.2)(64bit)
</span><span class="line">
</span><span class="line">....
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>看到libnss3了,重点输出：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">libnss3.so
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>那么这个包是谁提供的？输入如下命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ rpm -qf /usr/lib64/libnss3.so 
</span><span class="line">    nss-3.36.0-7.1.el7_6.x86_64
</span><span class="line">~ rpm -ql nss
</span><span class="line">/etc/pki/nss-legacy
</span><span class="line">/etc/pki/nss-legacy/nss-rhel7.config
</span><span class="line">/etc/pki/nssdb
</span><span class="line">/etc/pki/nssdb/cert8.db
</span><span class="line">/etc/pki/nssdb/cert9.db
</span><span class="line">/etc/pki/nssdb/key3.db
</span><span class="line">/etc/pki/nssdb/key4.db
</span><span class="line">/etc/pki/nssdb/pkcs11.txt
</span><span class="line">/etc/pki/nssdb/secmod.db
</span><span class="line">/usr/lib64/libnss3.so
</span><span class="line">/usr/lib64/libnssckbi.so
</span><span class="line">/usr/lib64/libsmime3.so
</span><span class="line">/usr/lib64/libssl3.so
</span><span class="line">/usr/lib64/nss/libnssckbi.so
</span><span class="line">...
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>至此水落石出，还可以看到我们熟悉的证书cert8.db文件；但其实 curl 最终使用的根证书库并不是该文件。那 curl 使用的根证书文件在哪儿呢？</p>

<p>使用 curl-config 命令行工具，能够了解更多：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ curl-config --ca                        
</span><span class="line">/etc/pki/tls/certs/ca-bundle.crt
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="ubuntu1604">ubuntu16.04</h4>

<p>ubuntu16上面验证类似，不一一说明了~~~</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ dpkg-query -L libcurl3
</span><span class="line">/.
</span><span class="line">/usr
</span><span class="line">/usr/share
</span><span class="line">/usr/share/doc
</span><span class="line">/usr/share/doc/libcurl3
</span><span class="line">/usr/share/doc/libcurl3/copyright
</span><span class="line">/usr/share/doc/libcurl3/changelog.Debian.gz
</span><span class="line">/usr/share/doc/libcurl3/NEWS.Debian.gz
</span><span class="line">/usr/share/lintian
</span><span class="line">/usr/share/lintian/overrides
</span><span class="line">/usr/share/lintian/overrides/libcurl3
</span><span class="line">/usr/lib
</span><span class="line">/usr/lib/x86_64-linux-gnu
</span><span class="line">/usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0
</span><span class="line">/usr/lib/x86_64-linux-gnu/libcurl.so.3
</span><span class="line">/usr/lib/x86_64-linux-gnu/libcurl.so.4
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ apt-cache depends  libcurl3
</span><span class="line">  Depends: libc6
</span><span class="line">  Depends: libgssapi-krb5-2
</span><span class="line">  Depends: libidn11
</span><span class="line">  Depends: libldap-2.4-2
</span><span class="line">  Depends: librtmp1
</span><span class="line">  Depends: libssl1.0.0
</span><span class="line">  Depends: zlib1g
</span><span class="line">  Recommends: ca-certificates
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后寻找libcurl的依赖库:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ ldd /usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0|grep ssl
</span><span class="line">libssl.so.1.0.0 =&gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fbdf8aa0000)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>验证一下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ apt-cache depends openssl
</span><span class="line">openssl
</span><span class="line">  Depends: libc6
</span><span class="line">  Depends: libssl1.0.0
</span><span class="line">  Suggests: ca-certificates
</span><span class="line">  
</span><span class="line">~ apt-cache rdepends  libssl1.0.0 | grep curl
</span><span class="line">  libcurl3  
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section">总结</h3>

<p>所以这就是想要解决一个问题的中途，又被带到了另外一条小路上；该说我是还有那么一点好奇心呢？还是注意力不集中呢？</p>

<p>Orz………</p>

<h3 id="section-1">参考资料:</h3>

<p>https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</p>

<p>https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</p>

<p>https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</p>

<p>https://www.lbbniu.com/6680.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import ctypes
</span><span class="line">import logging
</span><span class="line">
</span><span class="line">try:
</span><span class="line">    ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</span><span class="line">except Exception:
</span><span class="line">    ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</span><span class="line">
</span><span class="line">def check_result(val, func, args):
</span><span class="line">    if val == 0:
</span><span class="line">        raise ValueError
</span><span class="line">    else:
</span><span class="line">        return ctypes.c_void_p(val)
</span><span class="line">
</span><span class="line">
</span><span class="line"># ssl_library.EC_KEY_new.restype = ctypes.c_void_p
</span><span class="line">ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
</span><span class="line">ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result
</span><span class="line">
</span><span class="line">k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)
</span><span class="line">
</span><span class="line">if ssl_library.EC_KEY_generate_key(k) != 1:
</span><span class="line">    raise Exception("internal error")
</span><span class="line">ssl_library.EC_KEY_free(k)
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段代码在多线程的时候会出现segmentation fault error； google一下发现<code>EC_KEY_generate_key</code>并不是线程安全的；于是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">openssl_locks = [threading.Lock() for _ in range(ssl_library.CRYPTO_num_locks())]
</span><span class="line">openssl_locking_function = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_int, ctypes.c_char_p, ctypes.c_int)
</span><span class="line">openssl_threadid_function = ctypes.CFUNCTYPE(ctypes.c_ulong)
</span><span class="line">
</span><span class="line">@openssl_locking_function
</span><span class="line">def openssl_lock(mode, type, file, line):
</span><span class="line">    if (mode &amp; CRYPTO_LOCK) != 0:
</span><span class="line">        openssl_locks[type].acquire()
</span><span class="line">    else:
</span><span class="line">        openssl_locks[type].release()
</span><span class="line">
</span><span class="line">@openssl_threadid_function
</span><span class="line">def openssl_threadid():
</span><span class="line">    v = threading.current_thread().ident
</span><span class="line">    return v
</span><span class="line">
</span><span class="line">ssl_library.CRYPTO_set_id_callback(openssl_threadid)
</span><span class="line">ssl_library.CRYPTO_set_locking_callback(openssl_lock)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>诡异的是还是不定时的crash掉，又一通google之后发现是openssl1.0.0的实现问题，参考:</p>

<p>https://bugs.python.org/issue29340</p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒容器技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->

<h2 id="section">文档操作</h2>

<h4 id="section-1">增加一条记录</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PUT /website/_doc/1
</span><span class="line">{
</span><span class="line">  "title": "My 2 blog entry",
</span><span class="line">  "text":  "I am starting to get the hang of this...",
</span><span class="line">  "date":  "2014/01/02"
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-2">修改</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST /website/_update/1
</span><span class="line">{
</span><span class="line">   "doc" : {
</span><span class="line">      "tags" : [ "testing..." ],
</span><span class="line">      "views": 0
</span><span class="line">   }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-3">查询</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">
</span><span class="line">GET /website/_source/1
</span><span class="line">
</span><span class="line">GET /website/_mget 
</span><span class="line">{
</span><span class="line">    "ids" : [ "2", "1" ]    
</span><span class="line">}
</span><span class="line">
</span><span class="line">GET /_search
</span><span class="line">{
</span><span class="line">    "query": YOUR_QUERY_HERE
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-4">删除</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">DELETE /website/_doc/1
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="api">文档功能API</h2>

<h4 id="section-5">获取映射信息</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_mapping
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-6">测试分析器</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_analyze
</span><span class="line">{
</span><span class="line">  "field": "tweet",
</span><span class="line">  "text": "Black-cats" 
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-7">多层级对象用扁平化的方法来存储，比如</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">  "gb": {
</span><span class="line">    "tweet": { 
</span><span class="line">      "properties": {
</span><span class="line">        "tweet":            { "type": "string" },
</span><span class="line">        "user": { 
</span><span class="line">          "type":             "object",
</span><span class="line">          "properties": {
</span><span class="line">            "id":           { "type": "string" },
</span><span class="line">            "gender":       { "type": "string" },
</span><span class="line">            "age":          { "type": "long"   },
</span><span class="line">            "name":   { 
</span><span class="line">              "type":         "object",
</span><span class="line">              "properties": {
</span><span class="line">                "full":     { "type": "string" },
</span><span class="line">                "first":    { "type": "string" },
</span><span class="line">                "last":     { "type": "string" }
</span><span class="line">              }
</span><span class="line">            }
</span><span class="line">          }
</span><span class="line">        }
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>会被转换为如下内部对象:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    "tweet":            [elasticsearch, flexible, very],
</span><span class="line">    "user.id":          [@johnsmith],
</span><span class="line">    "user.gender":      [male],
</span><span class="line">    "user.age":         [26],
</span><span class="line">    "user.name.full":   [john, smith],
</span><span class="line">    "user.name.first":  [john],
</span><span class="line">    "user.name.last":   [smith]
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="nested-object">内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2 id="section-8">查询</h2>

<h4 id="section-9">查询语句的结构</h4>

<ul>
  <li>一个查询语句 的典型结构：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    QUERY_NAME: {
</span><span class="line">        ARGUMENT: VALUE,
</span><span class="line">        ARGUMENT: VALUE,...
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>如果是针对某个字段，那么它的结构如下：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    QUERY_NAME: {
</span><span class="line">        FIELD_NAME: {
</span><span class="line">            ARGUMENT: VALUE,
</span><span class="line">            ARGUMENT: VALUE,...
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>一条复合语句</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    "bool": {
</span><span class="line">        "must": { "match":   { "email": "business opportunity" }},
</span><span class="line">        "should": [
</span><span class="line">            { "match":       { "starred": true }},
</span><span class="line">            { "bool": {
</span><span class="line">                "must":      { "match": { "folder": "inbox" }},
</span><span class="line">                "must_not":  { "match": { "spam": true }}
</span><span class="line">            }}
</span><span class="line">        ],
</span><span class="line">        "minimum_should_match": 1
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-10">实战查询</h4>

<ul>
  <li>精确查询</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "constant_score" : {
</span><span class="line">      "filter":{
</span><span class="line">        "term": {
</span><span class="line">          "title": "helloworld"
</span><span class="line">        }
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>多词组合</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match": {
</span><span class="line">            "title": {      
</span><span class="line">                "query":    "BROWN DOG!",
</span><span class="line">                "operator": "and"
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>短语匹配</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match_phrase": {
</span><span class="line">            "title": "quick brown fox"
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>混合短语匹配</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match_phrase": {
</span><span class="line">            "title": {
</span><span class="line">                "query": "quick fox",
</span><span class="line">                "slop":  1
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>正则查询 (性能慢)</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /my_index/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "wildcard": {
</span><span class="line">            "postcode": "W?F*HW" 
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>智能匹配</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /my_index/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match_phrase_prefix" : {
</span><span class="line">            "brand" : {
</span><span class="line">                "query":          "johnnie walker bl",
</span><span class="line">                "max_expansions": 50
</span><span class="line">                }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>控制精度</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "match": {
</span><span class="line">      "title": {
</span><span class="line">        "query":                "quick brown dog",
</span><span class="line">        "minimum_should_match": "75%"
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "bool": {
</span><span class="line">      "should": [
</span><span class="line">        { "match": { "title": "brown" }},
</span><span class="line">        { "match": { "title": "fox"   }},
</span><span class="line">        { "match": { "title": "dog"   }}
</span><span class="line">      ],
</span><span class="line">      "minimum_should_match": 2 
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>按受欢迎度提升权重</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /blogposts/post/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "function_score": { 
</span><span class="line">      "query": { 
</span><span class="line">        "multi_match": {
</span><span class="line">          "query":    "popularity",
</span><span class="line">          "fields": [ "title", "content" ]
</span><span class="line">        }
</span><span class="line">      },
</span><span class="line">      "field_value_factor": { 
</span><span class="line">        "field": "votes" 
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span><span class="line">微调:
</span><span class="line">https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-11">排障</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_validate/query?explain
</span><span class="line">{
</span><span class="line">   "query": {
</span><span class="line">      "match" : {
</span><span class="line">         "text" : "really powerful"
</span><span class="line">      }
</span><span class="line">   }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-12">结果排序</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query" : {
</span><span class="line">        "bool" : {
</span><span class="line">            "filter" : { "term" : { "_id" : 1 }}
</span><span class="line">        }
</span><span class="line">    },
</span><span class="line">    "sort": { "date": { "order": "desc" }}
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-13">索引操作</h2>

<h4 id="section-14">增加</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PUT /my_index
</span><span class="line">{
</span><span class="line">    "settings": { ... any settings ... },
</span><span class="line">    "mappings": {
</span><span class="line">        "type_one": { ... any mappings ... },
</span><span class="line">        "type_two": { ... any mappings ... },
</span><span class="line">        ...
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-15">删除</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">DELETE /my_index
</span><span class="line">DELETE /index_one,index_two
</span><span class="line">DELETE /index_*
</span><span class="line">DELETE /_all
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>#### 配置</p>

<ul>
  <li>number_of_shards</li>
</ul>

<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
  <li>number_of_replicas</li>
</ul>

<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4 id="section-16">重新索引</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST _reindex
</span><span class="line">{
</span><span class="line">  "source": {
</span><span class="line">    "index": "twitter"
</span><span class="line">  },
</span><span class="line">  "dest": {
</span><span class="line">    "index": "new_twitter"
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-17">释放空间</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST /_all/_forcemerge?only_expunge_deletes=true
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python捕获所有异常]]></title>
    <link href="https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang/"/>
    <updated>2019-06-24T12:31:08+08:00</updated>
    <id>https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang</id>
    <content type="html"><![CDATA[<p>摘自 - Python cookbook</p>

<p>老生常谈了，但是在Pyflake检查出E722错误时有时候又犯老毛病。人年纪大了越来越有老年痴呆倾向  -_- …..</p>

<h2 id="section">怎样捕获代码中的所有异常？</h2>

<!-- more -->

<h4 id="exception-">想要捕获所有的异常，可以直接捕获 Exception 即可：</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">   ...
</span><span class="line">except Exception as e:
</span><span class="line">   ...
</span><span class="line">   log('Reason:', e)       # Important!
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个将会捕获除了 <code>SystemExit</code> 、 <code>KeyboardInterrupt</code> 和 <code>GeneratorExit</code> 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。</p>

<h4 id="section-1">讨论</h4>

<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>

<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def parse_int(s):
</span><span class="line">    try:
</span><span class="line">        n = int(v)
</span><span class="line">    except Exception:
</span><span class="line">        print("Couldn't parse")
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>试着运行这个函数，结果如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt;&gt;&gt; parse_int('n/a')
</span><span class="line">Couldn't parse
</span><span class="line">&gt;&gt;&gt; parse_int('42')
</span><span class="line">Couldn't parse
</span><span class="line">&gt;&gt;&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def parse_int(s):
</span><span class="line">    try:
</span><span class="line">        n = int(v)
</span><span class="line">    except Exception as e:
</span><span class="line">        print("Couldn't parse")
</span><span class="line">        print('Reason:', e)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候你能获取如下输出，指明了有个编程错误：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt;&gt;&gt; parse_int('42')
</span><span class="line">Couldn't parse
</span><span class="line">Reason: global name 'v' is not defined
</span><span class="line">&gt;&gt;&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>很明显，你应该尽可能将异常处理器定义的精准一些。 </p>

<p>不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>

<h4 id="section-2">最可怕的例子是我们在处理临时文件的时候，用</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因为碍人的E722, 有人会自作聪明的改成:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except Exception:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正确的办法是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except BaseException:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者更确定的语义之下，每次都清理临时文件，这样更明确，处理更好一点:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except BaseException:
</span><span class="line">    logger.error(....)
</span><span class="line">finally:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>参考:</p>

<p>https://github.com/PyCQA/pycodestyle/issues/703</p>

<p>https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[复利是世界第八大奇迹-爱因斯坦真的说过这句话吗?]]></title>
    <link href="https://happy123.me/blog/2019/06/22/fu-li-shi-shi-jie-di-ba-da-qi-ji-ai-yin-si-tan-zhen-de-shuo-guo-zhe-ju-hua-ma/"/>
    <updated>2019-06-22T18:40:38+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/fu-li-shi-shi-jie-di-ba-da-qi-ji-ai-yin-si-tan-zhen-de-shuo-guo-zhe-ju-hua-ma</id>
    <content type="html"><![CDATA[<p>爱因斯坦说:”复利是世界第八大奇迹”，这句话随处可见于各类理财鸡汤文中，甚至巴菲特也在纪录片中转述过这句话，但是挺奇怪的，爱因斯坦究竟是在何种情况下说出这句“名言”？</p>

<!-- more -->

<p>遍寻Google，发现只有一个地方比较详细的考证了这个事情:</p>

<p>https://skeptics.stackexchange.com/questions/25330/did-einstein-ever-remark-on-compound-interest</p>

<h4 id="section">第一个比较权威的引证来自于《纽约时报》1983年的一期，里面有这么一段:</h4>

<blockquote>
  <p>Asked once what the greatest invention of all times was,Albert Einstein is said to have replied, ‘‘compound interest.’‘His playful sense of humor and other aspects of his personality -as well as his genius - form the subject of a bus tour Sunday to the Institute for Advanced Study at Princeton, N.J., where the physicist worked during the last 20 years of his life</p>
</blockquote>

<p>看样子好像是爱因斯坦出来参观旅游至哪里的时候，幽默回答某个媒体人士的梗；毕竟当时是名人，媒体也不会一直问物理学，就像大家追着问巴菲特比特币一样; </p>

<h4 id="bank-performance-annual-warren-gorham--lamont-1978-p509">第二个比较早的引证来自于1978年的 Bank Performance Annual, Warren, Gorham &amp; Lamont, 1978, p509:</h4>

<p>这个就很直白了，有人问投资啥比较好，爱因斯坦就幽默了一把：“复利”</p>

<p>但是爱因斯坦逝世于1955年，都隔了30多年了还有人去引证这种“小故事”可信度也太低了，类似于知乎上到处都是”鲁迅先生说~~~”</p>

<h4 id="the-american-mathematical-monthly-vol-46-no-9-nov-1939-p595">最近的最靠谱的引用来自于The American Mathematical Monthly, Vol. 46, No. 9, Nov., 1939, p595</h4>

<p>貌似是当时的数学刊物征集读者问题，然后爱因斯坦对某个数学题的解法发表了评论，并表示这道题更好的解法是“复利”综上所述，怎么也找不到爱因斯坦说“复利是世界第八大奇迹”这句话的原梗。</p>

<p>“以讹传讹”可能就是当今各种“xxx曾经说过”的诠释吧。</p>

<p>等待更多资料补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币是泡沫?]]></title>
    <link href="https://happy123.me/blog/2019/06/22/huo-bi-shi-pao-mo/"/>
    <updated>2019-06-22T18:31:19+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/huo-bi-shi-pao-mo</id>
    <content type="html"><![CDATA[<p>诺贝尔经济学奖得主「托马斯·萨金特」的话：客观来说，所有货币都是泡沫？</p>

<p>萨金特教授解释道：</p>

<blockquote>
  <p>“客观来说，所有货币都是泡沫，因为当一种资产交易价格高于基础价值时候就是一种泡沫。我给你一美元，虽然它就是一张纸，但是因为你我承认其交换价值，使得这个价值得以维系。一旦有人不认同了，价值共识链条也将断裂。”</p>
</blockquote>

<p>https://36kr.com/p/5164521</p>

<!-- more -->

<p>关键是”货币”、”泡沫”很难量化。</p>

<p>货币脱胎于商品，但是成为一般等价物之后，就丧失大部分的商品价值，变成纯粹的价格标签。</p>

<p>现在各国发行的纸币基础就是这个国家的信用，假如国破家亡，这些货币将会飞速贬值，这也是可以预见的。</p>

<p>某一国家的货币价格实际上就是这个国家长期信用的折现值。</p>

<p>问题是世界上没有一种方法能用来衡量某一国家的长期信用折现值有多大，而且货币的发行、经济的兴衰完全无法预测。</p>

<p>但是有一点可以保证，没有万世不灭的国家；从长久的尺度来说，一个国家必然灭亡，如果人均寿命远远超过一个国家货币的平均寿命，那么可以称之为泡沫。比如几十年前我们的粮票，本质上也是一种货币，持有粮票的人可能做梦也不会想到说废弃就废弃；但是有很多人家积攒的粮票来不及兑换，就变废纸了：从这方面看，粮票确实是个泡沫，而且直到废止(泡沫破灭)的那一刻，才确认是一个泡沫。</p>

<p>所以可以把货币存在的基础看作是人们无可奈何的选择：人们知道早晚有一天会变成废纸，但这个早晚可能持续几十年，并且迄今为止没有更好的选择：贵金属由于其物理上的局限性无法承担信用交换的职责，利害权衡之下现有的货币制度还是可以接受的。</p>

<p>这种现象放在任何一个高估的资产上面都是成立的，比如大家都知道房价是个泡沫，肯定会跌，但是要是100年之后才跌呢？泡沫是破了，但是和我有什么关系！？</p>

<p>然后衍生到数字货币。我们说数字货币这个东西有点像是宗教，他是建立在数学及信息技术基础上的。如果你愿意，也可以把它看成是一种邪教组织：吸引的小部分核心教众是相信数理逻辑甚于国家信用的一小撮人，其它的都是投机赌博传销企图蹭一把油水的人~~~</p>

<p>那么结论就很清晰了：</p>

<ol>
  <li>数字货币在初期是一种信用抢占器，他的竞争对手是传统世界里面信用缺失的行业；比如博彩、保险、黑市、洗钱、某些投机行业等，这些行业本身及其需要信用的保证，但传统的金融手段无法提供这种保证；所以我们现在看到的是场子里面骗子横行，正说明了数字货币正以强大的吸力吸引传统诈骗行业从业人员</li>
  <li>数字货币第二步的竞争对手是某些信用非常弱小的国家的法币，比如委内瑞拉、津巴布韦等等；这些国家维持泡沫的能力比较弱，所以很容易受攻击</li>
  <li>数字货币第三步的竞争对手是贵金属，当其证明自己的信用吸纳能力超过一些国家的法币之后，这个系统就变成了一个正反馈–他会源源不断的吸纳信用提升价值，然后会吸引更多教众加入其中，这一点非常像传销。但是比传销更高明的是它的核心模式可能会持续非常非常久远的时间</li>
  <li>到底能持续多久远呢？这其实取决于人们的理智和贪婪的比例；一旦进入到泡沫正反馈的快车道，我挺悲观的，毕竟人的贪婪是无度的；当风潮来临时，能守住清明，抵住诱惑不动的人其实很少，所以我觉得数字货币很有可能发展到下一阶段，就是跟非常强势的国家货币竞争了；到了这一步，可能就不是简单的经济问题了，而是主权争夺，这个阶段可能会有围绕意识形态的战争、国家独立、个人建国、卫星劫持以维持系统运转等等等等</li>
  <li>最后，抢占所有的信用高地之后，就看数字货币本身能不能维系、甚至创造信用了，这一点不好预测</li>
</ol>

<h4 id="section">如果从千年的尺度来看，除了贵金属，毫无疑问所有货币都是泡沫。</h4>

<h4 id="section-1">如果从百年的尺度来看，大部分国家的货币是泡沫。</h4>

<h4 id="section-2">如果以十年的尺度来看，也有不少国家的货币寿命小于这个时间的。</h4>

<p>最后，比特币已经运转了10年，还能持续多少年呢？这是个很有意思的问题。</p>

<p>只要没有归零，还有全节点运转，就很难说是泡沫破灭。让我们拭目以待吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于货币的历史传说]]></title>
    <link href="https://happy123.me/blog/2019/06/22/guan-yu-huo-bi-de-li-shi-chuan-shuo/"/>
    <updated>2019-06-22T16:50:46+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/guan-yu-huo-bi-de-li-shi-chuan-shuo</id>
    <content type="html"><![CDATA[<h5 id="section"><人类货币史 /></h5>

<p>https://book.douban.com/subject/27018212/</p>

<!-- more -->

<p>是的，人类社会发明了货币，但至今为止没有谁能宣称自己完全搞明白了这个东西。</p>

<p>可以跟&lt; 三千年来谁铸币&gt;以及&lt; 货币的祸害&gt; 结合起来读，这本书主要描述了历史上的一些货币趣闻，对其意义和作用倒也没有长篇大论，毫无疑问是谦虚明智的做法。</p>

<p>记录一些小tips吧：</p>

<p>==================================</p>

<h4 id="section-1">历史上曾被用作货币的物品有:</h4>

<p>● 贵金属制成的条状物（例如古代美索不达米亚、现代的国家中央银行）</p>

<p>● 盐［盐在北非、中国和地中海地区都是用于保存食物、增加风味的重要商品，曾一度充当货币；“salary”（薪水）一词源于拉丁词语sal，代表salt，意为“盐”］</p>

<p>● 牛［例如在古印度和古代非洲。“pecuniary”（金钱的）一词源于拉丁词语pecus，即“cattle”（牛）；“capital”（资本）一词源于拉丁词语capita，即“head”（头）；印度货币卢比源于rupa，即“head of cattle”（一头牛）］</p>

<p>● 奴隶（例如古罗马、古希腊、现代印度的部分地方）</p>

<p>● 可可豆、纺织物（古代墨西哥）</p>

<p>● 玛瑙贝壳（古代中国、马尔代夫）</p>

<p>● 珠子（用于非洲奴隶贸易）</p>

<p>● 羽毛（圣克鲁斯群岛、所罗门群岛）</p>

<p>● 犬牙（巴布亚新几内亚）</p>

<p>● 鲸牙（斐济）</p>

<p>● 巨型、难以移动的石盘［太平洋雅浦（Yap）岛］</p>

<p>● 刀或其他工具（非洲部分地区）</p>

<p>● 铁戒指和手镯（非洲部分地区）</p>

<p>● 铜棒［西非的蒂夫（Tiv）族］</p>

<p>● 啄木鸟头皮［加州腹地的卡罗克（Karok）人］</p>

<p>● 人头骨（苏门答腊岛）</p>

<p>● 赌场筹码［19世纪暹罗（泰国）的一些城市］</p>

<p>● 贝壳念珠珠串（美国殖民地）</p>

<p>● 烟草或库存烟草的收据（美国殖民地）</p>

<p>● 香烟（战俘集中营、战后的德国、现代监狱——香烟不受通胀影响，因为一旦价值暴跌，就会被人们立即使用）</p>

<p>● 碳排放信用额</p>

<p>● 二进制信息（例如比特币）</p>

<h4 id="section-2">关于货币的那些字眼：</h4>

<p>公元前300年左右，在罗马，铸币最初在朱诺·墨涅塔（Juno Moneta）的神庙里铸造。墨涅塔是负责庇护金钱的女神，墨涅塔也是“钱”（money）一词的词源。</p>

<p>贝类在历史上曾长期充当过货币的角色， 在汉字中，一般与钱财有关的字，全和贝有关：贡 财 败 贬 贩 贯 货 贫 贪 购 贮 账 贵 费 贰 贷 贺…； 在英文中，我们最熟悉的就是shell out了。</p>

<h4 id="section-3">货币的起源：</h4>

<p>在 1990 年代晚期，考古学家 Stanley Ambrose 发现，在肯尼亚大裂谷的一座石头掩体中，藏着一些用鸵鸟蛋壳和贝壳碎片制成的项链。他们用（40Ar/42Ar）的氩测年法，将项链的年代确定为至少 4 万年前 。在西班牙发现的动物牙齿串珠也可以被追溯到这个年代 。在黎巴嫩（Lebanon）也发现了位于旧石器时代早期的穿孔贝壳。最近，（预备作为串珠）的完整贝壳，在南非的 Blombos 洞穴被发现，可以推前到距今 7 万 5 千年前！</p>

<p>现代考古学所发掘的最早的岩画，当属阿尔塔米拉洞；距今35000年左右，这被认为是人类艺术的开端；而文字的传播就更晚了；从这方面来看，货币其实是人类最早的语言、文化乃至艺术开端。</p>

<h4 id="section-4">铸币细节：</h4>

<p>通读我们提到的这三本货币史，我们发现了一个很有意思的细节：</p>

<p>早期中国的金属铸币都是带孔的，这很容易理解–古人需要用绳子串起来方便携带，所以我们的成语中才会有”腰缠万贯”这种词；而到了近代机制铸币，采用的是冲压铸币法，机器打孔导致良品率下降，而纸币开始风行，所以我们现代的硬币基本上都没有孔了；</p>

<p>国外铸币从古罗马时期开始，貌似他们的金银铸币没有打孔的习惯，这应该是铸造工艺的限制；</p>

<p>最有意思的是，能不能打孔，其实是筛选贝类货币的重要因素！早期的加工工艺粗糙，要求贝类有足够的坚韧度才能打孔，所以并不是所有的贝类都能做货币的；</p>

<p>英格兰在 17 世纪殖民美洲之时， 他们同当地的原住民交易，仍然入乡随俗，使用贝壳货币；有个描述特别有意思：</p>

<blockquote>
  <p>美洲的印第安人使用货币已有上千年历史，而且事实证明这些货币对初来乍到的欧洲人非常有用——就除了那些怀着 “印着大人物头像才是真钱” 偏见的人。最糟糕的是，这些新英格兰地区的原住民既不用金，也不用银，他们用的是生活环境中可见到的最合适的材料——猎物骨头中可长期保存的部分。具体一点来说就是用 venus mercenaria 等硬壳蚌类的壳做成的串珠（wampum），串成项坠。  -串珠项链。交易过程中，人们会点出珠子的数目、取出来并串到新项链上。美洲原住民的串珠有时候也会被串成腰带或其它有纪念或仪式意义的东西，表明财富或者对一些条约的承诺。-</p>
</blockquote>

<blockquote>
  <p>这些蚌类在大海里才能找到，但这些串珠却远播内陆。美洲大陆的各个部落中都可以找到各种各样的贝壳货币。易洛魁人（Iriquois）从未到蚌类栖息地去搞过事情，他们所收集到的串珠财宝却冠于所有部落 。只有少数几个部落，比如 Narragansett 人，才精于制造串珠，但几百个部落（大多都是 狩猎-采集 部落）都以串珠为货币。串珠项链的长度有很大差别，而串珠的数量与项链长度成比例。项链也总可以剪断或串联形成与商品价格相应的长度。</p>
</blockquote>

<p>呵呵，这就是项链的起源；今天我们赞美这种装饰品的华丽和艺术美感，其中有多少是从原始的”财迷崇拜”心理传承下来的呢？</p>

<p>另外，在货币上打孔将其穿起来这个动作具有深远的意义！你知道我在说什么，就是现在所谓的区块链技术–同样是用一个HASH值将所有的Block穿起来；人类历史发展了上万年，在电子世代重新发明一样东西，所考虑的事情同几万年前没有什么两样，这算不算是一种惊人的巧合呢？</p>

<h4 id="section-5">关于货币的幻觉:</h4>

<p>弗里德曼的<货币的祸害>同样是一本妙书，他开篇介绍的Yap（雅浦岛）的石币系统实在太有意思了；里面他记述了人类对于财富的度量其实不过是一种幻觉！这种幻觉的顶峰，无疑是现代的黄金储备系统。</货币的祸害></p>

<p>我们都知道世界上最大的金库是在 下曼哈顿区(或者翻译为“曼哈顿下城”)街道下方80英尺深的地方，属于美联储；各国的财富都储藏在这里；<货币的祸害>中记述了一个不可思议到可笑的故事：</货币的祸害></p>

<blockquote>
  <p>1932—1933年，法兰西银行害怕美国不再钉住金本位，不再按一盎司黄金兑换20.67美元的传统价格兑换黄金。于是，法兰西银行要求纽约联邦储备银行将它存在美国的大部分美元资产，转换成黄金。为了避免将黄金装船从海上运走，法兰西银行要求联邦储备银行把黄金存到法兰西银行的会计账簿上。作为一种回应，联邦储备银行的官员来到了金库，将与那笔资产等量的金锭放入了另外几个抽屉中，并且在这几个抽屉上贴了标签或是做了记号，以表明这个抽屉里的东西是法国的财产。这样，这些抽屉就像德国人在石头上做标记一样，也有可能“用黑色笔画一个十字”来标记。</p>
</blockquote>

<blockquote>
  <p>后来的结果是，财经报纸用头条报道了这件关于“黄金的损失”以及对美国金融体系的威胁等等诸如此类的消息。美国的黄金储备开始减少，法国的黄金储备则在增加。市场认为美元走软，法郎走强。这种因法国向美国兑换黄金而造成的所谓黄金流失，是最终导致1933年银行业恐慌的众多因素之一。
联邦储备银行的看法，即由于在自己的地下室里的抽屉上做了一些标记，美元就处于一个疲软的货币地位，与雅浦岛民的看法，即由于别人在他们的石币上做了一些记号，他们就变得比以前穷了，不是异曲而同工吗？或者说，在法兰西银行的看法与雅浦家族的信念之间，即由于3000多英里以外的一个地下室里数个抽屉上的标记，法国的货币地位即增强了，与由于数百英里以外的水底下的一块石头，雅浦的家族就富裕了的看法之间，有什么真正的区别吗？就此而言，有多少人会对我们认为现存的构成自己财富的大多数东西，具有实实在在的确切的把握？我们所拥有的多数似乎是财富的东西都记录在银行的账簿上，财产要由一张称为股票的纸来确定。</p>
</blockquote>

<p>货币是一种神秘奇妙的发明，它关乎信用、权力、与时间的博弈，人的幻想，秩序，疯狂，稳定，跟我们的社会紧紧缠绕在一起。</p>

<p>引自：</p>

<p>https://nakamotoinstitute.org/shelling-out/ </p>

<p>https://book.douban.com/subject/30426677/ </p>

<p>https://book.douban.com/subject/1860877/ </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读<投资者的心灵修炼>随想]]></title>
    <link href="https://happy123.me/blog/2019/06/22/du-tou-zi-zhe-de-xin-ling-xiu-lian-sui-xiang/"/>
    <updated>2019-06-22T16:48:28+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/du-tou-zi-zhe-de-xin-ling-xiu-lian-sui-xiang</id>
    <content type="html"><![CDATA[<h4 id="section"><投资者的心灵修炼 /></h4>

<p>https://book.douban.com/subject/27079024/</p>

<!-- more -->

<p>大多数人都没有意识到的一个事实是：投资最重要的不是智商，而是情商。</p>

<p>金融市场的投资到底有多难，看看书中序言专家的总结：</p>

<blockquote>
  <p>它需要洞悉市场在泡沫膨胀与破裂的长周期循环中处在哪个阶段，需要有一套可靠的与中短线不确定性进行“试错博弈”的方法体系，需要在第一时间对纷繁的噪声和有用信息做出鉴别，需要独立挖掘和洞悉别人看不到的重要因素，需要区别统计上的相关性与真正的因果关系，需要及时把握主要矛盾的动态变化以避免刻舟求剑，需要构建超越世俗生活的“对”与“错”的哲学观念，甚至使自己成为超越任何一个哲学流派的哲学家，需要洞悉大众人性规律和自我人性的特点，进而从本我的弱点中分离出来并战胜它……</p>
</blockquote>

<blockquote>
  <p>简言之，要成为金融市场成功的投资者，不仅要有一套超越大众并适应市场特性的思维方法，更要磨练出超越大众和本我弱点的“高异心性”。</p>
</blockquote>

<p>然后看看现在无处不在的各种<code>理财秘籍</code>，汗牛充栋的炒股秘策，我们普通人只会迷失在各种噪音当中……</p>

<p>巴菲特 1998年10月15日在佛罗里达大学商学院的演讲 值得我们一读再读，让我们再摘抄一下这位智慧老人的箴言：</p>

<blockquote>
  <p>各位同学，你们毕业之后未来会怎样？我简单说说我的想法。各位在这所大学能学到大量关于投资的知识，你们将拥有成功所需的知识，既然各位能坐在这里，你们也拥有成功所需的智商，你们还有成功所需的拼劲。你们大多数人都会成功地实现自己的理想。</p>
</blockquote>

<blockquote>
  <p>但是最后你到底能否成功，不只取决于你的头脑和勤奋。我简单讲一下这个道理。奥马哈有个叫彼得•基威特的人，他说他招人的时候看三点：品行、头脑和勤奋。他说一个人要是头脑聪明、勤奋努力，但品行不好，肯定是个祸害。品行不端的人，最好又懒又蠢。</p>
</blockquote>

<blockquote>
  <p>我知道各位都头脑聪明、勤奋努力，所以我今天只讲品行。为了更好地思考这个问题，我们不妨一起做个游戏。各位都是 MBA 二年级的学生，应该很了解自己周围的同学了。假设现在你可以选一个同学，买入他今后一生之内 10% 的收入。你不能选富二代，只能选靠自己奋斗的人。请各位仔细想一下，你会选班里的哪位同学，买入他今后一生之内 10% 的收入。</p>
</blockquote>

<blockquote>
  <p>你会给所有同学做个智商测试，选智商最高的吗？未必。你会选考试成绩最高的吗？未必。你会选最有拼劲的吗？不一定。因为大家都很聪明，也都很努力，我觉得你会主要考虑定性方面的因素。好好想想，你会把赌注压在谁的身上？</p>
</blockquote>

<blockquote>
  <p>也许你会选你最有认同感的那个人，那个拥有领导能力，能把别人组织起来的人。这样的人应该是慷慨大方的、诚实正直的，他们自己做了贡献，却说是别人的功劳。我觉得让你做出决定的应该是这样的品质。找到了你最钦佩的这位同学之后，想一想他身上有哪些优秀品质，拿一张纸，把这些品质写在纸的左边。</p>
</blockquote>

<blockquote>
  <p>下面我要加大难度了。为了拥有这位同学今后一生 10% 的收入，你还要同时做空另一位同学今后一生 10% 的收入，这个更好玩。</p>
</blockquote>

<blockquote>
  <p>想想你会做空谁？你不会选智商最低的。你会想到那些招人烦的人，他们可能学成绩优秀，但你就是不想和他们打交道，不但你烦他们，别人也烦他们。为什么有人会招人烦？原因很多，这样的人可能自私自利、贪得无厌、投机取巧或者弄虚作假。类似这样的品质，你想想还有什么，请把它们写在刚才那张纸的右边。</p>
</blockquote>

<blockquote>
  <p>看看左右两边分别列出来的品质，你发现了吗？这些品质不是把橄榄球扔出 60 米，不是 10 秒钟跑完 100 米，不是相貌在全班最出众。左边的这些品质，你真想拥有的话，你可以有。</p>
</blockquote>

<blockquote>
  <p>这些是关于行为、脾气和性格的品质，是能培养出来的。在座的各位，只要你想要获得这些品质，没一个是你得不到的。再看一下右边的那些品质，那些令人生厌的品质，没一个是你非有不可的，你身上要是有，想改的话，可以改掉。大多数行为都是习惯成自然。我已经老了，但你们还年轻，想摆脱恶习，你们年轻人做起来更容易。</p>
</blockquote>

<blockquote>
  <p>常言道，习惯的枷锁，开始的时候轻的难以察觉，到后来却重的无法摆脱。这话特别在理。我在生活中见过一些人，他们有的和我年纪差不多，有的比我年轻十几二十几岁，但是他们染上了一些坏习性，把自己毁了，改也改不掉，走到哪都招人烦。他们原来不是这样的，但是习惯成自然，积累到一定程度，根本改不了了。你们还年轻，想养成什么习惯、想形成什么品格，都可以，就看你自己怎么想了。</p>
</blockquote>

<blockquote>
  <p>本•格雷厄姆，还有他之前的本•富兰克林，他们都这么做过。本•格雷厄姆十几岁的时候就观察自己周围那些令人敬佩的人，他对自己说：“我也想成为一个被别人敬佩的人，我要向他们学。”格雷厄姆发现学他敬佩的人，像他们一样为人处世，是完全做得到的。他同样观察周围遭人厌恶的人，摆脱他们身上的缺点。我建议大家把这些品质写下来，好好想想，把好品质养成习惯，最后你想买谁 10% 的收入，就会变成他。</p>
</blockquote>

<blockquote>
  <p>你已经确定拥有自己 100% 的收入，再有别人的 10%，这多好。你选择了谁，你都可以学得像他一样。
假如有一位魔法老人问我，你今后要在投资领域成为什么样的人呢？是要巴菲特那样神奇的价值投资者？是芒格那样的智慧老人？还是彼得林奇一般的一代宗师？</p>
</blockquote>

<p>我想我会回答，我希望能在这个领域成为像阿甘那样的人。</p>

<p>哈，这个世界上聪明人实在太多了。人人都不想做傻子，而事实是市场上经常是聪明人赔钱，忘掉账户的那些傻子却”傻人有傻福”。我相信，阿甘到了市场上，大概率是那个有傻福的人，为什么呢？</p>

<p>他天资不高，但有着非常好的个人品质，他宅心仁厚，简单无私，同时自强不息，坚忍不拔，大概率能成就成功和快乐的人生。就像武侠小说里面的郭靖，以中下之资登武学绝顶之境。</p>

<h5 id="section-1">我不想学聪明，我想变简单，变得”笨一点”。</h5>

<p>最令人悲哀的事实就是，所有人都是”生而就笨”的，但经过生活的种种洗礼，我们不可避免的“越来越聪明”了，而生活和市场是心理变态的虐待狂，你越聪明，他就越会设置一个更高难度让你通关，最后你发现，变聪明了并不能让通关变得更容易。</p>

<p>这个时候我们需要重新学习“怎么变得更笨”这件事，而学习变笨在大多数人看起来就是一件荒谬的事情，在生活这个虐待狂的一次次鞭策下，我们已经忘了回家的路。更悲哀的是，要想学习”变笨”，就要先变得”更聪明”：聪明到能识别我们哪些“聪明”是多余的；这真是一个解不开的线团！</p>

<p>这本书通篇很好的提醒了我们哪些“聪明”是多余的。</p>

<p>我就我现在认识最深刻的一件”多余的聪明“写在这里供大家一乐。</p>

<h3 id="section-2">谬论1：你必须择时投资以获取像样的回报:</h3>

<p>在市场上投机的人最容易进入的一个心结就是，他们看着K线图，然后开始幻想：”如果我在这个低点买入，然后在那个高点抛出~~~”</p>

<p>快醒醒吧，一个最简单最惊人的统计学结论是：即使你每次都能低买高卖，在一个长期上涨的市场里面，你获取的收益大概率不如一直拿着不放的傻瓜！</p>

<p>为什么呢？这在数学上根本不成立嘛！</p>

<p>我们把事情放简单一点，如果在一个一直上涨的市场里面，每一分钟都创新高，最优的策略是什么？</p>

<p>当然是一把买入永远不动！把投资看成是储蓄，需要钱的时候取用就可以了。你每次卖出，都是抛掉便宜筹码，将来每次买入，跟历史比较起来，都是高买低卖。</p>

<p>但是市场是涨涨跌跌的啊？我每次高点抛出之后，再在低点买入更多份额不就好了吗？</p>

<p>这就涉及到另外一个统计结论，没有人能一直正确择时，甚至都没有统计结论支持这世上是否有个人能有50%的择时正确率！</p>

<p>那么这个结论已经很明显了，如果你能在你所认为的”市场低点”买入指数，拿着不动就可以了。就是这么简单。</p>

<p>但人性的”小聪明“往往会在市场动荡的时候出来骚扰你，在你耳边撒下喀耳刻海岛海妖迷人的歌声，这个时候你大概率要为聪明付出代价！</p>

<p>但是我们又迷惑了，难道永远不卖吗？万一我需要用钱的时候正好是市场低点怎么办？</p>

<h5 id="section-3">问得好！！这就要涉及到投资的本质，即无论是投机和投资，永远是跟时间的博弈！</h5>

<p>我们首先要明确，跟时间博弈，人是永远无法胜出的。人不可避免的衰老；不论你有多么成功的业绩，多么惊人的财富积累，最终都会被时间老人收回；在时间面前，所有人都是失败者！</p>

<p>我们能做的最好结果，就是在跟时间老人的博弈棋局中，让自己每次决定的边际效用最大化，尽可能延缓失败的到来；但在这个棋局中，人生来就是被打败的！</p>

<p>任何长期投资策略往往会受到情绪的影响。诀窍在于找到一种方法，可以在你晚上安然入睡与提高长期财务目标的实现概率之间取得平衡。</p>

<p>明白这个道理，我们就坦然了，不论是低买高卖，低买低卖，高买高卖，高买低卖，只要你不去耍小聪明，就是最大的边际效用！时间老人也会尊重你这样的对手。</p>

<p>====================================================</p>

<p>就是这么一个简单的道理，我们在寻求”变笨”的道路上摔了多少跤啊，要吃多少亏，被时间老人耍多少次才能领悟到自己那点”小聪明“是多么可笑啊！</p>

<p>悲哀的是， 人性的弱点总是充满贪婪、恐惧或者是愚蠢，这是完全可以预测的，但是我们无法预测这种人性弱点的发生顺序。 人生苦短，我们不可避免的要一次次的为自己的”聪明”付出代价。</p>

<p>让我在最后描述一个我发明的隐喻吧：</p>

<blockquote>
  <p>我们每个人生下来都被安排到一场棋局当中，我们的对手是一个慈祥的时间老人。他公正无私的同时又是一个宽大为怀的人；他手里面有许许多多的筹码，比如财富，美貌，健康，聪慧，正直，坚韧，勇敢等等等等，你在牌局初始就被随机赐予了一些筹码，当然你可以用自己的时间一点一点来换取这些筹码，也可以用已经拥有却暂时不需要的筹码去换取你急需的；</p>
</blockquote>

<blockquote>
  <p>每个筹码的作用和边际效用是时刻在变化的；比如对刚出生的你，时间老人是非常慷慨的，他说，你的一份时间可以换取1份财富，或者1份美貌，或者1份正直；但是随着时间流逝，时间老人可能严苛起来，这个时候可能你的1份时间可以换取10份财富，却需要10份时间才能换取1份健康；当然，你也可以用一百份财富换取1份健康；</p>
</blockquote>

<blockquote>
  <p>当我们渐渐成长之后，棋盘旁边来了两个观棋者，生活婆婆和市场国王；看的时间长了，他们开始叽叽喳喳起来，开始对你建议：先要这个，再要那个，那个傻瓜老头算不清楚，先要这个更划算；</p>
</blockquote>

<blockquote>
  <p>然后光靠说还不满足，他们开始偷偷往你手里塞筹码，是一些写着投机赌博、自私、欺骗等等的蓝筹，你们一时骗过了时间老人，让你用一个筹码换到了大量的财富，但是时间老人慢慢回过味儿来了，他开始严厉起来，100份时间，10000份财富也换不回一份正直了，最后，你手里面只剩下大量的自私、贪婪、赌博、财富等等，你想要一份正直，信任，倾尽所有筹码也换不回来了~~~</p>
</blockquote>

<p>最好的博弈策略就是，简以至纯，承认弱点、正视弱点、规避弱点。  </p>

<p>无波真古井，有节是秋筠；人生如逆旅，我亦是行人。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闪电网络慢慢成长]]></title>
    <link href="https://happy123.me/blog/2019/05/21/shan-dian-wang-luo-man-man-cheng-chang/"/>
    <updated>2019-05-21T09:44:25+08:00</updated>
    <id>https://happy123.me/blog/2019/05/21/shan-dian-wang-luo-man-man-cheng-chang</id>
    <content type="html"><![CDATA[<p>学习一件事情的最好办法就是尽可能去用。</p>

<p>我在Bitcoin Testnet上面运行一个LND全节点已经有很长时间了，对现在闪电网络的进化速度都有了直观的体验：<code>积跬步，至千里</code>；</p>

<!-- more -->

<p>首先必须先承认，现在要完整的体验闪电网络，即从后台构建+前端使用整个流程，是非常麻烦的，恐怕只有对其原理有比较深入了解的人才能完成这个过程；简单说一下:</p>

<h4 id="linux">1.需要Linux环境</h4>
<p>#### 2.需要运行一个bitcoin全节点，因为都是命令行操作，所以要<code>手工创建钱包</code> -&gt; <code>转账确保钱包有余额</code></p>

<ul>
  <li>bitcoin.conf的配置文件模板</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rpcuser=xxxxx
</span><span class="line">rpcpassword=xxxxx
</span><span class="line">rpcallowip=127.0.0.1/16
</span><span class="line">rpcport=18332
</span><span class="line">test.rpcport=18332
</span><span class="line">rpcthreads=10
</span><span class="line">server=1
</span><span class="line">rest=1
</span><span class="line">testnet=1
</span><span class="line">zmqpubrawblock=tcp://127.0.0.1:28332
</span><span class="line">zmqpubrawtx=tcp://127.0.0.1:28333
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>启动bitcoind</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bitcoin/bin/bitcoind --conf=~/bitcoin.conf --datadir=/opt/bitcoin/blockdata/ 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>同步后找到当前钱包收款地址</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bitcoin-cli listaddressgroupings
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>发送一笔转账到此地址，也可以直接去<a href="https://bitcoinfaucet.uo1.net/send.php">bitcoinfaucet</a>领一些测试币</p>
  </li>
  <li>
    <p>确认钱包余额</p>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bitcoin-cli getwalletinfo
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="lnd-daemon">3.运行一个LND Daemon</h4>

<p>这方面有几个主流选择，lightning labs的<a href="https://github.com/lightningnetwork/lnd">lnd</a>，或者<a href="https://github.com/ElementsProject/lightning">c-lightning</a>，或者<a href="https://github.com/mit-dci/lit">lit</a></p>

<p>lnd支持比较广泛，我们用其0.6beta版本搭建；</p>

<ul>
  <li>按照项目文档构建Go编译环境，编译生成lnd和lnd-cli两个可执行文件</li>
  <li>启动lnd daemon(注意这里没有启用验证，在mainnet上面切不可这么做)</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxxx  --bitcoind.rpcpass='xxxxx' --bitcoind.zmqpubrawblock=tcp://127.0.0.1:28332 --bitcoind.zmqpubrawtx=tcp://127.0.0.1:28333 --no-macaroons
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>之后lnd会通过bitcoind node同步区块头，大概需要10分钟</li>
  <li>创建lnd的钱包，保存seed，便于之后恢复</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli --network=testnet create
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>创建一个segwit地址</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli --network=testnet newaddress np2wkh
</span><span class="line">2NF5UC1ZgQzb8Ustm9JCTbQQTU5Ca438WWf
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>打一些测试币给这个地址</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/bitcoin-cli sendtoaddress 2NF5UC1ZgQzb8Ustm9JCTbQQTU5Ca438WWf 0.005
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>看一下钱包信息，收到款没有</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli --no-macaroons --network=testnet walletbalance
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">4. 建立通道</h4>

<ul>
  <li>直接到<a href="https://1ml.com/testnet/">1ml.com</a>找最近连接数最多的节点, 比如<a href="https://1ml.com/testnet/node/038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9">Node: aranguren.org</a>:</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">node ID:038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9@203.132.95.10:9735
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>连接这个节点：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli --no-macaroons --network=testnet connect 038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9@203.132.95.10:9735
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>建立通道，放一笔钱进去</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli --no-macaroons --network=testnet openchannel --node_key=038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9 40000
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>需要一段时间同步，然后看一下通道状态:</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli --network=testnet listchannels
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-1">5. 支付</h4>

<ul>
  <li>首先到<a href="https://testnet.satoshis.place/">testnet.satoshis.place</a>涂鸦两笔，得到一个支付地址:</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lntb1pwwykwhpp5jw4tekxmsqjwepw4070em7xe7gw3v8mxtenexmsp2np3pcc40jwqdqqxqruyqrzjqfcxsh9gr28y6ngphmk90q05ejfydpq89tjjc5rl36lfmtcv424hk9e8sgqqqvsqqqqqqqlgqqqqqeqqjqjpfnq26e2flenp79ywpyyftg3najf3wtpvkwuuw2h9y3dzdn7kc3342h6uzgf69ms8sx6fxsh5j2jcwzulr3dufryn9ljadm0wuj9fcpm86fax
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>lnd-cli支付</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lncli  sendpayment --pay_req lntb1pwwykwhpp5jw4tekxmsqjwepw4070em7xe7gw3v8mxtenexmsp2np3pcc40jwqdqqxqruyqrzjqfcxsh9gr28y6ngphmk90q05ejfydpq89tjjc5rl36lfmtcv424hk9e8sgqqqvsqqqqqqqlgqqqqqeqqjqjpfnq26e2flenp79ywpyyftg3najf3wtpvkwuuw2h9y3dzdn7kc3342h6uzgf69ms8sx6fxsh5j2jcwzulr3dufryn9ljadm0wuj9fcpm86fax 500
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-2">6. 收款</h4>

<p>lnd构建一个收款节点比较麻烦，我们可以借助一个实现了lnd hub全功能的钱包来体验，推荐 <a href="https://github.com/ACINQ/eclair">elcair</a>；</p>

<p><a href="https://bluewallet.io/">BlueWallet</a>也是一个非常受欢迎的闪电网络钱包，不过他并没有实现完整的lightning hub的功能，作为想要完全掌控一切的玩家不太合适，当然对于普通用户来说，BlueWallet更易用：</p>

<p>https://medium.com/bluewallet/bluewallet-brings-zero-configuration-lightning-payments-to-ios-and-android-30137a69f071</p>

<ul>
  <li>关于 elcair如何构建一个收款地址的过程，可以参考:</li>
</ul>

<p>https://medium.com/@ACINQ/enabling-receive-on-eclair-mobile-2e1b87bd1e3a</p>

<ul>
  <li>老实说，使用elcair的过程也需要一点技术，至少要搞明白我们之前讲述闪电网络技术原理的那篇文章</li>
</ul>

<h4 id="section-3">7. 总结</h4>

<p>好啦，相信小白看到这里已然头昏眼花，并发出怒吼：这么复杂的东西谁会用啊！</p>

<p>我得说，在使用闪电网络的过程中，我体会到了巨大的乐趣，就跟我第一次手工完成一笔比特币交易一样的乐趣！</p>

<p>回想互联网之初，发个电子邮件也需要精通命令行操作的<code>专家人士</code>来完成，跟现在闪电网络的使用体验完全一样！</p>

<p>我也相信随着产业发展，这项技术迟早会变得跟电子邮件一样，在IPAD上动动手指就完成一切，我憧憬着这一天。</p>

<p>然后我们看一下现在闪电网络面临的一些技术和实务上的挑战：</p>

<ol>
  <li>目前还没有完全靠谱的，敢于宣称可安全用于生产的基础软件实现，大家都在beta版</li>
  <li>目前运行一个lnd，需要配置一个bitcoin fullnode，而且是一对一的，成本比较高，虽然运行一个全节点可以取得一些手续费，但是其风险和收益不成对比；bitmex有<a href="https://blog.bitmex.com/the-lightning-network-part-2-routing-fee-economics/">一篇文章</a>详细分析了现在运行一个闪电网络节点的收益情况；</li>
  <li>现在lit项目和Neutrino项目都朝着<code>运行一个支持闪电节点的SPV节点</code>这个方向努力，但距离完成还有很长时间；</li>
  <li>在我们之前的文章分析中，每一个钱包，都需要一个类似<code>瞭望塔</code>的模块，来监控通道的状态；围绕这个实现，目前有两大流派：一类就是elcair 钱包自己继承这个功能，这就要求用户的钱包不能脱离网络超过两周；第二类就是BlueWallet的实现，让用户放弃掌控一切，由钱包服务商托管；这两种方案各有优劣，之后还要看市场和众多黑客们的测试结果；</li>
  <li>Electrum目前也在进行闪电网络的实现，他们采用了改造ElectrumX server端，增加一个和lnd连接的中间通讯层的方法，并且ElectrumX是可以复用的，以后如果lnd实现了Neutrino，可以完成<code>ElectrumX+Lnd+Neutrino</code>的部署，估计这样成本低，运营的好的话，能赚点小钱；</li>
</ol>

<p>最后的最后：</p>

<ul>
  <li>
    <p>闪电网络的成长目前是一个非常壮丽的场景，堪比互联网发展之初；</p>
  </li>
  <li>
    <p>终于出现了这样一种基础金融技术:</p>
    <ul>
      <li>可以支持个人开银行，没有任何法律、宗教、地域、政府的隔阂；</li>
      <li>只要有网络和你的信用，就可以面向全球用户做一个银行家；</li>
      <li>而且你的银行没有柜台、没有繁琐的开户流程，没有金碧辉煌的大楼，只需要一个联网的手机而已；但这是世界上最讲信用的，最具有扩展性的，最安全的银行；</li>
      <li>你的用户也无需繁琐的身份证明，政策限制，高昂的手续费，屈服于传统银行的被冻结账户的风险，甚至都不需要物理的货币和钱包，只需要在脑子里记住一串密语而已；而对于将来的那些<code>世界银行家</code>来说，你的信用就是一切。酷!!!</li>
    </ul>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is Craig Wright Real Satoshi Nakamoto-2]]></title>
    <link href="https://happy123.me/blog/2019/05/19/is-craig-wright-real-satoshi-nakamoto-2/"/>
    <updated>2019-05-19T10:15:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/19/is-craig-wright-real-satoshi-nakamoto-2</id>
    <content type="html"><![CDATA[<p>之前我们写过两篇文章来八卦所谓的<code>澳本聪</code>的故事:</p>

<p><a href="https://happy123.me/blog/2016/05/02/is-craig-wright-real-satoshi-nakamoto/">Is Craig Wright Real Satoshi Nakamoto?</a></p>

<p><a href="https://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">Satoshi Craig Wright Is Being Sued for $10 Billion</a></p>

<p>PS: 学术界普遍怀疑其实 <a href="https://www.blogger.com/profile/16820399856274245684">Nick Szabo</a>才是中本聪；偶也50%认同；</p>

<p>最近这个故事又有了新的神转折，实在是太有意思了。现实生活中，有时候我觉得八卦那些明星太无聊了，但是在cyberspace中，偶的八卦之心熊熊燃烧，都让我有点体会那些狗崽队的心情了~~~</p>

<!-- more -->

<p>之前我们做出的推论是:</p>

<blockquote>
  <p>Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>
</blockquote>

<blockquote>
  <p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>
</blockquote>

<blockquote>
  <p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p>
</blockquote>

<p>之后的剧情就是 David Kleiman的亲属起诉Craig Wright，声称他窃取了 本该属于  David Kleiman 的100w bitcoin；其起诉文书中公布了大量的由 Craig Wright声称其属于他和Kleiman成立的名为<code>郁金香信托</code>基金的bitcoin address;</p>

<p>参见<a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion">这里</a>， <a href="https://www.reddit.com/r/Bitcoin/comments/80e2l9/10_billion_lawsuit_filed_against_craig_wright/">这里</a></p>

<p>很快，就有人对其文件中所列出的地址做了详细分析；认为其地址根本就是 Craig Wright 随便在bitcoin blockchain找的大额未动币的地址，根本和他没关系；当然，跟David Kleiman也没关系；两拨人马完全是在为<code>一笔完全不存在的财富</code>纠缠不清；</p>

<p>甚至，这些地址中，有一个地址是Mtgox小偷的地址！ 如果这份文件是真的，那么岂不是说Craig Wright自己承认是Mtgox的窃贼！</p>

<p>参考<a href="https://blog.wizsec.jp/2018/02/kleiman-v-craig-wright-bitcoins.html">这里</a>；</p>

<p>地址分析：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">12tLs9c9RsALt4ockxa1hB4iTCTSmxj2me: unknown
</span><span class="line">1933phfhK3ZgFQNLGSDXvqCn32k2buXY8a: MtGox user
</span><span class="line">1FeexV6bAHb8ybZjqQMjJrcCrHGW9sb6uF: first major MtGox theft
</span><span class="line">1f1miYFQWTzdLiCBxtHHnNiW7WAWPUccr: unknown
</span><span class="line">1MHdm5XZMrfoZFoUktEaGhYevmdiXoc4x4: unknown (early miner)
</span><span class="line">18JPragfuDVHWWG8ABQ15cghJFetnXUjBD: MtGox user
</span><span class="line">1LXc28hWx1t8np5sCAb2EaNFqPwqJCuERD: unknown
</span><span class="line">1FpqQnKQCgDkJFMC94JL8FpRyHTZ3uRVZ1: unknown (early miner)
</span><span class="line">1F34duy2eeMz5mSrvFepVzy7Y1rBsnAyWC: from MyBitcoin.com
</span><span class="line">1JtpgqCf3SSeCeYWEDJjkfYFH7Ruhy4Vp1: unknown (early miner)
</span><span class="line">18k9tin39LKegFzHe8rxSgvJXDpuMriGJq: unknown
</span><span class="line">1HtTw9zR9wWFfgV8Jy8MqsaeVi7ZXrjdq6: part of a long chain of transactions that send minor amounts into a BTC-e deposit address
</span><span class="line">18pn4NQ7NgsJjeuFjazeTdVRnsmfw5ofTz: unknown
</span><span class="line">12fZ2HxkLjG9zn1u44XYsFFYKHM4A2zCea: MtGox user
</span><span class="line">12tkqA9xSoowkzoERHMWNKsTey55YEBqkv: unknown (early miner)
</span><span class="line">16Ls6azc76ixc9Ny7AB5ZPPq6oiEL9XwXy: MtGox cold storage
</span><span class="line">12HddUDLhRP2F8JjpKYeKaDxxt5wUvx5nq: MtGox cold storage
</span><span class="line">1P3S1grZYmcqYDuaEDVDYobJ5Fx85E9fE9: MtGox cold storage
</span><span class="line">1MyGwFAJjVtB5rGJa32M6Yh46cGirUta1K: MtGox cold storage
</span><span class="line">145YHsQU7HMzkRnD5SBSuFAzQgCYnAnLkN: unknown (early miner)
</span><span class="line">16TPVCpvtJ6FkV5xNKBp35aMo4BWFGxiEY: unknown
</span><span class="line">1KbrSKrT3GeEruTuuYYUSQ35JwKbrAWJYm: unknown
</span><span class="line">1FLFnbN7m5psLfvLEwYfRUUjJ34YkmV3dM: donation recipient
</span><span class="line">1A6SDef1TJAM8Saw2SqmqFGhkWR1y3qMx2: MtGox deposit address
</span><span class="line">16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT: MtGox user
</span><span class="line">12ib7dApVFvg82TXKycWBNpN8kFyiAN1dr: unknown (early miner)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>呵呵，就在前几天，有人用<code>16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT</code>这个地址的私钥，签名发布了一段消息：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Address 16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT does not belong to Satoshi or to Craig Wright.
</span><span class="line">Craig is a liar and a fraud.
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段消息的签名是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">G39S6i4XsfQnixN5ePMjVPboWvGXdnW8xFFAXiwEriZFCclflbD7umP58u3Sl+dvvXC5BxBrRNkTMNf92O1UIXw=
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这段签名可以用Electrum的工具验证无误；懂一点技术的人自然明白这意味这什么。</p>

<p>那么问题又来了，为什么这位英雄好汉不在去年早点揭露这件事呢？</p>

<p>也许是法律文件太过冗长，没什么人仔细去研究，更不用说作为一个早期的Bitcoiner Hodler了；</p>

<p>嗯，这个理由很合理；但是~~~~</p>

<p>马上又有人挖出了更大的瓜，这个地址是Roger Ver控制的；</p>

<p>https://www.reddit.com/r/btc/comments/bpdac1/address_16cou7ht6wjtzufydbnht9hmvxytg6xdvt_does/</p>

<p>https://www.reddit.com/r/btc/comments/7cehzo/roger_ver_45000_bitcoin_moved_to_exchange/</p>

<p>之前在Bitcoin扩容之争的时候，Roger Ver还用这个地址投过票；</p>

<p>而Roger Ver与Craig Wright的关系也是百转千回~~</p>

<ul>
  <li>
    <p>Craig Wright初次宣布自己是Satoshi, Roger Ver 坚持黑；</p>
  </li>
  <li>
    <p>BCH分叉， Craig Wright投入BCH阵营， Roger Ver 粉；</p>
  </li>
  <li>
    <p>BSV分叉， Craig Wright自立门户， Roger Ver 出来掀桌了；</p>
  </li>
</ul>

<p>真相目前不得而知，但是可以确认的有一件事情：</p>

<p>像所有的区块链项目以及牵涉其中的人一样， Craig Wright, Roger Ver， 所谓的<code>郁金香信托</code>， Mtgox， BCH, BSV 等等，他们之间充斥着谎言中的谎言，是迷宫中的迷宫；</p>

<p>我觉得所谓的<code>区块链行业</code>有个铁律：</p>

<h4 id="section">有区块链的地方一定会有骗子。</h4>

<p>这再一次提醒我们，在区块链世界中，任何人都不值得信任，唯一可以依靠的只有自己的知识和判断：</p>

<h2 id="dont-trust-verify">Don’t Trust. Verify.</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[永远都算不准的指数PE]]></title>
    <link href="https://happy123.me/blog/2019/05/12/yong-yuan-du-suan-bu-zhun-de-zhi-shu-pe/"/>
    <updated>2019-05-12T10:49:33+08:00</updated>
    <id>https://happy123.me/blog/2019/05/12/yong-yuan-du-suan-bu-zhun-de-zhi-shu-pe</id>
    <content type="html"><![CDATA[<p>看看一张2019-05-10的指数估值表:</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190512/bg1.png" alt="img" /></p>

<blockquote>
  <p>数据来源：https://xueqiu.com/u/8890498724</p>
</blockquote>

<p>大家肯定晕了，怎么这几家算出来的PE数据都不一样啊，个人计算的就罢了，怎么中证指数和Wind算的都不一样啊，究竟谁算得准啊？</p>

<p>PE是投资的重要指标因子，基础因子不准就做投资决策，犹如盲人骑瞎马，我们有必要好好弄明白为什么各家的PE算出来的值不一样！</p>

<!-- more -->

<h2 id="pe">PE是什么？</h2>

<p>PE，是市盈率（Price earnings ratio，即P/E ratio）的英文缩写。其定义是股价与每股收益的比率，也等价于总市值与净利润的比率。</p>

<p>最简单的理解，一家公司现在的股票总市值是10亿元，当年的净利润为1亿元，那么当年的PE就是<code>10/1=10</code>；</p>

<p>这么简单的算术题，为啥各路神仙还算不准？</p>

<h2 id="pe-1">PE的几种计算方法</h2>

<p>呵呵，股票市值很容易计算，但一家公司最难搞明白的就是当年净利润；试问大家去读公司年报，有几家公司能保证其中净利润是真实的准数呢？</p>

<p>更何况还有一个预测未来的问题，公司的股票市值天天变，财报有上一年的年报，当年季度报告，历史PE好算，当前PE如何计算呢？毕竟我们不能预测未来，在1月份就能预测当年整年的净利润；</p>

<p>为了解决这个算不准的问题，就有几种折中的计算方法：</p>

<h4 id="section">静态市盈率</h4>

<p>静态市盈率又称市盈率LYR(Last Year Ratio)，是以上一年的净利润为分母计算出来的市盈率；上一年的净利润，直接找公司财报就好了，这个没什么可说的；</p>

<p>但是我们要注意一点，静态市盈率是典型的看后视镜开车；去年挣大钱不代表今年也能挣大钱，对不？如果看静态市盈率炒股，结果就是呵呵哒；</p>

<h4 id="ttmtrailing-twelve-months">滚动市盈率 TTM(Trailing Twelve Months)，</h4>

<p>静态市盈率是后视镜，不实用，自然有人去改进，这就是滚动市盈率这项指标；</p>

<p>滚动市盈率和静态市盈率的区别在于，总利润以季报为参考，因为季报是每季度跟新一次，那样相比之前拿年报的总利润的算法，实时性更好一点；</p>

<p>比如我们在2019-05计算A公司的PE，那总利润就拿 2018年第二、第三、第四、以及2019年第一季度的季报利润总和相加，作为分母计算；</p>

<p>滚动市盈率实时性好，已经是当前最科学的估算方法了，大部分软件(比如雪球)就是这么计算的；但也有缺点，就是有的高速成长的公司，他前几个季度的成长是指数级的，但后面会越来越慢；而且有的公司为了PE数字好看，还会操纵利润；单看滚动市盈率炒股，最终结果还是呵呵哒；</p>

<h4 id="section-1">动态市盈率</h4>

<p>滚动市盈率的计算方法已经比较严谨了；但是还有一些软件的提供商偷懒，因为计算滚动市盈率需要处理很多情况，比如公司刚上市、比如公司去年停牌了一个季度，比如公司去年财报实锤造假了，等等等等，好烦啊，所以他们计算利润的方法更简单粗暴：</p>

<p>比如现在是2019年5月份，那么我觉得你今年的利润就是 2019年第一季度的利润X4；到了9月份，我就取全年利润=半年财报利润X2</p>

<p>呵呵哒~~~~</p>

<h4 id="section-2">根据财报利润个人计算</h4>

<p>设身处地想一下，我自己重仓了一支股票，发现连谁算的PE比较准都搞不明白，我岂不是每天惶惶然；于是我决定自己来算PE！</p>

<p>我拿来公司季报、半年报、年报仔细一看，乐了，基本上公司都会对未来的利润率有个预估，比如明年我预计全年净利润同比增长35%-45%；那么我保守一点，用去年35%的增长来预估你今年的利润，总可以了吧！</p>

<p>看看康美药业的年报吧! 呵呵哒~~~</p>

<h2 id="pe-2">指数PE的计算方法</h2>

<p>单个公司的PE已然如此难算，那么指数呢？囊括几百家公司的指数PE怎么算呢？</p>

<h4 id="section-3">指数滚动市盈率加权计算方法</h4>

<p>我们把整个指数囊括的公司看成一家公司，那么PE计算其实很简单，就是PE=总市值/总利润；</p>

<p>总市值就是指数中所有市值的相加，总理论就是所有利润的相加；当然单家公司的利润我们肯定要采用滚动市盈率(TTM)的计算方法；</p>

<p>这种相加的计算方法，也被称之为加权计算方法；</p>

<h4 id="section-4">指数滚动市盈率算术平均计算方法</h4>

<p>加权计算方法简单明了，但是有的人觉得有问题，因为如果指数里面有100家公司，有家公司特别大，市盈率特别低，其他99家公司虽然市盈率很高，但采取加权统计一看，都被平均低了，这个计算方法就会失真；</p>

<p>为了解决这个问题，我们采取算术平均计算方法；比如这家特别大的公司PE是5，而其他99家公司PE都是20；那么我们就不看总市值和总利润了，直接:</p>

<p>(5 + 20 * 99) /100 = 19.85</p>

<p>这是算数平均计算方法，算数平均和加权计算的结果相比，可能相差万里；</p>

<h4 id="section-5">总市值统计？</h4>

<p>A股市场上还有一个特殊现象，就是有些股票并不是全流通的，这个时候他的总市值是只计算流通股呢？还是全部都算呢？ </p>

<p>总市值统计方法的不同，又会影响到最终PE的计算结果</p>

<h4 id="section-6">亏损公司的计算</h4>

<p>如果一家公司亏损呢？还应该放到指数里面统计吗？</p>

<p>根据对亏损公司的处理方法的不同，又会影响到最终PE的计算结果</p>

<h4 id="b">B股的折价计算</h4>

<p>如果指数里面有的公司还有B股，那么B股的市值也要放进来计算吗？计算的时候如何设定权重？利润如何统计？</p>

<p>相对于B股的处理方法的不同，又会影响到最终PE的计算结果</p>

<h4 id="ah">A/H股的折价计算</h4>

<p>如果指数里面有的公司还有H股，那么H股的市值也要放进来计算吗？计算的时候如何设定权重？利润如何统计？</p>

<p>相对于H股的处理方法的不同，又会影响到最终PE的计算结果</p>

<h2 id="pe-3">指数PE的历史估值计算</h2>

<p>很多软件平台提供了PE/PB的历史估值计算，比如蛋卷基金会每天更新数值，告诉我们今天沪深300的PE估值处理历史百分位的xxx%；</p>

<p>如果你认真一点，就会发现所有平台的估值百分位都不一样！</p>

<p>PE的计算就如此五花八门，历史百分位当然不一样啦。</p>

<p>且慢，即使各大平台的PE计算都一样，历史估值百分位也可能不一样！为啥？</p>

<h4 id="section-7">统计时长的不同</h4>

<p>一个指数，他的历史区间该如何选取呢？</p>

<p>从指数成立的那一天开始？</p>

<p>取前5年历史？前8年历史？前10年历史？</p>

<h4 id="section-8">估值统计算法的不同</h4>

<p>算数平均 or 加权平均 or 中位数统计？</p>

<h2 id="section-9">总结</h2>

<p>所以有人说他算出了一个指数的PE，我们需要问他：</p>

<ol>
  <li>个股采用的啥PE计算方法？ 静态PE？动态PE？滚动PE？ 动态取的是季报？半年报？年报？还是上一期年报/季报的预测值？</li>
  <li>指数是总市值加权计算还是算术平均计算？</li>
  <li>亏损公司怎么处理？</li>
  <li>停牌公司怎么处理？</li>
  <li>B股怎么处理？</li>
  <li>H股怎么处理？</li>
  <li>估值采用的历史数据时间段怎么取？前3年，5年，8年，成立以来? 成立之前还根据指数编制原则计算并统计进来了？</li>
  <li>指数百分比的估值算法是什么？加权统计？算数平均？中位数？</li>
</ol>

<p>看了上面这么多干扰因子，相信你已经眼花缭乱了；而且每一种因子的处理方法都会引来无穷无尽的争论~~~</p>

<p>指数PE是永远也算不准的，那一个算不准的指标有啥好参考的？相信很快会有很多人跳出来说出各种理论~~~</p>

<p>无辜的摊手，我也不知道，呵呵哒。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Berkshire's Charlie Munger Calls Bitcoin 'Noxious Poison']]></title>
    <link href="https://happy123.me/blog/2019/05/09/berkshires-charlie-munger-calls-bitcoin-noxious-poison/"/>
    <updated>2019-05-09T10:12:02+08:00</updated>
    <id>https://happy123.me/blog/2019/05/09/berkshires-charlie-munger-calls-bitcoin-noxious-poison</id>
    <content type="html"><![CDATA[<p>Berkshire annual meeting 2019 Q&amp;A，巴菲特和芒格老爷子又来Diss bitcoin了；</p>

<h4 id="munger">Munger:</h4>

<blockquote>
  <p>It’s just disgusting. Bitcoin is noxious poison.</p>
</blockquote>

<h4 id="buffet">Buffet:</h4>

<blockquote>
  <p>It’s a gambling device… there’s been a lot of frauds connected with it. There’s been disappearances, so there’s a lot lost on it. Bitcoin hasn’t produced anything</p>
</blockquote>

<blockquote>
  <p>It doesn’t do anything. It just sits there. It’s like a seashell or something, and that is not an investment to me</p>
</blockquote>

<p>两位老爷子是bitcoin社区值得敬重的对手，从一而终，一直坚定的黑；</p>

<p>和一些骑墙派比起来，这份<code>坚守自己能力圈</code>的自律的确让人敬重。</p>

<p>不管今后结果如何，要把这两位智慧老人的话牢牢记在心里；记住我们的贪婪、愚蠢、傲慢等等;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go包管理工具]]></title>
    <link href="https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju/"/>
    <updated>2019-05-01T15:25:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju</id>
    <content type="html"><![CDATA[<p>真的，Go的包管理工具之发展过程充分体现了什么叫<code>折腾</code>。 (叹气~~~)</p>

<!-- more -->

<p>想想Java的Maven， Nodejs的NPM，还有我们赞颂一万遍也不过分的Python包管理，为什么生命总要浪费在这些事情上面呢？ 陷入了深深的沉思~~</p>

<p>从Go1.11版本发布Go MODULE之后，我希望这是最后一次折腾<code>包管理</code>这件事情，神呐，诚心诚意的祈祷中~~</p>

<p>摘抄备忘下：</p>

<h2 id="go111module">GO111MODULE</h2>

<p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。
按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，GO111MODULE 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p>

<ul>
  <li>
    <p>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</p>
  </li>
  <li>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</li>
  <li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:
    <ul>
      <li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li>
      <li>当前目录位于包含 go.mod 文件的目录下</li>
    </ul>
  </li>
</ul>

<h2 id="go-mod-">go mod 命令</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">download    download modules to local cache (下载依赖的 modules 到本地 cache)
</span><span class="line">edit        edit go.mod from tools or scripts (编辑 go.mod 文件)
</span><span class="line">graph       print module requirement graph (打印模块依赖图)
</span><span class="line">init        initialize new module in current directory (再当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
</span><span class="line">tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)
</span><span class="line">vendor      make vendored copy of dependencies (将依赖复制到 vendor 下)
</span><span class="line">verify      verify dependencies have expected content (校验依赖)
</span><span class="line">why         explain why packages or modules are needed (解释为什么需要依赖)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">既有项目</h2>

<p>假设你已经有了一个 go 项目， 比如在$GOPATH/github.com/brain-zhang/hello下， 你可以使用go mod init github.com/brain-zhang/hello在这个文件夹下创建一个空的 go.mod (只有第一行 module github.com/brain-zhang/hello)。</p>

<p>然后你可以通过 go get ./…让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 -tags, 这样可以把 tags 的依赖都查找到)。</p>

<p>通过go mod tidy也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理tags。</p>

<p>执行上面的命令会把 go.mod 的latest版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p>

<h2 id="replace">replace</h2>

<p>在国内访问golang.org/x的各个包都需要梯子，你可以在 go.mod 中使用replace替换成 github 上对应的库。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">replace (
</span><span class="line">  golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
</span><span class="line">  golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
</span><span class="line">  golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
</span><span class="line">)
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>依赖库中的replace对你的主 go.mod 不起作用，比如github.com/brain-zhang/hello的 go.mod 已经增加了replace, 但是你的 go.mod 虽然require了rpcx的库，但是没有设置replace的话， go get还是会访问golang.org/x。</p>

<p>所以如果想编译哪个项目，就在哪个项目中增加replace。</p>

<h2 id="section-1">包的版本控制</h2>

<p>下面的版本都是合法的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
</span><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2.9.1
</span><span class="line">gopkg.in/yaml.v2 &lt;=v2.2.1
</span><span class="line">github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
</span><span class="line">latest
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>版本号遵循如下规律：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
</span><span class="line">vX.0.0-yyyymmddhhmmss-abcdefabcdef
</span><span class="line">vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
</span><span class="line">vX.Y.Z
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p>

<p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p>

<h2 id="go-get-">go get 升级</h2>

<ul>
  <li>运行 go get -u 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li>
  <li>运行 go get -u=patch 将会升级到最新的修订版本</li>
  <li>运行 go get package@version 将会升级到指定的版本号version</li>
</ul>

<h2 id="go-modules--vendor">go modules 与 vendor</h2>

<ul>
  <li>
    <p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p>
  </li>
  <li>
    <p>Go modules 支持通过go mod vendor命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用go build -mod=vendor即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p>
  </li>
</ul>

<h2 id="section-2">参考:</h2>

<p>https://roberto.selbach.ca/intro-to-go-modules/</p>

<p>https://github.com/golang/go/wiki/Modules</p>

<p>https://windmt.com/2018/11/08/first-look-go-modules/</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指数投资策略]]></title>
    <link href="https://happy123.me/blog/2019/04/08/zhi-shu-tou-zi-ce-lue/"/>
    <updated>2019-04-08T17:55:22+08:00</updated>
    <id>https://happy123.me/blog/2019/04/08/zhi-shu-tou-zi-ce-lue</id>
    <content type="html"><![CDATA[<h4 id="section">降龙四式之亢龙有悔</h4>

<h4 id="section-1">谨记：一切回测有效的策略都是看后视镜开车。回测仅仅是参考，不能预测未来。</h4>
<p>#### 谨记：成功概率不能预测，失败风险无法回避，历史周期不断重复，时刻抱有敬畏之心。</p>

<h1 id="section-2">指数特点</h1>

<ul>
  <li>背靠国运，不死鸟</li>
  <li>长期上涨</li>
  <li>成本低</li>
  <li>不择股</li>
  <li>容易量化</li>
  <li>大道至简</li>
</ul>

<!-- more -->

<h1 id="section-3">指数品种</h1>

<p>简单粗暴的分为宽基和窄基，窄基又可以细分为策略类、风格类、行业类、主题类；</p>

<h2 id="section-4">宽基指数</h2>

<ul>
  <li>上市不满一个季度的股票不选；暂停上市的股票不选；财务上有问题的股票不选；多年亏损的股票不选。</li>
</ul>

<h4 id="section-5">上证50 (代码是000016)</h4>
<ul>
  <li>
    <p>上交所挑选沪市规模最大、流动性好、最具代表性的50只股票组成样本股，以综合反映沪市最具影响力的一批优质大盘企业的整体状况。2004年1月2日发布，但却是以2003年12月31日为基准日期开始运作的。</p>
  </li>
  <li>
    <p>从2003年年底以来，国内股市发生过三轮比较明显的牛市，分别发生在2006～2007年、2009年和2015年。其余时间里股市大多波澜不惊，走平或者阴跌。</p>
  </li>
</ul>

<h4 id="section-6">沪深300 (代码000300)</h4>

<ul>
  <li>从上交所和深交所挑选规模最大、流动性最好的300只股票。从市值规模上来说，占到国内股市全部规模的60%以上。沪深300基本上包括上证50</li>
</ul>

<h4 id="section-7">中证500 (代码000905)</h4>

<ul>
  <li>将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，这样可以最大限度地避免选入大公司。在剩下的公司中，选择日均总市值排名前500名的企业</li>
</ul>

<h4 id="section-8">创业板综指 (代码是399102)</h4>

<ul>
  <li>包括创业板全部的500多家企业</li>
</ul>

<h4 id="section-9">创业板指数 (代码是399006)</h4>

<ul>
  <li>创业板最主要的100家企业</li>
</ul>

<p>创业板指数整体公司规模较小，属于以中小型公司为主的指数。并且这些公司大多盈利没有进入稳定期，所以创业板的整体盈利数字比较低；公司开展新业务也更容易导致盈利大起大落。小公司＋盈利没有进入稳定期，创业板指数相比之前介绍的指数，更容易暴涨暴跌。</p>

<h4 id="section-10">上证综指(000001)</h4>

<p>综指指的是综合指数，上证综指包括了上交所全部的上市公司，目的是反映上交所所有股票的走势。</p>

<p>这个指数娱乐意义最大。</p>

<h4 id="section-11">中证100指数(000903)</h4>

<p>中证100指数是从沪深300指数中，再挑选出规模最大的100只股票组成的。比起上证50指数，它覆盖了深交所的大公司，所以更加全面一些。</p>

<h4 id="section-12">中证800指数</h4>

<p>中证500plus</p>

<h4 id="section-13">中证1000指数</h4>

<p>中证500plus+</p>

<h4 id="section-14">中证全指</h4>

<p>中证plus++</p>

<h4 id="hsl">恒生指数(HSL)</h4>

<ul>
  <li>港上市的公司中规模最大的50家企业。因为中国香港金融市场比较开放，境外投资者很容易就能进来投资或者撤资，所以一有风吹草动，就会体现在港股价格的波动上。</li>
  <li>最近3年国家先后开通了沪港通和深港通，内地资金正在夺回港股的定价权</li>
</ul>

<h4 id="h">H股指数</h4>

<ul>
  <li>内地注册，但是在香港地区上市，这样的公司就是H股了。与A股关联度大，因为同股不同价，有很多精明指数前来套利。</li>
</ul>

<h4 id="section-15">标普500指数</h4>

<ul>
  <li>巴菲特唯一指定接班人</li>
  <li>需要注意的是，标普500也有一个<code>完全没有用的</code>委员会搞一些选股工作</li>
</ul>

<h4 id="section-16">纳斯达克100指数</h4>

<ul>
  <li>纳斯达克规模最大的100家大型企业</li>
</ul>

<h4 id="dax">德国30DAX</h4>

<ul>
  <li>跟踪基金盘子小，误差大</li>
</ul>

<h4 id="section-17"></h4>

<h2 id="section-18">行业指数</h2>

<p>行业有自己的投资特点，不能一概而论，需要针对行业的特点具体分析。所以就投资难度来说，行业指数比宽基指数要高出不少。</p>

<p>值得投资的行业，主要有两个，一个是天生赚钱更容易的行业，另一个是具有明显强周期性的行业。</p>

<p>我认为最值得关注的是消费指数和医药指数。</p>

<h4 id="section-19">上证消费指数</h4>

<ul>
  <li>从上交所挑选必需消费行业公司。</li>
</ul>

<h4 id="section-20">上证消费80指数</h4>

<ul>
  <li>从上交所挑选80家规模最大的必需消费行业公司。</li>
</ul>

<h4 id="section-21">中证消费指数</h4>

<ul>
  <li>从中证800，即沪深300和中证500中挑选必需消费行业公司。</li>
</ul>

<h4 id="section-22">全指消费指数</h4>

<p>从所有上市公司中挑选必需消费行业公司，覆盖范围最广。</p>

<h4 id="section-23">300医药指数</h4>

<ul>
  <li>挑选了沪深300指数里的医药行业公司。</li>
</ul>

<h4 id="section-24">500医药指数</h4>

<ul>
  <li>挑选了中证500指数里的医药行业公司。</li>
</ul>

<h2 id="section-25">策略加权指数</h2>

<h4 id="ah">上证50AH优选指数</h4>

<ul>
  <li>基于A股、H股的聪明指数</li>
</ul>

<h4 id="section-26">上证红利指数 (000015)</h4>

<ul>
  <li>上交所过去两年平均现金股息率最高的50只股票</li>
</ul>

<h4 id="section-27">中证红利指数 (000922/399922)</h4>

<ul>
  <li>上交所和深交所挑选过去两年平均现金股息率最高的股票，成份股数量扩大到100只。</li>
</ul>

<h4 id="section-28">深证红利指数 (399324)</h4>

<ul>
  <li>专门投资深交所的高现金股息率的股票，不过成份股只有40只。</li>
</ul>

<h4 id="section-29">红利机会指数 (501029)</h4>

<ul>
  <li>传统的红利指数，一般只是挑选高股息率的股票，没有其他的要求。</li>
  <li>红利机会指数有3个要求：过去3年盈利增长必须为正；过去12个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过33%。符合这3个要求的成份股才能入选，所有入选的股票再按照股息率排名选出股息率最高的100只股票，构成红利机会指数。</li>
</ul>

<h4 id="section-30">中证基本面50指数</h4>

<p>基本面指数中，在国内最出名的就是中证基本面50指数。这个指数是按照4个基本面指标，挑选出综合排名前50的公司。具体来说，是从上市公司过去5年的年报数据中，计算4个基本面指标。</p>

<ul>
  <li>营业收入：公司过去5年营业收入的平均值。</li>
  <li>现金流：公司过去5年现金流的平均值。</li>
  <li>净资产：公司在定期调整时的净资产。</li>
  <li>分红：公司过去5年分红总额的平均值。</li>
</ul>

<h4 id="section-31">深证基本面60、120指数</h4>

<p>深证基本面60、120是基本面系列指数，跟之前我们提到过的基本面50规则一样。挑选市场上收入、净利润、净资产、分红综合起来最大的公司。</p>

<p>基本面120的成分股平均市值规模，跟中证200是最接近的。所以可以作为中证200的良好替代品。</p>

<h4 id="section-32">沪深300价值指数</h4>

<ul>
  <li>以沪深300指数样本股中价值因子评分最高的100只股票为成分股，采用价值因子数值作为权重分配依据。</li>
</ul>

<h4 id="section-33">中证500低波动</h4>

<ul>
  <li>从中证500指数中，挑选波动率最低的150只股票组成的。 波动率越低的股票，权重越高。</li>
  <li>每半年更换股票的时候，500低波动会因为成分股的更新，估值出现较大波动。</li>
</ul>

<h2 id="section-34">投资品种筛选</h2>

<h4 id="section-35">指数筛选</h4>

<ol>
  <li>不择股，宽基指数优于行业指数</li>
  <li>两个指数有重叠，选更宽的一个 （沪深300&gt;上证50）</li>
  <li>两个指数重叠，选策略加权的哪一个 (上证50AH优选&gt;上证50)</li>
  <li>宽基指数再用策略筛选，优先选择策略指数</li>
  <li>最终组合的关联度要小</li>
</ol>

<p>综合考虑，我们选取以下指数作为标的：</p>

<ul>
  <li>上证50AH</li>
  <li>沪深300价值</li>
  <li>中证500低波动</li>
  <li>深证基本面120</li>
  <li>红利机会指数</li>
  <li>恒生指数</li>
  <li>标普500</li>
  <li>纳斯达克</li>
</ul>

<h4 id="section-36">指数基金筛选</h4>

<ol>
  <li>选场外基金</li>
  <li>选费率低的基金</li>
  <li>港股指数选沪港通</li>
  <li>和增强指数相比，优先选取策略指数，增强指数人为因素多，市场越成熟，增强效果越小，但是当前增强指数还是值得选择，随着市场进一步成熟，我们会慢慢转移到ETF联结基金上以降低费率；</li>
  <li>盘子大，成立时间久，便于历史数据回测</li>
</ol>

<p>(整理时间:2019.04.1)</p>

<table>
  <thead>
    <tr>
      <th>基金简称</th>
      <th>基金代码</th>
      <th>管理费率%</th>
      <th>托管费率%</th>
      <th>申购费率%(取10%)</th>
      <th>规模 亿</th>
      <th>最大回撤 %</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>华宝标普中国A股红利机会指数A</td>
      <td>501029</td>
      <td>0.75</td>
      <td>0.15</td>
      <td>0.1</td>
      <td>20</td>
      <td>29.36</td>
    </tr>
    <tr>
      <td>申万菱信沪深300价值指数</td>
      <td>310398</td>
      <td>0.65</td>
      <td>0.15</td>
      <td>0.12</td>
      <td>20</td>
      <td>40.25</td>
    </tr>
    <tr>
      <td>景顺中证500行业中性低波动</td>
      <td>003318</td>
      <td>0.5</td>
      <td>0.1</td>
      <td>0.12</td>
      <td>8.13</td>
      <td>33.5</td>
    </tr>
    <tr>
      <td>嘉实深证120联接</td>
      <td>070023</td>
      <td>0.5</td>
      <td>0.1</td>
      <td>0.12</td>
      <td>5.84</td>
      <td>39.22</td>
    </tr>
    <tr>
      <td>华夏上证50AH优选指数A</td>
      <td>501050</td>
      <td>0.5</td>
      <td>0.1</td>
      <td>0.15</td>
      <td>9.17</td>
      <td>23.63</td>
    </tr>
    <tr>
      <td>国泰纳斯达克100指数</td>
      <td>160213</td>
      <td>0.8</td>
      <td>0.25</td>
      <td>0.15</td>
      <td>7.34</td>
      <td>22.25</td>
    </tr>
    <tr>
      <td>博时标普500ETF联接A</td>
      <td>050025</td>
      <td>0.6</td>
      <td>0.25</td>
      <td>0.12</td>
      <td>4.26</td>
      <td>18.08</td>
    </tr>
    <tr>
      <td>华夏沪港通恒生ETF联接A</td>
      <td>000948</td>
      <td>0.5</td>
      <td>0.1</td>
      <td>0.12</td>
      <td>7.89</td>
      <td>31.91</td>
    </tr>
  </tbody>
</table>

<h2 id="beta">Beta因子</h2>

<h4 id="section-37">以下因子仅适用于宽基指数</h4>

<h4 id="section-38">数据永远在变，切勿刻舟求剑</h4>

<h4 id="roe">收益率ROE</h4>

<p>ROE = PB/PE</p>

<p>ROE是称重机，长期来看，股票的回报率趋近于ROE。大多数时间里，宽基指数的ROE维持在10-15%左右。</p>

<h4 id="pb">市净率PB</h4>

<p>同样是股权资产，有的股权资产ROE就比较高而且稳定，像消费类医药类公司；有的股权资产ROE呈周期性波动，像钢铁石油券商；有的股权资产走向了没落，ROE甚至变为负数，是赔钱货。所以针对不同资产的定价也不同。</p>

<p>从定性的角度，ROE越高、越稳定，我们要买下这份净资产，每单位净资产就要花更多的钱，也就是市净率会越高。</p>

<p>所以我们买某个指数，也可以理解为是用一定的溢价（pb的数值）去买一份盈利的资产。</p>

<p>从这点，盈利收益率实际上就是折算了pb溢价之后的ROE。</p>

<p>PB在1-1.5为低估。</p>

<h4 id="pe">市盈率PE</h4>

<p>进入经济周期底部的时候，盈利增速放缓，我们为盈利增长支付的溢价比较少，PE处于低位；同时ROE也会降低，我们为资产盈利能力支付的溢价也比较少，PB也处于低位。</p>

<p>PE &lt; 10 为低估</p>

<h4 id="section-39">十年国债</h4>

<p>十年国债代表无风险收益率；当市面上能找到的无风险收益类产品&gt;十年国债利率X2，卖出指数，持有此产品。</p>

<h4 id="section-40">一些要点</h4>

<ol>
  <li>指数市盈率与市净率都是较低的时候，指数处于低估区域</li>
  <li>如果遇到成分股盈利下降导致指数市盈率上升，就参考市净率，看看是不是在1-1.5之间；</li>
</ol>

<h4 id="section-41">正常区间</h4>

<p>全市场25 PE，意味着收益率4% (超过十年期国债)。此时全市场一般 1.5-2 PB</p>

<h4 id="section-42">系统性低估机会</h4>

<p>市场出现PE&lt;7、PB&lt;1、股息率&gt;5% (ROE&gt;18%)的品种时，属于系统性低估机会</p>

<h4 id="section-43">系统性高估顶部</h4>

<p>全市场整体60 PE，整体PB&gt;5.5，哈迪斯之顶</p>

<h4 id="section-44">警惕</h4>

<ol>
  <li>低市盈率陷阱</li>
  <li>高股息陷阱</li>
</ol>

<h4 id="section-45">历史经验</h4>

<p>各指数的历史平均估值</p>

<p>从09年之后</p>

<ul>
  <li>上证50的主要估值在9-16倍之间</li>
  <li>沪深300在10-18倍之间</li>
  <li>中证500在28-53倍之间</li>
  <li>H股指数在9-13倍之间</li>
  <li>红利指数在9-15倍之间</li>
</ul>

<p>自成立以来</p>

<ul>
  <li>恒生指数在11-18倍之间</li>
  <li>标普500自成立以来在10-20倍之间</li>
</ul>

<h1 id="section-46">低估不定期不定额策略</h1>

<p>好了，选取了品种，充分了解了历史，剩下的就是制定策略，回测执行啦</p>

<p>我们的策略制定原则：</p>

<ol>
  <li>可复现、可回测</li>
  <li>排除人工干扰，机器拯救人类</li>
  <li>落子无悔，买定离手</li>
  <li>低估买，高估卖，没有机会不动</li>
  <li>资金分为100份分批投入</li>
</ol>

<h3 id="section-47">买入条件</h3>

<ol>
  <li>市场出现系统性低估机会可以买入</li>
  <li>单一标的PE、PB 处于历史30%以下可以买入</li>
  <li>PE处于历史30%以下，且PB&lt;1.5可以买入</li>
  <li>PB处于历史30%以下，且PE&lt;10 或 1/PE&lt;十年期国债利率X2，可以买入</li>
</ol>

<h3 id="section-48">卖出条件</h3>

<ol>
  <li>市场出现系统性高估机会可以卖出</li>
  <li>单一标的PE、PB 处于历史70%以上可以卖出</li>
  <li>PE处于历史70%以上，且PB&gt;2可以卖出</li>
  <li>PB处于历史70%以上，且PE&gt;25可以卖出</li>
  <li>1/PE&lt;市场能找到的最小无风险收益率，可以卖出置换</li>
</ol>

<h3 id="section-49">简单持有</h3>

<p>不符合买入，也不符合卖出条件，简单持有即可。</p>

<p>若市场利率缓慢下行，可简单买入短债基金持有，其他情况不动。</p>

<h3 id="section-50">半凯利公式控制仓位</h3>

<p>采用<a href="https://xueqiu.com/3079173340/62032246">银行螺丝钉</a>的方法计算仓位；</p>

<p>其盈利增长率我们替换为10年ROE中位值，因为长远来看，PEG会趋近于ROE；用ROE更加保险</p>

<p>以恒生指数为例。</p>

<ul>
  <li>恒生指数过去10年的ROE中位值10%左右</li>
  <li>我们期望5年年化15%的收益率</li>
  <li>PE历史30%大概为12，配合我们上面要求的条件，我们需要在10PE买入</li>
</ul>

<h4 id="section-51">凯利公式</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">F =（bp - q）/ b
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中b代表赔率，p代表获胜率，q代表落败率，q = 1-p</p>

<h4 id="section-52">投资指数基金的赔率</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">赔率b =（卖出时估值/买入时估值）*【1+指数盈利增长率】^持有年数 =（1+你要求的年复合收益率）^持有年数
</span><span class="line">
</span><span class="line">b = （卖出时估值/买入时估值）* 1.1^5 = 1.15^5
</span><span class="line">
</span><span class="line">卖出时估值PE/10 ≈ 1.25
</span><span class="line">
</span><span class="line">要求卖出时估值 ≈ 12.5
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样就把我们的投资行为固化为了这样一个事件：</p>

<p>假如未来恒生指数能保持平均10%的ROE，我们在10PE买入恒生指数，要求有15%的年复合收益率，那我们“需要在5年的时间里，至少有一次机会在12.5倍以上市盈率卖出”。</p>

<h4 id="section-53">投资指数基金的胜率</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">胜率 = 期望卖出PE的历史估值概率
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5年时间里，12.5PE是大概率事件，事实上，我们要求在70%的PE上方卖出，这个值大概是15PE。</p>

<p>12.5PE在历史上大概处于 60%的位置， 所以我们的条件还是非常宽松的。</p>

<p>按照我们前面制定的的边界卖出条件 PE估值百分位 &gt; 70%，所以如果能买到10PE以下的恒生指数，并且期望5年内年化收益15%的化，只要能持有不动，胜率&gt;60%；</p>

<h4 id="section-54">计算仓位</h4>

<p>通过凯利公式计算出来的仓位， X0.5；成为半凯利公式</p>

<p>胜率60%，赔率2；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">F =（bp-q）/b = (2 * 60% - 40%)/2 = 40%
</span><span class="line">
</span><span class="line">F * 0.5 = 20%
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>根据半凯利公式推出，推荐仓位为20%。</p>

<h4 id="section-55">一些推论</h4>

<ul>
  <li>预期收益越低，胜率就会越高，仓位也会越高。如果预期收益过高，甚至仓位会是负数（也就是无法实现）</li>
  <li>买入估值越低，胜率就会越高，仓位也会越高。如果买入估值过高，甚至仓位会是负数（无法赚取估值差收益）</li>
  <li>指数的盈利增长率越高，对应的胜率也会越高</li>
  <li>买入时不要求每次都能赢，但是一定要在赢面大的时候下大注</li>
</ul>

<h4 id="section-56">多指数组合计算仓位</h4>

<p>对组合中的每个指数设定 买入PE，卖出PE，持有年数，要求年复合增长率， 分别计算仓位</p>

<p>全部仓位相加，便可以决定总仓位。</p>

<h4 id="section-57">定投</h4>

<p>每次的总仓位即 定投总额 / 定投次数；比如5年计划投入60w，每月定投一次，那么每次总仓位1w；</p>

<p>每次计算卖出PE点大于历史估值70%即可盈利的品种，并决定仓位；然后所有仓位相加。</p>

<p>如果定投不定额， 每次仓位可以超过100%；</p>

<p>如果定投定额，每个品种的仓位比例再等分平均，最后达到100%</p>

<p>如果没有符合条件的品种或者总仓位&lt;100%，买入短债基金代替；</p>

<p>达到卖出条件分批减仓，减仓可以逆运算，也可以简单的用一个网格策略逐步卖出。</p>

<h4 id="section-58">不定期不定额</h4>

<p>如果我们有一个量化策略，可以直接把投入资金分为100份，在某个品种达到极高的胜率的时候计算仓位一把买入；然后在此之上， 采用价值平均策略定投，长期持有；</p>

<h4 id="section-59">卖出</h4>

<p>卖出的选择可以很简单，设定一个简化的网格策略，PE到了历史70%的区间每次卖掉1%，到了80%每次卖掉10%….</p>

<p>或者可以更精确的来控制，我们买入每一份指数时都精确计算了5年后期待的PE值，你可以先等够5年，然后市场到了期待的PE之后卖出；</p>

<p>经过我的统计，大部分宽基指数(沪深300为例) 70%的区间值/30%的区间值 ≈ 1.3，而历史ROE趋近于10%，也就是说这么算下来，只要30%以下买，70%以上卖，大概率能达到我们的期待收益。</p>

<h1 id="section-60">回测</h1>

<p>为了验证我们的策略靠谱程度，我选取了最简单的样本集合：</p>

<table>
  <thead>
    <tr>
      <th>指数代码</th>
      <th>指数名称</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>000919.XSHG</td>
      <td>300价值</td>
    </tr>
    <tr>
      <td>399702.XSHE</td>
      <td>深证F120</td>
    </tr>
    <tr>
      <td>000905.XSHG</td>
      <td>中证500</td>
    </tr>
    <tr>
      <td>000922.XSHG</td>
      <td>中证红利</td>
    </tr>
  </tbody>
</table>

<h3 id="pepb">历史PE，PB，估值统计</h3>

<p>夫以铜为镜，可以正衣冠；以古为镜，可以知兴替；以人为镜，可以明得失。让我们先看下历史估值。</p>

<p>每周采样；当前PE、PB值取自2019-04-10，市值加权算法统计</p>

<h4 id="section-61">时间段选取2004-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190402/bg1.jpg" alt="img" /></p>

<h4 id="section-62">时间段选取2009-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190402/bg2.jpg" alt="img" /></p>

<h4 id="section-63">时间段选取2011-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190402/bg3.jpg" alt="img" /></p>

<p>从图上可以看出，A股市场的整个PE和PB中枢逐年降低；所以用最近5年或者最近8年的历史数据来判断估值百分位比较靠谱。</p>

<p>另外一个感性结论，从图上很容易看出，只要是宽基指数，拉长时间来看，PE、PB的震荡曲线几乎是一样的；所以用我们的历史PE、PB估值法，每次买入的时间点可能基本相同，但是份额不同。</p>

<h2 id="section-64">量化回测</h2>

<p>是滴，我就是这么严谨；为了取得最大的普适性，我选取了华夏沪深300ETF联结基金作为标的，采取我们上述的策略，回测了一下：</p>

<ol>
  <li>初始资金100000，分为20份，每份5000元</li>
  <li>时间就选取2018-08-01 – 2019-04-10，这段时间内的波动比较大，容易看出我们策略的行动模式</li>
</ol>

<p>一图抵千言：</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190402/bg4.jpg" alt="img" /></p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190402/bg5.jpg" alt="img" /></p>

<p>整个过程中，我们买入了17份，然后2019-04-02开始逐步卖出，卖出策略我选取了简单的网格策略；</p>

<p>当然，这个时间段实在太短，娱乐效果为主；不过我们还是看到了这个套路的一些特点：</p>

<ol>
  <li>买入卖出的时间段都非常短，大概就持续半年左右的时间窗口，其他时间我们都是<code>不动</code></li>
  <li>因为买的特别便宜，所以安全边际大，你可以很放心的持有不动</li>
  <li>采用凯利公式判断仓位的方法不是特别有效，70%的百分比太严格，一般到了这里基本上每次买的份额都差不多，体现不出仓位管理</li>
</ol>

<h4 id="section-65">可以有如下改进</h4>

<ol>
  <li>仓位管理引入PB因子，进一步实现<code>低估重手买</code>的策略</li>
  <li>20份资金有点少，可以增大资金分数</li>
  <li>多个指数组合策略，进一步降低风险，也能把握更多机会</li>
  <li>70%的百分比标准可以适当放宽</li>
</ol>

<p>采用了上述优化策略之后，需要在一个较长的时间周期中回测(2010-2019)检验其靠谱程度。</p>

<h2 id="section-66">量化回测2</h2>

<p>调优了几个小参数：</p>

<ul>
  <li>投注份额改为50份；原因：做了大量统计之后，虽然我们的买入点实在PE历史30%以下，但实际上以5年为区间，买入的时机只有1年左右，我们按周测算，总投注份额50份为佳</li>
  <li>为了方便计算，总投注金额为50000元，每份1000元</li>
  <li>对于卖出策略做了简单的优化</li>
  <li>回测时间拉长到2012-10-01 — 2019-04-10</li>
  <li>计算PE、PB的历史估值区间选取前5年；原因：A股市场每7年就有一次大的波动，其实把这种波动放在总的统计数据里面是失真的，5年时间刚好能避开此类波动，而且我国每5年一个经济计划，一定程度上5年时间反应了一个小的经济周期</li>
</ul>

<p>代码放在这里：</p>

<p>https://github.com/brain-zhang/kanglong</p>

<p>好啦，我们还是以沪深300为基准，看看这个策略和原指数的对比：</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190402/bg6.jpg" alt="img" /></p>

<p>从这个画风上来看，这个策略确实是一个看后视镜开车的老司机，结果拟合相当完美；你可以把它看成是一个超级稳健、超级耐心的基金经理，这个经理的风格如下：</p>

<ol>
  <li>超级稳健，超级懒，80%的时间是持有现金不动的</li>
  <li>其7年的总收益为87%，这个没有计算现金产生的收益，如果按照3%的货基收益，总收益是可以超过100%的；</li>
  <li>最大回撤&lt;10%</li>
</ol>

<h4 id="section-67">当然，看后视镜开车开的再好也只是个参考，这个策略作为一个简单易行的思路还是有不少借鉴意义的。关键是它给了我们<code>身处何方</code>的坐标。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[资产配置初探]]></title>
    <link href="https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan/"/>
    <updated>2019-04-07T14:51:33+08:00</updated>
    <id>https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan</id>
    <content type="html"><![CDATA[<p>在<a href="https://www.douban.com/doulist/112721741/">死读书一年</a>之后，对这个问题自我感觉颇有心得，谬论如下：</p>

<blockquote>
  <p>道理已在书单中，只记录我的思考结果</p>
</blockquote>

<ul>
  <li>这个世界上有两种永远成立的投资方法：基于选取资产标的获取超额收益，以及基于资产配置获取市场平均收益。</li>
  <li>对普通人来说，资产配置优于择时择股</li>
</ul>

<!-- more -->

<p>资产配置选择包括不动产、国债、黄金、大类资产、货币基金、银行固收、债券逆回购、可转债、地方债、企业债、分级基金、指数基金、个股、股指期货等；</p>

<p>个人能驾驭的不过是三样：不动产、债券、ETF</p>

<p>我个人认为除了中心城市的不动产有配置价值之外，其他城市只有使用价值，故而排除在外；以下我尝试着只利用权益类资产来构建一个可攻可守的组合。</p>

<p>为了娱乐自己，我总结出来的普适个人的资产配置方法称之为降龙四式：</p>

<h4 id="section">第一式密云不雨</h4>

<p>总流动现金的20%配置为现金、银行固收、货币基金、7天债券逆回购；</p>

<p>要求拥有完全的流动性和安全性；其边际风险等同于国债。这是完全的防守招式。</p>

<h4 id="section-1">第二式潜龙在渊</h4>

<p>总流动现金的35%构建一个股债平衡的资产包；</p>

<p>其中80%选取流动性好、配置稳健的债基、其20%选取两个ETF(沪深300和中证500)做二八轮动；</p>

<p>80%的债和20%的股每过半年做动态再平衡；</p>

<p>且慢有个<a href="https://qieman.com/portfolios/ZH006358">安心动盈</a>的策略，跟我不谋而合。</p>

<p>这一招守中带攻，在第一式的基础上(两招相加55%的现金流)保证自己立于不败之地</p>

<h4 id="section-2">第三式亢龙有悔</h4>

<p>总现金流的15% 价值平均策略定投低估指数；</p>

<p>选取宽基策略指数(具体策略另外文章详述)；根据PE、PB、ROE、十年国债收益率确定入场时机，根据半凯利公式决定仓位，采用价值平均策略定投，子弹五年陆续打完；</p>

<p>这一招以攻代守，在指数低估时间入场、利用定时不定额定投降低风险；</p>

<p>切记，只有在前两式基础上，才能施展此招；这三式已然能在江湖行走而自保。</p>

<h4 id="section-3">第四式飞龙在天</h4>

<p>将总资金的30%投入到你最看好的一项资产中，<strong>永远持有</strong></p>

<p>这一招具有极大的杀伤性，用的好伤敌一千，用的差自伤八百。一定要在前三式完全施展之后才能接续此招。</p>

<h4 id="section-4">动态再平衡</h4>

<p>20%，35%，15%, 30%的比例每年做一次动态再平衡，同时取出一年生活用的现金流。</p>

<h2 id="section-5">总结</h2>

<p>前三式配置了所有资金的70%，是个攻守结合的套路，并且每一式都充分考虑了安全边际，力求风险最小化；</p>

<p>最后一式是一往无前、只求进攻、落子无悔的拼命招式，带有大概率的赌的成分；其成败完全取决于个人眼光和运势；</p>

<p>施展飞龙在天，我个人认为最好要35岁之后，一旦施展，无从回头；</p>

<h2 id="section-6">实践</h2>

<p>光说不练假把式，下面是我的实盘配置：</p>

<table>
  <thead>
    <tr>
      <th>招式</th>
      <th>配置品种</th>
      <th>比例%</th>
      <th>期待收益%</th>
      <th>最大回撤%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>密云不雨</td>
      <td>定存、货基、7天债券逆回购</td>
      <td>20</td>
      <td>3.5 (等同于十年国债收益率)</td>
      <td>0</td>
    </tr>
    <tr>
      <td>潜龙在渊</td>
      <td>安心动盈</td>
      <td>35</td>
      <td>8-10</td>
      <td>3-5</td>
    </tr>
    <tr>
      <td>亢龙有悔</td>
      <td>低估指数定投(具体策略另述)</td>
      <td>15</td>
      <td>12-18 (企业长期ROE)</td>
      <td>10-20</td>
    </tr>
    <tr>
      <td>飞龙在天</td>
      <td>比特币</td>
      <td>30</td>
      <td>50</td>
      <td>90</td>
    </tr>
  </tbody>
</table>

<p>每年收益的最大期望值为： 20 * 0.035 + 35 * 0.1 + 15 * 0.18 + 30 * 0.5 =  21.9%</p>

<p>每年最大回撤为: 20 * 0 + 35 * 0.05 + 15 * 0.2 + 30 * 0.9 = 31.75%</p>

<p>由此可以看出飞龙在天这一招的风险所在，飞龙在天的风险远远超过了收益，在纯粹的概率游戏中不应该施展；</p>

<p>但是对我而言，经过了5年多的反复思量，我认为这个标的值得施展这一招；</p>

<h4 id="section-7">当然，过度自信是悲剧的源泉，好在31.75%的风险还算不上万劫不复；如果没有绝对的自信的话，前三招行走江湖足矣。</h4>
]]></content>
  </entry>
  
</feed>
