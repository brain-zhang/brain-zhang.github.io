<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-04-24T17:44:14+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Get Pubkey From a Transaction]]></title>
    <link href="http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction/"/>
    <updated>2018-04-22T20:42:49+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction</id>
    <content type="html"><![CDATA[<p>比如<code>1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD</code>，这个地址，有转出过，如何得到公钥</p>

<p>原理很简单，但是实践起来比较烦：</p>

<!-- more -->


<p>首先我们找一下这个地址的随便一笔花费，比如这个:</p>

<p><a href="https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33">https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33</a></p>

<p>然后需要一个工具通过交易hash解析一下这笔交易</p>

<p>推荐用这个 <a href="https://github.com/libbitcoin/libbitcoin-explorer/wiki/Download-BX">libbitcoin/libbitcoin-explorer</a></p>

<p>执行</p>

<pre><code>bx-windows-x64-icu.exe fetch-tx 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
</code></pre>

<p>得到了这笔交易解析后的完整输出:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>transaction
</span><span class='line'>{
</span><span class='line'>    hash 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
</span><span class='line'>    inputs
</span><span class='line'>    {
</span><span class='line'>        input
</span><span class='line'>        {
</span><span class='line'>            address_hash b4a5d3960471568c3883046eec3b41b4953d61a1
</span><span class='line'>            previous_output
</span><span class='line'>            {
</span><span class='line'>                hash 5fb9f0e7f520163e4afe0baa440fe93999273e95d9e345e0488a0802ed62674f
</span><span class='line'>                index 0
</span><span class='line'>            }
</span><span class='line'>            script "[3045022100e4a4695ecbe6f507ec7181a2f321f489c7a3bd7eea032c75e4e1eba89174183c022019555aa917be6191db14da72e5c234a4b628f321b917ea334bcf9c122296cd5901] [044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b]"
</span><span class='line'>            sequence 4294967295
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    lock_time 0
</span><span class='line'>    outputs
</span><span class='line'>    {
</span><span class='line'>        output
</span><span class='line'>        {
</span><span class='line'>            address_hash c621cbfd778e6109e26046d96738c7af75e7b78b
</span><span class='line'>            script "dup hash160 [c621cbfd778e6109e26046d96738c7af75e7b78b] equalverify checksig"
</span><span class='line'>            value 43103
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    version 1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意script那一段，就是分成了两部分，前面一个中括号里面是签名，后面是公钥。</p>

<p>然后仔细看看这还是个老钱包生成的地址，没有压缩;</p>

<p>写个小脚本parse一下这个公钥，就可以看看是不是和地址对应啦:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env python
</span><span class='line'>
</span><span class='line'>from hashlib import *
</span><span class='line'>from base58 import *
</span><span class='line'>
</span><span class='line'>def SHA256D(bstr):
</span><span class='line'>    return sha256(sha256(bstr).digest()).digest()
</span><span class='line'>
</span><span class='line'>def ConvertPKHToAddress(prefix, addr):
</span><span class='line'>    data = prefix + addr
</span><span class='line'>    return b58encode(data + SHA256D(data)[:4])
</span><span class='line'>
</span><span class='line'>def PubkeyToAddress(pubkey_hex):
</span><span class='line'>    pubkey = bytearray.fromhex(pubkey_hex)
</span><span class='line'>    round1 = sha256(pubkey).digest()
</span><span class='line'>    h = new('ripemd160')
</span><span class='line'>    h.update(round1)
</span><span class='line'>    pubkey_hash = h.digest()
</span><span class='line'>    return ConvertPKHToAddress(b'\x00', pubkey_hash)
</span><span class='line'>
</span><span class='line'>pubkey = "044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b"
</span><span class='line'>print(len(pubkey))
</span><span class='line'>print("Address: %s" % PubkeyToAddress(pubkey))</span></code></pre></td></tr></table></div></figure>


<p>输出是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>130
</span><span class='line'>Address: 1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD</span></code></pre></td></tr></table></div></figure>


<p>OK，打完收工。</p>

<p>如果一个地址只收币，从来没消费币，公钥是不会广播到网上的，所以这种地址拿不到公钥。一定要有花费，才能得到公钥。</p>

<p>所以有人推荐每次花费币之后就不要再用老地址了，每次交易都用新地址，避免将来出现什么黑科技（比如量子计算机之类的）穷举破解。 其实我觉的无所谓，大不了有人喊ECDSA挂了我再转移一下就行了，人家富豪榜里面都有好几个大佬也不在乎这点事。</p>

<p>PS:更新自打脸一下，我还是觉得每次交易用新地址是一定要做的，理论上HASH碰撞的概率有2<sup>160</sup>，但是我现在觉得这个量级不能简单的推算为1/2<sup>160</sup>；所以再进行HASH还是很有必要的。</p>

<h4>再强调一遍，每次交易用新地址是一个必须养成的习惯。</h4>

<p>另外公钥有两种形式：压缩与非压缩。一把私钥其实可以搞出两个地址哈。早期比特币均使用非压缩公钥，现大部分客户端已默认使用压缩公钥。早期openssl库的文档写的比较糙，导致Satoshi以为必须使用非压缩的完整公钥，后来大家发现其实公钥的左右两个32字节是有关联的，左侧(X)可以推出右侧(Y)的平方值，有左侧(X)就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Satoshi Craig Wright Is Being Sued for $10 Billion]]></title>
    <link href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/"/>
    <updated>2018-04-22T19:31:24+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion</id>
    <content type="html"><![CDATA[<p>啥也不说了，涉及百亿美元的案子，估计在人类历史上都能排前排了。</p>

<p>而且作为Bitcoin粉，我估计这个案子有可能在历史上空前绝后。涉及悬疑，天才，欺诈，巨额金钱，先知等等元素~~</p>

<p>留名之。</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>另外我对这篇<a href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">文章</a>用press.one进行了<a href="https://press.one/file/v?s=60db2f3ea40a25d28781c900af248523eb3c17024ce3ca18a42433035aff55524e4b2df76cfcef1466d38c4e23e4ab770d42359835b66d159cd5dd5099e0be260&amp;h=a93f5a68189ff4a9b14d9e592c4dd0a8a1b649d0191b58740d93ce10c0d055ec&amp;a=7e32e3deba87efcd35bc6d1ab355d85c50aa60bd&amp;v=2&amp;f=P1">签名:</a></p>

<!-- more -->


<h4>PS:附一下之前的总结</h4>

<p>2016-05更新:</p>

<p>=========================</p>

<p>参考<a href="http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:">http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:</a></p>

<p>为什么说这个中本聪是假的</p>

<p>Craig Wright 又在声明他是”中本聪”了.</p>

<p>“中本聪”给出的签名是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MEUCIQDBKn1Uly8m0UyzETObUSL4wYdBfd4ejvtoQfVcNCIK4AIgZmMsXNQWHvo6KDd2Tu6euEl13VTC3ihl6XUlhcU+fM4=</span></code></pre></td></tr></table></div></figure>


<p>我们先对信息串进行base64解码，再转换成hex是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3045022100c12a7d54972f26d14cb311339b5122f8c187417dde1e8efb6841f55c34220ae0022066632c5cd4161efa3a2837764eee9eb84975dd54c2de2865e9752585c53e7cce</span></code></pre></td></tr></table></div></figure>


<p>很遗憾，我们可以在交易ID：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe</span></code></pre></td></tr></table></div></figure>


<p>中找出这个签名。可通过：</p>

<p><a href="https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex">https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex</a></p>

<p>找到十六进制串的交易内容</p>

<p>然后搜索一下hex样子的签名，遗憾地发现，能在这个交易中找到这个签名。</p>

<p>但是令人疑惑的是GAVIN ANDRESEN为这位”中本聪”背书:</p>

<p><a href="http://gavinandresen.ninja/satoshi">http://gavinandresen.ninja/satoshi</a></p>

<p>Gavin不是一个无的放矢的人,他肯定是见到了更多的证据.</p>

<p>但是Craig Wright 又不对其他给定的文本签名来证明自己是中本聪,反而老是用这种神神遭遭的签名来忽悠大家……</p>

<p>卫平布莱恩特老师说,这球有意思啊…….</p>

<p>最后, 如果Craig Wright这个人是为了某种目的假冒的话,只能说他真是煞费苦心啊. 我不认为一个签名造假如此low的家伙能有这种能力.</p>

<p>但是他的一些行为如果算恶作剧的话,又未免太高段了,参考这里:</p>

<p><a href="https://www.zhihu.com/question/22199390/answer/76083139">https://www.zhihu.com/question/22199390/answer/76083139</a></p>

<p>不负责任的YY一下, Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>

<p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>

<p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p>

<p>呵呵, 绝佳的侦探小说体裁啊.</p>

<p>2017-12-24更新</p>

<p>================</p>

<p>我在比特币开发论坛的早期帖子上发现了一个线索，在bitcoin release 0.1版本的时候，satoshi曾经自称自己:</p>

<pre><code>"The design supports a tremendous variety of possible transaction types that I designed years ago.  Escrow transactions, bonded contracts, third party arbitration, multi-party signature, etc.  If Bitcoin catches on in a big way, these are things we'll want to explore in the future, but they all had to be designed at the beginning to make sure they would be possible later."
</code></pre>

<p>这代表satoshi早期的职业生涯和金融、保险以及法务方面联系很紧密，同时看他的代码风格是老派C++的写法，有MS的味道 ：），然后看看 David Kleiman的个人主页，浮想联翩啊。</p>

<p>2018-04-22更新</p>

<p>==================</p>

<p>Craig Wright的案宗已经出来了:</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>我觉得基本上可以确定猜测是对的，但是除了Craig Wright本人，真相的细节可能永远不会有人知道了。</p>

<p>现在最大的疑问就是100w币的私钥是谁控制着？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Disable Performance_schema to Save Mysql's Memory]]></title>
    <link href="http://happy123.me/blog/2018/04/02/disable-performance-schema-to-save-mysqls-memory/"/>
    <updated>2018-04-02T09:14:01+08:00</updated>
    <id>http://happy123.me/blog/2018/04/02/disable-performance-schema-to-save-mysqls-memory</id>
    <content type="html"><![CDATA[<p>小VPS内存一般都不大，比如 1GB 什么的。估计总是发现装完 LAMP 就基本上内存全用光了。</p>

<p>访问量不大的话，可以在 my.conf 中加入以下配置，关掉性能优化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mysqld]
</span><span class='line'>performance_schema=off</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable Multiusers Support for Win10]]></title>
    <link href="http://happy123.me/blog/2018/02/28/enable-multiusers-support-for-win10/"/>
    <updated>2018-02-28T11:14:54+08:00</updated>
    <id>http://happy123.me/blog/2018/02/28/enable-multiusers-support-for-win10</id>
    <content type="html"><![CDATA[<p>自从买了套正版Win10，感觉又回归软粉行列。这就是所谓的屁股决定脑袋。</p>

<p>开了hyper-v，日常使用足够了，我感觉hyper-v的虚拟化可能真的是Vmware的有力竞争对手。</p>

<p>然后WSL的横空出世，让人调侃<code>win10将变成最好的Linux发行版</code>，此言不虚啊。</p>

<p>最后我寻寻觅觅，找到了一个RDP多用户支持的工具:</p>

<p><a href="https://github.com/stascorp/rdpwrap">https://github.com/stascorp/rdpwrap</a></p>

<p>妥妥的把Win10变成了Win2012 Server。</p>

<p>现在Win10日常使用组件好评度爆表依次为:</p>

<ul>
<li><p>多桌面</p></li>
<li><p>hyper-v</p></li>
<li><p>WSL</p></li>
<li><p>RDP</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Do Cryptic Github Comments Mean?]]></title>
    <link href="http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean/"/>
    <updated>2018-02-17T16:35:55+08:00</updated>
    <id>http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean</id>
    <content type="html"><![CDATA[<p>在Github的Issue里面经常见到一堆<code>ACK</code>，原来知道肯定不是TCP的ACK，估计是acknowledge之类的缩写，但是一直不求甚解。</p>

<!-- more -->


<p>今天心血来潮搜了一下，嗯，猜的也差不多:</p>

<ul>
<li><p>LGTM—looks good to me</p></li>
<li><p>ACK—acknowledgement, i.e. agreed/accepted change</p></li>
<li><p>NACK/NAK —negative acknowledgement, i.e. disagree with change and/or concept</p></li>
<li><p>RFC—request for comments, i.e. I think this is a good idea, lets discuss</p></li>
<li><p>WIP—work in progress, do not merge yet</p></li>
<li><p>AFAIK/AFAICT—as far as I know / can tell</p></li>
<li><p>IIRC—if I recall correctly</p></li>
<li><p>IANAL—“I am not a lawyer”, but I smell licensing issues</p></li>
</ul>


<p>像比特币代码仓库里还经常见到:</p>

<ul>
<li><p>Concept ACK—agree with the concept, but haven’t reviewed the changes</p></li>
<li><p>utACK (aka. Untested ACK)—agree with the changes and reviewed them, but didn’t test</p></li>
<li><p>Tested ACK—agree with the changes, reviewed and tested</p></li>
</ul>


<p>资料来源:</p>

<p><a href="https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4">https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4</a></p>

<p><a href="https://github.com/dear-github/dear-github">https://github.com/dear-github/dear-github</a></p>

<p><a href="http://www.catb.org/jargon/html/index.html">http://www.catb.org/jargon/html/index.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币POW难度调节分析]]></title>
    <link href="http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/"/>
    <updated>2018-02-12T20:50:34+08:00</updated>
    <id>http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi</id>
    <content type="html"><![CDATA[<p>比特币白皮书在工作量证明章节中解释了工作量证明（PoW）的方式：</p>

<blockquote><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p></blockquote>

<p>那这个随机数难度值是怎么产生的呢？</p>

<!-- more -->


<p>原理是简单的，但是细节总是需要穷根究底。</p>

<h2>比特币难度值Difficulty</h2>

<p>难度值在区块中并不记录，仅仅是为了人类直观感受解题难度而演变出的一个浮点数。难度每2016个区块改变一次，公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diffculty = difficulty_1_target / currentTarget</span></code></pre></td></tr></table></div></figure>


<p>此处的 difficulty_1_target 为一个常数，非常大的一个数字。表示矿池挖矿最大难度。目标值越小，区块生成难度越大。区块中存储的是这个名为target的值。</p>

<h2>难度值如何存储在区块中的</h2>

<p>在区块中存储的是Target，但是将Target经类似于浮点数的一种压缩表示法，字段为nbits。例如，如果区块bits记录为0x1b0404cb，那么他表示的十六进制的Target值为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span></code></pre></td></tr></table></div></figure>


<h3>在计算时，后面3个字节0x0404cb作为底，前面1字节0x1b表示次方数。具体压缩过程如下：</h3>

<ul>
<li><p>将数字转换为256进制数</p></li>
<li><p>如果第一位数字大于127(0x7f),则前面添加0</p></li>
<li><p>压缩结果中的第一位存放该256进制数的位数</p></li>
<li><p>后面三个数存放该256进制数的前三位，如果不足三位，则后面补零</p></li>
</ul>


<h4>例如，将数字1000压缩，先转换为256进制数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1000 = 0x03 * 256 + 0xe8 * 1</span></code></pre></td></tr></table></div></figure>


<p>那么是由两个数字构成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>03   e8</span></code></pre></td></tr></table></div></figure>


<p>第一个数未超过0x7f,则不需填0，但长度两位低于三位，在后面补零，最终表示为：0x0203e800</p>

<h3>等等，我有点晕了，为什么要采取这种绕弯的存储方式呢?</h3>

<ul>
<li><p>比特币的工作量证明本质是计算一个256bits的hash值，并保证这个值小于target，表示为公式如下:</p>

<p>  <code>
  SHA256(SHA256(区块头)) &lt; Target
 </code></p></li>
<li><p>初始Target，即difficulty_1_target设置为<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>，此时难度为1</p></li>
<li><p>Target是一个256位的很大的数，对这个数进行乘除运算需要特殊的库来处理，所以中本聪考虑用一个32位的数来近似表示Target</p></li>
<li><p>256 / 32 = 8, 2<sup>8</sup> = 256，因此我们需要用256进制来表示Target，256进制的运算规则如上所述</p></li>
<li><p>那么初始Target其实可以表示为0x1D00FFFFFF，解压验证一下:</p>

<p>  <code>
      0x00ffff *256** (0x1d - 3)  = ff ff 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 </code></p></li>
<li><p>0x1D00FFFFFF 这个值可以称为nbits，就是存储在区块中的原始值，通过nbits可以推算当前Target，通过当前Target及初始Target可以推算当前难度</p></li>
</ul>


<h2>难度如何调节</h2>

<p>目标值计算公式如下，但在实际计算时有些特别处理，将目标值控制在一定范围内。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>新目标值= 当前目标值 * 实际2016个区块出块时间 / 理论2016个区块出块时间(2周)。</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>判断是否需要更新目标值(2016的整数倍)，如果不是则继续使用最后一个区块的目标值</p></li>
<li><p>计算前2016个区块出块用时</p></li>
<li><p>如果用时低于半周，则按半周计算。防止难度增加4倍以上。</p></li>
<li><p>如果用时高于8周，则按8周计算。防止难度降低到4倍以下。</p></li>
<li><p>用时乘以当前难度, 再除以2周</p></li>
<li><p>如果超过最大难度限制，则按最大难度处理</p></li>
</ol>


<p>代码参考这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857">https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857</a></p>

<h2>知道nbits，如何推算全网算力</h2>

<ul>
<li><p>nbits为0x1b0404cb时，难度为：</p>

<p>  <code>
  0x00000000FFFF0000000000000000000000000000000000000000000000000000 / 0x00000000000404CB000000000000000000000000000000000000000000000000 = 16307.420938523983
 </code></p></li>
<li><p>为了找到新区块，该区块的target值必须小于目标target值，实际上是一个在0到2<sup>256</sup>-1之间的随机数，难度1的偏移量是：</p>

<p> <code>
 0xffff * 2^208
</code></p></li>
<li><p>难度D的偏移量是</p>

<p> <code>
 (0xffff * 2^208)/D
</code></p></li>
<li><p>在难度D下，为了找到新区块，我们预期要计算的HASH数量是</p>

<p> <code>
 D * 2^256 / (0xffff * 2^208)
</code></p></li>
<li><p>难度的设定，是为了以每10分钟一个区块的产生速度产生2016个区块，因而我们在600秒内计算 (D * 2<sup>48</sup> / 0xffff) 个HASH，这就意味着产生2016个区块的网络HASH速率(算力)是</p>

<p> <code>
 D * 2^48 / 0xffff / 600
</code></p>

<p> 可以进一步简化为：</p>

<p> <code>
 D * 2^32 / 600
</code></p></li>
<li><p>2018-02-12 21:00:00(UTC+8), 难度值D为2,874,674,234,415; 此时全网算力为20.75EH/S</p></li>
<li><p>如果我有一台蚂蚁S9，算力13T/S，那么一个区块周期(10分钟)的期望BTC收益为12.5 * 13T / 20.75EH</p></li>
</ul>


<h2>一点小TIPS</h2>

<ul>
<li>难度为1时，目标target在比特币客户端中表示为</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFF0000000000000000000000000000000000000000000000000000</span></code></pre></td></tr></table></div></figure>


<p>但是在绝大部分矿池里面表示为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></code></pre></td></tr></table></div></figure>


<p>这样挖矿的时候，挖矿软件显示的难度和比特币客户端api调用算出来的难度有微小差别，可以忽略。这个其实时早期矿池实现的时候找方便造成的不统一，因为比特币客户端判断HASH合法性的时候用的是nbits来判断，所以不影响最终计算结果</p>

<ul>
<li>现有的算法中，难度值每2016个区块调整一次，但新的难度值不需要与难度“1”进行比较运算，而是根据前2015个块的出块时间来计算，所以严谨的计算公式为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>difficulty = [prev_target] * 【前2015个区块生成所用的时间】 / 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数）</span></code></pre></td></tr></table></div></figure>


<p>为啥？就是中本聪早期的代码比较糙，他在循环的时候因为还有一个genius block要处理，可能为了代码干净起见就不去特殊处理了，其实也没啥影响</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[央行抵押补充贷款PSL浅析]]></title>
    <link href="http://happy123.me/blog/2018/02/02/yang-xing-di-ya-bu-chong-dai-kuan-pslqian-xi/"/>
    <updated>2018-02-02T22:38:15+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/yang-xing-di-ya-bu-chong-dai-kuan-pslqian-xi</id>
    <content type="html"><![CDATA[<p>看到一则新闻，山东取消了货币化安置奖励，美其名曰控制房价，其实想想就明白是政府余粮不足了，房价飞涨，补贴不能。</p>

<p>老家这里的棚户改造轰轰烈烈搞了两年了，货币化安置的效果非常显著，周边的房价一个劲往上涨。我就有点纳闷了，这个货币化安置的钱是从哪儿来的呢？</p>

<!-- more -->


<p>央行在2014年推出的PSL（抵押补充贷款）创新性政策工具，部分解决了棚改货币化安置的资金问题。央行通过PSL向国开行发放贷款，国开行通过棚改专项贷款向地方政府发放贷款，地方政府通过货币化安置向棚户区居民发放补偿款，地方政府拆迁卖地后偿还国开行贷款，国开行偿还央行贷款，形成资金流的闭环。</p>

<p>我查了一下资料，问题来了:</p>

<ul>
<li><p>开行是把什么抵押给央行了？是只能抵押棚改专项贷款，还是国债、开行债、扶贫贷款、小微企业贷款之类的都可以?</p></li>
<li><p>PSL利率怎么设定？央行指定还是市场化？</p></li>
<li><p>如何监控PSL的投向，并防止利差套利。</p></li>
<li><p>开行用什么方式来偿还PSL贷款？</p></li>
</ul>


<h2>最重要的是，这是不是放水？</h2>

<p>又学习了一下基本金融知识，发现一个比较权威的解释:</p>

<p>国信证券宏观经济分析师钟正生认为，这一工具最大突破在于，将商业银行贷款纳入用于基础货币投放的合格抵押品框架，从而摆脱再贷款的信用风险问题，打造一个常规的基础货币投放渠道。央行投放基础货币需要同时扩张资产方和负债方，而为了保证央行资产的安全性，央行一般会要求交易对手提供抵押品并进行风险评估。而合格抵押品意味着受到央行认可的，可在货币政策工具中用于抵押给央行的资产，例如我国正逆回购以及SLO、SLF操作中，一般使用国债和政策性金融债作为合格抵押品。我们在之前报告中提及，外汇占款趋势下滑，央票自然到期萎缩背景下，央行需要重启再贷款作为弥补基础货币缺口的手段。其主要原因在于，央行缺乏合适的抵押品，用于大规模基础货币的投放。而再贷款是信用贷款，不需要抵押。但吊诡的是，无需抵押既是再贷款的突出优点，也是再贷款的局限所在。无抵押会带来信用风险问题，央行资产有可能会遭受损失，历史上由于再贷款在央行账目上产生坏账的案例并不鲜见。因此，我们一直认为，短期内再贷款可以充当提供基础货币的过渡职能，但长期来看仍需完善央行的合格抵押品框架。现在看起来，PSL可能正是在央行在完善合格抵押品框架上作出的重要推进。</p>

<p>然后我又脑补为通俗版:</p>

<ul>
<li><p>央行采用外汇占款发行人民币的老路子越来越难了，美国加息，外汇流出压力大啊。</p></li>
<li><p>现在我要以国内资产来定价发行货币了</p></li>
</ul>


<h4>好吧，看起来这不是放水，顶多可以称之为定向宽松。那么是不是就不用紧张通胀了呢？</h4>

<p>完全不是！</p>

<p>类比一下，这其实是股市里面的一种对敲手法。</p>

<p>央行最终收下的抵押品不外乎还是地方财政的资产，那地方财政最大的抵押资产是什么呢？还是土地。</p>

<p>发出去的货币标的其实就是不断推升的地价。</p>

<p>这下好了，其实是央行和地方政府联手对敲，把地价炒高了，还多出来一种发行货币的手段，顺便把高杠杆风险转给平头百姓，一箭三雕啊。</p>

<p>兴，百姓苦；亡，百姓苦</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coincheck被盗5亿个XEM]]></title>
    <link href="http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem/"/>
    <updated>2018-02-02T21:16:43+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem</id>
    <content type="html"><![CDATA[<p>2018-01-26,Coincheck 被盗 5 亿个 XEM, 这个数目估计是史上最大了，hacker 的账户地址是这里:</p>

<p><a href="http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG">http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG</a></p>

<p>按照 coinmarketcap 的市场价来算，现在 5 亿个 XEM 价值大概 4 亿美元</p>

<p>另外可能是 coincheck 自己的防护，他们的 Ripple 钱包也有一笔大额的转账:</p>

<p><a href="https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8">https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8</a></p>

<p>有将近 1 亿个 xrp 转账到了一个地址，这个地址貌似有 30 亿个 xrp.</p>

<p>这笔转账可能是 coincheck 正在审计，不是 hack 行为。</p>

<p>除去 MTGOX 那次，Coincheck 的这次悲剧不论数量还是市场价格估计都是史上最强了</p>

<p>2018-01-28, Coincheck公布了补偿措施</p>

<p><a href="http://corporate.coincheck.com/2018/01/28/30.html">http://corporate.coincheck.com/2018/01/28/30.html</a></p>

<p>共损失 52300,0000 个 XEM，按照被偷时的币值返还，每个币 88 日元</p>

<p>额，貌似总额超过 25 亿人民币了</p>

<p>最奇怪的是，直到2018-02-01，市场才起了反应，开始下跌。</p>

<p>这个赌博的场子越来越让人看不懂了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block Chain White Papers]]></title>
    <link href="http://happy123.me/blog/2018/01/09/block-chain-white-papers/"/>
    <updated>2018-01-09T16:42:45+08:00</updated>
    <id>http://happy123.me/blog/2018/01/09/block-chain-white-papers</id>
    <content type="html"><![CDATA[<h2>比特币白皮书</h2>

<h4>中文版</h4>

<p><a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a></p>

<h4>英文版</h4>

<p><a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p>

<h2>以太坊白皮书</h2>

<h4>中文版</h4>

<p><a href="http://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6">http://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6</a></p>

<h4>英文版</h4>

<p><a href="https://github.com/ethereum/wiki/blob/master/drafts/%5Benglish%5D-old-ethereum-whitepaper.md">https://github.com/ethereum/wiki/blob/master/drafts/%5Benglish%5D-old-ethereum-whitepaper.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NiceHash被盗]]></title>
    <link href="http://happy123.me/blog/2017/12/07/nicehashbei-dao/"/>
    <updated>2017-12-07T13:13:52+08:00</updated>
    <id>http://happy123.me/blog/2017/12/07/nicehashbei-dao</id>
    <content type="html"><![CDATA[<p>Nicehash 被盗 4700+币</p>

<p>比 bitfinex 要幸运一点，这次发现的比较早，但是按照现在的币价大涨来算，损失也超过了 6000w USD，上次 bitfinex 11w 币不过折合 7000w USD 而已。</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>这个是 hacker 的转入地址:</p>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>最早的一笔交易发生在 2017-12-06 13:17:12(UTC+8)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrate Firewalld to Iptables on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/12/06/migrate-firewalld-to-iptables-on-centos7/"/>
    <updated>2017-12-06T16:23:22+08:00</updated>
    <id>http://happy123.me/blog/2017/12/06/migrate-firewalld-to-iptables-on-centos7</id>
    <content type="html"><![CDATA[<h2>关闭 FireWall</h2>

<pre><code>systemctl stop firewalld.service #停止firewall
systemctl disable firewalld.service #禁止firewall开机启动
</code></pre>

<h2>安装 iptables</h2>

<pre><code>yum install iptables-services
</code></pre>

<!-- more -->


<h2>配置 iptables</h2>

<pre><code>#!/bin/bash

IF="eth0"

#清除规则
/sbin/iptables -F
/sbin/iptables -X
/sbin/iptables -Z

# 预定义策略
/sbin/iptables -A INPUT -s 127.0.0.1 -j ACCEPT  # 允许回环接口可以被访问
/sbin/iptables -P INPUT   DROP # 默认是拒绝访问
/sbin/iptables -P OUTPUT  ACCEPT  # 允许本机访问其他机器，无限制
/sbin/iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
/sbin/iptables -A INPUT -p icmp -j ACCEPT # 允许ping


#允许的本机服务
/sbin/iptables -A INPUT -p TCP -i $IF --dport 22 -j ACCEPT        # SSH
# /sbin/iptables -A INPUT -p TCP -i $IF --dport  3306 -j ACCEPT        # mysql
/sbin/iptables -A INPUT -p TCP -i $IF --dport  80 -j ACCEPT        # web
/sbin/iptables -A INPUT -p TCP -i $IF --dport  8888 -j ACCEPT        # web

# 黑名单
#/sbin/iptables -A INPUT -s 1.1.1.0/24 -j DROP
#/sbin/iptables -A INPUT -s 1.1.1.0 -j DROP

# 信任的网络和IP
/sbin/iptables -A INPUT -s 1.1.1.1/24 -j ACCEPT # 信任的网络

# 保存配置
/usr/libexec/iptables/iptables.init save
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Penetrate GFW With ShadowSocks Docker Container on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/12/04/how-to-penetrate-gfw-with-shadowsocks-docker-container-on-centos7/"/>
    <updated>2017-12-04T20:23:40+08:00</updated>
    <id>http://happy123.me/blog/2017/12/04/how-to-penetrate-gfw-with-shadowsocks-docker-container-on-centos7</id>
    <content type="html"><![CDATA[<p>The quickest way to Penetrate GFW With ShadowSocks(Docker Container) On Centos7.</p>

<h2>Install Docker CE</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo yum install -y yum-utils   device-mapper-persistent-data  lvm2
</span><span class='line'>$ sudo yum-config-manager    --add-repo     https://download.docker.com/linux/centos/docker-ce.repo
</span><span class='line'>$ sudo yum install docker-ce</span></code></pre></td></tr></table></div></figure>


<h2>start  docker</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo systemctl start docker</span></code></pre></td></tr></table></div></figure>


<h2>pull shadowsocks container</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker pull oddrationale/docker-shadowsocks</span></code></pre></td></tr></table></div></figure>


<h2>start shadowsocks service</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -d -p 1984:1984 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1984 -k $SSPASSWORD -m aes-256-cfb</span></code></pre></td></tr></table></div></figure>


<p>You can configure the service to run on a port of your choice. Just make sure the port number given to Docker is the same as the one given to shadowsocks. Also, it is highly recommended that you store the shadowsocks password in an environment variable as shown above. This way the password will not show in plain text when you run docker ps.</p>

<p>For more command line options, refer to the <a href="https://github.com/shadowsocks/shadowsocks/tree/master">shadowsocks documentation</a></p>

<h2>windows Client</h2>

<p>Client is the machine you want to bypass the GFW.</p>

<p>Download the client package <a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Shadowsocks-win-latest-release</a>, extract it, and run.</p>

<p>You can check its “System Proxy” option, which is convenient for all browsers and terminal.</p>

<h2>now enjoy it</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Game Theory]]></title>
    <link href="http://happy123.me/blog/2017/12/04/game-theory/"/>
    <updated>2017-12-04T17:39:24+08:00</updated>
    <id>http://happy123.me/blog/2017/12/04/game-theory</id>
    <content type="html"><![CDATA[<p>看网易公开课的博弈论，很有意思，记下笔记:</p>

<h2>导论-五个入门结论</h2>

<ol>
<li><p>don’t play a strictly dominated strategy</p></li>
<li><p>rational choice in case lead to outcomes suck</p></li>
<li><p>you can’t get what you want ,till you know what you want</p></li>
<li><p>put yourself in others’ shoes and try to figure out what they will do</p></li>
<li><p>most people are evil</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Config Samba Config With No Password Share]]></title>
    <link href="http://happy123.me/blog/2017/12/03/how-to-config-samba-config-with-no-password-share/"/>
    <updated>2017-12-03T09:49:15+08:00</updated>
    <id>http://happy123.me/blog/2017/12/03/how-to-config-samba-config-with-no-password-share</id>
    <content type="html"><![CDATA[<p>年老记忆力下降，做了N+1遍了，还是忘。</p>

<h2>卸载干净</h2>

<pre><code>apt-get purge samba
rm -rf /etc/samba /etc/default/samba
</code></pre>

<h2>重装</h2>

<pre><code>apt-get install samba
</code></pre>

<h2>配置</h2>

<pre><code>vim /etc/samba/smb.conf


[share_name]
public = yes
browseable = yes
path = /home
guest ok = yes
read only = no
writeable = yes
create mask = 0644
directory mask = 2777
</code></pre>

<h2>重启</h2>

<pre><code>systemctl restart smbd
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Http Referer 的盗链与反盗链]]></title>
    <link href="http://happy123.me/blog/2017/10/31/http-referer-de-dao-lian-yu-fan-dao-lian/"/>
    <updated>2017-10-31T21:47:27+08:00</updated>
    <id>http://happy123.me/blog/2017/10/31/http-referer-de-dao-lian-yu-fan-dao-lian</id>
    <content type="html"><![CDATA[<p>HTTP的图片防盗链技术基本上人民群众喜闻乐见了。 今天突然发现一种比较通用的隐藏referer来反盗链的hack手段，记录之。</p>

<p>简单来说，Referer是HTTP协议中的一个请求报头，用于告知服务器用户的来源页面。比如说你从Google搜索结果中点击进入了某个页面，那么该次HTTP请求中的Referer就是Google搜索结果页面的地址。</p>

<p>一般Referer主要用于统计，像CNZZ、百度统计等可以通过Referer统计访问流量的来源和搜索的关键词（包含在URL中）等等，方便站长们有针性对的进行推广和SEO什么的~</p>

<p>当然Referer另一个用处就是防盗链了，主要是图片和网盘服务器使用的较多。盗链的危害不言而喻，侵犯了版权不说，增加了服务器的负荷，却没有给真正的服务提供者带来实际利益（广告点击什么的）</p>

<p>另外要注意的是，Referer是由浏览器自动为我们加上的，以下情况是不带Referer的</p>

<ul>
<li><p>直接输入网址或通过浏览器书签访问</p></li>
<li><p>使用JavaScript的Location.href或者是Location.replace()</p></li>
<li><p>HTTPS等加密协议</p></li>
</ul>


<p>很多网站挟持脚本一般是注入https链接来隐藏referer，这样固然好用，但是一定要一个域名，有点不方便。前人实践发现只要在iframe里面的src属性填上 <code>javascript: &lt;html&gt;....</code>的内容就可以隐藏referer了。一试果然如此。</p>

<p>比如大家常见的微信公众号文章，如果引用过来，一般就是防盗链了，这个时候可以用下面的通用代码解决：</p>

<ul>
<li>需要引用jquery和 <a href="https://github.com/jpgerek/referrer-killer">ReferrerKiller.js</a> 这两个库:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   jQuery(function() {
</span><span class='line'>       //遍历所有的img元素，凡是QQ和微信引用的统统放到iframe里面
</span><span class='line'>       jQuery("div").find("img").each(function() {
</span><span class='line'>           var img = jQuery(this);
</span><span class='line'>           var img_src = img.attr("src");
</span><span class='line'>           if (img_src != undefined && img_src != '') {
</span><span class='line'>               img_src = decodeURI(img_src);
</span><span class='line'>               img_src = img_src.split("?")[0];
</span><span class='line'>               if (img_src.indexOf("qpic.cn") &gt; 0 || img_src.indexOf("qlogo.cn") &gt; 0 || img_src.indexOf("qq.com") &gt; 0) {
</span><span class='line'>                   var frameid = 'frameimg' + Math.random();
</span><span class='line'>                   img.parent().append('&lt;span id="' + frameid + '"&gt;&lt;/span&gt;')
</span><span class='line'>                   img.remove();
</span><span class='line'>                   document.getElementById(frameid).innerHTML = ReferrerKiller.imageHtml(img_src);
</span><span class='line'>               }
</span><span class='line'>           }
</span><span class='line'>       })
</span><span class='line'>   })</span></code></pre></td></tr></table></div></figure>


<p>这样看出来的效果就是原来引用微信的图片:</p>

<pre><code>&lt;img src="http://mmbiz.qpic.cn/mmbiz/cfxQzmUp8b0E12wMVv6SzROhSAgmxENxKPSQibVNhXAx8vr3BQW1lnlakR8wDVLc38QSZwnRfiaDtPZ0d3PhBMtQ/640?"/&gt;
</code></pre>

<p>就会被替换到iframe里面，同时iframe的src属性包括了完整的html内容，这样浏览器请求图片的时候，就不会带referrer了，微信的盗链就被绕过。</p>

<p>不知道微信啥时候堵上这个洞呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Btc UAHF]]></title>
    <link href="http://happy123.me/blog/2017/08/01/btc-uahf/"/>
    <updated>2017-08-01T22:11:54+08:00</updated>
    <id>http://happy123.me/blog/2017/08/01/btc-uahf</id>
    <content type="html"><![CDATA[<p>UTC时间 2017-08-01 18:12，UAHF<a href="https://blockchair.com/bitcoin-cash/block/478559">第一个大于1MB的块</a>被挖出，虽然现在算力占比很小，但值得关注，UAHF是否能存活下去，算力来决定吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Local Repo by Iso]]></title>
    <link href="http://happy123.me/blog/2017/06/06/set-local-repo-by-iso/"/>
    <updated>2017-06-06T22:15:22+08:00</updated>
    <id>http://happy123.me/blog/2017/06/06/set-local-repo-by-iso</id>
    <content type="html"><![CDATA[<p>想要挂载一个iso安装镜像作为本地repo</p>

<h2>mount iso</h2>

<pre><code>mkdir -p /mnt/cdrom
mount -t iso9660 -o loop /home/Centosxxxx.iso /mnt/cdrom
</code></pre>

<h2>set local repo</h2>

<pre><code>vi /etc/yum.repos.d/local.repo

[localrepo]
name=Unixmen Repository
baseurl=file:///mnt/cdrom
gpgcheck=0
enabled=1
</code></pre>

<h2>set up</h2>

<pre><code>yum clean all
yum repolist
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy Local Ntp Server on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/06/06/deploy-local-ntp-server-on-centos7/"/>
    <updated>2017-06-06T21:20:35+08:00</updated>
    <id>http://happy123.me/blog/2017/06/06/deploy-local-ntp-server-on-centos7</id>
    <content type="html"><![CDATA[<p>有时候需要内网环境搭建一个ntp服务器同步内网的几台机器。</p>

<p>四步走:</p>

<h2>安装ntpd</h2>

<pre><code>yum -y install ntp ntpdate
</code></pre>

<h2>修改/etc/ntpd.conf</h2>

<pre><code># line 18: add the network range you allow to receive requests
restrict 10.0.0.0 mask 255.255.255.0 nomodify notrap

# local clock
server 127.127.1.0
fudge  127.127.1.0 stratum 10
</code></pre>

<h2>重启</h2>

<pre><code>systemctl start ntpd
systemctl enable ntpd
firewall-cmd --add-service=ntp --permanent
firewall-cmd --reload
</code></pre>

<h2>瞄一眼</h2>

<pre><code>watch ntpq -p
</code></pre>

<p>注意reach这个值，在启动ntp server服务后，这个值就从0开始不断增加，当增加到17的时候，从0到17是5次的变更，每一次是poll的值的秒数，是64秒*5=320秒的时间。</p>

<p>如果之后从ntp客户端同步ntp server还失败的话，用ntpdate –d来查询详细错误信息，再做判断。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Update to gcc4.9.x on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/04/15/how-to-update-to-gcc4-dot-9-x-on-centos7/"/>
    <updated>2017-04-15T15:50:53+08:00</updated>
    <id>http://happy123.me/blog/2017/04/15/how-to-update-to-gcc4-dot-9-x-on-centos7</id>
    <content type="html"><![CDATA[<p>现在很多软件包默认编译要求GLIBCXX >=3.4.20，碰到这种事redhat系又哭了，目前Centos7.x默认仓库里的gcc还是4.8.5的，所以需要一个办法升级gcc相关组件>=4.9.1。</p>

<p>CentOS下升级gcc版本有两个途径，一个是添加其他源进行自动升级，一个是手动编译升级，这里先顺便讲下自动升级的两个办法：</p>

<h3>添加Fedora源</h3>

<p>在 /etc/yum.repos.d 目录中添加文件 FedoraRepo.repo ，并输入以下内容:</p>

<pre><code>[warning:fedora]
name=fedora
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch
enabled=1
gpgcheck=1
gpgkey=https://getfedora.org/static/34EC9CBA.txt
</code></pre>

<p>然后执行</p>

<pre><code>yum update gcc gcc-c++
</code></pre>

<h3>使用Devtoolset-4升级</h3>

<pre><code>yum install centos-release-scl
yum install devtoolset-4-gcc*
scl enable devtoolset-4 bash
which gcc
gcc --version
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migarate Duoshuo to Disqus]]></title>
    <link href="http://happy123.me/blog/2017/03/26/migarate-duoshuo-to-disqus/"/>
    <updated>2017-03-26T15:27:11+08:00</updated>
    <id>http://happy123.me/blog/2017/03/26/migarate-duoshuo-to-disqus</id>
    <content type="html"><![CDATA[<p>没有盈利前景的产品死掉了，话说disqus是怎么活的?</p>
]]></content>
  </entry>
  
</feed>
