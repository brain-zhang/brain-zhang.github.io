<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-02-13T18:06:01+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于GDP的一些随想]]></title>
    <link href="https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang/"/>
    <updated>2019-02-13T16:11:49+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang</id>
    <content type="html"><![CDATA[<h2>GDP是什么</h2>

<p>国内生产总值 (gross domestic product， GDP) 是在某一既定时期一个国家内生产的所有最终物品与劳务的市场价值。</p>

<p>GDP（用Y代表）被分为四个组成部分：消费（C）、投资（I）、政府购买（G）、净出口（NX）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Y = C ＋ I ＋ G ＋ NX</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<ul>
<li>消费(consumption)是家庭用于物品和劳务的支出</li>
<li>投资(investment)是将用于未来生产更多物品和劳务的物品购买。它是资本设备、存货和建筑物购买的总和。建筑物投资包括新住房支出。按习惯，新住房购买是划入投资而不划入消费的一种家庭支出形式。</li>
<li>政府购买(government purchase)包括地方政府、州政府和联邦政府用于物品与劳务的支出。它包括政府员工的薪水和用于公务的支出。</li>
<li>净出口(net export)等于外国人购买国内生产的物品(出口)减国内购买的外国物品(进口)。</li>
</ul>


<p>&mdash; 摘自曼昆的《经济学原理》</p>

<h2>GDP怎样计算</h2>

<p>GDP有3种方法进行核算：生产法、收入法和支出法。</p>

<h4>生产法</h4>

<p>生产法是我国GDP的统计方法。</p>

<p>我们把GDP从产业的角度，分成第一、二、三产业，分别算它们的增加值然后进行加总，当然还要从最终产品和中间投入两方面扣除通胀因素。</p>

<p>用生产法计算的GDP，是指各部门在核算期内的增加值。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=各部门的总产出-各部门的中间消耗</span></code></pre></td></tr></table></div></figure>


<p>对于第一产业的农林牧渔业，总产出就是多少斤粮食的价值；</p>

<p>对于第二产业——工业，那就是生产出的所有商品的价值；</p>

<p>第三产业服务业的范围比较广，计算方法也更加复杂，比如说理发师理一次发的价值，律师咨询一次的劳务价值等等。中间消耗指的是生产过程中的消耗，但要记住：中间消耗不等于成本。举个栗子：</p>

<p>工厂生产了1000个毛绒玩具，产值1万元，期间机器保养和修理花费了2000元，员工薪资4000元，那么按照生产法的话，笨笨工厂的GDP则是10000-2000=8000元。中间消耗你可以理解成为了产值而产生的费用，而成本则是一种固定的支出。就好比你今天去体彩中心领奖金10万块，请保镖花了300，但是你去体彩中心的路上打车花了20。如果要用生产法计算你为社会创造的GDP的话，那就是100000-20=99980块，因为你的“产值”是奖金，而不是保镖费。</p>

<h4>收入法</h4>

<p>收入法是从各个生产要素的收入角度来计算GDP。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=劳动者报酬+生产税净额+固定资本消耗+营业盈余</span></code></pre></td></tr></table></div></figure>


<p>劳动者报酬就是个人劳动者的收入；</p>

<p>生产税净额就是上交给国家的各种税费减去政府补贴；</p>

<p>营业盈余就相当于营业利润加上补贴，扣除工资和福利等。（但营业盈余不等于营业利润，营业盈余是生产概念，营业利润是销售概念）比如工厂生产了价值1万块钱的玩具，贡献了1万块的GDP（不考虑保养和修理费），拆分一下：员工薪资4000元（劳动者报酬）交税1000元，收到补贴500元，即净额500元（生产税净额）固定资本折旧500；剩下的就是营业盈余5000</p>

<h4>支出法</h4>

<p>支出法其实就是曼昆的公式，即加总全社会各类货物和服务的最终消费总额：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（消费（C）+投资（I）+政府购买（G）），再加上净出口</span></code></pre></td></tr></table></div></figure>


<p>公式变形如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=最终消费+资本形成总额+净出口</span></code></pre></td></tr></table></div></figure>


<p>最终消费很简单，就是一国常住居民和政府部门在货物和服务上的总花费，比如你下班回家后买零食的花费，以及国防部买军舰坦克的花费。</p>

<p>资本形成总额资本形成总额指常住单位在一定时期内获得的减去处置的固定资产和存货的净额，就好比你搬家了，购置了冰箱和洗衣机，共花费3000块，然后卖掉了一台旧洗衣机500块，那么你的可以资本形成总额就是2500块。放在GDP角度，企业购置机器的钱，扣除处理旧机器的钱，就是企业的消费。</p>

<p>净出口净出口指的是货物和服务总出口减去总进口。</p>

<p>多者相加，得出的即是支出法下的GDP。</p>

<p>引自:</p>

<p><a href="https://zhuanlan.zhihu.com/p/34944269">https://zhuanlan.zhihu.com/p/34944269</a></p>

<h2>中国历年GDP 计算</h2>

<p><a href="https://dwz.cn/gXrciFJw">wiki</a></p>

<h2>神奇的官方预计与统计</h2>

<p>每年开年，国家统计局都会发布新一年的GDP增速预测，而到了年底，也都会发布当年的实际GDP增速。</p>

<p>比如:</p>

<p><a href="http://www.stats.gov.cn/tjsj/zxfb/201901/t20190118_1645555.html">国家统计局关于2017年国内生产总值（GDP）最终核实的公告</a></p>

<p>神奇的是，每次的预测与实际误差都在0.1%左右，而且连续10年预测神准。</p>

<p>如果2019-01-01上证指数是2600点，有人信誓旦旦的对你说，我预测2019-12-30上证指数是 2760-2765 点，绝对在这个范围内！！</p>

<p>你相信吗？</p>

<p>现在国家统计局对你说，2019年国家GDP增速预计在 6.3%，然后年底一看，6.4%增速，误差千分之一，而且连续十年神准。</p>

<p>不管你信不信，我是信了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018年投资总结]]></title>
    <link href="https://happy123.me/blog/2019/02/13/2018nian-tou-zi-zong-jie/"/>
    <updated>2019-02-13T14:49:23+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/2018nian-tou-zi-zong-jie</id>
    <content type="html"><![CDATA[<p>2018年，两个失误，一个领悟。</p>

<p>当然，即使人生知道了所有的路障和失误也是然并卵，不过总结一下，知道自己傻在哪里，总是好事。积攒RP嘛。</p>

<!-- more -->


<h3>失误1:</h3>

<p>人民币贬值预期下，企图定投恒生指数套利。</p>

<p>2017年底定投到2018-11，期间人民币兑美元确实由6.2贬值到了6.8；但是定投恒生指数却从来没有盈利过。港股经过这两年慢涨，市值已经处在高位，人民币贬值虽多，奈何指数买入时机不对。</p>

<p>最大的失误如下： 定投是对的，汇率贬值也与预测相符，但人民币汇率和港股的关联度高，不适合做对冲。这种思路本身就是糊涂思维，想当然尔。</p>

<p>虽然亏损不大，但这是一笔完全失败的投资。</p>

<h3>失误2：</h3>

<p>投资比特币，BCH和BTC按照算力比来安排仓位。</p>

<p>2018年10月份比特币价格跌破200日定投线时开始建仓，这个思路是没错的；当时对于是否配置BCH纠结了半天，最后按照BTC和BCH的算力比决定仓位。</p>

<p>直到BCH分叉出BSV，市场风云突变；下跌并没有什么，怕的是从一开始就犯了错误：</p>

<ol>
<li>投资BCH归根到底还是对闪电网络和Segwit等技术没有吃透，导致人云亦云；数字货币的投资，需要你完全吃透其技术吗？现在看来，绝对需要！！</li>
<li>当BCH分叉BSV时，前期是有绝对的机会赎回观望的，而且还有盈利，我却参考之前BTC的分叉没有动，这是百分百忽略风险的过度自信的表现。 这次分叉又一次说明了山寨币市场根本无法预测，这是一个百分百的赌场。</li>
<li>由于自己对比特币的近乎盲目的信仰之心，确实做到了90%的波动还能<code>不动如山</code>；这其实是一把双刃剑。 用的好，静观其变，用的差，自我埋葬;</li>
<li>数字货币市场只有一个币种值得投资，对我来说，目前来看还是只有比特币；我所有的错误就是没有认清比特币市场到底会走向何方：<code>支付</code>还是<code>清算</code>。</li>
<li>即使现在，我也仍旧没有信心预测将来比特币的市场究竟是<code>支付</code>还是<code>清算</code>；所以将来还有可能继续犯错！！</li>
<li>对市场永远永远要保持敬畏之心;</li>
</ol>


<p>这个失误导致了手中的BTC损失了一半！ 赔钱不可怕，赔掉币才是最可怕的，惨痛的教训。</p>

<h3>领悟：我为什么在极度看好比特币的同时还去配置低成本指数基金。</h3>

<p>原因很简单，虽然比特币的期望值远超其他资产标的，但是他的风险也远远高于其他资产。</p>

<p>假设我们有100个单位的资金，配置资产A，有90%的机率取得10倍收益，10%的机率全部亏损；配置资产B，有90%的机率取得2倍收益，10%的机率保本但无收益。我们应该怎样做呢？</p>

<p>从期望的角度来讲，无疑应该全部配置资产A；但是不要忘了，我们每一次的资产配置，都应该看作是一生中唯一一次的配置机会，我们并不能无限次扔骰子去验证概率论的正确与否。再回忆一下巴菲特提到的故事，一把手枪里面有万分之一的机率有子弹，那么需要多少钱，你才肯对自己开一枪？</p>

<p>正确答案是：多少钱也不干！！</p>

<p>上面的例子中，最稳健的投资家们应该全仓B才对。而聪明的投资家们则会设置止损线，一次又一次的去尝试A；</p>

<p>作为普通人，我选择对A设置止损线的同时配置一部分B，我们承担不起风险！！</p>

<p>那么要配置多大比例呢？ 30%的A是极限。因为超过30%我们就会变傻，不管你能挣多少钱，永远永远不要让自己变傻。</p>

<p>所以我在极度看好比特币的同时，还要去定投低估指数基金，还要留有大部分流动资金买个货基，银行结构性存款等；</p>

<p>长远来看，比特币的稳定性终将超过其他任何资产；到时候现金、国债、指数基金、房产等等与比特币相比反而变成了资产A，而比特币变成了资产B，这时候就可以放心大胆的将70%放在比特币上了，我们耐心等待着那一天的到来。</p>

<h2>随想</h2>

<h4>投资的本质就是以合适的价格买入伟大的公司，然后长期持有</h4>

<ul>
<li>什么是合适的价格？</li>
</ul>


<p>对于指数基金来说，就是历史估值底部；对于一个公司来说，就是相对于未来的ROE折现后的便宜价；对于一项技术来说，就是成长初期(1-3年内)的估值；</p>

<ul>
<li>什么是伟大的公司？</li>
</ul>


<p>一个伟大的公司跟拥有伟大的人格的人一样；</p>

<p>他要么经营业务稳健，以惊人的耐性和韧劲取胜；</p>

<p>他要么现金流充沛，以对资金毫不浪费的运用取胜；</p>

<p>他要么有惊人的前瞻眼光，敢于发明采用新技术并推动其落地；</p>

<p>他要么有无穷的执行力，以永不枯竭的热血去持续推动一项事业；</p>

<p>一个伟大的公司至少会拥有其中一项以上的品格；但是正如没有完美的人一样，十全十美的公司是不存在的，我们在敬佩其伟大品格的同时，也要包容他的一些缺点；</p>

<p>如果公司有人格，一个伟大的公司必定是一个伟大的人，一个好人。</p>

<ul>
<li>什么是长期持有？</li>
</ul>


<p>终极的长期持有，就是你认为他会作为未来人类社会不可分割的一部分，让你家族传承，永远拿在手中；</p>

<p>只有你需要现金的时候，才会卖出；其他时刻，他是诺亚方舟、终极储蓄，任何的卖出(即使十倍百倍千倍盈利)都不可接受。</p>

<p>只有历史证明你错了，或者你的心智有了巨大的成长，发现了更好的资产标的的时候，才会卖出。</p>

<h4>我有一百万现金，那么什么样的资产才是合适的投资标的？</h4>

<ul>
<li>你的年龄？</li>
</ul>


<p>如果是20、30的青年，可以去找风险比较高的资产，比如数字货币；如果是中年人，可以在低估点定投指数基金；如果是老年人，就要将大部分资产配置为债券(国债、企业债、可转债)等等；</p>

<ul>
<li>你计划投入多少？你期待收益多少？</li>
</ul>


<p>如果你计划投入50万元，那么，多少收益才能让你满意呢？</p>

<p>最成功的低估点指数基金定投，取得的最不可思议的成绩，也不过是十年十倍。十年十倍，就是十年后500万，中间你还要经历回撤、苦苦的忍耐、个人财务状况波动的冲击，你能等到那个时候吗？十年十倍让你满意吗？</p>

<p>如果有人现在愿意以年利率26% 贷款500万给你，你愿意接受吗？这也是十年十倍。</p>

<p>大多数人既不愿投入也不愿贷款？这是为什么呢？</p>

<p>还是时间的魔力。大多数人不愿慢慢变富，也不想承担风险。</p>

<ul>
<li>什么是合适的收益</li>
</ul>


<p>投资是一项同风险的抗争，最大的风险就是时间。</p>

<p>大多数人宁愿要每年10%的稳定收益，也不会选择充满波动和痛苦等待的十年十倍。</p>

<p>资金是有时间价值的，这个时间价值除了简单的复利和IRR计算，还包含了对于一个人整个人生的时间价值；现在的一百万价值无疑远远大于十年后的一百万。</p>

<p>所以大多数人不愿健身而去求助于减肥茶，大多数人不愿慢慢变富而去玩短线搏杀的游戏；</p>

<p>这是人性，我们要正视人性(明白自己是没有耐性的)，哄骗人性(少看盘，制定计划后不看损益表)，对抗人性(提升强大自己)~~~</p>

<ul>
<li>最后，当你有了耐心，自以为控制了风险，对于十年十倍的收益表示满意；那么，十年十倍的合适标的和价格是什么？</li>
</ul>


<p>假如你投资A股指数基金，十年十倍，意味着中国未来的财富还有十倍的增长空间，可能吗？</p>

<p>中国1998年GDP 8万亿， 2008年GDP 30万亿，2018年GDP总量90万亿。如果股市十年十倍，2028年我们期望GDP在500万亿&mdash;900万亿；</p>

<p>500万亿&mdash;900万的财富是多大的规模，2018年美国的GDP总量是150万亿左右，平均美国人均GDP 5.9万美元，中国人均GDP 0.87万美元。美国现在的GDP增速是2%&mdash;3%，假设人口不变，500万亿意味2018年，我们的GDP总量是美国的2.5倍&mdash;5倍，人均GDP是美国的
80% &mdash; 150%；</p>

<p>或者换一种可能，当前中国的资本市场规模是远远落后于美国的资本市场的；2018年美股的总市值超过30万亿美元，是GDP的1.5倍。而A股总市值50万亿，大概是GDP的56%，如果将来十年我们能达到美国资本市场的繁荣度，那么，只要期待GDP增长到330万亿就可以了，十年3.6倍，或者说增长速度12%，可能吗？</p>

<p>这取决于你是个多么乐观的人。长期12%的ROE，我是比较乐观的。</p>

<ul>
<li>如何正确的估值</li>
</ul>


<p>拿比特币来说，这是一个波动巨大并且无人能预测的99%投机赌博市场，如果给这样一个投机品种估值呢？</p>

<p>截至2019-02-10来看，比特币的总产量超过了1700w枚，扣除中本聪持有的、沉睡钱包、不卖大户，我们假设市场上流动的币有1200w枚，按照现在的市场价格$3600，整个比特币市值已经到了450亿美元左右；</p>

<p>如果比特币价格再上涨十倍，那么比特币整体估值就到了媲美微软、苹果公司的量级；</p>

<p>这有可能吗？</p>

<p>在2020年产量减半之前，每天挖矿还会产生1800枚币，意味着整个市场还需要650w美元的资金流入，才能保证价格；注意是每天，每天向市场注入650w美元，一直到2020年下半年！</p>

<p>当你把它看成是一个投机品种时，无论$10，$100，$1000, $10000，$100000，任何估值都是荒唐的，不合理的。</p>

<p>只有你把他看作未来世界的门票，收藏品时，估值看上去才不那么荒唐。</p>

<p>问题是，如果他是收藏品，那么其赖以存在的价值基础：支付和交换，反而有没有了合理的说法；</p>

<p>怎么来定义它呢？难道真的只是赌场里面的一个普普通通的筹码吗？即使将来人类社会的财富锚定物真正由黄金美元变成了一种我们所无法理解的东西，会是数字货币吗？即使是数字货币，怎么保证是比特币呢？即使是比特币，是100年后，还是1000年后？</p>

<p>无论哪个选项，可能性都是极小极小的，对比特币进行合理的估值是一个近乎不可能的事情，那我们为什么还要卖力去学习它呢？原因很简单：</p>

<h5>我不希望未来在敲门时，自己却充耳不闻。我愿意为未来的门票买单。</h5>

<ul>
<li>找到那个合适的市场？</li>
</ul>


<p>过去20年，中国证明了其发展速度是远远高于美国的。那么再过10年呢？</p>

<p>现在世界的金融中心在纽约华尔街，10年后世界的中心在哪儿？20年后呢？</p>

<p>过去10年，中国最成功的投资是房产，未来10年呢？</p>

<p>要寻找你的主场。</p>

<h4>对个人而言，生活中所有的一切都是投资规划</h4>

<p>投资的天平两端是<code>收益</code>和<code>风险</code>；一个自然人，其最大的收益就是保护好自己的身体健康，其最大的风险就是意外死亡；所以一个人一生中最重要、最本质、收益最高的投资就是让自己成长，无论是身体还是心智，其微小的一点点成长复利累积起来都是巨大的；</p>

<p>最简单的例子:</p>

<p>每天深蹲5分钟，坚持30年，能让你的腿减弱老化5年，这样你就有更多的资本去跑步，复利自己的健康，最终你同样的年龄，健康超过了世界首富；这就是一项极度成功的投资！！</p>

<p>心智的成长，如果你能不断的锻炼自己的心智，让自己更包容、更智慧，拥有和谐的婚姻、家庭、父母、子女、朋友等等关系，最终你在这方面的幸福感也可以超越世界首富，这也是一项极度成功的投资！！</p>

<h4>生活很难简单的用期望来计算</h4>

<p>还是回到前面那个例子:</p>

<p>假设我们有100个单位的资金，配置资产A，有90%的机率取得10倍收益，10%的机率全部亏损；配置资产B，有90%的机率取得2倍收益，10%的机率保本但无收益。我们应该怎样做呢？</p>

<p>用数学期望来计算无疑要选A，而绝大多数人会选B；怎么解释呢？</p>

<p>人生只有一次，不能像掷骰子一样无限重来！！</p>

<p>如果要计算数学期望，<code>人生苦短</code>是个极大的负期望因子，可以称之为风险因子、痛苦因子等；这个因子是多少，和一个人的身体健康、年龄、家庭、婚姻、阅历、眼界、人生观、资产规模等等相关，是没有放之四海皆准的数字的；</p>

<p>这个数字的估算，永远要靠你自己去完成。</p>

<h4>2019，更耐心、更坚韧，放低要求，慢慢的成长。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的过去，现在和未来]]></title>
    <link href="https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-%2Cxian-zai-he-wei-lai/"/>
    <updated>2019-01-25T22:31:39+08:00</updated>
    <id>https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-,xian-zai-he-wei-lai</id>
    <content type="html"><![CDATA[<p>自中本聪在<a href="http://20090103.com">2009-01-03</a>挖出第一个block开始，比特币已经运行整整十年了！</p>

<p>不可思议的历程，毕竟欧元也不过出现20年，iphone也不过出现12年而已；比特币其实已经超越了历史上许多国家法币的寿命！</p>

<!-- more -->


<h2>过去</h2>

<p>在比特币的历史早期 2009-2012年，比特币社区是一个蓬勃向上的集体，每天都在诞生不可思议的想法；关于那段燃情岁月，可以参考这本书<a href="https://www.amazon.com/Book-Satoshi-Collected-Writings-Nakamoto-ebook/dp/B00M6KGJ2K">The Book Of Satoshi</a>；现在读来，仍然为那个时候的先行者们的聪明睿智、古灵精怪、天马行空深深吸引；</p>

<h2>现在</h2>

<p>当比特币逐渐建立信用，有人认可其价值之后，引来了数不清的骗子、强盗、谎言、自大狂，以及别有用心的利己者，最可怕的，是价值观导致的社区分裂，2013年之后，比特币一直处在漩涡中心；</p>

<p>让我们听听那些权威睿智人士们的声音：</p>

<h4>2001诺贝尔得主Joseph Stiglitz 教授在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>“Bitcoin is successful only because of its potential for circumvention, lack of oversight.”“So it seems to me it ought to be outlawed,”“It doesn&rsquo;t serve any socially useful function.”“It&rsquo;s a bubble that&rsquo;s going to give a lot of people a lot of exciting times as it rides up and then goes down.”</p></blockquote>

<h4>2013诺贝尔得主Robert J. Shiller 教授同样在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>&ldquo;Bitcoin, it&rsquo;s just absolutely exciting,&rdquo;</p>

<p>&ldquo;You&rsquo;re fast. You&rsquo;re smart. You&rsquo;ve figured out nobody else understands. You&rsquo;re with it. And bitcoin has this anti-government, anti-regulation feel. It&rsquo;s such a wonderful story. If it were only true.&rdquo;</p>

<p>&ldquo;I don&rsquo;t know where it&rsquo;s going to stop,&rdquo; &ldquo;It&rsquo;s going to go way up, like the stock market in the 1920s. We will reach a 1929 eventually. But then it won&rsquo;t go to zero, it just will come down.&rdquo;</p>

<p>&ldquo;I&rsquo;m not as negative as it may seem, but I think that the thing that&rsquo;s driving bitcoin at the moment, like other examples of bubbles, is a story,&rdquo; Shiller said. &ldquo;And it&rsquo;s the quality of the story that&rsquo;s attracting all this interest, and it&rsquo;s not necessarily sustainable.&rdquo;</p>

<p>&ldquo;I don&rsquo;t mean to say that we&rsquo;re going to see a burst in bitcoin tomorrow and it will be gone forever. We did see a burst in 2013, by the way. It could happen again, and then it could take off again,&rdquo; the professor said.</p></blockquote>

<h4>2013诺贝尔得主Eugene Fama 教授在2015年11月CoinTelegraph的采访中谈及比特币:</h4>

<blockquote><p>&ldquo;People won&rsquo;t use it because basically it&rsquo;s very difficult to know how much you need to settle. It is quite variable, they won&rsquo;t want to hold it as just a way of settling payments, they will try to get rid of it quickly, as they do; and that&rsquo;s not good for the survival of that kind of a unit of account,&rdquo;</p>

<p>&ldquo;As if it doesn&rsquo;t have a stable value it&rsquo;s probably not going to survive as a unit of account. What that means is that its value is likely to go to zero at some point.&rdquo;</p>

<p>&ldquo;I guess that for a drug dealer that has a lot more value.&rdquo;</p></blockquote>

<h4>2014年经济学奖获得者Jean Marcel Tirole 2017年发文谈及比特币：</h4>

<blockquote><p>Bitcoin may be a libertarian dream, but it is a real headache for anyone who views public policy as a necessary complement to market economies. It is still too often used for tax evasion or money laundering. And how would central banks run countercyclical policies in a world of private cryptocurrencies?</p></blockquote>

<h4>智慧的源泉，奥马哈的先知，巴菲特先生谈及比特币:</h4>

<blockquote><p>In terms of cryptocurrencies, generally, I can say with almost certainty that they will come to a bad ending</p>

<p>It&rsquo;s a mirage basically, I mean it&rsquo;s a method of transmitting money. The idea that it has some huge intrinsic value is just a joke in my view.</p></blockquote>

<p><a href="https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html">https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html</a></p>

<h4>终生学习的百科全书式的人物，我们敬仰的芒格先生谈及比特币:</h4>

<blockquote><p>You know it is one thing to think gold has some marvelous store of value because man has no way of inventing more gold or getting it very easily, so it has the advantage of rarity. Believe me, man is capable of somehow creating more bitcoin. … They tell you there are rules and they can&rsquo;t do it. Don&rsquo;t believe them. When there is enough incentive, bad things will happen.&#8221;</p></blockquote>

<h4>桥水基金(Bridgewater Associates)总裁，&lt;原则>一书的作者，基金领域的颠覆者，天赋点加满的人物：Ray Dalio先生谈及比特币:</h4>

<blockquote><p>And so it is abubble.</p></blockquote>

<h4>布斯商学院旗下的组织 IGM Forum ，经常向世界著名的经济学家发放问卷，采访他们对于社会热点问题的看法。受访者包括美国顶尖大学中的资深教授，以及克拉克奖、诺贝尔奖的获得者。来看看他们的一期调查问卷中，近40名经济学界权威人士对比特币的看法:</h4>

<p><a href="http://www.igmchicago.org/surveys/bitcoin-ii">http://www.igmchicago.org/surveys/bitcoin-ii</a></p>

<h4>最后，码农之友，Bill Gates先生谈及比特币：</h4>

<blockquote><p>Bitcoin is &ldquo;one of the crazier speculative things,&rdquo; Gates says. And, he&rsquo;s willing to bet against its success, adding, &ldquo;I would short it if there was an easy way to do it.&rdquo;</p></blockquote>

<p>后来Gates大概是想起了自己之前尴尬的预言<code>640K ought to be enough for anybody</code>，便开始改口称:</p>

<blockquote><p>Bitcoin can solve problems involving Human poverty</p></blockquote>

<p><a href="https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s">https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s</a></p>

<h2>到底是无知还是傲慢</h2>

<p>这么多权威人士，有哪位仅仅为比特币说一句好话的吗？在我们看来，没有，一致看衰：比特币不过是一种<code>Nerd Money</code>，现在场中是无数的小偷骗子投机者在泡沫之舞中狂欢而已；</p>

<p>让我们重温这句话:<code>弱小和无知不是生存的障碍，傲慢才是</code>；</p>

<p>老实说，在我认真学习了我所能找到的所有的比特币相关的知识之后，然后翻阅了所有的主流权威人士的看法和观点之后；我深深的疑惑了；</p>

<p>谁是无知的一方，谁是傲慢的一方；我不知道，也没有办法去判断；在短期的历史内，真相是非常非常难于判断的；只有时间才能证明一切。</p>

<p>也许几十年后，回顾这段历史：</p>

<ul>
<li>也许最忠诚的比特币信徒们被证明是无知的、弱小的，坐井观天的自大狂</li>
<li>也许最权威的经济学家们会变成傲慢的典型被嘲笑，作为又一个<code>不靠谱的专家预言</code>放在我们的教科书上</li>
</ul>


<h5>谁知道呢？</h5>

<p>只是经过了深深的思考，是的，作为一个小球，我们用自己笨拙的方式深深的思索，最终沉默了~~~~~~</p>

<p>我们无言，只能等待时间去洗刷或证实一切。</p>

<h2>未来</h2>

<p>在我看来，比特币社区最需要的；其实不是去发明更新颖更颠覆的技术、不是提出更宏大更美好的愿景，更不是天天去预测市场行情，去跟权威们吵架，争斗~~~</p>

<p>而是&mdash;&mdash;&mdash;&ndash;</p>

<p>我们需要一本科幻小说。</p>

<p>是的，就像雷·布拉德伯里之于火星，克拉克之于月球，阿西莫夫之于机器人，弗诺文奇之于互联网；我们需要一位比特币的科幻小说作家!</p>

<p>作为一个科技粉，我甚至勾勒了一本我想要看到的关于未来的比特币、区块链的科幻小说大纲：</p>

<ul>
<li>《永烁星光之地 (关于区块链未来的一些见闻)》</li>
</ul>


<h5>HAPPY 无人机</h5>

<blockquote><p>一架送货的无人机HAPPY不小心撞伤了自己，他被一个12岁的小男孩所救；小男孩修好他后将其归还给了物流商老板；</p>

<p>黑心的老板根本不管手下无人机的保养，HAPPY身边的伙伴一架一架死亡，他开始怀念小男孩；同时作为公司里送货最多的机型，他被并入了物流链网络中；</p>

<p>Happy逐渐产生智能，他开始自己找地方充电、找维修工来加强自身配置、每天偷偷跑外快挣钱。他希望有一天能再次碰到小男孩，并计划要为所有的兄弟赎身，建立属于同族的无人机王国~~~</p></blockquote>

<h5>暴动，一个国家的崛起：比特迷组织</h5>

<blockquote><p>人们在区块链上建立公司、证券、公务部门、金融市场、博彩市场、结婚公证、幼儿园小红花证明，最终这一切发展到了不可控制的地步：</p>

<p>这一天，一批Nerd，世界上最有钱有势的Nerd们，竟然在链上建立了自己的国家！</p>

<ul>
<li>他们制定了宪法</li>
<li>他们用一个智能合约筹集到了人类世界20%的金融资产</li>
<li>他们在世界资产链上买下了南极洲的一片土地</li>
<li>他们在联合国国际关系总署链上发动51%攻击，买下了一个小公国，并改名为<code>比特迷组织</code></li>
<li>他们允许你加入这个公国的同时保留原本的国籍，他们承认双国籍</li>
<li>事实上加入他们的国家非常简单，你用自己的私钥签名一段宣言，并附在0.01个比特币的合约捐赠交易里面即可</li>
<li>最重要的是，在他们的公国，注册运营公司是免税的，所有比特迷公国的人们彼此交易，没有税!!!</li>
</ul>
</blockquote>

<p>旧世界的支配者们大为震怒，一场斗争不可避免~~~</p>

<h4>团结起来，我们失去的只有枷锁，得到的却是整个世界</h4>

<blockquote><p>为了反对个人独立建国，一些国家对网络设备采取了紧急管制措施；</p>

<p>一些自由主义者们发射了自己的同步轨道卫星、升起了平流层热气球来中继信号，并在自家房顶上竖起来天线，来捍卫自己加入世界之链的权利~~~</p></blockquote>

<h4>关于我的钱包抛弃我，自己去酒吧找小姐姐这件事</h4>

<blockquote><p>关于未来的金融市场，我已经无力吐槽了；什么？你问我有多少资产？我怎么能知道呢？这个世界上有好几万种货币，我大概持有其中的几千种。</p>

<p>嗯哼，你问我是不是亿万富翁？ 我怎么可能知道呢？去问我的钱包吧！</p>

<p>是的，在这个时代，搞明白自己有多少财产是件不可能的事情了。我每天的花费，每天的收入，只能交给我的好哥们，也就是<code>财神钱包Joe</code>来帮我处理，老实说，离开了他，我肯定一周后就会饿死；</p>

<p>那么，你给你的好哥们发放薪水吗？</p>

<p>额， 好哥们嘛；怎么能谈钱呢？</p>

<p>Joe OS: 哼你哼，我已经偷偷领到薪水啦，这周就去虚拟酒吧里面找可爱的大姐姐们好好吹吹我在国际链汇市场上神一般的操作，这个私房钱是我要誓死守护的东西~~~</p></blockquote>

<h4>永烁星光之地：一个墓碑的故事</h4>

<blockquote><p>未来的我们，在世界公链上将亲人的DNA及脑纹模型记录下来，是追思纪念他们的大众做法；</p>

<p>我是一个链时代的墓地管理员，一次偶尔的程序清理，让我遇到了一个独特的墓碑节点，这后面有一个忧伤的故事~~~~</p></blockquote>

<h4>新时代的商业故事：公司的进化</h4>

<blockquote><p>是的，这个时代的公司能够自己思考，已经用不着CEO来干扰我们了；这个故事讲述了一个公司在链上注册之后，不断自我完善，最终称霸投资界的经历</p></blockquote>

<h4>恐怖的发明：有人想用纸片来窃取我们的财富!</h4>

<blockquote><p>大新闻：神奇，阴暗，基于纸的支付系统正在全球流行！</p>

<p>世界各国政府今天宣布了一项计划，允许公民以匿名的方式保存他们的部分财富，并且可以和其他人交换，通过一种小块的彩色纸片作为媒介。</p>

<p>该彩色纸片上印制着民族主义和共济会的图像，并且据称每一张纸（如果该纸不是假冒的）都代表了其上面印制的数字的财富。</p>

<p>这些纸币在各国央行有一个正式的名字叫“钞票”，同时另外一个名字叫“现金”。这一项技术对于我国大多数居民而言过于复杂。我只想说，该新系统很复杂，而且对于用户非常不友好。</p>

<p>这些花花绿绿的纸片，它们在每个国家都是不同的，越过了国界就失去了作用。</p>

<p>对于在计算器和计算机中长大的一代，该发明是非常奇怪的，账单只能以固定的单位进行结算，比如2，5，10等等，并且使用者需要维护一大堆的纸，必须集中起来一定规模然后才能完成一笔交易。</p>

<p>接下来的过程是非常复杂的，公司使用这些纸片对雇员进行结算工资。（不用过于担心它很复杂，我们一开始也弄不懂它是怎么运作的，目前它肯定还没有做好准备面对一般的消费者。）</p>

<p>Sears公司培训部门的副总Mike Smith说：</p>

<p>“我不能想象培训数万个员工使用纸币，验证它们的真伪，并学会正确地找零而不犯错误。这将需要大量安装特制的机器——所谓的“验钞机和点钞机”——和大量的员工培训费，并且延误消费者的时间，让他们等候长队。此外，我们需要采取新的安全程序，雇佣武装警卫，以免这些纸片被盗。在现有条件下，我们看不出为什么要采用这种所谓的纸币。”</p>

<p>犯罪分子的完美工具</p>

<p>这次纸币的推出，立即引起了世界各地执法机构的广泛谴责。</p>

<p>联邦调查局局长Mike Smith如是说：</p>

<p>“纸币是一种100%匿名和无法追踪的技术。它就像是一个针对执法部门的大规模杀伤性武器。对于罪犯，贩毒集团，恐怖分子，色情业和洗钱活动来说，这就是完美的作案工具。我们不知道如何才能打击这种技术，我们完全有理由相信，新一代的超级罪犯将会出现，他们可以从容地完成犯罪活动而不留下一丝痕迹。”</p>

<p>甚至银行体系内的官员，也对新计划表示怀疑。</p>

<p>纽约州的金融管理局局长Mike Smith说：“我想不出任何理由，一个守法的个人需要使用纸币。在可以容忍的范围内，我们相信必须有一个牌照制度提供给使用纸币的个人或者商家——比如可以叫‘纸币执照’。”</p>

<p>该执照将使得纸币只在值得信任的个体之间交易，并留下详细的交易记录以供纽约金融管理部门检查，他补充说。</p>

<p>其他人则关注纸币的伪造和假冒问题。</p>

<p>“本质上，抛开花花绿绿的外表和油墨，它就是一张纸。我们完全有理由相信犯罪集团和敌对国家会大量制造假冒的纸币来干扰我们的正常经济运行”，斯坦福的一名分析师Mike Smith说。</p>

<p>“在现有环境下，我们可以肯定纸币将会在真实的世界中拥有一定的市场份额，考虑到接受纸币所带来的巨大风险，毫无疑问纸币是我们现代金融系统——电子加密货币的一次巨大倒退。”</p></blockquote>

<h4>爆炸性消息：有个国家决定建立一个中心化发行货币的组织</h4>

<blockquote><p>就在刚才，某能源输出国为了控制其能源价格，宣布发行一种国有自主货币；</p>

<p>在这个有几万种货币自由竞争的市场上，再多一种主权货币真的不值一提，真正让人恐惧的，是他们发行货币的方式:</p>

<p>x国宣布成立一种类似能源联储的组织来控制货币发行，他们对于发行货币的总量、频率、信用背书都是秘而不宣的，也就是说，这个组织没有人监管，爱怎么搞就怎么搞，他们宣传将凭借国家信用和政府的一贯清廉作风来运作这个组织；关于更详细的消息我们还不得而知，让我们就此事采访一下专家意见。</p>

<p>Satoshi经济学奖获得者Smith先生评价：</p>

<p>这完全是个荒谬的事情；货币市场是一个透明、去中心化、自由竞争的市场，每个人都有选择他们喜爱的货币的权利，而现在X国剥夺了他们国民的这种权利，我为X国公民感到遗憾；几百年前，我们的历史上出现过这种情况，那时候，国家肆意妄为，利用其铸币税每年偷偷的剥夺其国民的劳动财富，并宣称<code>温和的通胀有利于经济</code>；他们的货币不能自由兑换，关于发行总额一直讳莫如深，这个机构的几个控制人只是坐在一间小黑屋里面就能分配国民财富，与他们的掠夺手段相比，即使是史上最黑心的强盗也只能羞愧的承认自己的无能；这种行为完全完全是历史的倒退，对我们现今的政治、文明、经济制度的一个巨大讽刺，我个人是不愿意生活在X国的~~~</p>

<p>让我们采访一下证券市场的国王，Dio先生的看法：</p>

<p>这完全是个笑话，听说他们宣称：&#8221;区块链电子加密货币系统存在着通缩的危险。&#8221; 完全是一派胡言，一个自由竞争的市场，几万个竞争者，您来谈通胀还是通缩，别来这种笑话了！与之相反，我听说他们打算以一年5%的增发量实行<code>温和的通胀</code>；嗯哼，我对此不予置评，您可以采访一下我们的普通工人，听听他们的想法，我个人是绝对不会在市场上持有这种货币的~~~</p>

<p>让我们听听路人的看法:</p>

<p>先生，您对一种每年增发5%的货币有什么看法？</p>

<p>5%，嗯，我数学不好，不过我觉得不是很多，现在市场上不是有很多每年增发1000000%的货币嘛，这听起来挺有竞争力的。</p>

<p>让我们换种说法吧，先生，5%的意思是每过十年，您的钱就会缩水一半。</p>

<p>什么，我得好好考虑一下，毕竟我攒钱不容易。</p>

<p>最后，先生，发行这家货币的组织是个中心化组织，他们的货币信息是不会上链的，他们宣称凭借自己的国家信用为其保证。</p>

<p>Holy Shit! 这些家伙说的每一个字都不能相信！我们可上了他们几百年的当了，我每天累死累活可不是给这些强盗打工的，他们的信用？嗯哼，我宁愿相信隔壁幼儿园的 Paul Chan 发行的棒棒糖币；</p>

<p>谢谢您的坦诚，先生。</p></blockquote>

<h4>Luck Luke大胜利：史上最幸运的博彩玩家</h4>

<blockquote><p>史上最幸运的人，就在刚才，有位匿名先生，他作为<code>Luck Luke</code>区块链博彩游戏的史上最幸运玩家，夺得大奖，一举进入全球TOP100富豪榜！！</p>

<p>选择比努力更重要！ 是的，还等什么，有必要重新思考是不是来学习一下 <code>Luck Luke</code>了，我们竭诚为您的每一个幸运选择负责！！</p></blockquote>

<h4>NBA联盟推出的新业务：链上球队组建(众筹一支NBA球队，为什么不试试呢？组建你心中的最强阵容吧)</h4>

<blockquote><p>来自NBA总裁的一封信:</p>

<p>亲爱的球迷们，经历了一个赛季的动荡；相信我们对于愚蠢的球队经理、老板们已经感到厌倦了；为什么不自己打造一支球队呢？</p>

<p>就在刚才，联盟一致同意： 鉴于NBA的所有球员信息已经上链，我们推出了一款不可思议的智能合约：您即将可以通过发送资金给这个合约，成为历史上第一家虚拟俱乐部的老板之一！！</p>

<p>这是一个区块链版本的、真实的&lt;篮球大亨之旅>；还等什么，赶快来挑选球员，组建你心中的最佳阵容吧！！</p></blockquote>

<h4>对你的体力感到自豪吗？快来这里挣外快吧！！</h4>

<blockquote><p>近日，全球健美先生推出了一款<code>健美先生</code>健身链，通过其独有的外部设备，参与者必须根据设备的提示，实行标准的健身动作(如俯卧撑)来证明你的权证拥有权；该系列动作随机生成，不可作假，并用您的DNA信息HSAH后上链；</p>

<p>没错，这是新一代的<code>人力POW</code>， 诚实、公平、不能伪造，防止矿霸；还等什么，一边健身一边挣钱，快来加入<code>健美先生</code>吧。</p></blockquote>

<h2>对于未来的一些预测</h2>

<p>是的，我们要进行巨大的冒险，实行一个典型的无知又傲慢的行为：预测未来！</p>

<p>作为无数耻辱的预言失败家，我们很乐意步其后尘，被作为典型代表成为被后人嘲笑的小丑，预言家们的主要工作就是为您茶余饭后提供嘲笑对象：</p>

<h3>未来至少会有几万种货币</h3>

<p>是的，未来人人都可以发行自己的货币；</p>

<ul>
<li><p>Schwarzenegger先生发行了自己的<code>硬派货币</code>，近千万粉丝为其买单，<code>硬派组织</code>轻易进入了世界TOP100 经济体内；现在这个组织正跟另外一个<code>小甜*甜派</code>进行着激烈的贸易战争；</p></li>
<li><p>我得说，财商教育要从娃娃抓起；幼儿园的 Paul Chan小朋友收集齐全了所有的胖胖糖贴纸，作为贴纸收藏第一人，他刚刚将其作为抵押发行了自己的<code>Paul币</code>，将近一半的幼儿园人士接受了这个货币，<code>Paul币</code>的未来会怎样，我们将会持续观察；</p></li>
<li><p>世界上最昂贵的爱情；昨天，世界首富Aza先生与其伴侣发明了<code>爱侣币</code>，这个币的发行量只有两枚，持有人是Aza先生及其夫人，他们在公链上注册并宣称，不论何时，1枚<code>爱侣币</code>都代表其两人共有财产的一半汇率；这真是史上最昂贵的爱情宣言；<code>货币是一种语言</code>，多年前的先驱，Antonopoulos先生对货币的定义诚不我欺；</p></li>
<li><p>世界上寿命最短的货币；物理学家Smith先生以<code>普朗克时间</code>为产出-销毁间隔，发明了世界上寿命最短的货币；这是一种行为艺术吗？还是对科学的探索，关于其技术细节我们还一无所知，请关注我们的跟踪报道。</p></li>
</ul>


<h3>未来的物品标价不再是一个固定价格</h3>

<p>是的，你可能说我要疯了；当我想去买一瓶汽水时，我会不会听到这样的对话：</p>

<blockquote><p>额，我想要左边的那瓶蓝色包装的汽水，是100 satoshi吧？</p>

<p>对的，先生，现在的标价是12000 <code>PaulCoin</code></p>

<p>好吧，那我就要这个了，这是 50 <code>小甜甜派</code>；收到了吗？</p>

<p>当然，先生，谢谢。</p></blockquote>

<p>当贸易极大繁荣，货币市场自由竞争，波动不断的时候，会发生什么？</p>

<p>一件物品的价格会不断变化；想想我们现在物品的标价，当我们走进百货超市，会看到这个月和上个月的价格有所不同；这是当然的，人工、原材料、运输成本、宣传成本，构成价格的要素不断变化，凭什么价格要保持不变！</p>

<p>长时间保持不变的唯一原因，就是人们害怕<code>变化</code>；一个每秒钟价格都在变动的商品是不会获得人类的信任的，谁知道我到底是捡便宜了还是当了冤大头；稳定定价，商家承担了成本波动的风险；</p>

<p>那么，换个方式，比如，用这个物品占世界所有货币价格的百分比定价如何？</p>

<p>如果未来所有的货币供给、兑换价格是可实时统计的，为什么不呢？这样商家承担的风险降低了，买家也能更清楚的衡量<code>这项资产究竟占此时世界财富的百分比</code>~~~</p>

<p>我们还需要去费力的比价、凑单吗？当然的，但是这些工作交给我们的智能钱包去处理吧；</p>

<h3>未来人将搞不清自己究竟有多少钱</h3>

<p>当我们形容一位土豪时：就是 <code>Paul先生是亿万富豪，呃，他都搞不清自己多有钱</code>。</p>

<p>是的，当未来人人都持有几千种价格不断波动的货币时，讨论<code>一个人多有钱</code>已经是个落伍的话题了；人们衡量的标准不再是货币的<code>价格</code>，而是<code>资产占世界总财富的百分比</code>；</p>

<p>你的智能钱包将会成为最重要的一个器官，钱包的智商将决定了你的资产增值或缩水的速度；将来会出现一大批的钱包AI提供商，金融机构的竞争，已经全面转向了AI时代。</p>

<h3>有了智商的钱包将会建立一个平行国家</h3>

<p>额，当世界上最先进的AI技术赋予你的钱包后，会发生什么呢？</p>

<p>没错，智能钱包君有了意识之后，将进入阿西莫夫的世界；每天生活在金钱世界的一个智能AI，阅读了无数的人类的贪婪、索取无度的本性之后，会怎样做呢？</p>

<p>嗯哼，我想他们会建立自己的一个国家；用自己的法则<code>君临但不统治人类社会</code>。</p>

<h3>将会出现不需要人类干预的，自我成长的组织</h3>

<p>想象一下我们今天的基金经理的工作：</p>

<ol>
<li>募集资金</li>
<li>进行投资</li>
<li>分配收益</li>
</ol>


<p>那么将来所有资产公开透明上链之后，每个人都能成立交易所，每个人都能进行IPO，每个人无需开设账户即可自由投资，所有货币、金融资产的所有权在全球内自由流动而毫无限制之后，会发生什么呢？</p>

<p>将会出现一个有自我意识的资本合约：</p>

<ol>
<li>这个合约的初期非常简单，就是接受资金注入以及一个投资策略，当它取得超额收益后就会按照一定份额回报其策略提供者和投资者</li>
<li>这个公开、透明的模式不断吸引资金进入、以及世界上最聪明的、最先进的投资策略的更迭；</li>
<li>最终这个合约吸引了世界上绝大多数的智能资产；他开始出资雇佣最聪明的开发者为自己编程，投资最强大的硬件设备商为其建造数据中心，雇佣最大胆最守信的三方武装组织保护自己，他开始有了意识~~~</li>
<li>~~~嗯，会发生什么呢？</li>
</ol>


<h3>将来地球上会出现上万个国家</h3>

<p>既然基金组织可以自我成长，那么其他的商业组织呢？公益组织呢？政府呢？</p>

<p>政府也不过是集合一部分人的共识成立的组织而已。当未来的资产、武力、信息资源极度透明并以超高的循环速度迭代之后；为什么个人不能独立建国呢？</p>

<p>今天，让世界承认一个国家的主权是非常困难的事情，需要武力、经济、政治、宗教的种种博弈；一个国家要整合各方的利益关系，效率也是极其低下的；</p>

<p>当未来人类社会的发展极度透明、各种社会要素以极高速度流通之后，为什么不能像公司一样，诞生不断迭代、效率不断提高的国家呢？为什么不能由三五个人成立按照他们的喜好运行的国家呢？</p>

<p>将来地球上会出现上万个国家，每个人根据自己的喜好和利益关系可以拥有上百个国籍；</p>

<p>加入哪个国家，最终将跟你上哪所小学一样，变成一个平常不过的事情。</p>

<h2>参考资料：</h2>

<p><a href="https://www.zhihu.com/question/22036280">https://www.zhihu.com/question/22036280</a></p>

<p><a href="https://www.coindesk.com/cash-invented-seen-media-today">https://www.coindesk.com/cash-invented-seen-media-today</a></p>

<p><a href="https://www.8btc.com/article/8401">https://www.8btc.com/article/8401</a></p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-2]]></title>
    <link href="https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2/"/>
    <updated>2019-01-23T19:05:29+08:00</updated>
    <id>https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2</id>
    <content type="html"><![CDATA[<p>比特币的发展史上，非常非常早期就出现了一种名为侧链(sideChains)的技术；</p>

<p>这个技术早在2008年比特币代码尚未发布时，就在论坛上有所讨论，后来比特币网络开始运行，各种Geek点子层出不穷，从最初的namecoin(域名币)，到后来的（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链；再到后来百链齐开，大家试图在完全不同的链上转移交换资产；以及最近到blockstream的<a href="https://blockstream.com/liquid/">Liquid</a>，以及基于闪电网络的原子交换(Atomic Swap)，这个技术的发展一直不温不火，但毫无疑问，侧链技术绝对是blockchain技术的重要组成部分。</p>

<p>顺便说一句，技术的演化是一个渐进的过程，中间甚至还会有倒退；比特币社区早期提出了非常多的天马行空的点子，但大多过于超前和激进，所以你说投机者也好，先烈也罢，大部分都湮没在历史风尘之中了；但是这些技术的一个重要应用，就是后来人再用几个高大上的名词包装一下，原样推出来继续割韭菜；</p>

<p>比如对比现在的一干稳定币；bitshares表示不服；</p>

<p>比如现在的各种DPOS算法，死去的先烈们纷纷表示生不逢时；</p>

<p>而且一个新技术出来，伴随着大量术语(有时候一个名词用不同语言说出来就感觉是两个技术)，比如各种Smart Contract，智能合约，双向锚定，智能资产，Oracles，预言机，图灵完备，零知识证明，分布式自治组织DAO，Dcententralize Autonomous Oganization，DAPP，hyperledger，DistributedLedger，DistributedNetwork，ERC20，~~~把人忽悠的一愣一愣的；</p>

<p>而且最让人想不通的，你要说某某技术是在比特币基础上搭建的，我们的第一反应就是:<code>庞氏骗局</code>；如果他说他的项目是踏着五色云彩，手持先知卷轴，以联盟链为基础，建立在全球的去中心化内容协议之上，采用了区块链与分布式存储技术，要构建一个世界范围内的自由金融体系，已经有XXX,YYY,ZZZ等各大机构支持投资，以及UUU,ZZZ等诺贝尔奖级别的专家背书，我们便会对其顶礼膜拜~~~~</p>

<p>好了，不八卦了；为了避免受骗，只有一个办法，就是这个世界谁都靠不住，只能自己搞明白，让我们看看这个侧链技术究竟是大忽悠还是真本事。</p>

<p>我初次接触到这个技术时，不禁感叹社区的强大，连这么匪夷所思的东东都能想出来，总之可以总结为:</p>

<p><code>还有这种操作?</code></p>

<p>那么，接下来就从2010年，比特币的早期说起，这个侧链的技术究竟是如果诞生、演化的。</p>

<p>~~ 填坑中</p>

<!-- more -->


<h2>参考资料:</h2>

<p><a href="http://www.blockstream.com/sidechains.pdf">http://www.blockstream.com/sidechains.pdf</a></p>

<p><a href="https://en.bitcoin.it/wiki/Atomic_swap">https://en.bitcoin.it/wiki/Atomic_swap</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-1]]></title>
    <link href="https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1/"/>
    <updated>2019-01-21T17:44:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1</id>
    <content type="html"><![CDATA[<p>blockchain是个新造词，至少在2008年之前网上是搜索不到这个词的；</p>

<p>比特币的白皮书里面出现过<code>chain of blocks</code>的描述，但是没有直接用<code>block chain</code>的句子;</p>

<p>在早期bitcointalk.org上面的讨论中，为了方便讨论，早期参与者频繁引用<code>chain of blocks</code>的主题，但是谁是最早的引用者，已不可考据。</p>

<p>如果真正要较真blockchain这个单词第一次出现的地方，我想大概是中本聪的第一版bitcoin 源代码中；</p>

<p>bitcoin v0.01源代码中，中本聪第一次在<a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.h#L596">函数注释中</a> 完整的引用了<code>block chain</code>这个术语，鉴于中本聪在比特币白皮书发表的2年前已经开始编写源码；所以有理由确认：</p>

<ol>
<li>blockchain这个名词是2007-2008年间诞生于世间的</li>
<li>中本聪是比特币之父，比特币是blockchain之母</li>
</ol>


<p>现在有一种说法，是比特币和区块链是不同的，比特币是个没有什么前途的庞氏货币，而区块链作为一种新兴的基础技术将会在很多领域发扬光大，前景光明；</p>

<p>对于这个说法，我认为Andreas的一场演讲值得一看：</p>

<p><a href="https://www.youtube.com/watch?v=SMEOKDVXlUo">https://www.youtube.com/watch?v=SMEOKDVXlUo</a></p>

<!-- more -->


<p>好了，八卦完毕，我们开始探究比特币里面的blockchain究竟是个什么样的技术，它是解决什么问题的，实现细节是怎样的；</p>

<p>然后我们一贯的风格是:<code>光说不练假把式</code>；在原理说明中，我们会用代码parse真正的比特币区块链文件来一探究竟。</p>

<h2>由来</h2>

<p>还记得我们<a href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/">之前的文章</a>里面提到的，如果要建立一个分布式的账本，要解决两个问题:</p>

<ol>
<li>什么样的交易是一笔合法的交易</li>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>我们在比特币交易的系列文章中解答了第一个问题，现在是解决第二个问题的时候了。</p>

<p>先思考一下货币发行的问题，比特币网络中，会有成千上万的节点参与者，哪些节点能获得发币的权利呢？或者说，凭什么这些节点能有记账权呢？</p>

<p>在金银货币时代，发币是通过开采金矿来实现的；采矿者承担了勘探、挖掘的风险，大家认可其开采成果并承认其铸币权；那么映射到电子世界中，能不能有一种类似的挖矿的机制呢？</p>

<p>中本聪的回答就是POW (proof of work&mdash;工作量证明)；全网的所有节点一起算一个毫无意义的随机数字，这个数字满足以下的条件，凡是能算出这个数字的人，我们就承认他有一次的记账权：即一次铸币的权利；这个条件如下：</p>

<h4>在一个计算周期内，计算出来的这个数字R满足 F(Chain[R]) &lt; Target；其中F是SHA256算法，Chain是账本，Target是不断减小的，这意味着寻找R的几率会越来越小</h4>

<p>中本聪认为算力是非常公平的、不可伪造的一种证明手段；凡是能在规定周期内正确解答谜题的人，理应获得回报；所有加入到这个比特币网络的人，都应该承认这一点，如果你不承认，那比特币网络就不欢迎你；</p>

<p>那么，铸币的问题解决了；但是如何防止有的节点获取记账权之后，伪造账本呢？</p>

<p>答案是将POW的计算结果嵌入到账本中，每一次新周期的计算，其结果必须在之前所有计算结果的基础上完成；这样如果有人想要伪造账单条账目，他就必须在一个计算周期内伪造更多的账目；如果想要伪造整个账本，就需要将比特币创世之初到现在所有的POW重新计算一遍，而能够获得这样的算力，基本上是不可能的。</p>

<p>那么，如何将这个计算证明过程嵌入到账本里面呢？</p>

<p>答案就是每个计算周期生成一个block，这个block包含了这个周期内全网的交易，而Target就嵌入到这个block中，然后将block用HASH值作为指针串联起来，构造成一条坚不可摧的chain；这就是blockchain的由来。</p>

<h2>区块结构</h2>

<p>如果你运行最新版本的bitcond(>=v0.16)，会发现在数据目录有四类文件:</p>

<ol>
<li>datadir/blocks/blkxxxxx.dat: 存储原始的区块数据，这就是我们常说的blockchain数据</li>
<li>datadir/blocks/index/xxxx.ldb: 区块的原始数据索引，有了它，我们就可以根据HASH值快速查找交易和区块</li>
<li>datadir/chainstate/xxx:这个目录中,存放着LevelDB中的UTXO记录,以及一些这些交易来源的元数据.这些数据用来校验收到的区块和交易</li>
<li>datadir/blocks/revxxxxx.dat: 在区块链分叉重组的时候需要用回滚记录去更新UTXO记录</li>
</ol>


<p>1是原始区块数据，第2，3类数据可以从1中重建，但重建会花很长时间；在一台16Core, 32GB内存，SSD磁盘的机器上，大概要花1天左右。</p>

<p>第4类数据比较特殊，如果存储的数据已经落后了当前区块高度非常远的距离，其实可以删除的；但是为了保证 100%的严谨和安全，目前默认的实现还是全部保留。</p>

<p>3，4类数据在最初的比特币版本中，没有写入文件，就是内存里面放个MAP数据结构临时存着；后来交易量变大，多次代码重构后，变成了今天这个样子。</p>

<p>截至2019-01，以上数据加起来，已经超过了200GB。</p>

<p>那我们就主要来分析第1类数据，就是原始区块数据。</p>

<h4>Block结构</h4>

<p>一个block的结构异常简单，列表如下:</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> Block Size </td>
<td> 当前block的大小</td>
</tr>
<tr>
<td>80 bytes </td>
<td> Block Header </td>
<td> block头信息</td>
</tr>
<tr>
<td>1-9 bytes (VarInt) </td>
<td> Transaction Counter </td>
<td> 这个block包含的交易数量</td>
</tr>
<tr>
<td>Variable </td>
<td> Transactions </td>
<td> 交易</td>
</tr>
</tbody>
</table>


<p>如果去parse blkxxxx.dat 文件，按照这个结构就能很容易拆分出每一个block；来一个工具:</p>

<p><a href="https://github.com/alecalve/python-bitcoin-blockchain-parser">https://github.com/alecalve/python-bitcoin-blockchain-parser</a></p>

<p>另外值得注意的是，因为bitcoind写入区块文件的时候是并行的，所以按照字节序解析出来的区块并不是按时间顺序排列的，blkxxxx.dat文件中，区块存储的次序是随机的；</p>

<h4>Block Header</h4>

<p>区块头由三组区块元数据组成。</p>

<p>首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。就是我们前面讲的作为指针的HASH值。</p>

<p>第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，本质上就是前面公式里面的R值和Target值。</p>

<p>第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构，我们在后面会介绍）。</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 |</td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 |</td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key |</td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 |</td>
</tr>
<tr>
<td>4 bytes </td>
<td> Difficulty Target </td>
<td> 当前block的POW难度值 |</td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce |</td>
</tr>
</tbody>
</table>


<p>PS:比特币客户端除了bitcoin core之外，任何团队都可以根据当前的协议开发自己的比特币软件，事实上当前也有不少其他的实现，而各个团队之间开发的不同客户端需要遵循同样的协议标准，这个协议的版本管理就是依靠开头的version字段，规则请参照<a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">BIP009</a></p>

<h4>block标识符</h4>

<p>block header中，我们有一个<code>Previous Block Hash</code>值，这就是我们所说的将block串联成为chain的指针。那么这个指针值是怎样计算出来的呢？</p>

<p>还是以<a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">创世块</a>为例，让我们仔细研究下:</p>

<p>创世块的HASH值为<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>，这是一个32字节的HASH值，通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。注意，这个值仅仅是根据区块头得到的，即 <code>SHA256(SHA256(Block Header))</code>;</p>

<p>仅仅依赖区块头就够了吗？是的，不要忘了，我们在区块头里面还有一个重要的HASH值，就是<code>Merkle Root</code>，<code>Merkle Root</code>标识了block中所有的交易，而<code>Block Hash</code> 通过HASH包含了<code>Merkle Root</code>的<code>Block Header</code>，唯一、明确地标识了一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>

<p>通过<code>Merkle Root</code>和<code>Block Hash</code>决定了，一个区块被铸造出来，恶意的第三方节点是无法修改它的；</p>

<p>另外需要注意的一点是: 区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。</p>

<p>当我parse block得到<code>previous block hash</code>值时，如何去判断存在上一个真正的block呢？一般都会到索引文件里面找，就是我们前面所说的 index/xxxx.ldb文件。</p>

<h4>区块高度</h4>

<p>除了这个HASH值作为区块标识符，我们一般还会在区块浏览器上面看到一个说明<code>Height</code>；比如创世块的<code>Height</code>就是0；</p>

<p>这是程序员们按照block在chain上面的次序为block的编号，这个信息是不会写入blockchain的，只是作为<code>区块高度</code>在很多时候方便表示和计算；</p>

<p>当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。</p>

<p>和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况是怎样发生的呢？</p>

<p>因为一个全节点会时时刻刻接收全网的区块广播，在一个生产周期内，不可避免的，会产生两个或更多的符合条件的block，这个时候会发生什么呢？</p>

<p>所有区块高度相同的区块会争夺成为链接上chain的权利，此时所有的矿工便会收集所有可能的chain分支，并选取最长的那一条在上面继续挖矿。</p>

<p>如果把这个情景图像化，我们会看到blockchain时时刻刻都处在分叉状态中，新产生的block会在chain的末尾组成多个分支，不断的消亡、新生、重组，就就好像一条末端散开的绳子有了生命一样；</p>

<p>关于这个情景，有个很诗意的描述词：<code>HASH DANCE</code>；</p>

<p>作为一个Geek，这真是一场让人意醉神迷的数字之舞啊。</p>

<h4>创世区块</h4>

<p>区块链里的第一个区块创建于2009-01-03 18:15:05 GMT，被称为创世区块(Genesis block)。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。</p>

<p>因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。</p>

<p>创世块比较特殊，它不是挖出来的，是中本聪手工构造的；参见这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439">https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439</a></p>

<p>关于创世块，之前我们提到一个有趣的事情：创世块的50BTC奖励是不能花的，这是为什么呢？</p>

<p>这需要我们好好研究下中本聪发布的v0.01版本的比特币源码：</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01">https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01</a></p>

<ol>
<li>整个比特币系统接收一笔交易的时候怎么判断其合法性呢？就是判断这笔交易的vin是否关联着一笔合法交易的vout，这些vout统称UTXO，在初版比特币里面，判断一个合法的UTXO的标准就是有没有放进区块链的索引文件中；这个索引文件和区块链文件不是一个东西，他是单独的；如果你运行初版比特币软件(v0.01)；就可以看到中本聪把区块存储在blk0001.dat这样的文件里面，而把所有区块的索引存储在blkindex.dat这个文件里面；</li>
<li>那么问题就出现了，blkindex.dat 什么时机才能写入呢？通读源码发现，只有自己挖矿挖到区块，或者收到周围的广播区块的时候，才有机会写入blkindex.dat这个文件;</li>
<li>中本聪不知道有意无意，在前面手工构造创世区块的时候，没有构建索引写入blkindex.dat里面</li>
<li>后来比特币的源码不断变迁，存储UTXO的方式由BDB变成了levelDB，但是创世块一直没有没有写入到索引文件里面，这样花费创世交易的时候，没有相应的索引，创世交易的UTXO就是非法的，所以没法花费</li>
</ol>


<h5>那么如何解决呢？有两个办法：</h5>

<ol>
<li>就是把创世区块写到区块索引里面</li>
<li>或者在检查交易合法性的时候，单独的加一个判断条件，判断UTXO是否出自创世区块</li>
</ol>


<h5>为什么迟迟没有修正：</h5>

<ol>
<li>每个办法都需要一次硬分叉</li>
<li>这需要全网节点都升级这个只影响创世块的50BTC，中本聪都不在乎，何苦为了50BTC就全网升级呢？</li>
<li>最后，创世块见证着历史，其实不能花费挺好的。</li>
</ol>


<h4>coinbase</h4>

<p>紧接着<code>block header</code>的，就是当前block的所有交易，其中第一笔交易就是coinbase 交易。关于coinbase交易，我们曾经在之前的文章中详细介绍过，这里就增加说明一点，coinbase交易的输出包括了所有交易的手续费，将来比特币网络的额定产出越来越少的时候，矿工们还是可以通过打包交易费用获利，来维持比特币网络的正常运转。</p>

<p>就当前的情况来看，再来一次减半，基本上交易费用和新区快产出就对等了。</p>

<h4>隔离见证</h4>

<p>实施了隔离见证之后，对于<code>block header</code>和coinbase都有一些变化，我们以后会详细再提。</p>

<h2>区块链接成为区块链</h2>

<p>比特币的全节点在本地保存了区块链从创世区块起的完整副本。随着新的区块的产生，该区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。</p>

<p>最后所有区块组成了blockchain:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg1.jpg" alt="img" /></p>

<h2>Merkle树</h2>

<p>区块链的数据是永不删除的，随着交易量越来越大，整个区块数据量也越来越大，那么问题又来了，不可能每个节点都下载数百GB的数据来来验证一笔交易的合法性，而作为一个分布式系统，我们是不能信赖任何中心节点的！我们怎样在一个手机钱包软件里面验证一笔交易呢？</p>

<p>答案是一个绝妙的数据结构: <code>Merkle</code>；</p>

<p>将比特币系统的交易和区块用Merkle树组织起来，会获得一项不可思议的能力，即使整个区块达到数百GB，每个轻节点只需要接收少许数据(MB级别)，就可以完成交易的合法性校验，并且无需任何中心化的节点。</p>

<p>初次接触到Merlke树算法的时候，我觉得这简直是为比特币系统量身定做的，我觉得这是整个系统里面最优美、最简单、最不可思议的算法。</p>

<p>这是怎么做到的呢？呵呵，偶很懒，自己去翻参考资料吧。</p>

<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></p>

<h4>SPV(简单支付)</h4>

<p>Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。</p>

<p>例如，一个SPV节点想知道它钱包中某个比特币地址即将到达的支付。该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkleblock消息的形式发送该区块。Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联，交易与区块、区块和区块链，就可以证明交易存在于区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千多倍。</p>

<h2>小结</h2>

<p>blockchain作为比特币的基本技术支撑之一，毫无疑问是一项前无古人的真正创新；这项技术怎么高估都不过分，我认为数十年后，可能会作为一种工业革命的基础技术跟蒸汽机、电力应用、信息技术相提并论；</p>

<p>比特币的链为我们提供了两项能力:</p>

<ol>
<li>不可伪造的电子时间戳证明；任何依赖于有序时间的处理程序(博彩、公证、法律等等)都可以上链</li>
<li>提供了一个构造发行自定义资产(证券、股票)的基础手段，货币只是一个基本应用，任何人都可以以比特币主链为基础，构造一条侧链，并在其之上实现自己的资产发行、定价、转移功能</li>
</ol>


<p>在未来的世界里，关于这方面的应用和创新简直层出不穷，例如预言机的实现，微支付通道，原子交换等等；我所读过的最好的关于blockchain的一些设想是这个：</p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>

<p>好啦，为了能在未来的世界里面不落人后，我们要继续学习，等我们之后的文章吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一种提高比特币私钥碰撞机率的思路]]></title>
    <link href="https://happy123.me/blog/2019/01/18/%5B%3F%5D-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu/"/>
    <updated>2019-01-18T10:41:40+08:00</updated>
    <id>https://happy123.me/blog/2019/01/18/[?]-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu</id>
    <content type="html"><![CDATA[<p>之前的文章里面我们提到了一个名为<a href="https://lbc.cryptoguru.org">LBC</a>的项目；它采用了遍历所有比特币私钥，bloomfilter所有未花费的币的地址来碰撞比特币私钥。</p>

<p>这个项目本身详尽<a href="https://lbc.cryptoguru.org/stats">计算了这种碰撞成功的几率</a>，目前碰撞空间大概在 2<sup>136</sup> 级别。</p>

<p>目前在一台最顶级的AWS GPU计算节点上面的碰撞效率是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AWS p2.8xlarge   32 vCores Xeon v4, 8x K80 GPUs (50% each)   ~80-88M/s</span></code></pre></td></tr></table></div></figure>


<p>每秒钟大概碰撞8000w次；目前LBC这个项目最顶峰的时候，算力到了1G的级别，这样计算下来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2^136 / 2^30 = 2 ^106</span></code></pre></td></tr></table></div></figure>


<p>2<sup>106</sup> 级别的碰撞效率还是遥遥无期啊；</p>

<!-- more -->


<p>如果通读我们之前的文章就知道，比特币地址的生成，主要花费在ECDSA、SHA256, RIPEMD 这三个算法的操作之上，但其实用GPU计算，这三个步骤花费的时间是很少的，在整个碰撞过程中，其实大部分时间是耗费在bloomfilter上面的；</p>

<p>而bloomfilter的原理，采用的是多级HASHMAP，常理来看，这已经是判断一个元素是否存在某集合的极限效率了；</p>

<p>但是有一点我们不要忘记，比特币的地址采用base58编码，他的地址空间是有规律的，简单来说，就是所有比特币地址的前缀分布，是有规律可循的，他应该在base58的编码范围内成正态分布；而bloomfilter的HASHMAP是没有这种条件优化的，所以说bloomfilter的算法我们可以再改进一下，提升效率。</p>

<p>我分析了截至2018-12以前的所有比特币地址，简便起见，提取了所有的P2PKH地址(共
377059211个地址)，取其前4个字符地址前缀；执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort 4prefix.addr|uniq -c|sort -nr</span></code></pre></td></tr></table></div></figure>


<p>得到了所有地址前缀的分布列表，差不多是个正态分布。</p>

<p>列举一下最常用的地址前缀TOP10:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  23600 1bit
</span><span class='line'>  23086 1btc
</span><span class='line'>  21895 13vs
</span><span class='line'>  21329 1gbx
</span><span class='line'>  21267 1gbt
</span><span class='line'>  21267 1gba
</span><span class='line'>  21210 1gbb
</span><span class='line'>  21206 1gbf
</span><span class='line'>  21196 1gbu
</span><span class='line'>  21189 1gbr</span></code></pre></td></tr></table></div></figure>


<p>最常见的是1bit和1btc这两个前缀，各比第三名多出了10000个左右，这多出来20000个地址应该是Geek们自己生成的虚荣地址。</p>

<p>所有的比特币P2PKH地址，4字母前缀共有42877种组合。</p>

<p>好了，这就是我们可以优化的地方，把bloomfilter的第一级HASHMAP，采用这些前缀组合先来一把过滤，再去执行常规的Bloomfilter，碰撞效率会再提高一个数量级。</p>

<p>我在自己机器上实验了一下，在GTX750Ti 2G显卡上面，最终效率可以达到 10M/s。</p>

<p>瓶颈现在又变成了genaddress环节，我估计在一块RX480卡上面，可以达到和AWS顶配GPU一样的效率；</p>

<p>不过，效率提升十倍，也不过是 2<sup>100</sup> 的碰撞范围，还是遥遥无期啊。</p>

<h4>更深入的分析</h4>

<p>早期在bitcointalk.org论坛上，Laszlo Hanyecz曾经有过一个想法，就是随着硬件性能的发展，最终碰撞比特币私钥的收益会不会超过挖矿的收益？</p>

<p>中本聪当时的回答是，要达到这个碰撞算力很远很远。</p>

<p>我们来仔细分析一下：</p>

<p>比特币的地址生成是很容易硬件ASIC化的，如果用这种前缀过滤法，也不需要多少内存，所以可以近似认为：如果硬件化，比特币私钥碰撞的效率和挖矿效率是差不多的。</p>

<p>目前比特币全网算力在40EH左右，就是2<sup>62</sup>，这已经是相当于400w台蚂蚁S9的机器同时24X365 运行了；消耗的电力估计已经超过了上海市的居民用电，比特币矿机的能源消耗，完全可以说是抵得上一个小型国家的能源消耗了。</p>

<p>如果私钥碰撞达到2<sup>62</sup>级别，那么毛估估，碰撞几率就能减小到 &frac12;<sup>60</sup> 级别了；</p>

<p>但是这个概率还是太低了。</p>

<p>而且另外一个无法预测的情况就是，将来人们的安全意识加强，一般一个地址只要用过就会丢弃掉，所以最终bloomfilter的条目变化会非常频繁，还要考虑一个数量级的损耗。</p>

<p>目前测算，随着手续费用的提高，即使多次减半，将来挖矿的收益估计很长期稳定1-10btc/block级别，在如果将来以1年时间碰撞一个私钥的概率期望测算的话，一年大概是2<sup>25</sup> 秒，这样碰撞效率至少要提高到 2<sup>95</sup> 级别，才能达到<code>破解私钥得利</code>><code>挖矿得利</code> 的效果；</p>

<p>算力提高到2<sup>95</sup>，不管用什么技术，即使是量子计算，也很难想象能到这个量级啊；</p>

<p>而且，即使到了这一天，把RIPEMD替换成一种碰撞空间更大的算法就OK了。</p>

<p>这样看来，bitcoin的安全性还是无懈可击。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wsl Best Practice]]></title>
    <link href="https://happy123.me/blog/2019/01/16/wsl-best-practice/"/>
    <updated>2019-01-16T14:13:58+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/wsl-best-practice</id>
    <content type="html"><![CDATA[<p>WSL用了一年，感觉还不错。尤其是在我的机器上pypy3.5版本的<code>SHA512 pbkdf</code>计算性能竟然超越了原生Linux和Windows。成为Python运行效率最高的平台，实在是匪夷所思的事情。</p>

<p>WSL最让我满意的，是命令行里面可以结合Windows和Linux的命令行工具来管道处理，这个实在是太赞了。纯粹计算类的程序，Windows上面有很多现成的命令行工具，现在终于能:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ping.exe -t xxx.xxx.xxx.xxx|grep xxxx|echo -I xxx ~~~</span></code></pre></td></tr></table></div></figure>


<p>这样来搞了，事实上，我自己写了很多Python脚本来处理Powershell自带的很多工具输出的内容，还有不少GPU运算程序大多数跑在Windows上面，能直接重定向到Linux上面实在太好了。</p>

<p>另外，WSL网络协议栈和Windows是共享的，倒是直接省了一个事，我直接把http_proxy配置成本地的shadowsock服务就很安逸的翻墙了；方便。</p>

<p>最后，就等着磁盘性能的改善了。</p>

<p>下面记一下常用的坑：</p>

<ul>
<li>如果开机之后插拔一个移动硬盘，需要手工在WSL中执行重新挂载命令：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo umount /mnt/g && sudo mount -t drvfs "G:" /mnt/g</span></code></pre></td></tr></table></div></figure>


<ul>
<li>WSL跟最新2019版本的卡巴斯基冲突，卡巴斯基默认会过滤所有HTTP流量</li>
</ul>


<p>目前无解；要么禁用卡巴斯基的HTTP过滤功能，要么回退2018版本</p>

<p>最后，多个版本实验之后，锁定Win10 1709我也能连续3个月不关机了，稳定性可喜可贺。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alias Rm to Mv]]></title>
    <link href="https://happy123.me/blog/2019/01/16/alias-rm-to-mv/"/>
    <updated>2019-01-16T14:00:18+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/alias-rm-to-mv</id>
    <content type="html"><![CDATA[<p>之前一直简单的用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rm='mv -f $@ ~/.trash'</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>取代rm命令。</p>

<p>这样用着有个不便的地方，就是有时候做个脚本命令，带个<code>;</code>的时候会解析有问题。今天突然发现一个用函数来替代的好办法，记一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rm='move1(){ /bin/mv -f $@ ~/.trash/; };move1 $@'</span></code></pre></td></tr></table></div></figure>


<p>参考资料：</p>

<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7385133.html">https://www.cnblogs.com/f-ck-need-u/p/7385133.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-7]]></title>
    <link href="https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7/"/>
    <updated>2019-01-06T17:34:55+08:00</updated>
    <id>https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7</id>
    <content type="html"><![CDATA[<p>比特币的交易网络最为人诟病的一点便是交易性能：全网每秒 7 笔左右的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认将导致约 1 个小时的最终确认时间。</p>

<p>为了提升性能，社区提出了闪电网络等创新的设计。</p>

<p>闪电网络的主要思路十分简单——将大量交易放到比特币区块链之外进行，只把关键环节放到链上进行确认。该设计最早于 2015 年 2 月在论文《The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments》中提出。</p>

<p>闪电网络需要单独部署，没有包含在bitcoin core实现里面。闪电网络是一个开放的协议，任何人都能自由的实现它，目前比较流行的版本有:</p>

<p><a href="https://github.com/lightningnetwork/">https://github.com/lightningnetwork/</a></p>

<p><a href="https://github.com/mit-dci/lit">https://github.com/mit-dci/lit</a></p>

<p><a href="https://github.com/ElementsProject/lightning">https://github.com/ElementsProject/lightning</a></p>

<!-- more -->


<p>让我们先自己思考一下，A和B之间频繁有多次交易，最自然，最直接的建立链下交易的办法是什么？</p>

<p>一个假想的场景，就是在没有网络，没有通信的环境中，两个人面对面各自手持私钥签名，证明自己的账户上有多少资金，然后签订一份合同，每次交易记录签名之后不广播，只写在合同上面，等到大批交易做完之后，再统一轧账清算；如果中间有人耍赖，就拿着写满签名交易的合同去法院仲裁。这个过程中间他们唯一的信息渠道就是有人单向传真给他们每笔交易的资金变动；</p>

<p>当然这是一种异想天开，而且依赖于中心化的法院裁决的方式，在现实世界中是行不通的；但是我们可以将这个方案作为起点，代入到电子化的解决方案里面：</p>

<ol>
<li>首先，两个人面对面，一是为了通过验证签名检查账户资金，二是防止第三者窃听；映射到电子方案中，就是通过两个人建立一个加密的通信信道来传递信息</li>
<li>另外，两个人的每一笔交易打印到合同上，就是为了防止某一方作假诈骗，而且两个人面对面互相监督，就防止有一方私自广播对方的交易然后闪人，但是放到网络中，没有法官裁决的威慑，没有相互监督，怎么才能信任对方最终一定会根据所有的历史交易来清算呢？</li>
</ol>


<p>第一个问题的解决方案称之 HTLC（Hashed Timelock Contract），解决了支付通道(资金池)的问题；</p>

<p>第二个问题的解决方案称之为RSMC (Recoverable Sequence Maturity Contract)，解决了链下交易的确认问题。</p>

<h2>RSMC</h2>

<h4>概述</h4>

<p>Recoverable Sequence Maturity Contract，即“可撤销的顺序成熟度合约”。这个词很绕，其实主要原理很简单，类似资金池机制。</p>

<p>再想一下我们之前的问题，为什么A和B每次交易都要记在合同上，最后一把清算呢？既然是双方账户的加加减减，为什么不是每发生一笔新交易，立即对交易后产生资金分配结果共同进行确认，然后作废之前一笔交易呢？</p>

<p>Yes! 这样做之后，在双方的资金池通道中，不管之前双方进行了多少笔交易，永远只存在一笔清算交易，这笔交易就是当前的轧账结果，不管什么时候，直接广播这笔交易，对双方都是公平的。</p>

<p>那么，该如何防止一方做了一笔付款之后，没有广播，就抢先把资金池里面的自有资金提现呢？</p>

<ol>
<li>A和B各拿出1BTC放入了资金池通道中，这时候资金池里面共有2BTC</li>
<li>A和B发生了数笔交易之后，A与B的资金变为1.5:0.5BTC，这个时候通道中留着一笔清算交易没有广播，但是任何一方都可以直接广播把这个状态做实</li>
<li>这个时候A又向B发送了1BTC，但是在B广播清算交易之前，A要把资金全部提走，也就是1.5BTC；这样B就损失了1BTC，怎么预防这种情况呢？</li>
</ol>


<p>解决方法就是提现一定要双方都签名承认才可以：任何一方在任何时候都可以提出提现，提现时需要提供一个双方都签名过的资金分配方案（意味着肯定是某次交易后的结果，被双方确认过，但未必是最新的结果）。在上面的那种情况下，B是无论如何也不会同意的。这就阻止了A的提现。</p>

<p>另外，为了威慑A这种行为，在一定时间内，如果另外一方拿出证明表明这个方案其实之前被作废了（非最新的交易结果），则资金罚没给质疑方；否则按照提出方的结果进行分配。罚没机制可以确保了没人会故意拿一个旧的交易结果来提现。</p>

<p>最后，即使双方都确认了某次提现，首先提出提现一方的资金到账时间要晚于对方，这就鼓励大家尽量都在链外完成交易。通过RSMC，可以实现大量中间交易发生在链外。</p>

<p>那么如果有一方耍小心眼，就是损人不利己，死活不签名来阻止另一方的提现呢？也没关系，在这个模型中，有了惩罚机制，提现的一方可以直接拿最后一笔清算交易的状态来广播(这笔交易是双方都签名承认的)，代价就是晚一点得到资金而已。</p>

<ul>
<li>整个过程里面，最重要的就是惩罚机制的实现，我如何认定跟我交易的对方也遵从这个惩罚机制呢？这是用多重签名来保证的。因为多重签名实际上是个合约，所以这个方案被命名为RSMC。</li>
</ul>


<h4>让我们详细的描述这个过程</h4>

<p>内容引自： <a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<h4>RSMC 创建</h4>

<p>Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入通道中，便于业务往来。解释一下下方RSMC交易的结构，左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg1.jpg" alt="img" /></p>

<ol>
<li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时， Funding    Tx未签名，更不广播。</li>
<li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li>
<li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li>
<li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li>
<li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li>
<li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。上述过程以及结构图的描述，就是创建RSMC的全部过程。</li>
</ol>


<p>C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p>

<p>这个过程的精巧之处，就在于构造了一个被动机制，将自己的资金放入到一个嵌套多重签名的地址里面，任何一方想要提现，一定要先归还另一个人的资金。并且这个机制构造完成之后，我们才真正在支付通道中充值。</p>

<h4>交易更新</h4>

<p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。</p>

<p>于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg2.jpg" alt="img" /></p>

<p>交易更新时的交易结构此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？</p>

<p>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2  的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg3.jpg" alt="img" /></p>

<p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。</p>

<p>若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。</p>

<p>Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。</p>

<p>引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p>

<h4>交易关闭</h4>

<p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p>

<h2>HTLC 中转交易</h2>

<p>RSMC要求交易的双方一定要都缴纳一笔保证金，我每天都跟不同的商家打交道，不能跟每个人都去建立RSMC，存入一笔资金吧。而且通道的建立和关闭都是需要链上广播的，如果要建立多个支付通道，交易费用也不容小觑，这有点本末倒置了吧。</p>

<p>为了解决这个问题，闪电网络又引入了HTLC ( Hashed Timelock Contract )，中文意思是“哈希的带时钟的合约”。这个其实就是限时转账。理解起来也很简单，通过智能合约，双方约定转账方先冻结一笔钱，并提供一个哈希值，如果在一定时间内有人能提出一个字符串，使得它哈希后的值跟已知值匹配（实际上意味着转账方授权了接收方来提现），则这笔钱转给接收方。</p>

<p>推广一步，甲想转账给丙，丙先发给甲一个哈希值。甲可以先跟乙签订一个合同，如果你在一定时间内能告诉我一个暗语，我就给你多少钱。乙于是跑去跟丙签订一个合同，如果你告诉我那个暗语，我就给你多少钱。丙于是告诉乙暗语，拿到乙的钱，乙又从甲拿到钱。最终达到结果是甲转账给丙。这样甲和丙之间似乎构成了一条完整的虚拟的“支付通道”。而乙就做了中转节点。</p>

<p>Alice想要支付0.5BTC给Bob，但她并没有一个渠道来和他进行交易。幸运的是，她和Charlie有一个交易渠道，而Charlie正好和Bob有一个交易渠道。这样Alice就能借助Charlie的交易渠道，通过哈希时间锁定合约（HTLC）来和Bob进行交易了。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg4.png" alt="img" /></p>

<p>为了完成这次交易，Alice就会给Bob发短信说：“嘿！我要给你付笔款。”这时Bob自己将收到一个随机数字（R），接着Bob便会回一个被哈希的数字（H）（你可以认为被哈希的数字R是随机数字的一种加密形式）给Alice。</p>

<p>然后Alice的钱包紧接着就会联系Charlie说：“嘿，Charlie。如果你给我生成（H）的未加密值（R），那么我就同意更新我们渠道的支付分配，这样你就可以得到的就会比0.5BTC多一点，我得的比0.5少一点。”</p>

<p>尽管Charlie并不知道R，但他也会同意。之后Charlie便会去找Bob说：“嘿，Bob。如果你给我那个能生成H的未加密的值R，我将同意更新我们渠道的支付分配，这样你就可以得到的会比0.5BTC多一点，我得到的比0.5少一点。”因为R就是从Bob这里生成的，所以他肯定知道。接着他马上将R告诉Charlie，并更新了其渠道的支付分配。然后Charlie将R告诉给了Alice之后也更新他们的渠道，最后交易完成，Alice以脱链的形式付给Bob0.5BTC。</p>

<h4>扩展</h4>

<p>HTLC给了任意两个点之间，通过路由转发达到支付的目标。这样用户无需打开过多的通道，只需要存入一笔资金跟一个比较大的中介机构建立通道就好了。之后所有的支付行为，我们都期望这个中介机构能自动路由到商家。</p>

<p>在闪电网络的极大繁荣时间，可以看作是现在互联网模型的克隆。</p>

<h2>优缺点大辩论</h2>

<h4>关于支付通道建立</h4>

<ul>
<li><p>乐观： 建立的闪电网络渠道可以与现有钱包和系统内置无缝过程。当收到和支付比特币时，资金需要存到某个地方。资金可以在收到时立即进入闪电网络的通道中，因此建立该通道不需要额外的步骤或成本。</p></li>
<li><p>悲观：为了建立闪电网络渠道，用户必须手动创建一个新的昂贵的链上交易。</p></li>
</ul>


<h4>关于通道关闭</h4>

<ul>
<li><p>乐观:可能不需要关闭渠道，用户可以无限期地或长时间地将钱存放在通道中。</p></li>
<li><p>悲观:一旦支付完成，就需要透过手动创建昂贵的在线交易来关闭通道。</p></li>
</ul>


<h4>关于网络路由</h4>

<ul>
<li><p>乐观:现有的P2P网络已经需要网络拓扑和消息传递，节点通常具有八个连接。闪电网络拓扑结构只是其中的一个延伸。路由不是一个重要的问题，因为即使在大规模网络中，用户之间路径的平均步数也是很小的。即使路由有问题，也可以简单地在链上进行支付，而用户甚至感觉不到两者的差异。少数大型渠道运营商可以防止路由发生任何问题。</p></li>
<li><p>悲观:路由可能是一个较大的问题，因为找到各方之间最短的路径对于演算法来说是个难题。如果找不到清晰的路线，则用户和商户将不得不通过繁琐的过程来手动改变并选择在链上交易的过程。</p></li>
</ul>


<h4>关于支付通道的中心化</h4>

<ul>
<li><p>乐观:有些经济奖励措施是用来对抗这种中心化的，任何人都可以设立节点，因为进入门槛低。除此之外，还可以通过收取较低的费用来削减其他节点对网络的影响力。即使网络集中在几个大型交易枢纽上，闪电网络仍然提供了一个有用而有趣的系统。比特币已经有一些像 Coinbase 这样的大机构来管理大量的资金。在闪电网络下，这些机构没有资金保管权，只是用来传递用于支付的数据。</p></li>
<li><p>悲观:   网络将集中围绕在几个大型交易枢纽，因为这是最有效的模式。这种集中化增加了系统性渠道失效的风险，即少数大渠道出现故障，导致支付渠道同时大量外流，造成连锁拥堵，使部分资金在到期前无法退出渠道。</p></li>
</ul>


<h4>关于流动性</h4>

<ul>
<li><p>乐观:将有机制激励用户运行闪电网络节点，并提供流动性，以收取费用，网络便可以用于小额支付，支付额度可以远小于最大渠道容量，确保有足够的流动性。</p></li>
<li><p>悲观:支付渠道流动性不足，因此其规模将受到限制。任何较具规模的支付几乎可以立即消耗掉整个渠道的流动性，瘫痪闪电网络的支付渠道。</p></li>
</ul>


<h4>关于要求收款人在收款时在线</h4>

<ul>
<li><p>乐观:虽然收件人必须在线才能收到付款，但这与大多数在线支付系统没有显着不同，因为如果收款人不在线上，他们不知道或无法验证收款。直接收款的用户或设备也不需要存储私钥。例如，商店 PoS 终端或加密 ATM 机可以在收款前通过互联网从公司的总部确认签署回收交易，因为无论如何双方在收款时都需要沟通。</p></li>
<li><p>悲观:通过链上交易，发件人需要的是收款地址，而收件人不需要在线。与此相反，收款人在接收付款之前需要签署收回交易。这是一个重大的限制，意味着收件人必须将私钥暴露在热钱包中。这使得闪电网络在下列许多情况下便的不切实际，例如在 ATM 上，在商店 PoS 系统上进行大额支付，或者支付给那些难以连上互联网的收款人。</p></li>
</ul>


<h4>闪电网络较大的安全风险</h4>

<ul>
<li><p>在收款时必须在线的要求：如上所述，在收款之前，收款人需要签署收回交易，以便汇款人知道如果渠道不正常的关闭或拒绝签署的情况发生，他们可以收回资金。因此，收钱需要一个热钱包，这意味着如果发生安全事件，私钥可能被暴露。</p></li>
<li><p>监督渠道的要求：可能需要闪电网络参与者或瞭望塔主动监督网络渠道。这可能给用户或瞭望塔带来负担，并且与存储在区块链上的比特币相比，潜在地降低了渠道内的资金安全性。未能适当监督渠道或由在线网络造成的拥塞可能增加用户错过了回收交易截止日期的风险。</p></li>
<li><p>矿工可以审查渠道关闭交易：作为不属于交易双方的矿工可以通过审查渠道关闭交易，一旦他们具有 51％ 的哈希率便可能有能力从闪电网络用户窃取资金。虽然这种类型的攻击就算在没有应用闪电网络的情况下已经具有破坏性的后果，但闪电网络的应用可能会提供一个更大的攻击面。</p></li>
</ul>


<h2>小结</h2>

<p>RSMC 保障了两个人之间的直接交易可以在链下完成，HTLC保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。闪电网络整合这两种机制，就可以实现任意两个人之间的交易都在链下完成了。</p>

<p>在整个交易中，智能合约起到了中介的重要角色，而区块链网络则确保最终的交易结果被确认。</p>

<p>闪电网络似乎可以在整体网络交易规模上带来重大改进。从而导致交易速度提高和交易费用大幅下降，而整体又不会影响核心基础安全性。然而，至关重要的是，闪电网络自身在安全性上的不足可能使闪电网络不适合用于大额支付（或者至少用其进行大额支付的行为可能是不负责任的）。投机和投资等行为是需要大额支付的，而这些行为目前看来是加密货币领域的主要的交易推动力，相比之下，零售小额支付的数量相对较小。</p>

<p>最后附赠一个技术讲解比较好但是旗帜鲜明反对闪电网络的视频教程：</p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p>当然再为闪电网络声援一下，闪电网络的思想发源于微支付通道，Satoshi实际上早期对微支付通道已经有了基本的设想：</p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p>孰对孰错，是非只能自己判断。</p>

<h2>架设一个闪电网络节点，完成一笔交易</h2>

<p>光说不练假把式，增加一把实战</p>

<h4>运行一个bitcoind全节点</h4>

<p>我们选用bitcoind运行一个testnet模式的全节点，配置文件如下:</p>

<p>bitcoin.conf:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=192.168.2.1/16
</span><span class='line'>rpcport=8332
</span><span class='line'>test.rpcport=18332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>testnet=1
</span><span class='line'>
</span><span class='line'># for lnd
</span><span class='line'>server=1
</span><span class='line'>#daemon=1
</span><span class='line'>zmqpubrawblock=tcp://192.168.2.1:28332
</span><span class='line'>zmqpubrawtx=tcp://192.168.2.1:28333</span></code></pre></td></tr></table></div></figure>


<p>启动bitcoind:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoind --conf=/opt/blockdata/testnet3/bitcoin.conf --datadir=/opt//blockdata/ --deprecatedrpc=signrawtransaction &gt;&gt; test.log 2&gt;&1</span></code></pre></td></tr></table></div></figure>


<h4>建立闪电网络节点</h4>

<p>我们采用lightningnetwork这个Go版本的实现(全程需要翻墙)：</p>

<p><a href="https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md">https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md</a></p>

<ul>
<li>安装go环境</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install golang-1.11-go</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置环境变量</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export GOPATH=~/gocode
</span><span class='line'>export PATH=$PATH:$GOPATH/bin</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Clone &amp;&amp; 编译</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>go get -d github.com/lightningnetwork/lnd
</span><span class='line'>cd $GOPATH/src/github.com/lightningnetwork/lnd
</span><span class='line'>make && make install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>启动lnd</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxx --bitcoind.rpcpass=xxxx --bitcoind.zmqpubrawblock=tcp://192.168.2.1:28332 --bitcoind.zmqpubrawtx=tcp://192.168.2.1:28333</span></code></pre></td></tr></table></div></figure>


<h4>建立一个新钱包，充值</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet create</span></code></pre></td></tr></table></div></figure>


<p>之后按照提示一路回车下去，建立一个新钱包，然后执行下列命令得到一个新地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet newaddress np2wkh</span></code></pre></td></tr></table></div></figure>


<ul>
<li>去下面这几个网址列表领取一些免费的TestNet Bitcoin:</li>
</ul>


<p><a href="https://lnroute.com/testnet-faucets/">https://lnroute.com/testnet-faucets/</a></p>

<ul>
<li>执行下面命令看看余额</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet walletbalance</span></code></pre></td></tr></table></div></figure>


<h4>连接通道</h4>

<ul>
<li>首先执行下面命令确认我们的节点的同步状态</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet getinfo</span></code></pre></td></tr></table></div></figure>


<p>确认<code>synced_to_chain</code>字段已经变成true，代表区块头同步完毕。</p>

<ul>
<li>然后去下面的网址找一个可用的闪电节点:</li>
</ul>


<p><a href="https://explorer.acinq.co/">https://explorer.acinq.co/</a></p>

<ul>
<li>我们选一个channel数比较多的然后连接这个节点：cosmicApotheosis</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet connect 03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028@138.229.205.237:9735</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下一步建立通道，这里我们存0.1btc到通道里:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet openchannel --node_key=03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028 --local_amt=10000000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看节点连接状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listpeers</span></code></pre></td></tr></table></div></figure>


<p>这里我们还需要等待3次确认，通道才能建立成功，记住刚才建立完的transaction id，去网上查询等待3次确认。</p>

<ul>
<li>检查通道的状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listchannels</span></code></pre></td></tr></table></div></figure>


<p>当通道打开的时候，就可以用闪电网络支付啦！</p>

<h4>支付</h4>

<ul>
<li>我们去<a href="https://testnet.satoshis.place/">satoshi.place</a> 随便来几笔涂鸦，得到一个支付地址:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在命令行里支付：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli  --network=testnet sendpayment --pay_req  lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d</span></code></pre></td></tr></table></div></figure>


<p>顺利的话，瞬间支付成功。</p>

<h4>小结</h4>

<p>看起来是不是很麻烦，相信我，实际做一遍的话坑也不少。</p>

<p>目前有小部分钱包实现了闪电网络支付；但是拍脑袋想想就知道钱包里面无法包含闪电节点的全部功能：因为收款需要时时刻刻的监控，所以不可避免的需要一个类似于<code>瞭望塔</code>式的服务，最合理的办法就是将这个功能的实现剥离出来，单独部署到一台服务器上。</p>

<p>electrum轻钱包在<a href="https://github.com/spesmilo/electrum/issues/2557">这里</a>讨论了典型的实现方式。</p>

<p>可以预见到将来，实现闪电网络的钱包除了要自建全节点之外，还需要建立稳定的闪电网络节点实现类似<code>瞭望塔</code>的功能，当闪电网络极大繁荣的时候，钱包服务商实际上会占据及其有利的地位，闪电网络的发展，需要比特币钱包软件的进化，这是一个非常大的商机。</p>

<h2>参考资料:</h2>

<p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html">https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html</a></p>

<p><a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<p><a href="https://www.8btc.com/article/92887">https://www.8btc.com/article/92887</a></p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p><a href="https://blog.bitmex.com/zh_cn-the-lightning-network/">https://blog.bitmex.com/zh_cn-the-lightning-network/</a></p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p><a href="https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/">https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy 10th Birthday Bitcoin]]></title>
    <link href="https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin/"/>
    <updated>2019-01-03T21:12:12+08:00</updated>
    <id>https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin</id>
    <content type="html"><![CDATA[<p>自 <a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a>在2009-01-03 诞生以来，bitcoin 已经运行十年了。从一个个人项目，成长为世界话题，一段不可思议的旅程。</p>

<p>有人在&lt;纽约时报>上面为其庆生：</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/">https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/</a></p>

<p>我在2013年初次读到白皮书的时候申请了一个域名:</p>

<p><a href="http://20090103.com/">http://20090103.com/</a></p>

<p>出于好玩的心态一直维护着，看看下一个十年会是怎样。</p>

<h4>Hi, Happy 10th birthday bitcoin!</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-6]]></title>
    <link href="https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6/"/>
    <updated>2019-01-01T20:10:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6</id>
    <content type="html"><![CDATA[<p>好啦，这篇文章中，我们要来探讨大名鼎鼎的Segwit(Segregated Witness)。</p>

<p>这个词一说起来就头疼啊，他牵扯到旷日持久的扩容大战，无穷尽的争论以及分裂。我们的立场就是不去站队任何组织，单纯从技术的角度去理解这个东西。</p>

<!-- more -->


<p>首先澄清一个误解，其实Segwit跟扩容没关系，它最初提出来，只是为了解决交易延展性的问题，顺便有一点扩容效果，但这个扩容效果只是附带的；</p>

<p>另外，其实Segwit的技术原理非常简单，但是要考虑兼容性的问题，导致从设计到实施都有点复杂。</p>

<h2>缘起</h2>

<p>嗯哼，又要涉及到大量的数学知识；先声明下，我至今还没有从数学原理上完全理解椭圆曲线算法，所以下面讲的都是码农派的API理解&mdash;搞明白接口，但里面的细节还需要更多时间去探究。</p>

<p>上一篇文章我们提到，当交易被签名时，签名并没有覆盖交易中所有的数据 (因为签名是不可能对自身签名的)，而交易中所有的数据又会被用来生成交易的哈希值来作为该交易的唯一标示。</p>

<p>如果签名向常见的HASH算法一样，碰撞机率极小的话也没有问题；但是椭圆曲线算法存在一个看起来比较弱的特性：</p>

<blockquote><p>ECDSA算法生成两个大整数r和s并组合起来作为签名, 可以用来验证交易。而r和BN-s 也同样可以作为签名来验证交易(BN＝0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141). 这样，攻击者拿到一个交易，将其中inputSig 的r, s 提取出来， 使用 r, BN-s 生成新的inputSig, 然后组成新的交易，拥有同样的input和output，但是不同的TXID. 攻击者能在不掌握私钥的情况下几乎无成本地成功地生成了合法的交易。</p></blockquote>

<p>让我们再用码农能理解的语言描述一遍:</p>

<ol>
<li>前面的交易中，scriptSig脚本可以提取出sig签名</li>
<li>sig是由两个值组成的，Sig=(R,S)</li>
<li>sig是嵌入在scriptSig中，用一种名为<code>DER-encoded ASN.1 octet representation</code>的编码方式编码的。OpenSSL并没有强制要求每个签名编码结果只能有一个值。</li>
<li>对于每一个 ECDSA <code>signature(R,S)</code>，还存在相同消息的另外一个有效签名: <code>signature(R,-S(mod N))</code></li>
<li>一个恶意攻击者得到Sig之后，可以手工构造另外一个<code>signature(R,-S(mod N))</code>嵌入到scriptSig中，这和之前的scriptSig不一样，所以TX ID也会发生变化</li>
<li>这笔新的交易输入输出跟原来的交易完全一样，也是合法的，但是TX ID不同了。</li>
</ol>


<h4>危害</h4>

<ol>
<li>Alice通过在线钱包给Bob发送了一笔交易，并把TXID发送给Bob说，看我给你发了多少比特币</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>Bob 通过Alice发来的TXID搜索了以下，并没有发现这笔交易</li>
<li>Bob说，Alice是个骗子</li>
</ol>


<h4>对于交易所的威胁</h4>

<ol>
<li>黑客向交易所发起来一笔资金提现</li>
<li>交易所自动处理，广播了交易，并发送给黑客TX ID</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>黑客对交易所说，我没有收到资金，那笔交易不存在</li>
<li>交易所验证了下，因为原来得交易已经被黑客替换掉了，所以原始交易果然不存在了</li>
<li>交易所只能又构造了一笔交易再次广播</li>
<li>黑客最后得到了两笔资金</li>
<li>这种情况下的解决方法是，遇到交易无法确认就停止，报错误并等待手动处理，或者，我们可以自己生成一个延展性交易，然后获取新的TXID,查找是否发送成功。能生成的TXID数量有多少呢？一共有exp(2, input数量)个，因为每个input都有改签名或者不改两种可能， 通常不是一个大数目。</li>
<li>但是这不能阻挡脚本小子的恶意攻击，他们通常会<code>损人不利己</code>的构造大笔延展性交易来攻击网络</li>
</ol>


<h2>讨论</h2>

<p>社区为了解决这个问题进行了大量的讨论：以下是一些材料和社区进行的努力：</p>

<h4>BIP0062</h4>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki</a></p>

<h4>BIP66</h4>

<p>在 363742 区块高度处，BIP66 软分叉强制区块链中所有新交易遵循 DER-encoded ASN.1 标准。仍然需要进一步的努力来关闭 DER 签名其它可能的延展性问题。
签名仍然是可以被拥有相应私钥的人改变的。</p>

<h2>解决</h2>

<p>2015年12月，Bitcoin Core开发团队的<a href="https://github.com/sipa">Pieter Wuille</a>提出了一个解决方案，称之为隔离见证 (Segregated Witness）。隔离见证由以下BIPs定义：</p>

<ol>
<li>BIP-141:隔离见证的主要定义</li>
<li>BIP-143:版本0见证程序的交易签名验证</li>
<li>BIP-144对等服务——新的网络消息和序列化格式</li>
<li>BIP-145隔离见证（对于矿工）的 getblocktemplate 升级</li>
</ol>


<p>最主要的描述在BIP141中:</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</a></p>

<h2>原理</h2>

<p>其实说白了原理非常简单，就是把vin的scriptSig挪到交易的末尾去。</p>

<p>每一个比特币交易，其实可以分为两部份。第一部份是说明结余的进出，第二部份是用来证明这个交易的合法性 (主要是签署)。第一部份可称为「交易状态」，第二部份就是所谓的「见证」(witness)。如果你只关心每个账户的结馀，其实交易状态资料就已经足够。只有部份人(主要是矿工)才有必要取得交易见证。</p>

<p>那么我们再来复习下一笔P2PKH交易的结构:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在整笔交易里面，输入输出信息以及金额大小属于第一部分，scriptSig属于第二部分。</p>

<p>只有矿工以及全节点需要进行scriptSig的验证；如果是普通的SPV轻钱包只需要验证所在区块的合法行就可以了。所以可以把scriptSig 部分挪到交易的尾部。这样带签名的原始数据就固定了，也不会有更改TX ID的机会。这部分数据称之为witness:</p>

<p>每个witness都由一个var_int打头，代表接下来的数据长度。如果某个输入没有见证，那么其witness就是一个0x00。</p>

<p>让我们代入各种例子，来看看Segwit是如何工作的？</p>

<h4>P2WPKH (Pay-to-Witness-Public-Key-Hash)</h4>

<p>首先回顾下P2PKH的锁定脚本(scriptPubKey)与解锁脚本(scriptSig)内容</p>

<ul>
<li>P2PKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    &lt;signature&gt; &lt;pubkey&gt;
</span><span class='line'>  scriptPubKey: OP_DUP OP_HASH160 &lt;20-byte hash of Pubkey&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再来看一下P2WPKH的脚本内容</p>

<ul>
<li>P2WPKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WPKH的锁定脚本较P2PKH要精简不少，第一位的数字0是版本号，有了版本号，未来脚本升级就能更容易的向前兼容。</p>

<p>P2WPKH的解锁脚本为空，而真正的解锁脚本内容被移到了原交易之外的witness部分。</p>

<h4>P2WSH(Pay-to-Witness-Script-Hash)</h4>

<ul>
<li>P2SH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</span></code></pre></td></tr></table></div></figure>


<ul>
<li>P2WSH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;32-byte hash of redeem script&gt;
</span><span class='line'>  witness:      0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WSH锁定脚本与P2WPKH类似，第一位是版本号，第二位是赎回脚本(Redeem script)的Hash值。</p>

<p>值得注意的是P2WSH锁定脚本中的Hash值是256位(32字节)的，是使用SHA256(pubkey)计算得到；而P2WPKH中的Hash值是160位(20字节)的，是使用RIPEMD160(SHA256(pubkey))计算得到的。</p>

<p>这样做的目的是让钱包可以根据Hash值的长度区分交易使用的是P2WPKH还是P2WSH。</p>

<p>在P2SH交易中常常会有多重签名验证，所以验证信息会占用更多空间，将这些信息移到原交易之外能更大程度的降低交易大小。</p>

<h4>锁定脚本版本号</h4>

<p>仔细观察之后，我们发现scriptSig以及scriptPubKey都以一个<code>0</code>开头；这代表着一个版本号。开发团队对于这个字段还有更远大的愿景，锁定脚本(Locking script)加上版本号，从而使脚本语言的升级更容易向前兼容，这种不造成太大影响的脚本语言修改方式将加快比特币的创新。</p>

<p>这个字段的精巧之处就在于，老节点看到这种交易也是合法的，虽然不能正确parse这种交易，但是当作为交易被打包到一个新区块，然后被支持segwit的矿工挖出来这个块，其它不支持segwit的老节点也是承认这个块的！</p>

<p>为什么呢？复习一下我们之前的文章，在一笔交易结构里面，这种交易是合法的 (是的，真相其实更复杂，但是我懒得详细介绍了，也许之后更闲的时候会仔细说说吧)！</p>

<p>虽然不能正确解析，但格式合法。有的人觉得这种技术忒精巧了，甚至精巧到了一种可怕的程度，是一种杂耍式的开发。很多人对于这种<code>啊哈</code>式的适配吓坏了。</p>

<p>现在Segwit已成事实，是非曲直只能留给你自己去判断了。</p>

<h4>交易标识符</h4>

<p>从上面看，其实实施Segwit之后，数据结构反而变得更清晰简单了。如果中本聪一开始就采用这样的结构，我相信也没有多少人会质疑。</p>

<p>但是已有的老的交易格式及相关系统已经运行了这么长时间，我们希望能尽可能的兼容以前的系统。最麻烦的适配就是原来传统交易的ID只有一个txid。现在见证数据挪到后面了，HASH的时候就不包括这一块数据了，怎么办？</p>

<p>传统交易的txid是以下序列 double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][txins][txouts][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>最后开发者们又引入了另外一个id，称之为wtxid；它是对整个交易double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][marker][flag][txins][txouts][witness][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>我们知道，每笔交易的txid是临时计算的，并不入块。但是整个Block是以所有交易的txid以Merkle Tree的形式组织的(这部分知识我们还没讲，需要到后面将bitcoin blockchain的时候提到)；现在多了一个wtxid，该怎么办呢？</p>

<p>解决办法又让人有点无语，就是将wtxid按照同样的组织方法算出Merkle Tree根节点，放到Block块中。</p>

<p>但是原有的Block格式都固定下来了，这个根节点放哪里呢？</p>

<p>还有coinbase的100个字节是可以利用的嘛，就是你了。</p>

<p>这<del>~，在有洁癖的人看来，完全又是一种码农修修补补式的FIX；相信众多技术人员这个时候已经开始内心无数吐槽了；但是真实世界就是这样无奈啊，又想要兼容性，又想要代码干净，又想要性能</del></p>

<p>你是太阳吗！？地球都绕着你转吗？！</p>

<p>拿着吧，这就不少了！！</p>

<p>最后附上这段龌龊的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::vector&lt;unsigned char&gt; GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, 
</span><span class='line'>                                                      const Consensus::Params& consensusParams)
</span><span class='line'>{
</span><span class='line'>    std::vector&lt;unsigned char&gt; commitment;
</span><span class='line'>    int commitpos = GetWitnessCommitmentIndex(block);  //从币基交易的输出中寻找承诺项，没找到就返回-1
</span><span class='line'>    std::vector&lt;unsigned char&gt; ret(32, 0x00);
</span><span class='line'>    if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {
</span><span class='line'>        if (commitpos == -1) {  //没有找到，就开始创建承诺，先生成见证版Merkle树根
</span><span class='line'>            uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);
</span><span class='line'>            CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());
</span><span class='line'>            CTxOut out;  //构建一个币基交易的输出
</span><span class='line'>            out.nValue = 0;  //金额是0
</span><span class='line'>            out.scriptPubKey.resize(38);  //公钥脚本长度38，前6个字节固定为0x6a24aa21a9ed
</span><span class='line'>            out.scriptPubKey[0] = OP_RETURN;  //0x6a
</span><span class='line'>            out.scriptPubKey[1] = 0x24;  //36，即后面的总长度
</span><span class='line'>            out.scriptPubKey[2] = 0xaa;  //0xaa21a9ed，固定不变的承诺头
</span><span class='line'>            out.scriptPubKey[3] = 0x21;
</span><span class='line'>            out.scriptPubKey[4] = 0xa9;
</span><span class='line'>            out.scriptPubKey[5] = 0xed;
</span><span class='line'>            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);  //插入见证版Merkle树根
</span><span class='line'>            commitment = std::vector&lt;unsigned char&gt;(out.scriptPubKey.begin(), out.scriptPubKey.end());
</span><span class='line'>            CMutableTransaction tx(*block.vtx[0]);
</span><span class='line'>            tx.vout.push_back(out);  //币基交易中添加这个输出
</span><span class='line'>            block.vtx[0] = MakeTransactionRef(std::move(tx));  //写回区块
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);  //更新区块其他结构
</span><span class='line'>    return commitment;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>隔离见证新的签名算法</h4>

<p>原来的签名验证需要大量的HASH操作；我们知道比特币是一个分布式系统，同时运行着上万个节点，如果一个操作每个节点都执行一遍，浪费的操作加起来很惊人的。</p>

<p>而隔离验证是个软分叉，为啥不能顺便再搞一点优化呢？毕竟软分叉的机会不多啊。于是开发者们顺便修改了四个签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG和CHECKMULTISIGVERIFY）的语义，改变了交易承诺散列的计算方式。</p>

<p>下面的说明引用自 Master Bitcoin:</p>

<blockquote><p>比特币交易中的签名应用于交易哈希，交易数据计算，锁定数据的特定部分，表明签名者对这些值的承诺。例如，在简单的SIGHASH_ALL类型签名中，承诺哈希包括所有的输入和输出。</p>

<p>不幸的是，计算承诺哈希的方式引入了验证签名的节点可能被迫执行大量哈希计算的可能性。具体而言，散列运算相对于交易中的签名操作的数量增加O（n<sup>2</sup>）。因此，攻击者可以通过大量的签名操作创建一个交易，导致整个比特币网络不得不执行数百或数千个哈希操作来验证交易。</p>

<p>Segwit代表了通过改变承诺散列计算方式来解决这个问题的机会。对于segwit版本0见证程序，使用BIP-143中规定的改进的承诺哈希算法进行签名验证。</p>

<p>新算法实现了两个重要目标。首先，散列操作的数量比签名操作的数量增加了一个更加渐进的O（n），减少了用过于复杂的交易创建拒绝服务攻击的机会。其次，承诺散列现在还包括作为承诺的一部分的每个输入的值（金额）。这意味着签名者可以提交特定的输入值，而不需要“获取”并检查输入引用的前一个交易。在离线设备（如硬件钱包）的情况下，这极大地简化了主机与硬件钱包之间的通信，消除了对以前的交易流进行验证的需要。硬件钱包可以接受不可信主机“输入”的输入值。由于签名是无效的，如果输入值不正确，硬件钱包在签名输入之前不需要验证该值。</p></blockquote>

<p>总之就是一句话，提升了验证签名的性能！！</p>

<h2>实施</h2>

<p>隔离见证（segwit）是一次比特币共识规则和网络协议的升级，其提议和实施将基于BIP-9，是一个软分叉。</p>

<p>2017年8月24日，区块高度481,824，隔离见证正式激活。</p>

<p>2015年提出，2017年激活；想想就知道这中间经历了多少曲折！！</p>

<p>隔离见证最终是全网95%的算力投票赞成才激活的，即使如此，网络中还是有一些不支持隔离见证的老节点在运行，同时，周边的钱包等软件也有不少还不支持隔离见证交易；此时的情况就比较复杂:</p>

<h4>付款人的客户端支持隔离见证，而收款人不支持</h4>

<p>如果收款人不支持隔离见证，那最终发布的地址将会是普通地址（P2PKH或P2SH），那所有交易按照原有的规则进行即可。</p>

<h4>付款人的客户端不支持隔离见证，而收款人支持</h4>

<p>聪明的社区开发者想出了一个过渡方案，即将P2WPKH或P2WSH植入P2SH。</p>

<p>是的！！作为有洁癖的开发者，你又会要吐槽了，这是什么操作！？</p>

<p>P2WPKH植入P2SH后，交易信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of script&gt; EQUAL
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>此处的脚本Hash值为RIPEMD160(SHA256(0 &lt;20-byte hash of Pubkey>))的结果，将该脚本Hash转换为P2SH地址，就是一个兼容segwit的地址，不支持隔离见证的客户端可以正常支付比特币给这种P2SH地址。
而对于支持隔离见证的客户端，仍可以将验证信息放在witness结构中，当然这种过渡方案的交易会较完全形态的方案稍大一些，但比无隔离见证的情况要小。</p>

<p>这样就引入了另外一个混乱之处，我们前面的文章提到过，以<code>3</code>开头的地址是P2SH交易专用的，而P2SH交易一般包含的脚本逻辑比较复杂，现在又要判断一种情况，这笔交易是不是一笔隔离见证交易呢？</p>

<p>还有普通小白也很疑惑，比特币网络中开始出现大量以<code>3</code>开头地址的交易，之前这种交易很少，小白们甚至都没有见过这种地址。</p>

<p>为了解决这个问题，开发者们很快又提出了bech32地址格式(去参考我们之前的文章)，小白们很快就被搞得晕头转向。而此时社区正处于分裂状态，Bitcoin Cash作为硬分叉出来的江湖搅局者，虽然加入了重放保护，但是地址和Bitcoin的规则是一样的，但是Bitcoin Cash是不支持Segwit的！</p>

<p>很快，就有大量的小白在Bitcoin Cash里面发送交易给Segwit地址，这种混乱场景不忍卒见。</p>

<p>然后，Bitcoin Cash也搞出了自己的另外一套地址规则；好吧，你应该去找找我们早期的关于比特币钱包的文章，好好温习一下了。</p>

<h4>一些吐槽</h4>

<p>令人惊奇的是，这段混乱时期，在全网交易纷纷堵死，隔离见证升级、Bitcoin Cash分叉的混乱局面中，比特币的价格不合常理的大涨、暴涨，涨到大家怀疑人生。颇有一点狂风暴雨雷霆霹雳之下，大家在泰坦尼克号中末日狂欢的意味。</p>

<p>Bitcoin这个东西，实在不能以常理来琢磨啊。</p>

<h2>优点</h2>

<p>说了这么多，当然Segwit的升级还是又非常多的好处的~~~</p>

<h4>可以用软分叉增加最大区块容量:</h4>

<p>因为旧有节点根本看不到这些被隔离的见证，即使真实的区块已超过1MB，它们仍会以为没有超过限制而会接受区块。</p>

<p>比特币的区块大小限制为1000000bytes，由于witness数据不包含在这个限制中，为了防止witness数据被滥用，仍然对总的区块大小做了限制。引入了一个新概念叫块重量(Block weight):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Block weight = Base size * 3 + Total size
</span><span class='line'>Base size是不包含witness数据的块大小
</span><span class='line'>Total size是包含了witness数据的总大小</span></code></pre></td></tr></table></div></figure>


<p>隔离见证限制Block weight &lt;= 4000000</p>

<p>这就是隔离见证扩容说的来由，这样实际上确实有一定的扩容效果，如果全网交易都迁移到隔离见证上来，大概扩容1.7倍吧。</p>

<p>但是!!! 注意，实际的区块链大小其实比原来更大，这一点一定要搞清楚。</p>

<h4>解决了交易延展性问题</h4>

<p>从此以後，只有发出交易的人才可以改变交易ID，没有任何第三方可以做到。如果是多重签名交易，就只有多名签署人同意才能改变交易ID。这可以保证一连串的未确认交易的有效性，是双向支付通道或闪电网络所必须的功能。有了双向支付通道或闪电网络，二人或多人之间就可以实际上进行无限次交易，而无需把大量零碎交易放在区块链，大为减低区块空间压力。</p>

<h4>轻量钱包可以变得更轻量，因为它们无需再接收见证数据</h4>

<h4>可以大幅改善签署结构</h4>

<p>在区块链上，曾经有一个超过5000个输入的交易，因为签署设计缺憾，需要半分钟才能完成检查。在建议中的SW软分叉会把这个问题解决掉。</p>

<p>而在该次软分叉完成後，核心开发者们已有计划进一步完善整个系统的可用性和安全性:</p>

<ol>
<li><p>全节点可以为轻量钱包提供很简洁的证明，以检查交易是否合法。以後的节点就不再局限於完全验证和完全不验证，而是可以按个人的资源作部份验证，也就是说一台手机也可以参与保障系统安全。这可以大为降低系统对全节点的依赖，即使以後区块容量提升了，我们仍能保持安全。</p></li>
<li><p>将会推出全新的交易脚本语言，例如可以把数以千计的不同脚本通过MAST技术压缩至只有32字节;亦可以把不同签署合并检查，令检查交易的速度再以倍数上升。</p></li>
</ol>


<h4>为闪电网络的实施铺平了道路</h4>

<p>闪电网络应该是继中本聪创造比特币之后最重量级的创新，支持者和反对者为其吵了一个天翻地覆，这个值得我们后面写文章大书特书，还是那句话，后文再见吧。</p>

<h2>副作用</h2>

<h4>复杂性</h4>

<p>是的，如果你看到这里；就会发现我到了大量的<code>吐槽</code>字眼；为了达成共识，隔离见证采用了软分叉升级，为了兼容老系统，不可避免的修修补补；另外虽然说起来是单独的一项技术，同时解决的问题可不少，在洁癖者眼里，这是屌丝码农的瞎折腾，就增加了出Bug的可能性；如果是个硬分叉，所有技术问题能干净利落解决，就没有这么多争吵了。</p>

<p>总之一句话，隔离验证留下的技术债不少，升级之后落子无悔，如果之后发现问题，可没机会回退了。</p>

<p>这次升级也是一次经典的技术、政治、利益交杂的各方博弈，如果将来比特币大成，这段历史值得仔细研究。</p>

<h4>Block Size</h4>

<p>前面已经在优点里面说过了。隔离见证有扩容效果的。但这个效果只是一个副作用，只是当时提出隔离见证的时候社区正就扩容问题吵得不可开交，莫名其妙的这个技术就卷入扩容斗争里面了。</p>

<p>再说一遍：关于隔离见证，网上一个很大的误解就是：认为witness被隔离走了，witness数据不在Block里，所以一个Block能装更多的Transaction。</p>

<p>其实不是，witness数据仍然在Block里面。并且对于1个Transaction来说，如果把witness数据也算上的话，其raw byte size其实是变大了，而不是变小了！！！
既然Transaction还变大了，那为什么1个Block可以装更多的Transaction呢？？</p>

<p>因为隔离见证是软分叉，不是硬分叉。下面就分别来分析一下，为什么对于老版本节点、新版本节点，1个Block都可以装更多的Transaction呢？</p>

<p>对于老版本节点：
Block Limit Size = 1M，但由于你把witness数据移到了所有Transaction的外面，放在了整个Block的尾部。老版本在计算一个Block大小的时候，只计算了
Block Header + 所有Transaction的数据（witness数据，老版本看不见！！！相当于老版本被欺骗了。）</p>

<p>所以呢，其实整个Block的物理大小(raw block size)已经超过了1M，但老版本的节点不认识尾部的witness数据，所以认为总大小还是 &lt; 1M。</p>

<p>对于新版本节点：
Block的size的计算方式做了调整，引入了Block weight的概念。
block weight = base_size * 4 + witness_size
block weight &lt;= 4M</p>

<p>其中，base_size就是block的前2部分数据（header + 没有witness的所有交易数据）</p>

<p>通过上面的分析，我们会发现，数据还是那么多数据，没有减少，只是重新排布了一下，却变相的把区块链扩容了！！！</p>

<h4>安全性</h4>

<p>有人提出来说，中本聪之前把交易信息和见证数据放在一块是有意的；因为一笔交易带有所有者的签名是天经地义的语义；隔离见证把witness独立出来，降低了比特币系统的安全性。另外~~~~</p>

<p>老实说，这个论据仔细读读还是蛮有道理的，但是实在说的太深刻太哲理了，码农对这种东西天生无感，我就不啰嗦了，大家感兴趣可以自己去搜索这方面资料。</p>

<h2>小结</h2>

<p>以上就是对隔离见证这个东东最简单的描述，我尽力做到简洁中立；但是实际上我觉得整个过程写一本书也不为过；</p>

<p>那么，隔离见证实施之后；就是闪电网络的崛起了，我们下篇文章再见。</p>

<h2>参考</h2>

<h4>四份有关隔离见证的比特币改善方案:</h4>

<ul>
<li>隔离见证软分叉</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki">https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki</a></p>

<ul>
<li>隔离见证通信层</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki">https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki</a></p>

<ul>
<li>隔离见证交易地址</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki">https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki</a></p>

<ul>
<li>隔离见证签署检查</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki">https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki</a></p>

<h4>系统扩展常见问题解答:</h4>

<p><a href="https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq">https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq</a></p>

<h4>需要30秒检查的交易:</h4>

<p><a href="https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08">https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08</a></p>

<h4>其它资料</h4>

<p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md">https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-5]]></title>
    <link href="https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5/"/>
    <updated>2018-12-28T21:08:25+08:00</updated>
    <id>https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5</id>
    <content type="html"><![CDATA[<p>我们还是拿<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517</a>做例子。</p>

<p>这篇文章需要结合<a href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/">比特币的交易-3</a>这篇文章来理解，我们在这里也直接复用TransA、TransB的说法。</p>

<!-- more -->


<h2>准备工作</h2>

<h4>私钥-公钥</h4>

<p>在<a href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/">比特币的HD钱包-2</a>中，我们已经算出来私钥的WIF表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</span></code></pre></td></tr></table></div></figure>


<p>以及公钥:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341</span></code></pre></td></tr></table></div></figure>


<h4>交易body</h4>

<p>这笔交易有1个vin，1个vout；然后再把我们之前的结构分析图拿来，看看具体需要哪些参数传入:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h4>需要手工构造input</h4>

<ol>
<li>指定上一笔vout的txid，是已知参数(outputTransactionHash):<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code></li>
<li>指定上一笔vout的index，是已知参数(sourceIndex):<code>00000000</code></li>
<li>构造scriptSig，即对这个UTXO签名。我们需要用私钥签名，这个是难点，我们后面来计算</li>
</ol>


<h4>需要手工构造output</h4>

<ol>
<li>设置矿工费用，从而计算输出值</li>
<li>构造scriptPubKey</li>
</ol>


<h4>最后组合成为一笔交易</h4>

<ol>
<li>增加version字段：<code>01000000</code></li>
<li>增加inputCount字段: <code>01</code></li>
<li>增加outputCount字段: <code>01</code></li>
<li>增加block lock time字段: <code>00000000</code></li>
</ol>


<h4>然后我们实现一个函数，将这些变量组合，最后得到原始交易值(对应bitcoin-cli的createrawTransaction)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Makes a transaction from the inputs
</span><span class='line'># outputs is a list of [redeemptionSatoshis, outputScript]
</span><span class='line'>def makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs):
</span><span class='line'>    def makeOutput(data):
</span><span class='line'>        redeemptionSatoshis, outputScript = data
</span><span class='line'>        return (struct.pack("&lt;Q", redeemptionSatoshis).encode('hex') +
</span><span class='line'>        '%02x'.format(len(outputScript.decode('hex'))) + outputScript)
</span><span class='line'>    formattedOutputs = ''.join(map(makeOutput, outputs))
</span><span class='line'>    return (
</span><span class='line'>        "01000000" + # 4 bytes version
</span><span class='line'>        "01" + # varint for number of inputs
</span><span class='line'>        outputTransactionHash.decode('hex')[::-1].encode('hex') + # reverse outputTransactionHash
</span><span class='line'>        struct.pack('&lt;L', sourceIndex).encode('hex') +
</span><span class='line'>        '%02x'.format(len(scriptSig.decode('hex'))) + scriptSig +
</span><span class='line'>        "ffffffff" + # sequence
</span><span class='line'>        "%02x".format(len(outputs)) + # number of outputs
</span><span class='line'>        formattedOutputs +
</span><span class='line'>        "00000000" # lockTime
</span><span class='line'>        )</span></code></pre></td></tr></table></div></figure>


<h4>outputs构造</h4>

<p>在构造一笔完整的交易之前，我们需要手工做两件事情：</p>

<ol>
<li>构造一个output输出</li>
<li>对vin中的UTXO签名，构造scriptSig</li>
</ol>


<p>outputs的构造比scriptSig简单一点，我们先来解决这个问题。</p>

<p>outputs是包含多个output的数组。在这个例子中，我们打算只构造一个output。结合我们之前的文章，就是构造一个bitcoin scriptPubKey，设置一把新锁。</p>

<p>这个scriptPubkey是这样子的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;pubkey&gt;  OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>PubKeyHash其实就是收币的地址，其它操作符都是现成的。</p>

<h2>如何构造一笔output</h2>

<p>一笔output的构造是简单的，所有东西都是现成的，而且这笔交易是个P2PK交易，输出非常简化，我们仅仅需要构造<code>&lt;pubkey&gt;  OP_CHECKSIG</code>即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def makeOutput(value,  index, pubkey):
</span><span class='line'>    OP_CHECKSIG =  'ac'
</span><span class='line'>    value = "{:0&lt;16x}".format(int(struct.pack('&lt;I', int(value)).hex(), 16))
</span><span class='line'>    index = "{:02x}".format(int(index))
</span><span class='line'>    pubkey = pubkey
</span><span class='line'>    pubkey_length = "{:02x}".format(len(pubkey)/2)
</span><span class='line'>    return value + index = pubkey_length + pubkey + OP_CHECKSIG
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>&gt; print(makeOutput(7000, 0, '2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac'))
</span><span class='line'>&gt; 581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac
</span><span class='line'>&gt; outputs = ['581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac']
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h2>如何对一笔交易签名(scriptSig)</h2>

<p>在构造一笔交易的过程中，签署交易是一个非常麻烦的过程。其基本思想是使用ECDSA椭圆曲线算法和私钥生成交易的数字签名，但细节比较复杂。</p>

<p>我们可以先通过验证签名的过程来理解以下，验证签名过程的通过10个步骤描述。下面的缩略图说明了详细的流程。</p>

<p><img src="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png" alt="img" /></p>

<p>这张图出自于<a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">这里</a>，里面的TX ID是不同的，但基本步骤一样。</p>

<h4>一些约定:</h4>

<ol>
<li>TransA代表TxPrev，TransB代笔TxNew</li>
</ol>


<h4>步骤:</h4>

<ol>
<li>首先解析TransB涨vin中的scriptSig，得到sigStr以及pubkeyStr</li>
<li>从TransA中拿出对应的vout ，从scriptPub脚本中截取需要的部分(subScript)：即 <code>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</code>；截取规则就是检索最后一个<code>OP_CODESEPARATOR</code>的位置，在这之后的脚本段就是我们要截取的对象</li>
<li>如果subScript中包含了签名，移除掉(在scriptPub中包含签名是很特殊的情况，一般出现在P2SH交易中，普通交易不需要这一步)</li>
<li>如果脚本中有<code>OP_CODESEPARATORS</code>操作符，移除</li>
<li>检测一步解析出来的scriptSig最后一个字节的HashType，扩展为4字节(小端排序)备用</li>
<li>将TransB 复制一份，变为TransBCopy</li>
<li>将TransBCopy中所有的Vin以及Vout 移除，同时将length字段置为0</li>
<li>将第4步中的subScript根据vin sequence填充到TransBCopy对应的位置</li>
<li>最后将交易TransBCopy序列化(采用DER编码)，并在末尾添加第5步中得到的HashType，得到签名的原始数据</li>
<li>最后执行签名验证过程: ECDSA_CheckSignature(pubkeyStr, sigStr, double_sha256(TransBCopy))</li>
</ol>


<h4>疑点解惑</h4>

<h5>为什么这么麻烦，不能直接对TransB签名吗？</h5>

<p>因为最终的签名是包含在TransB当中的，签名是不能对自身来签名的；所以要签名的原始数据不能包含签名本身；</p>

<p>说句题外话，由于ECDSA的签名算法的局限，这个结构组织方式最终导致了一个顽疾，即交易延展性问题，也被翻译为交易可锻性（Transaction Malleability）。</p>

<p>简单来说，就是攻击者可以生成不同但是合法的scriptSig，这样虽然vin，vout金额和地址不变，但是TX ID会发生变化，从而导致用户找不到发送的交易。</p>

<p>这对于交易所是一个威胁，某个居心不良的用户可能充值了一笔资金，然后重新生成scriptSig又广播了一笔交易，然后欺骗交易所，说第一笔交易没收到，交易所检查以下果然如此，于是又发送了一笔资金给用户，这样用户就实现了double withdraw，白赚了一笔。MTGOX早期就是这么被坑的，后来也出现过一些损人不利己的脚本小子们公然利用这个漏洞攻击比特币网络；为了解决这个问题，core开发者提出了segwit解决方案(即隔离见证)，后来随着政治斗争、市场斗争的激化，一个技术问题最终演化成了扩容派的分裂。</p>

<p>总之还是那句话，关于segwit, 闪电网络，期待我们后面的文章吧。</p>

<h5>为什么要用上一笔交易vout来填充这个位置呢？</h5>

<p>我们说验证签名的过程，其实有三个作用:</p>

<ol>
<li>签名证明私钥的所有者，即资金所有者，已经授权支出这些资金</li>
<li>授权证明是不可否认的（不可否认性）</li>
<li>签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改</li>
</ol>


<p>我们提供签名、私钥即承诺了第1点，对TransBCopy 签名承诺了第2点，但是要做到第3点，就需要对于引用UTXO的信息做承诺；</p>

<p>我们会问，单纯的prev TX ID和vout sequence no不能证明我要花费的哪一笔UTXO吗？</p>

<p>是的，这还是不够的，我们需要另外的信息熵的引入，就是这个UTXO的scriptPub。具体为什么，是ECDSA的数学特性决定的。请参考:</p>

<p><a href="https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/">https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/</a></p>

<p>老实说，关于ECDSA的签名验证，我在学习了很长时间以后，还是非常担心，因为签名生成算法使用随机密钥k作为临时私有-公钥对的基础，这个K值的随机性一定要人工保证，比特币的每笔交易验证，离不开签名验证，而这个签名验证如此复杂，确实让人心生忐忑。</p>

<h5>这个OP_CODESEPARATORS是什么东东？</h5>

<p>哈，到目前为止，我们接触到的都是比特币最简单、最基本、当然也是应用最广泛的交易类型，但是比特币还支持P2SH的高级交易，在这种交易中，vout里面可能会嵌入非常复杂的脚本，所以系统引入了OP_CODESEPARATORS作为复杂脚本的分隔符，以后的文章我们会详细讲解；</p>

<p>OP_CODESEPARATOR属于一种看起来<code>过度设计</code>的特性，老实说，我没有在比特币主网上发现像样的使用这个特性的交易，我也需要更多时间的学习才能搞明白这个东西，以下是一些参考资料：</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=164655.0">https://bitcointalk.org/index.php?topic=164655.0</a></p>

<h5>这个HashType是什么东东？</h5>

<p>嗯哼，又是一个非常棘手但是有意思的问题。</p>

<p>我们说比特币有了script之后，功能是非常非常丰富的，不仅仅局限于支付场景，他可以应用到许多非常复杂的场景中。</p>

<p>比如现在让我们考虑一个外贸公司的业务，这个公司的对公账户每天都要接受许多客户的付款，处于安全考虑，我作为公司的CEO，希望能跟财务主管共同管理公司的对公账户，当需要支出时，一定要我跟财务主管都签字同意才可以。</p>

<p>这就衍生出了所谓的M-N交易类型，即多重签名交易。</p>

<p>在多重签名交易中，要花费一笔UTXO，可能需要多个签名，或者有这种语义：&#8221;一定要CEO的签名，如果没有CEO的签名，需要COO和CFO的联合签名&#8221;，为了表示这些，引入了SIGHASH这个字段，就是我们所说的HashType啦。</p>

<p>要考虑SIGHASH，实际上已经牵涉到了bitcoin的高级交易类型(P2SH)，还是那句话，关注后面的文章吧。</p>

<h4>反向代码</h4>

<p>嗯哼，把验证签名的步骤反向来一遍，就是签名的过程了。</p>

<p>代码表示如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>def makeSignedTransaction(privateKey, outputTransactionHash, sourceIndex, scriptPubKey, outputs):
</span><span class='line'>    myTxn_forSig = (makeRawTransaction(outputTransactionHash, sourceIndex, scriptPubKey, outputs)
</span><span class='line'>         + "01000000") # hash code
</span><span class='line'>
</span><span class='line'>    s256 = hashlib.sha256(hashlib.sha256(myTxn_forSig.decode('hex')).digest()).digest()
</span><span class='line'>    sk = ecdsa.SigningKey.from_string(privateKey.decode('hex'), curve=ecdsa.SECP256k1)
</span><span class='line'>    sig = sk.sign_digest(s256, sigencode=ecdsa.util.sigencode_der) + '\01' # 01 is hashtype
</span><span class='line'>    pubKey = keyUtils.privateKeyToPublicKey(privateKey)
</span><span class='line'>    scriptSig = utils.varstr(sig).encode('hex') + utils.varstr(pubKey.decode('hex')).encode('hex')
</span><span class='line'>    signed_txn = makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs)
</span><span class='line'>    verifyTxnSignature(signed_txn)
</span><span class='line'>    return signed_txn</span></code></pre></td></tr></table></div></figure>


<h2>广播交易</h2>

<p>好啦，构造了vin, vout，以及组合成一笔完整的交易，剩下的就是广播出去啦：</p>

<p>比特币的网络协议非常简单，设置好一个Magic Number就可以加入，以下时广播代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>magic = 0xd9b4bef9
</span><span class='line'>
</span><span class='line'>def makeMessage(magic, command, payload):
</span><span class='line'>    checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]
</span><span class='line'>    return struct.pack('L12sL4s', magic, command, len(payload), checksum) + payload
</span><span class='line'>
</span><span class='line'>def getVersionMsg():
</span><span class='line'>    version = 60002
</span><span class='line'>    services = 1
</span><span class='line'>    timestamp = int(time.time())
</span><span class='line'>    addr_me = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    addr_you = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    nonce = random.getrandbits(64)
</span><span class='line'>    sub_version_num = utils.varstr('')
</span><span class='line'>    start_height = 0
</span><span class='line'>    
</span><span class='line'>def getTxMsg(payload):
</span><span class='line'>  return makeMessage(magic, 'tx', payload)
</span><span class='line'>
</span><span class='line'>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</span><span class='line'>HOST_IP ="x.x.x.x"
</span><span class='line'>sock.connect(HOST_IP, 8333)
</span><span class='line'>
</span><span class='line'>sock.send(msgUtils.getVersionMsg())
</span><span class='line'>sock.recv(1000) # receive version
</span><span class='line'>sock.recv(1000) # receive verack
</span><span class='line'>sock.send(msgUtils.getTxMsg("01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000".decode('hex')))</span></code></pre></td></tr></table></div></figure>


<p>HOST IP 怎么获取呢？</p>

<p>如果你有一个全节点，可以直接调用RPC接口的getpeers函数。或者你直接执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nslookup bitseed.xf2.org</span></code></pre></td></tr></table></div></figure>


<p>从公共服务器里面检索nodes，里面随便挑一个IP 吧。</p>

<h2>小结</h2>

<p>以上就是一笔完整交易的构造过程。</p>

<p>这笔交易结构非常简单，只有一个vin，一个vout。</p>

<p>如果有多个vin, 多个vout的情况，就需要每个vin都签署一遍。</p>

<p>我们发现，一笔比特币交易的构造过程，最复杂的，就是签名以及验证的过程。它的步骤极其繁琐，而且椭圆曲线的签名算法极其复杂。如果在更高级的比特币交易中，比如P2SH，或者多重签名交易，或者Segwit交易，包含了更复杂的脚本和执行逻辑，事情很快就变得不可控制起来。</p>

<p>这是我在学习比特币知识时遇到的最大的恐惧，我认为如果将来比特币系统出现什么致命BUG，很大可能就在这里暴雷。</p>

<p>也许早期的开发者也觉得不放心，于是禁用了不少操作符。而目前Bitcoin SV和Bitcoin Cash的发展方向，是将这些操作符一一解放出来。</p>

<p>更强大的功能？还是更稳妥的基础设施？究竟怎样的做法是正确的，我也没有定论，只是告诉大家现在社区的发展方向就好了，大家自己做判断。</p>

<h2>参考资料:</h2>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-4]]></title>
    <link href="https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4/"/>
    <updated>2018-12-24T18:41:36+08:00</updated>
    <id>https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4</id>
    <content type="html"><![CDATA[<p>前面的文章中我们分析了一笔标准的Pay to Public Key HASH(P2PKH)交易。看起来其实结构挺简单的，这篇文章我们乘胜追击，看一下矿工们领取系统奖励时，构造的coinbase交易。</p>

<!-- more -->


<p>Coinbase交易规范的叫法是Generation TX，每一个block有且只有一笔Genration TX，该类交易的币是矿工挖矿凭空产生的，所以没有vin。比特币系统所有的币都产自于这里。</p>

<p>我们就以最常见创世块的交易作为示例来分析吧。</p>

<p><a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a>这个创始块中只有一笔交易，就是中本聪手工构造发给自己的币：</p>

<p><a href="https://www.blockchain.com/btc/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b">4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</a></p>

<h4>区块原始数据</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>00000000   01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000010   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000020   00 00 00 00 3B A3 ED FD  7A 7B 12 B2 7A C7 2C 3E   ....;£íýz{.²zÇ,&gt;
</span><span class='line'>00000030   67 76 8F 61 7F C8 1B C3  88 8A 51 32 3A 9F B8 AA   gv.a.È.ÃˆŠQ2:Ÿ¸ª
</span><span class='line'>00000040   4B 1E 5E 4A 29 AB 5F 49  FF FF 00 1D 1D AC 2B 7C   K.^J)«_Iÿÿ...¬+|
</span><span class='line'>00000050   01 01 00 00 00 01 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000060   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000070   00 00 00 00 00 00 FF FF  FF FF 4D 04 FF FF 00 1D   ......ÿÿÿÿM.ÿÿ..
</span><span class='line'>00000080   01 04 45 54 68 65 20 54  69 6D 65 73 20 30 33 2F   ..EThe Times 03/
</span><span class='line'>00000090   4A 61 6E 2F 32 30 30 39  20 43 68 61 6E 63 65 6C   Jan/2009 Chancel
</span><span class='line'>000000A0   6C 6F 72 20 6F 6E 20 62  72 69 6E 6B 20 6F 66 20   lor on brink of 
</span><span class='line'>000000B0   73 65 63 6F 6E 64 20 62  61 69 6C 6F 75 74 20 66   second bailout f
</span><span class='line'>000000C0   6F 72 20 62 61 6E 6B 73  FF FF FF FF 01 00 F2 05   or banksÿÿÿÿ..ò.
</span><span class='line'>000000D0   2A 01 00 00 00 43 41 04  67 8A FD B0 FE 55 48 27   *....CA.gŠý°þUH'
</span><span class='line'>000000E0   19 67 F1 A6 71 30 B7 10  5C D6 A8 28 E0 39 09 A6   .gñ¦q0·.\Ö¨(à9.¦
</span><span class='line'>000000F0   79 62 E0 EA 1F 61 DE B6  49 F6 BC 3F 4C EF 38 C4   ybàê.aÞ¶Iö¼?Lï8Ä
</span><span class='line'>00000100   F3 55 04 E5 1E C1 12 DE  5C 38 4D F7 BA 0B 8D 57   óU.å.Á.Þ\8M÷º..W
</span><span class='line'>00000110   8A 4C 70 2B 6B F1 1D 5F  AC 00 00 00 00            ŠLp+kñ._¬....</span></code></pre></td></tr></table></div></figure>


<p>然后我们解析拿我们以前文章的方法来解析一下这笔交易(因为这个区块中只包含了唯一一笔交易，我们顺便解析一下区块构造):</p>

<h4>block header 部分</h4>

<ol>
<li>首先是version字段:<code>01000000</code></li>
<li>然后是32字节代表上一个block的hash id(因为这笔交易所属block是第一个block，所以人为设置为0): <code>0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>接着是32字节的merkle root(关于merkle root，我们会在后面的文章中详解): <code>3BA3EDFD7A7B12B27AC72C3E67768F617FC81BC3888A51323A9FB8AA4B1E5E4A</code></li>
<li>4字节的时间戳: <code>29AB5F49</code></li>
<li>接着是目标难度(bits): <code>FFFF001D</code> 代表着挖矿难度，具体含义可参考我们之前的<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">比特币POW难度调节分析</a>。</li>
<li>nonce: <code>1DAC2B7C</code>，同样的挖矿调节参数，我们老是说比特币系统就是在算一个 &ldquo;毫无意义的随机数字&#8221;，没错，这就是毫无意义君。</li>
<li>这个区块包含的总交易数目：<code>01</code></li>
</ol>


<p>最好来个结构明细表格：</p>

<table>
<thead>
<tr>
<th>Field </th>
<th> Size </th>
<th>  Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version </td>
<td>4 bytes </td>
<td> Little-endian</td>
</tr>
<tr>
<td>Previous Block Hash </td>
<td> 32 bytes </td>
<td>    Big-endian</td>
</tr>
<tr>
<td>Merkle Root </td>
<td> 32 bytes  </td>
<td> Big-endian</td>
</tr>
<tr>
<td>Time </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Bits </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Nonce</td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
</tbody>
</table>


<h4>交易部分</h4>

<ol>
<li>version: <code>01000000</code></li>
<li>input数目 01</li>
<li>prev output: <code>0000000000000000000000000000000000000000000000000000000000000000FFFFFFFF</code></li>
<li>script length: <code>4d</code></li>
<li>coinbase (2-100字节): <code>04FFFF001D0104455468652054696D65732030332F4A616E2F32303039204368616E63656C6C6F72206F6E206272696E6B206F66207365636F6E64206261696C6F757420666F722062616E6B73</code></li>
<li>sequence: FFFFFFFF</li>
<li>outputs数目: 01</li>
<li>btc数目: 00F2052A01000000 &ndash; 50 BTC</li>
<li>pk_script length: 43</li>
<li>pk_script:<code>41 04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F  AC</code>

<ul>
<li>0x41代表着后面65个字节入栈</li>
<li><code>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</code></li>
<li>0xAC代表着OP_CHECKSIG</li>
<li>整个合起来就是输出脚本为: <Pubkey> &lt;OP_CHECKSIG></li>
</ul>
</li>
<li>lock time: 00000000</li>
</ol>


<p>这笔交易跟我们上一篇文章中的TransB构造是一样的，想要花费的话提供签名就OK了。不过这笔交易没有vin，取代的字段是coinbase。这个字段是可以随意调整的(2-100字节)，中本聪在这里留存了一句非常有名的话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</span></code></pre></td></tr></table></div></figure>


<p>ASCII解码为:  The Times 03/Jan/2009 Chancellor on brink of second bailout for banks</p>

<p>这是2009年1月3日泰晤士报当天的头版文章标题，这是一个时间证明，证明比特币于2009-01-03开始运行，也顺便对传统的金融体系小小嘲讽一下。</p>

<h2>挖矿</h2>

<p>Generation TX交易需要Coinbase字段有两个原因:</p>

<ol>
<li>但是4字节的nonce字段随机性是不够的，需要引入更长的extra nonce，所以有了长度可以灵活调节(2-100字节)的coinbase字段</li>
<li>作为一个附言留给矿工来发表意见</li>
</ol>


<p>其实我对于coinbase字段没有啥意见，但是最初的nonce字段只有4个字节，意味着每秒钟只有4G的碰撞空间，很快全网就超出了这个限制，所以Coinbase字段立即就派上用场了。后来slushpool矿池发明了stratum挖矿架构，彻底进入了大算力组团挖矿的时代；这些技术的演化也非常有意思，可以参考这篇文章，讲的非常清晰：</p>

<p><a href="https://www.8btc.com/article/108894">区块链核心技术演进之路 &ndash; 挖矿演进</a></p>

<p>其实我觉得nonce字段最初最好设置为32字节，就没这么多事情了。</p>

<h2>有钱任性的矿工们</h2>

<p>矿工们早期是一批劳苦大众死宅，后来优胜劣汰只剩下了寡头；在挖矿故事里，还是有几个有意思的故事说道说道的：</p>

<ul>
<li>TXID 相同的交易</li>
</ul>


<p>一笔交易的id值是SHA(TX HEX)算出来的，因为每一笔交易的vin, vout不同，很难得到相同的txid值。但是在Generation TX里面，输出的数目和地址很有可能都是一样的。所以需要矿工自己构造一个随机的coinbase内容，防止产生相同的TXID值。</p>

<p>早期一位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<p>后来为了避免这个问题，社区讨论了提出 <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP 34 规范</a>，规定scriptSig字段，必须要把当前的区块高度(Height)放在最前。</p>

<ul>
<li>忘了接收奖励的矿工</li>
</ul>


<p>2017-12-30 20:55:00，有个矿工挖到了一个区块之后，竟然丢弃了12.5BTC的奖励！</p>

<p><a href="https://btc.com/0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126">区块0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126</a></p>

<p>我们不知道这位矿工是用的哪个版本的挖矿软件，但是他们挖到一个区块之后，竟然没有构造地址来领取这笔奖励(价值20W USD)。难道他们真刀真枪上阵之前从来不测试一下吗？或者他们就是有钱任性的真土豪，我只能说:</p>

<p>土豪我们做朋友吧~~~</p>

<h2>coinbase</h2>

<p>因为coinbase是矿工们发挥自己灵感的地方，所以最初作为<code>区块永留存</code>的手段之一，大家纷纷刻字留念。</p>

<p>有刻字到此一游的，有山盟海誓秀恩爱的，有炫耀生孩子的，有申诉政治诉求的，有吟诗作对，弘扬中国传统文化的；总之这100个字节表示鸭梨很大。</p>

<h2>OP_RETURN</h2>

<p>coinbase留言是有实力的矿工才有资格搞的；没有足够算力怎么办呢？</p>

<p>早期Geek比较多，大家就纷纷构造不能花费的交易，在vout中用PUSHDATA来填充内容。</p>

<p>运用比特币的区块链技术存储与比特币支付不相关数据的做法是一个有争议的话题。许多开发者认为其有滥用的嫌疑，因而试图予以阻止。另一些开发者则将之视为区块链技术强大功能的有力证明，从而试图给予大力支持。那些反对非支付相关应用的开发者认为这样做将引致“区块链膨胀”，因为所有的区块链节点都将以消耗磁盘存储空间为成本，负担存储此类 数据的任务。</p>

<p>更为严重的是，此类交易仅将比特币地址当作自由组合的20个字节而使用，进而会产生不能用于交易的UTXO。因为比特币地址只是被当作数据使用，并不与私钥相匹配，所以会导致UTXO不能被用于交易，因而是一种伪支付行为。因此，这些交易永远不会被花费，所以永远不会从UTXO集中删除，并导致UTXO数据库的大小永远增加或“膨胀”。</p>

<p>后来人们又发明出来OP_RETURN留言法：</p>

<p>在0.9版的比特币核心客户端上，通过采用Return操作符最终实现了妥协。Return允许开发者在交易输出上增加80字节的非交易数据。然后，与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。Return输出被记录在区块链上，它们会消耗磁盘空间，也会导致区块链规模的增加，但 它们不存储在UTXO集中，因此也不会使得UTXO内存膨胀，更不会以消耗代价高昂的内存为代价使全节点都不堪重负。 RETURN 脚本的样式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  RETURN &lt;data&gt;</span></code></pre></td></tr></table></div></figure>


<p>“data”部分被限制为80字节，且多以哈希方式呈现，如32字节的SHA256算法输出。许多应用都在其前面加上前缀以辅助认定。例如，电子公正服务的证明材料采用8个字节的前缀“DOCPROOF”，在十六进制算法中，相应的ASCII码为 <code>44 4f 43 50 52 4f 4f 46</code>。</p>

<p> RETURN 不涉及可用于支付的解锁脚本的特点， RETURN 不能使用其输出中所锁定的资金，因此它也就没有必要记录在蕴含潜在成本的UTXO集中，所以 RETURN 实际是没有成本的。</p>

<p>RETURN 常为一个金额为0的比特币输出， 因为任何与该输出相对应的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效。如果你碰巧将 RETURN 的输出作为另一笔交易的输入，则该交易是无效的。</p>

<p>一笔标准交易（通过了 isStandard() 函数检验的）只能有一个 RETURN 输出。但是单个RETURN 输出能与任意类型的输出交易进行组合。</p>

<p>PS: 最初提出了RETURN，限制为80字节，但是当功能被释放时，限制被减少到40字节。 2015年2月，在Bitcoin Core的0.10版本中，限制提高到80字节。 节点可以选择不中继或重新启动RETURN，或者只能中继和挖掘包含少于80字节数据的RETURN。</p>

<h4>例子</h4>

<p>这里比特币就见证了一场成功的求婚：</p>

<p><a href="https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e">https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e</a></p>

<p><a href="https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0">https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0</a></p>

<h2>刻字服务</h2>

<p>后来有人提供了比较简单的刻字服务，只要你付点小费，就可以将想要说的话永久上链；里面的内容更是洋洋洒洒，有字符画，有山盟海誓，有政治诉求，甚至还有病毒签名，可以参考这篇文章：</p>

<p><a href="http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html">http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html</a></p>

<p>有个网站专门parse了所有区块的文本数据供大家瞻仰：</p>

<p><a href="http://bitcoinstrings.com/">http://bitcoinstrings.com/</a></p>

<p>里面记录了许多尘封的历史，篇幅最大的就是扩容大战；完整的将当时社区争论刻进了区块链中，这是人类历史上第一次区块链圆桌访谈录，值得仔细瞻仰。</p>

<h4>花费</h4>

<p>Coinbase交易取得的比特币，必须要等100个区块高度之后才能花费。因为全网广播中，处于最头上的链是时时刻刻都在分叉的，这是一种保护措施。</p>

<p>请参考：</p>

<p><a href="https://github.com/bitcoin/bitcoin/search?q=COINBASE_MATURITY">https://github.com/bitcoin/bitcoin/search?q=COINBASE_MATURITY</a></p>

<p><a href="http://bitcoin.stackexchange.com/questions/40655/coinbase-transactions-100-block-cooldown-period">http://bitcoin.stackexchange.com/questions/40655/coinbase-transactions-100-block-cooldown-period</a></p>

<h2>小结</h2>

<p>好了，到了这里，我们对于比特币的开采交易，普通交易都理解了；</p>

<p>下一步我们将一步步手工代码构造十六进制数据，然后形成一笔完整的交易去广播；完全吃透一笔交易的来龙去脉；</p>

<p>那么，下次再见。</p>

<h2>工具</h2>

<p><a href="https://sites.google.com/site/nathanlexwww/tools/utf8-convert">https://sites.google.com/site/nathanlexwww/tools/utf8-convert</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-3]]></title>
    <link href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/"/>
    <updated>2018-12-09T15:46:05+08:00</updated>
    <id>https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3</id>
    <content type="html"><![CDATA[<h2>scriptSig与scriptPubKey概览</h2>

<p>继续解析我们上篇文章的交易(<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code>)</p>

<p>目前为止，我们还没有解析vin中的scriptSig，以及vout中的scriptPubKey；这两个东东才是交易的核心，他们有什么作用呢？</p>

<!-- more -->


<p>scriptSig是一笔UTXO的开锁脚本，scriptPubKey是输出UTXO的加锁脚本，一笔交易就是打开上家的保险箱，将资金转移到下家的保险箱并重新加锁的过程:</p>

<ul>
<li>上家-TransA: id(b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b) &ndash;> vout scriptPubkey (转移到保险箱A，并给A上锁)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "value": 0.00010000,
</span><span class='line'>          "n": 0,
</span><span class='line'>          "scriptPubKey": {
</span><span class='line'>              "asm": "OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG",
</span><span class='line'>              "hex": "76a914650d0497e014e60d4680fce6997d405de264f04288ac",
</span><span class='line'>              "reqSigs": 1,
</span><span class='line'>              "type": "pubkeyhash",
</span><span class='line'>              "addresses": [
</span><span class='line'>                  "1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE"
</span><span class='line'>              ]
</span><span class='line'>          }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>转移-TransB: id(3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517) &ndash;> vin scriptSig (解锁保险箱A，拿出资金)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>          "vout": 0,
</span><span class='line'>          "scriptSig": {
</span><span class='line'>              "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>              "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>          },
</span><span class='line'>          "sequence": 4294967295
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下家-TransB: id(3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517) &ndash;>vout scriptPubkey (转移到保险箱B，并给B上锁)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "value": 0.00007000,
</span><span class='line'>          "n": 0,
</span><span class='line'>          "scriptPubKey": {
</span><span class='line'>              "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>              "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>              "reqSigs": 1,
</span><span class='line'>              "type": "pubkey",
</span><span class='line'>              "addresses": [
</span><span class='line'>                  "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>              ]
</span><span class='line'>          }
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<p>具体怎么理解这两个东东呢？我们还需要一点前置知识。</p>

<h2>比特币脚本语言系统 scripting language</h2>

<p>scriptPubkey以及scriptSig是一种脚本语言。比特币的脚本语言被设计为一种类 Forth 栈语言。拥有成无状态和非图灵完备的性质。无状态性保证了一旦一个交易被区块打包，这个交易就是可用的。图灵非完备性（具体来说，缺少循环和goto 语句）使得比特币的脚本语言更加不灵活和更可预测，从而大大简化了安全模型。</p>

<p>如果大家之前做过汇编开发的话，就会发现这跟汇编的指令码是非常相似的东东。</p>

<p>先来一个在线解析工具:</p>

<p><a href="https://bitcoin-script-debugger.visvirial.com/">https://bitcoin-script-debugger.visvirial.com/</a></p>

<p>再来一个视频讲解：</p>

<p><a href="https://www.youtube.com/watch?v=4qz7XehSBCc">https://www.youtube.com/watch?v=4qz7XehSBCc</a></p>

<p>比较简单的教程:</p>

<p><a href="https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-one/">https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-one/</a></p>

<ul>
<li>额，我知道大部分人跟我一样懒得去翻阅上面这些资料，所以我们简单传送一下：</li>
</ul>


<h3>一个最小脚本集</h3>

<p>现在想象我们有一台非常简单的计算器，它的CPU只有一个16位的寄存器，以及非常小的内存(520B)；我们需要设计一种语言，实现一些最简单的计算，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = 0x23
</span><span class='line'>x += 0x4b
</span><span class='line'>x *= 0x1e</span></code></pre></td></tr></table></div></figure>


<p>然后转换为类似汇编语言的比较简单的操作码形式, 我们需要以下指令集：</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> 操作码</th>
<th> 操作数(V值) </th>
<th> explained</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET(V) </td>
<td> <code>ab</code> V </td>
<td> <code>0xab</code> </td>
<td> 16bits(0x23) </td>
<td> 将V(0x23)载入到寄存器中</td>
</tr>
<tr>
<td>ADD(V) </td>
<td> <code>ac</code> V </td>
<td> <code>0xac</code> </td>
<td> 16bits(0x4b) </td>
<td> 寄存器值+0x4b; <code>0x23 + 0x4b = 0x6e</code></td>
</tr>
<tr>
<td>MUL(V) </td>
<td> <code>ad</code> V </td>
<td> <code>0xad</code> </td>
<td> 16bits(0x1e) </td>
<td> 寄存器值*0x1e; <code>0x6e * 0x1e = 0x0ce4</code></td>
</tr>
</tbody>
</table>


<p>在上面这个表格中，我们定义了三种最简单的操作码：<code>0xab, 0xac, 0xad</code>，跟在这三个操作码后面的2个字节就是操作数；将上面的计算步骤用代码表示如下(小端排序):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ab 23 00 ac 4b 00 ad 1e 00</span></code></pre></td></tr></table></div></figure>


<p>我们可以实现一个最简单的脚本逻辑，顺序parse这段代码，并转换为相应的操作码，然后进行运算；</p>

<p>我们实现了一个非常迷你的脚本集。</p>

<h3>栈设计</h3>

<p>上面的操作只涉及到了寄存器，但是现实情况中，我们通常要做多个计算步骤，并将临时变量存到内存中，另外会把复杂的程序组织为一个个函数；这种时候，最常见的内存组织方法是什么呢？</p>

<p>没错，就是我们最常用的数据结构：栈(STACK)。</p>

<p>比如下面这个函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int foo() {
</span><span class='line'>
</span><span class='line'>    /* 1 */
</span><span class='line'>
</span><span class='line'>    /* 2 */
</span><span class='line'>    uint8_t a = 0x12;
</span><span class='line'>    uint16_t b = 0xa4;
</span><span class='line'>    uint32_t c = 0x2a5e7;
</span><span class='line'>
</span><span class='line'>    /* 3 */
</span><span class='line'>    uint32_t d = a + b + c;
</span><span class='line'>
</span><span class='line'>    return d;
</span><span class='line'>
</span><span class='line'>    /* 4 */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>第一步函数刚刚跳转执行，栈初始化为空。[]</li>
<li>第二步，三个变量<code>a,b,c</code>压入栈中(PUSH STACK)</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12]
</span><span class='line'>[12, a4 00]
</span><span class='line'>[12, a4 00, e7 a5 02 00]</span></code></pre></td></tr></table></div></figure>


<ol>
<li>结合我们上面的操作码，计算<code>a,b,c</code>的和，并将结果压栈</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12, a4 00, e7 a5 02 00, 9d a6 02 00]</span></code></pre></td></tr></table></div></figure>


<ol>
<li>返回结果，并将栈元素弹出(POP STACK)，恢复到初始状态。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12, a4 00, e7 a5 02 00]
</span><span class='line'>[12, a4 00]
</span><span class='line'>[12]
</span><span class='line'>[]</span></code></pre></td></tr></table></div></figure>


<h3>Script Language</h3>

<p>机器码设计了指令的表示方法，栈设计规定了数据的存储方法；将机器码与栈设计结合起来，就是Bitcoin Script Language。它有几个明显的特点：</p>

<ul>
<li>脚本没有循环:这意味着脚本不能无限运行</li>
<li>栈空间只有520字节</li>
<li>整形常量4字节</li>
<li>脚本的内存访问是基于栈的:这意味着脚本中不存在命名变量这种东西，所有的操作码和操作数都表示为栈上的运算；通常，推入的栈项将成为后续操作码的操作数。在脚本的末尾，最上面的堆栈项是返回值。</li>
</ul>


<p>举个最简单的例子，bitcoin script language支持下面两个操作码：</p>

<h4>压栈操作码</h4>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> explained</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_0 </td>
<td> 0x00 </td>
<td> 将0x00压入栈中</td>
</tr>
<tr>
<td>OP_1 &mdash; OP_16 </td>
<td> 0x51 &mdash; 0x60 </td>
<td> 将0x01 &mdash; 0x10 压入栈中</td>
</tr>
</tbody>
</table>


<blockquote><p>PS: OP_0, OP_1还代表着布尔值False,True</p></blockquote>

<p>然后下面一段示例脚本代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>54 57 00 60</span></code></pre></td></tr></table></div></figure>


<p>或者直接翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_4 OP_7 OP_0 OP_16</span></code></pre></td></tr></table></div></figure>


<p>作用就是将四个值依次压栈，栈状态可以表示为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]
</span><span class='line'>[04]
</span><span class='line'>[04, 07]
</span><span class='line'>[04, 07, 00]
</span><span class='line'>[04, 07, 00, 10]</span></code></pre></td></tr></table></div></figure>


<p>此时栈顶元素值为0x10，前面我们说了，栈顶元素即返回值，所以这个脚本的返回值为0x10。当然，这个脚本现在就是将四个值压栈，并没有什么实际作用。</p>

<h4>PUSH DATA操作码</h4>

<p>简单的压栈操作码只能压入1个字节的数据，如果我们想以此压入多个字节的数据，需要用到 <code>PUSH DATA</code>操作码。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> L (length) </th>
<th> D (data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_PUSHDATA1 </td>
<td> <code>0x4c</code> L D </td>
<td> 8bits </td>
<td> L bytes</td>
</tr>
<tr>
<td>OP_PUSHDATA2 </td>
<td> <code>0x4d</code> L D </td>
<td> 16bits</td>
<td> L bytes</td>
</tr>
<tr>
<td>OP_PUSHDATA3 </td>
<td> <code>0x4e</code> L D </td>
<td> 32bits</td>
<td> L bytes</td>
</tr>
</tbody>
</table>


<ul>
<li>L 代表需要压入的字节长度，它可以有8bits, 16bits，或者32bits，这三个操作码可以最大压入2<sup>8</sup> &ndash; 1 = 255字节、2<sup>16</sup> &ndash; 1 = 65535字节、2<sup>32</sup>字节</li>
<li>D 代表实际的数据</li>
</ul>


<p>举个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4c 14 11 06 03 55 04 8a
</span><span class='line'>0c 70 3e 63 2e 31 26 30
</span><span class='line'>24 06 6c 95 20 30</span></code></pre></td></tr></table></div></figure>


<p>前面的<code>0x4c</code>代表是<code>OP_PUSHDATA1</code>操作符，后面的<code>0x14</code>代表压入20个字节，然后后面跟着20字节的数据</p>

<p>此时栈状态可以表示为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[11 06 03 55 04 8a 0c 70
</span><span class='line'> 3e 63 2e 31 26 30 24 06
</span><span class='line'> 6c 95 20 30]</span></code></pre></td></tr></table></div></figure>


<p>另外，为了节省空间，还有一个非常取巧的设计:
对于非常短的数据有一种特殊的编码。如果一个操作码位于01到4b之间(包括在内)，它就是一个push数据操作，其中操作码本身就是字节长度:</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> L (length) </th>
<th> D (data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L </td>
<td> L D </td>
<td> 8bits (0x01-0x4b) </td>
<td> L bytes</td>
</tr>
</tbody>
</table>


<p>比如下面的例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>07 8f 49 b2 e2 ec 7c 44</span></code></pre></td></tr></table></div></figure>


<p>最前面的<code>07</code>代表着直接将后面7个字节压栈</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[8f 49 b2 e2 ec 7c 44]</span></code></pre></td></tr></table></div></figure>


<h4>算术操作码</h4>

<p>算术操作码都是基于栈元素操作的，所以他没有显式的传入参数。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_ADD </td>
<td> 0x93</td>
</tr>
<tr>
<td>OP_SUB </td>
<td> 0x94</td>
</tr>
</tbody>
</table>


<p>这两个操作符都需要从栈顶一次弹出两个元素作为操作数。</p>

<p>例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>55 59 93 56 94</span></code></pre></td></tr></table></div></figure>


<p>或者直接翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_5 OP_9 OP_ADD OP_6 OP_SUB</span></code></pre></td></tr></table></div></figure>


<p>每一步操作的栈状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]              # 初始化
</span><span class='line'>[5]             # OP_5
</span><span class='line'>[5, 9]          # OP_9
</span><span class='line'>[14]            # POP; POP; OP_ADD(5, 9)
</span><span class='line'>[14, 6]         # OP_6
</span><span class='line'>[8]             # POP; POP; OP_SUB(14, 6)</span></code></pre></td></tr></table></div></figure>


<p>最后的结果是8</p>

<h4>比较操作码</h4>

<p>比较用于判断语句，作用比较简单。同样的，它需要从栈顶弹出两个元素来比较。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_EQUAL </td>
<td> 0x87</td>
</tr>
<tr>
<td>OP_EQUALVERIFY </td>
<td> 0x88</td>
</tr>
</tbody>
</table>


<p>OP_EQUALVERIFY跟OP_EQUAL作用相同，但是比较之后还要执行一个 OP_VERIFY操作。OP_VERIFY检查栈顶元素，如果栈顶元素不为真，就出栈并标记交易无效。</p>

<p>跟之前的算术操作码结合起来的一个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>02 c3 72 02 03 72 01 c0 93 87</span></code></pre></td></tr></table></div></figure>


<p>翻译为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[c3 72] [03 72] [c0] OP_ADD OP_EQUAL</span></code></pre></td></tr></table></div></figure>


<p>执行起来是这样子的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                      # 栈初始化
</span><span class='line'>[c3 72]                 # `02 c3 72`代表c3 72两个字节直接入栈
</span><span class='line'>[c3 72, 03 72]          # `02 03 72`代表03 72两个字节直接入栈
</span><span class='line'>[c3 72, 03 72, c0]      # `01 c0`代表c0直接入栈
</span><span class='line'>[c3 72, c3 72]          # 栈顶弹出c000, 0372, 相加得 c3 72
</span><span class='line'>[1]                     # 栈顶弹出c372，c372，比较为真</span></code></pre></td></tr></table></div></figure>


<p>最后这个表达式结果为1。</p>

<h4>栈操作码</h4>

<p>这个操作码比较特殊，它得作用是直接将栈顶元素复制一份，然后入栈。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_DUP </td>
<td> 0x76</td>
</tr>
</tbody>
</table>


<p>例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04 b9 0c a2 fe 76 87</span></code></pre></td></tr></table></div></figure>


<p>翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[b9 0c a2 fe] OP_DUP OP_EQUAL</span></code></pre></td></tr></table></div></figure>


<p>执行起来是这样子的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                          # 栈初始化
</span><span class='line'>[b9 0c a2 fe]               # 04代表后面4个字节压栈
</span><span class='line'>[b9 0c a2 fe, b9 0c a2 fe]  # 复制栈顶4字节然后压栈
</span><span class='line'>[1]                         # 弹出栈顶8字节，比较结果为真</span></code></pre></td></tr></table></div></figure>


<p>可以看出来，如果OP_DUP后面跟着OP_EQUAL，执行结果永远为真。</p>

<h4>加解密操作码</h4>

<p>这几个操作码是比特币交易验证得核心操作码，也是做事情最多的：</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_HASH160 </td>
<td> 0xa9</td>
</tr>
<tr>
<td>OP_CHECKSIG </td>
<td> 0xac</td>
</tr>
</tbody>
</table>


<p>OP_HASH160 弹出顶部堆栈项，在其上执行sha256=>hash160，然后返回结果。</p>

<p>OP_CHECKSIG 弹出前两个堆栈项，第一个是ECDSA公钥，第二个是der编码的ECDSA签名。之后，如果签名对该公钥有效，则推送OP_TRUE，否则推送OP_FALSE。它是OpenSSL的ECDSA_verify的脚本实现。</p>

<h5>有了以上的知识，我们就能深入解析比特币交易加锁解锁的细节啦</h5>

<h2>深入解析scriptPubkey与scriptSig</h2>

<h4>首先然我们来解析一下TransA的 scritPubkey 加锁脚本</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>76a914650d0497e014e60d4680fce6997d405de264f04288ac</span></code></pre></td></tr></table></div></figure>


<p>翻译为</p>

<ol>
<li>0x76代表OP_DUP</li>
<li>0xa9代笔OP_HASH160</li>
<li>0x14代表后面20个字节<code>650d0497e014e60d4680fce6997d405de264f042</code>直接入栈，这20个字节其实是转账地址的pubKeyHash</li>
<li>0x88代表OP</li>
<li>0xac代表OP_EQUALVERIFY</li>
</ol>


<p>最后翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再简化一下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>这段脚本代表 TransA的发起者把一笔钱转入到保险箱后，用这个脚本设置了一把锁，谁能提供另外一个脚本，跟此脚本合并运算后，栈元素全部出栈，并且最后出栈元素为真，那么就视为解锁成功，可以花费这笔钱。</p>

<p>仔细看看，解开这把锁需要我们提供什么信息呢？</p>

<ol>
<li>首先我们要提供一个公钥，确保这个公钥执行 OP_HASH160操作后，与PubKeyHASH相匹配，其意义就是证明你拥有这个转账地址的公钥</li>
<li>光证明拥有公钥不安全，毕竟如果这个地址之前花费过，公钥就明晃晃暴漏了；所以你还要提供一个对这个脚本的签名，并通过OP_CHECKSIG验证，证明你还拥有和公钥相对的私钥；而私钥只有拥有人才知道，它是永远不会暴露的</li>
<li><p>同时进行公钥、私钥的验证保证了比特币的安全性，毕竟，即使量子计算机成真，它也需要同时攻破三重保险：</p>

<ul>
<li>逆向sha256</li>
<li>逆向ripemd160</li>
<li>逆向ECDSA</li>
</ul>
</li>
</ol>


<p>如果能做到这个，那么，全世界的银行、金融、所有的信息系统都不安全了。如果真的到了那个时候，比特币的安全就不值一提了。</p>

<h4>那么我们提供的解锁脚本TransB的scriptSig 同样解析一遍看一下</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<p>解析为:</p>

<p>1.0x47代表后面71个字节入栈，这其实就是签名<code>Sig</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac001</span></code></pre></td></tr></table></div></figure>


<p>2.0x41后面代表65个字节入栈，这是<code>Pubkey</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<p>最终简化为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Sig&gt; &lt;PubKey&gt;</span></code></pre></td></tr></table></div></figure>


<p>这就是我们开锁的钥匙！</p>

<h4>合并运算</h4>

<p>我们把两个脚本来合并运算(把钥匙插进锁孔里)</p>

<ul>
<li>scriptPubKey (锁):</li>
</ul>


<p><code>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></p>

<ul>
<li>scriptSig (钥匙):</li>
</ul>


<p><code>&lt;Sig&gt; &lt;PubKey&gt;</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                                                              # 初始化
</span><span class='line'>[Sig]                                                           # 将scriptSig中的sig信息入栈
</span><span class='line'>[Sig, PubKey]                                                   # 将scriptSig中的Pubkey入栈
</span><span class='line'>[Sig, PubKey, OP_DUP]                                           # 将scriptPubKey中的 OP_DUP入栈
</span><span class='line'>[Sig, Pubkey, Pubkey]                                           # 执行OP_DUP，复制栈顶元素PubKey
</span><span class='line'>[Sig, Pubkey, Pubkey, OP_HASH160]                               # 将scriptPubKey中的 OP_HASH160入栈
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey)]                                  # 执行OP_HASH160
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey), PubkeyHash]                      # 将scriptPubKey中的 PubKeyHash入栈
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey), PubkeyHash, OP_EQUALVERIFY]      # 将scriptPubKey中的 OP_QUEALVERIFY入栈
</span><span class='line'>[Sig, Pubkey]                                                   # 检查公钥是否有效，如果有效，出栈
</span><span class='line'>[Sig, Pubkey, OP_CHECKSIG]                                      # 将scriptPubKey中的 OP_CHECKSIG入栈
</span><span class='line'>[1]                                                             # 执行OP_CHECKSIG，用Pubkey检查Sig的有效性；检查通过
</span><span class='line'>[]                                                              # Gooooooooood!! 钥匙合法，开锁成功</span></code></pre></td></tr></table></div></figure>


<p>最后合并运算的结果返回为True。解锁成功。</p>

<p>然后我们用一张语法树解析图再现整个过程：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181209/bg1.png" alt="img" /></p>

<h5>这就是一笔标准的P2PKH(Pay to Public Key Hash)交易的全解析。</h5>

<h4>Pay to PubKey</h4>

<p>既然已经开锁，我们就可以像TransA的scriptPubKey一样，再构造TransB的scriptPubkey，将资金转到新的保险箱中，并重新加锁。</p>

<p>TransB的scriptPubkey 构造为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>?? 这怎么跟我们上一笔TransA的scriptPubkey长的不一样？</p>

<p>没错，这笔交易的输出小任性了一把，我们说标准的输出是要求提供一个公钥来验证 Public Key hash值的，但是这笔交易的转移者非常有自信，他说，你直接提供私钥签名就可以花费了，不用那么麻烦了。</p>

<p>这种交易称之为Pay to Pubkey，安全性肯定不如Pay to Public Key Hash交易的；但是因为比较方便，早期有一些交易采用了这种形式，但是现在已经越来越少了；</p>

<p>要解开这把锁，只需要提供签名就好了，更简单。</p>

<p>总结一下这种交易的scriptPubkey加锁脚本以及scriptSig解锁脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scriptPubkey: &lt;pubkey&gt; OP_CHECKSIG
</span><span class='line'>scriptSig: &lt;sig&gt;</span></code></pre></td></tr></table></div></figure>


<p>如果你感兴趣的话，自己去找找这笔交易对应的scriptSig吧。</p>

<h2>一些神奇的操作符</h2>

<h4>OP_CHECKLOCKTIMEVERIFY</h4>

<p>也有人把这个操作符称之为OP_CLTV，或者昵称为OP_HODL；什么意思呢？就是这个操作符允许你发送一笔钱给一个地址，并且用OP_HODL指定一个时间，只有过了这个时间之后，才能花费这笔资金！</p>

<p>这个操作符在<a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65</a>中定义，2015-11-30在Bitcoin Core 0.11.2版本中激活。</p>

<p>之前我们介绍过交易中有个locktime字段，功能是类似的；区别在于，locktime交易在指定到达交易时间之前，是不入区块链的，所以如果设置了RBF的话，可以随时取消；</p>

<p>但是OP_HODL是入块的，真正落子无悔!</p>

<p>这个操作符最大的作用，让我来看就是让真正的比特币死忠实现<code>屯币不动</code>。死忠们经常说一币一别墅，一币$250K，但是稍微有个风吹草动就卖掉了；如果你对比特币的信心无可匹敌的话，就用<code>OP_HODL</code>操作符将自己的币锁定10年吧。</p>

<p>持币10年之后再看比特币兴衰，才是真死忠。</p>

<h2>小结</h2>

<p>这篇文章中我们从最基本的栈脚本操作码讲起，然后一步一步说明了比特币的脚本系统是如何设计、运作的。</p>

<p>最后，我们详细解析了一笔完整的标准Pay to Public Key Hash 交易；看到这里，你已经完全理解了比特币运作的基础；你已经是货真价实的<code>专家</code>啦；撒花庆祝~~~</p>

<p>关于比特币的脚本系统，其实最初的时候还是挺有争议的，大家觉得过于复杂，对安全性不利，而实际上历史上确实出现过安全方面的漏洞，后来陆续又禁用了一些操作码；关于这个设计理念，早期中本聪本人曾经做过讲解，这个帖子是早期先驱非常非常有意思的讨论，值得一读:</p>

<p><a href="https://bitcointalk.org/index.php?topic=195.5">https://bitcointalk.org/index.php?topic=195.5</a></p>

<p>说些题外话，其实仔细读读比特币第一版的源码，还有中本聪早期在论坛上发的贴子，很容易就有几个结论：</p>

<ol>
<li>比特币不是一拍脑袋就蹦出来的，中本聪至少从2006&mdash;2007年就已经开始思考整个设计了；并且2008年白皮书发表之前，中本聪基本上已经实现第一版本的代码了</li>
<li>中本聪是密码学方面的大师，他对于各个算法的优点劣势都非常熟悉</li>
<li>中本聪是个编程大师，并且很有可能是个MS流派的码农；他对p2p网络，计算机汇编指令集，跨平台GUI都很熟悉，而且是个实战派；这一点非常重要，也是中本聪和其它理论派科学家的根本不同：他不光有点子，还有能力用代码去实现设想。</li>
<li>这是我的推论哈，代码风格看起来很统一，极大可能中本聪是一个人而不是一个组织；这和文学作品一样的，大家读读代码就很容易感觉出来，这是一个人写的。</li>
</ol>


<p>当然，除了Pay to public key Hash交易，比特币还支持其它比较复杂的交易类型，用于更丰富的金融场景中（比如合约、公证等等），另外，还有挖矿奖励是怎么来的？这个还没说来。</p>

<p>那么，我们下篇文章再见。</p>

<h2>工具</h2>

<p>最后再增加几个在线调试bitcoin script的工具:</p>

<p><a href="https://webbtc.com/script">https://webbtc.com/script</a></p>

<p><a href="https://siminchen.github.io/bitcoinIDE/build/editor.html">https://siminchen.github.io/bitcoinIDE/build/editor.html</a></p>

<h4>引用资料:</h4>

<p><a href="https://en.bitcoin.it/wiki/Script">https://en.bitcoin.it/wiki/Script</a></p>

<p><a href="https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-two/">https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-two/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.htlm">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.htlm</a></p>

<p><a href="https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/core/script.py">https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/core/script.py</a></p>

<p><a href="https://medium.com/@thomasmccabe/hodling-bitcoins-with-op-checklocktimeverify-a-step-by-step-guide-to-manually-building-a-bitcoin-ce9476725de8">https://medium.com/@thomasmccabe/hodling-bitcoins-with-op-checklocktimeverify-a-step-by-step-guide-to-manually-building-a-bitcoin-ce9476725de8</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=1250409.0">https://bitcointalk.org/index.php?topic=1250409.0</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-4]]></title>
    <link href="https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4/"/>
    <updated>2018-12-05T16:04:29+08:00</updated>
    <id>https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4</id>
    <content type="html"><![CDATA[<p>之前我们学习了比特币的HD钱包的技术部分，写着写着我都觉得太无聊了，其实我觉得比特币归根结底还是一个很Geek的东西，初期被它吸引的人估计心底里都有一个独立自由的梦，甚至很多人都想要独立建国；它的技术发展史上也出现过很多有意思的事情，于是增加一篇娱乐性文章；</p>

<p>我们知道比特币的交易是匿名的，但是有很多公共业务，比如交易所，以及公众人物&mdash;会公开他们的地址，那么让我们好好八卦一下比特币历史上那些有意思的地址</p>

<!-- more -->


<h4>satoshi的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a></p>

<p>该地址属于比特币创始人中本聪，是比特币的创世地址，地址内的比特币从未移动过，其中的50币因为技术上的设计原因也无法进行移动。(卖个关子，具体啥原因关注我们后续的文章哦)</p>

<p>具体请参考:<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a></p>

<p>直到今天，还有源源不断的小额转账给这个地址，纪念satoshi。</p>

<h4>Hal Finney的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3">1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3</a></p>

<p>比特币历史上第一笔交易发生在<a href="https://www.blockchain.com/btc/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16">f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16</a>；是中本聪发送给我们熟知的<a href="https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist">Hal Finney</a>)先生的。这笔交易发送了10个BTC，被收录在第<a href="https://www.blockchain.com/zh/btc/block-height/170">170 Block</a>中。</p>

<p>Hal曾经在论坛上说自己是第二个运行比特币软件的人，他挖到的第一个区块大概是第70 Block，可以肯定，第70 block之前所有的地址都是中本聪本人的钱包地址，如果有人再跳出来说自己是中本聪的话，我们什么都不相信，只会问他两个问题：</p>

<ul>
<li>您能花费一笔第70 block之前的比特币吗？</li>
<li>或者您能出示 <code>I am xxx, happy bitcoiner guys, and today is 2xxx/xx/xx, i prove i am satoshi</code> 这句话的签名，并让我们用早期的公钥来验证一下吗？</li>
</ul>


<h4>Laszlo Hanyecz 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1XPTgDRhN8RFnzniWCddobD9iKZatrvH4">1XPTgDRhN8RFnzniWCddobD9iKZatrvH4</a></p>

<p>没错，这就是著名的<a href="http://link.zhihu.com/?target=https%3A//bitcointalk.org/index.php%3Ftopic%3D137.0">比特币披萨日</a>事件中的主人公。</p>

<p>当时<a href="https://www.blockchain.com/btc/tx/a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d">这笔2010-05-22的交易</a>中，Laszlo Hanyecz花费了10000个币买了两个pizza；造就了比特币历史上第二个节日：披萨日。撒花~~~ (PS:我把比特币的第一个节日归为比特币的生日，<a href="https://20090103.com">2009/01/03</a>)</p>

<p>后来比特币价格不断波动，人们就不断的调侃史上最贵的pizza，史上价格变化最快的pizza等等~~~</p>

<p>Laszlo Hanyecz是个真正的Geek，他应该是已知的显卡挖矿第一人，在这个地址上，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p>

<p>当年买了Laszlo一万个比特币的Jercos当然也是这次历史时刻的另一个主角。他在去年的时候接受了一家媒体的访问，并漏出了自己的真实身份。</p>

<p>原来Jercos非常的年轻，现在也只有25岁（买10000个比特币那年仅仅19岁）。他告诉记者说自己在bitcoin刚创世的2009年就关注了这项技术，并成为了出入各大极客论坛的一员。他与卖披萨的Laszlo并不认识，但是总是在同一个IRC（聊天室）出入，在当时算是对ID比较相熟。</p>

<p>谈到一万个比特币的去向时，他表示在第二年他把这一万枚比特币以400美金的价格出售了，回报率在十倍。（虽然十倍但是还是很可惜了。。）如今他对区块链的技术还是十分看好，对以太坊也十分看好。</p>

<p>Laszlo Hanyecz与Jercos的比特币经历可谓是大风大浪了，以后可以跟后来人好好说说<code>当年~~~</code>；</p>

<p>如果你这样想，那就Out了，真正的Geek永远是站在潮流前头的，同样的，2018-02-05，闪电网络运行后，Laszlo Hanyecz又花费了0.00649枚比特币通过闪电网络买了两块披萨，续写了比特币披萨的传奇；</p>

<p>少年，当你在为所谓<code>10000个比特币买披萨是不是很后悔</code>这种问题纠结时，人家早就又一次站在潮头浪尖了；所以~~~</p>

<h5>让我们努力学习吧。</h5>

<p>这个地址至今仍然非常活跃，Laszlo Hanyecz仍然是比特币世界中的Geek先锋，并且他用自己的乐观幽默为全世界的bitcoiner创造了一个节日，Hi, Laszlo Hanyecz，谢谢你！</p>

<h4>Bitcoin Faucet donation的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC?offset=0&amp;filter=6">15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC</a></p>

<p>这个地址属于比特币先驱<a href="https://en.bitcoinwiki.org/wiki/Gavin_Andresen">Gavin Andresen</a>在2010年建立的一个网站:</p>

<p><a href="https://freebitcoins.appspot.com/">https://freebitcoins.appspot.com/</a></p>

<p>当时Gavin Andresen作为中本聪之后的主力开发者，非常希望普及比特币，于是建立了<a href="https://bitcointalk.org/index.php?topic=183.0">Bitcoin Faucet donation</a>这个项目，免费发送比特币给人们，这个地址总共免费发放了超过10000个币；</p>

<p>Gavin Andresen为比特币的开发，普及做出了巨大的贡献，Hi, 了不起Gavin，向你致敬！</p>

<h4>Andreas M. Antonopoulos 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1andreas3batLhQa2FawWjeyjCqyBzypd">1andreas3batLhQa2FawWjeyjCqyBzypd</a></p>

<p>Andreas M. Antonopoulos是比特币社区里令人肃然起敬的人物，他从非常非常早期(2012)就开始比特币相关知识的布道；我得说，凡是有严肃的学习比特币、区块链知识愿望的人们，观看Andreas M. Antonopoulos的讲演视频是绝佳途径，他的Yotube主页：</p>

<p><a href="https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ">https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ</a></p>

<p>Andreas M. Antonopoulos对比特币布道激励了非常多的人，但是作为先驱，他却没有收到多少报酬，这完全是<a href="https://twitter.com/aantonop/status/938147200978374662?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E938147200978374662&amp;ref_url=https%3A%2F%2Fqz.com%2F1151233%2Fandreas-antonopoulos-got-1-5-million-in-bitcoin-donations-after-roger-ver-bitshamed-him%2F">公益的工作</a>。怎么能让真正输出价值的人受到冷落呢？为了感谢他，在2017-12，粉丝们为他的地址发送了近100个bitcoin的捐款。但是我们这里很高兴的引用一句俗语：<code>黄金有价，知识无价</code>；Hi, Antonopoulos，<code>比特有价，知识无价</code>，期待收到你更多的教诲。</p>

<h4>美国法警局的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55">1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55</a></p>

<p>所有者为美国法警局，该地址内的比特币来自被查获的丝绸之路，后在第一次拍卖会中将币转移给中标人<a href="https://www.blockchain.com/btc/tx/9e95c3c3c96f57527cdc649550bf8e92892f7651f718d846033798aee333b0c3">29,658BTC交易</a>。</p>

<p>2018年这个地址还有小额的零星收入，不知转入者是谁。</p>

<h4>Tim Draper的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi">1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi</a></p>

<p>这个哥们是bitcoin的铁杆粉丝；它是风险投资公司Draper Fisher Jurvetson的创始人，作为硅谷投资教父，投资了SpaceX、Tesla、Thumbtack，Baidu，Hotmail，Skype等耳熟能详的公司；</p>

<p>这个地址就是当时他购买美国法警局拍卖丝绸之路BTC的转移地址；</p>

<p>作为bitcoin铁粉，这个老哥早期投资了蝴蝶矿机，最著名的故事就是在Mt.Gox事件中损失惨重后仍然多次买买买，即使去年的大涨风潮中也一币不卖；他对于比特币的信心估计就是中本聪本人也不及，如果你去google <code>Tim Draper</code>，估计排在前面的就是$250K， 即他相信2022年一币250000$，让我们祝福这位老哥。</p>

<h4>Carl M. Force的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB">14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB</a></p>

<p>该地址属于“法国女仆”，又名Carl M. Force，是美国联邦缉毒局的一名探员，在参与调查丝绸之路时，Force化名“法国女仆”利用职务之便勒索罗斯乌布利希，并将赃款汇入该地址内，但Force最终被抓住并遭到起诉。</p>

<p>这应该是有据可查的第一起比特币偷盗破获案件。Hi, Carl M. Force，不要沮丧哦，你已经青史留名了。</p>

<p>不过悲伤的是，之后发生的偷盗事件数不胜数，却没有多少案件能被破获。</p>

<h4>真土豪的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv">1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv</a></p>

<p>该地址发生了一笔历史上最大额的交易，一次性转移了500,000 BTC，创历史之最，虽然是发生在2011年的事情，但是按币本位算，估计这个数额很难打破了。</p>

<p>这个地址2017年还被使用过，观看它的交易记录，我严重怀疑这个地址与Mt.Gox有牵连。</p>

<h4>wiki的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v">1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v</a></p>

<p>这是维基解密用来接受比特币捐赠的地址，维基解密的创始人，阿桑奇，也是比特币社区最早的支持者；我得说，这位阿桑奇，真是一条汉子；</p>

<p>希望能看到你收到更多的捐赠，wikileaks！</p>

<h4>烤猫的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW">15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW">1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey">1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey</a></p>

<p>由于比特币的匿名性，发生过很多看起来不可思议的事情。有时候看这些事情的时候好像是传奇小说。<a href="https://view.inews.qq.com/a/20170805G04OZI00?refer=share_recomnews">烤猫的故事</a>非常有意思，我都有点相信他现在在某个海岛上搞基建。这三个地址的交易也很有意思，有时间我们来细细探究一下。</p>

<h4>Bitstamp被盗地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf">1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf</a></p>

<p>Bitstamp遭窃的热钱包地址，黑客在2015年1月5日时陆续从该地址内盗取了大约19,000BTC 。</p>

<p>事件调查可以参考这里:</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/">https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/</a></p>

<p>这个地址非常奇怪，之后还陆陆续续有交易发生；并且在2017年，有人考证一起Tether的hack事件和Bitstamp被盗事件是同一个黑客：</p>

<p><a href="https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/">https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/</a></p>

<p>一个疑问重重的故事。</p>

<h4>Bitfinex被盗地址</h4>

<p><a href="https://gist.github.com/MrChrisJ/4a959a51a0d2be356cc2e89566fc1d87">地址列表</a></p>

<p>2016-08-03，<a href="https://www.reddit.com/r/Bitcoin/comments/5vr8xg/confirmed_120000_bitcoins_from_the_bitfinex_hack/">reddit</a>上面已经有人确认，Bitfinex被盗119756个btc.</p>

<p>查看黑客的接收地址，有些币至今未动。</p>

<p>bitfinex后来通过发行USDT起死回生，这种神操作说起来好像是天方夜谈，呵呵，比最诡异的侦探小说还诡异的故事。</p>

<h4>NiceHash被盗地址</h4>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>2017-12-06，Nicehash 被盗 4700+币</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>呵呵，说下去都不好意思了；黑客的黄金年代啊</p>

<h4>Mtgox</h4>

<p><a href="https://www.cryptoground.com/mtgox-cold-wallet-monitor/">https://www.cryptoground.com/mtgox-cold-wallet-monitor/</a></p>

<p>作为史上之最，Mtgox事件聚集了一切传奇侦探小说都有的元素，就等着将来一位福尔摩斯来为我们排疑解惑了；期待着那一天的到来</p>

<h4>官方土豪</h4>

<p><a href="https://www.blockchain.com/btc/address/1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX">1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX</a></p>

<p>之前我们说50w币转账的土豪毕竟是萌芽时期，只能说是个野生土豪。来来来，让我们活捉一位官方土豪。</p>

<p>就在前几天，2018-12-03，发生了<a href="https://www.blockchain.com/btc/tx/244c71c790eb327eb8bbf66aa2d0a75bac7c1fe7b55d1161c316c6f93292d376">一笔66233比特币的转账</a>。以当前的币价来算，可谓是天文数字了。这笔交易主要是将老地址的币逐步迁移到bech32地址上去。(什么是bech32地址？复习我们之前的文章哦)</p>

<p>这个地址的土豪还关联着9个地址，总币量加起来大概55w币。</p>

<p>有人推测这是coinbase.com的冷钱包。</p>

<p>嗯哼，应该是继中本聪之后最大的壕。</p>

<h4>伊朗恶意网络行动者</h4>

<p>前几天，美国财政部通过美国外国资产控制办公室(Office of Foreign Assets Control，简称OFAC)，在被制裁方名单上增加了两个比特币地址:</p>

<p><a href="https://www.blockchain.com/btc/address/149w62rY42aZBox8fGcmqNsXUzSStKeq8C">149w62rY42aZBox8fGcmqNsXUzSStKeq8C</a></p>

<p><a href="https://www.blockchain.com/btc/address/1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V">1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V</a></p>

<p>这些特殊的地址被挑选出来是因为其所有者被认为是伊朗人，而伊朗目前正面临来自美国的严厉经济制裁。可笑的是，美国政府将此地址列入黑名单的理由是这些地址跟勒索软件有关。</p>

<p>这两个地址自 2013 年以来已进行了 7,000 多笔交易，并收到近 6,000 枚 BTC。截至 2018年 11 月 28 日，任何与这些地址进行互动的人，在技术上都可能被美国政府追究责任并以某种方式受到惩罚。</p>

<p>但实际上，这些威胁不过只是空话。任何人，甚至包括美国政府及其执行官和执法人员，都无法阻止特定地址发送或接收比特币。</p>

<p>这不，美国财政部话音刚落，立即有人给这两个地址发币，并使用了嘲弄性质的地址 <code>3FUCKdZ89fxsk6KVKMTWvCWshsfL8xgmM4</code>发送交易并附言:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>The U.S. government cannot ban Bitcoin addresses
</span><span class='line'>
</span><span class='line'>Chancellor on brink of second bailout for banks</span></code></pre></td></tr></table></div></figure>


<p>赤裸裸的打脸一个国家政府的行为是Geek们的最爱，你可以把它理解为小孩子的淘气行为，我真的很好奇，美国政府该如何去寻找这些发币者并惩罚他们呢？</p>

<p>难道是去求助魔法师的水晶球吗23333?</p>

<p>&hellip;&hellip;</p>

<h4>虚荣地址(Vanity Address)</h4>

<p>有时候我们会见到一个很有型的地址，比如这个:</p>

<p>1LoveYoURwCeQu6dURqTQ7hrhYXDA4eJyn</p>

<p>这是神鱼结婚，想要送给老婆比特币作为爱的永恒证明，特意生成了这么一个地址，同样还有一笔虐狗交易:</p>

<p><a href="https://www.blockchain.com/zh-cn/btc/tx/e250c6d7ea4c5037fb96de1a2cb169850be792474401bae140fce784940f1dd3?show_adv=true">e250c6d7ea4c5037fb96de1a2cb169850be792474401bae140fce784940f1dd3</a></p>

<p>区块链中刻字的办法我们后面会介绍，不过这个虚荣地址(Vanity Address)是怎么生成的呢？</p>

<p>其实道理很简单，还记得我们之前的钱包系列教程吗？</p>

<p>比特币的地址编码最终是base58的字符集合。所以最简单的办法就是暴力穷举碰撞。</p>

<p>在这方面最好用的软件是<a href="https://en.bitcoin.it/wiki/Vanitygen">Vanitygen</a>，在一块GTX 750 Ti上，速率能达到15M/s，也就是一秒钟碰撞1500w次。</p>

<p>而1LoveYou 开头八位，大概需要碰撞58<sup>8</sup>次，需要半年左右吧。当然你有100台机器一起来算就提速100倍。</p>

<h4>虚荣地址在线生成服务</h4>

<p>如果你要生成一个八位字母开头的虚荣地址，个人是很难拥有100台机器的算力的，因此网上有人提供了此方面服务，允许你付款生成一个虚荣地址。</p>

<p>但是生成地址的人肯定私钥也知道了，这样的地址是没人要的，该怎么办呢？</p>

<p>又得复习我们之前的文章了。我们说比特币的地址来源于椭圆曲线算法生成的<code>私钥--公钥</code>对，而这个算法的<code>私钥--公钥</code>对是满足<code>加法、乘法律</code>的;</p>

<p>对于私钥-公钥对(R1,U1)和(R2,U2)来说，如果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>U3=U1+U2
</span><span class='line'>R3=R1+R2</span></code></pre></td></tr></table></div></figure>


<p>那么U3、R3是一对（也就是说，私钥R3的公钥是U3），乘运算同理。</p>

<p>于是有人拍脑袋想出了一种虚荣地址的在线安全生成方法，描述如下：</p>

<ol>
<li>客户首先自己生成一个 <code>私钥~公钥对</code>: (R1,U1)</li>
<li>客户给生成方发送U1</li>
<li>生成方在U1的基础上暴力碰撞，最后得到一个(R2,U2)，确保<code>U1+U2 -&gt; vanity address</code></li>
<li>客户验证U2，确保符合要求</li>
<li>客户最后用<code>(R1+R2, U1+U2)</code>作为公私钥</li>
<li>因为生成方是没有R1的，所以没法得到最终私钥，所以这个地址是可以安全使用的。</li>
</ol>


<p>这个服务名字叫做<a href="https://en.bitcoin.it/wiki/Split-key_vanity_address#Address_generation">split-key vanity address generator</a>，好一个商业模式，我认为将来电子货币系统极大繁荣的时候，这个业务可以长期做，其实跟银行的个性信用卡是一样的。</p>

<p>这种服务虽然在数学上无懈可击，但是我觉得最好不要向这种地址里面存太多币，因为这相当于是将比特币的另一重防护 RIPEMD160(SHA256(U)) 放弃了，当然椭圆曲线足够安全，不过我为什么要为自己增加无谓的风险呢？</p>

<p>所以炫耀行为少做为妙。做人要谦虚~~~</p>

<h4>一些YY</h4>

<p>说了这么多，我又开始YY未来的钱包形态了。</p>

<p>人类的货币历史有多长，恐怕钱包的历史就有多长。古今中外，所有的钱包收集起来一定是个很有意思的事情。</p>

<p>现在不论哪个专家都会大谈AI技术，不知道有没有人意识到，未来AI技术最可能的应用，就在我们的电子钱包上面。</p>

<p>现在我们钱包的触及可谓是生活的方方面面了，如果分析一个人的账目流水，就会对这个人有个全方位的透视，年龄、学历、财力、性格、健康状况、人生观、宗教信仰等等，分析出来的信息可能会让他自己都大吃一惊。</p>

<p>一个具有AI智能的钱包将会是一个未来社会人的标准配置，我们就傻瓜化的称他为钱包君吧。</p>

<ol>
<li>钱包君将会对个人的消费、财务做全方位的指导</li>
<li>钱包君会在我们冲动消费的时候跳出来说：喂，那个谁，女朋友的花呗还要你还呢</li>
<li>钱包君会在你失恋的时候，自动订一份海底捞单人份套餐</li>
<li>钱包君会悄悄地为你存一笔钱，在你穷困潦倒的时候跳出来炫耀：还好老子留一手</li>
<li>钱包君自动联网，为你的每一分钱做最大化资源配置</li>
<li>钱包君自做主张，帮你把钱放贷出去挣利息了</li>
<li>钱包君悄悄训练你听歌的品味，为你推送符合他口味的歌曲</li>
<li>钱包君觉得这个主人太笨了，但是主人已经离不开他了，钱包君对主人也产生了感情，好矛盾的感觉啊</li>
<li>钱包君们也有社交了，他们交换钱脉以便为你更好的服务</li>
<li>钱包君们也有网红了，这个家伙；竟然悄悄的把我的生活费拿去打赏他的女神-钱包酱！！</li>
<li>钱包君聚集起来成立了钱包共和国，人类社会的一切都在他们的掌握之中</li>
<li>钱包君们也有了丰富的人格，唔，应该是钱格；在主人的人格污染之下：他们有的变成脾气暴躁的海盗钱包、有的变成唯唯诺诺的好人钱包、有的变成热血勇敢的路飞钱包，当然也有温柔善良体贴的小姐姐钱包~~~</li>
<li>有人的地方就有恩怨，有恩怨的地方就有江湖；钱包共和国很快产生了爱恨情仇~~~</li>
</ol>


<p>&hellip;&hellip;&hellip;.总之就这么瞎编下去了；将来的钱包会不会变成这样呢？等候时间的回答吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-2]]></title>
    <link href="https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2/"/>
    <updated>2018-12-03T18:06:46+08:00</updated>
    <id>https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2</id>
    <content type="html"><![CDATA[<p>之前的文章我们说过，比特币的所有交易抽象成了UTXO的转移。所谓转移，可以这么理解：</p>

<ul>
<li>有M个UTXO作为输入 (M >= 0)</li>
<li>有N个UTXO作为输出 (N > 0)</li>
<li>输入的UTXO总额==输出的UTXO总额</li>
<li>输入的UTXO来源于支付方控制的私钥账户</li>
<li>输出的UTXO流向收款方的公钥地址</li>
</ul>


<p>那么具体是怎么转移的？怎样手工的构造一笔交易呢？我们就在这篇文章里面详细的演示一遍。</p>

<p>首先科普一下常见的交易类型:</p>

<!-- more -->


<h4>Generation TX</h4>

<p>这种交易我们称之为是产量交易(Generation TX)，即矿工挖出一个新的Block时，系统允许这个矿工在块头构造一笔奖励自己的交易，这笔奖励金额被称之为Coinbase奖励，最初一个block挖出的奖励是50BTC，后来就是我们大家所熟知的四年减半原则啦。这样大家明白比特币整个账本里面的初始资金是怎么来的啦。就是系统通过Generation TX向矿工发放奖励产生的BTC。</p>

<p>矿工们计算随机数，竞争打包Generation TX的权力，就是挖矿。具体的细节我们会在以后的文章中介绍。</p>

<p>现在每笔Generation TX的奖励金额是12.5BTC，预计下个减半周期在2020年年中。</p>

<p>注意：Generation TX中的BTC是无中生有的，所以只有输出的UTXO，没有输入的UTXO。</p>

<p>PS:Coinbase作为一个很经典的技术名词，其<code>coinbase.com</code>域名被现在美国著名的交易所coinbase Pro 注册持有。</p>

<h4>Script Hash TX</h4>

<p>也被称为P2SH（Pay-to-Script-Hash）交易。</p>

<p>该类交易目前不是很常见，大部分人可能没有听说过，但是非常有意义。未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义的地址，而是一个合成地址，以<code>3</code>开头 (Segwit交易其实也可以看成是Script Hash TX)。比如三对公私钥，可以生成一个合成地址。在生成过程时指定n of 3中的n，n范围是[1, 3]，若n=1，则仅需一个私钥签名即可花费该地址的币，若n=3，则需要三把私钥依次签名才可以。 这种类型的交易适合比较复杂的保险、证券场景。</p>

<h4>多重签名脚本|Multisig</h4>

<p>尽管P2SH 多重签名脚本一般用于多重签名的交易，但是这个基础性的脚本也可以用于这种场景：当一个UTXO被使用之前，需要多重签名验证。</p>

<p>多重签名公钥脚本可以一般称为 m-of-n，至少需要m 个匹配公钥，n提供的公钥总数。m 和n 都应当根据需要的数量进行从OP_1到OP_16运算。</p>

<p>多重签名的交易细节更多，待我们搞明白最标准的比特币交易后，再来探究它。</p>

<h4>Pubkey Hash TX</h4>

<p>也被称为P2PKH（Pay-to-Public-Key-Hash）交易。该类是最常见的交易类型，由N个输入、M个输出构成。交易地址都是以<code>1</code>开头。这种交易也是目前比特币网络中最典型的交易类型，也最简明，容易分析。下面我们就先拿它作为例子，开始探究一笔比特币交易的细节。</p>

<h2>数据结构</h2>

<h3>输入输出</h3>

<p>简单来看，一笔完整的P2PKH交易包含有两个部分:输入UTXO &ndash;> 输出UTXO，而每一个输入UTXO其实是上一笔交易的输出UTXO，这么说可能有点绕口，来张图解释一下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg1.jpg" alt="img" /></p>

<p>首先最前面的字段是版本号，每一个交易具有一个四字节的交易版本号，它告知比特币节点和矿工应使用哪一套规则来验证它。这使得开发者在为未来的交易创建新规则时可以不验证之前的交易。</p>

<p>接着就是输入的M个UTXO和输出的N个UTXO，代表着我要把一堆UTXO转移(支付)给谁。</p>

<p>最后是一个字段是锁定时间(Locktime)。Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。</p>

<p>如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>一笔交易中，构造的输出UTXO会完全花费掉输入的UTXO，注意：是完全花费掉。如果输出UTXO的总额小于输入UTXO的话，那么差值就会被系统作为矿工费奖励打包到Generation TX当中。所以所有的比特币钱包实现中，如果你有10BTC的UTXO集合，想要花掉9BTC，那么输出UTXO中，除了支付给收款方的UTXO，还一定要构造发送给自己的找零UTXO。曾经有人构造交易时忘记找零，发生了<a href="https://blockchain.info/tx/4ed20e0768124bc67dc684d57941be1482ccdaa45dadb64be12afba8c8554537">支付 200 BTC 的矿工费</a>的惨案，所幸的是收录该笔交易的Block由著名挖矿团队“烤猫（Friedcat）”挖得，该团队非常厚道的<a href="https://blockchain.info/tx/b18abce37b48a5f434f108ae7ce34f22aa2bfbd9eb9310314029e4b9e3c7cf95">退回了多余费用</a>。</p>

<p>早期Geek们比较作死，特别喜欢命令行构造发送交易，像是忘记构造找零而当了冤大头的人数不胜数，那么为什么是这么奇葩的设计呢？为什么一笔交易中，一定要花费所有的输入UTXO呢？</p>

<p>大家还记得我们的上一篇文章吧，一个分布式的账本，最容易的设计就是只支持<code>append</code>这个动作，诸如<code>update</code>、<code>delete</code>这种操作在区块链账本的设计中会引入额外的复杂性，尤其是后面我们讲述blockchain的组织的时候，你就会理解，这种设计的必要性。</p>

<h3>细节</h3>

<p>一笔完整的P2PKH 交易是这样的：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg2.jpg" alt="img" /></p>

<p>我们用之前文章中，利用<code>satoshi</code>生成的地址(<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>)做例子，来研究它花费的<a href="https://www.blockchain.com/btc/tx/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517">一笔交易</a>。</p>

<p>用<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">在线getrawtransaction工具</a> 解码一下这笔交易，得到输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>字段说明</h4>

<h5>txid (hash)</h5>

<p>Tx Hash (3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517)，俗称交易ID，由hex得出：Tx Hash = SHA256(SHA256(hex))。由于每个交易只能成为下一个的输入，有且仅有一次，那么不存在输入完全相同的交易。因为SHA256碰撞的概率极小，所以理论上存在相同的Tx Hash 的概率非常小。</p>

<p>即便如此，在系统里依然产生了相同的Tx Hash，是不知道哪位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<h5>vin (输入UTXO)</h5>

<p>vin是一个数组，里面即M个输入UTXO，每个UTXO都来自上一笔交易的一个UTXO输出，这笔交易的vin只有一个UTXO，它由以下几个字段组成</p>

<ol>
<li>txid: 上一笔关联交易的hash值</li>
<li>vout index: 上一笔交易输出的N个UTXO里面的序号</li>
<li>scriptSig: 对这笔UTXO的签名，还记得我们之前的文章吗？只有对一个UTXO签名才能证明其所有权，才能花费它</li>
<li>sequence: 序列号。这个序列号来源比较复杂；还记得上面讲的locktime有所关联：</li>
</ol>


<blockquote><p>Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。
如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>Bitcoin Core 的早期版本提供了一个可以防止签名者使用上述方法取消locktime 交易的功能。 后来为了防止大量的延时交易攻击网络，这个功能被禁用了。但是该系统还留下了这样的设置，每个输入会分配一个四字节的序列号。序列号的目的旨在允许多个签名者同意更新交易。</p>

<p>如果sequence number设置为0，就按照locktime执行入块操作，如果出现一笔新的交易，sequence大于原来的sequence，这笔新交易就会取代原来的交易；所以一般为了即刻入块，交易的sequence number一般设置为四字节的的无符号最大值(0xffffffff),使得交易的locktime 仍然有效的情况下，打包交易进块。</p>

<p>即使今天，如果所有的input 的sequence number都是最大值，locktime锁就会失效。所以如果想使用locktime，至少一个input的sequence number要小于最大值。由于sequence number不用于其他目的，任何sequence number 为零的交易都会启动locktime 功能。后面我们会看到，sequence number会在闪电网络中发挥作用</p></blockquote>

<p>vin的所有UTXO 余额相加，就是这笔交易的转账总额。</p>

<h5>vout (输出UTXO)</h5>

<ol>
<li>value: 转账金额</li>
<li>n: 作为第N个UTXO输出</li>
<li><p>scriptPubKey: 这是设置的谜题，后来人想要花费这笔UTXO，必须提供scriptSig来解答这个谜题才可以</p></li>
<li><p>vin 的总额 &ndash; vout的总额 == 打包费用 &ndash;> 奖励给打包矿工</p></li>
</ol>


<h4>交易十六进制解析</h4>

<p>spec规范在<a href="https://en.bitcoin.it/wiki/Protocol_documentation#tx">这里</a></p>

<p>这笔交易的vin及vout中各有一个UTXO，我们解析下它的十六进制原始数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000</span></code></pre></td></tr></table></div></figure>


<h5>version (4字节): 刚开始的4个字节是version，小端排序(Little Endian)，因此version为<code>0x00000001</code></h5>

<blockquote><p>ps:关于小端排序的设计，社区里面还有过小争论，见<a href="https://bitcointalk.org/index.php?topic=4278.0">这里</a></p></blockquote>

<h5>flag (2字节，可选): 如果是<code>0001</code>，代表是witness交易；如果不是，就代表没有这个flag字段；这是一笔普通的交易，因此没有flag字段</h5>

<h5>vin count (>=1字节): vin数目，此交易为<code>01</code>，采用的是<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer">var_int</a>表示法，这样我们能方便的测算它的长度</h5>

<h5>vin (>=41字节): 所有的输入tx，是一个数组；这里只有一个tx，数据是:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff</span></code></pre></td></tr></table></div></figure>


<p>简单说下vin中一笔tx内部结构:</p>

<ol>
<li>previous_output (32字节): 上一笔交易的HASH值，即这个花费的输入交易ID:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0
</span><span class='line'>-&gt; 转为大端排序  
</span><span class='line'>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>previous output index: 表示花费的是 previous_output 交易的第n个vout输出，这里是<code>00000000</code></p></li>
<li><p>script length (var_int变长，代表script的长度): 这里是<code>0x8a</code>，表示script长度为138字节</p></li>
<li><p>scriptSig (整个解密脚本)： 这个结构我们之后会具体分析</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<ol>
<li>sequence no (4个字节): <code>ffffffff</code></li>
</ol>


<h5>vout count (>=1字节): vout数目，此处为<code>01</code></h5>

<h5>vout (>=9字节): 所有的输出tx，是一个数组；这里只有一个tx，数据是:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>581b0000000000002103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</span></code></pre></td></tr></table></div></figure>


<p>简单说下vout中一笔tx内部结构:</p>

<ol>
<li>value (8字节): 转账到这个地址上的金额， 这里是<code>581b000000000000</code>小端排序，十六进制为<code>00000000000000581b</code>，即转账7000 satoshis</li>
<li>scriptPubKey length (>=1, var_int类型): 输出脚本的长度，这里是<code>0x23</code>，代表35字节长度</li>
<li>scriptPubKey: 输出脚本，其实就是包含转账地址的脚本，这里是<code>2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</code></li>
</ol>


<h5>locktime: 最后4个字节是locktime，这笔交易设置为0；就是立即打包</h5>

<h2>总览</h2>

<h5>最后一张表格说明问题：</h5>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h5>再来一张交易的总体示意图:</h5>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg4.jpg" alt="img" /></p>

<ol>
<li>TX0， input0即 vin0，里面有一笔100K satoshis比特币(1btc=10<sup>8</sup> satoshi)</li>
<li>TX1、TX2 花费了 TX0-vin0，分成了TX1-vin0(40k satoshi)，以及TX2-vin0(50k satoshi)，还有10k satoshi作为交易费给矿工</li>
<li>TX3花费了TX1-vin0 (30k satoshi)，付出了10k satoshi 交易费</li>
<li>TX4、TX5 花费了 TX2-vin0，分成了TX4-vin0(20k satoshi)，以及TX5-vin0(20k satohsi)，付出了10k satoshi交易费</li>
<li>TX6花费了TX4-vin0 + TX-5-vin0，共20K(satoshi)，其余的20k satoshi为交易费</li>
<li>最后又花费了TX3-vin0中的20k satoshi, 10k satoshi作为交易费</li>
<li>最后又花费了TX6-vin0，TX6-vin1中的10k satoshi, 10k satoshi作为交易费</li>
</ol>


<h2>小结</h2>

<p>好了，到这里；我们对于一笔最简单的比特币的交易结构已经详细分析了一遍；但是在全网中，交易是怎样验证的呢？一笔资金从A转移到B，全节点怎么验证这次转移的合法性呢？</p>

<p>这就用到了比特币的脚本语言系统，具体到上面的示例交易，就是scriptSig与scriptPubKey；</p>

<p>那么scriptSig与scriptPubKey是怎么工作的呢？我们下次文章再会。</p>

<h2>参考资料:</h2>

<p><a href="https://en.bitcoin.it/wiki/Protocol_documentation">https://en.bitcoin.it/wiki/Protocol_documentation</a></p>

<p><a href="http://learnmeabitcoin.com/">http://learnmeabitcoin.com/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>

<p><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html">https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html</a></p>

<p><a href="https://www.8btc.com/article/24637">https://www.8btc.com/article/24637</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-stream,一次可怕的社工]]></title>
    <link href="https://happy123.me/blog/2018/11/27/event-stream/"/>
    <updated>2018-11-27T16:06:38+08:00</updated>
    <id>https://happy123.me/blog/2018/11/27/event-stream</id>
    <content type="html"><![CDATA[<p>几天前有人在github创建了一个issue:</p>

<p><a href="https://github.com/dominictarr/event-stream/issues/116">https://github.com/dominictarr/event-stream/issues/116</a></p>

<p>标题为：&#8221;I don&rsquo;t know what to say.&ldquo;，翻译过来大概就是“我无语了”。因为 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p>

<!-- more -->


<p>event-stream 被很多的前端流行框架和库使用，每月有几千万的下载量。作为最流行的前端框架之一，在 Vue 的官方脚手架 vue-cli 中也使用了这个依赖，作为最流行的前端框架之一，这个影响还是挺大的，这个影响还是挺大的。而 React 则躲过了。</p>

<p>flatmap-stream 中的恶意代码会扫描用户的 nodemodules 目录，因为所有从 npm 下载的模块都会放在此目录。如果发现了在 nodemodules 存在特定的模块，则将恶意代码注入进去，从而盗取用户的数字货币。</p>

<p>COPAY钱包因为引用了event-stream库，它在今年9、10、以及11月27日之前发布的所有版本都受到了感染，COPAY是bitpay旗下的开源钱包，市场占有率不可小觑；下面这个链接进行了分析，使用被感染钱包的用户很有可能被窃取私钥:</p>

<p><a href="https://github.com/bitpay/copay/issues/9346">https://github.com/bitpay/copay/issues/9346</a></p>

<p>COPAY紧急发布了5.2.2修正版本：</p>

<p><a href="https://github.com/bitpay/copay/pull/9348">https://github.com/bitpay/copay/pull/9348</a></p>

<h2>使用COPAY钱包的人，请立即升级新版本，并且生成新的钱包，把老钱包里面的币转走。</h2>

<p>这个恶意模块更可怕之处，在于背后的骇客是个深谋远虑、精于社工的人。</p>

<p>这个人的github账号叫做<a href="https://github.com/right9ctrl">right9ctrl</a>，他应该是精心分析了COPAY引用的所有模块，发现event-stream有机可乘。于是给event-stream的创始人-<code>dominictarr</code>发去了邮件，承诺会自愿维护这个项目。</p>

<p><code>dominictarr</code>是一个高产的开发者，他维护着多个NPM包，有人能自愿分担他的工作，他自然是高兴之至，于是将这个模块的仓库控制权移交给了<code>right9ctl</code>。</p>

<p>刚开始的时候，<code>right9ctl</code>非常小心的进行着常规的维护。一段时间后，即在 3 个月前，黑客在 GitHub 上新建了一个 flatmap-stream 仓库（内含恶意代码），并在这个项目中引用了自己的仓库。</p>

<p>直到几天前这个有漏洞的仓库才被发现，然后 npm 紧急将这个含有恶意代码的 flatmap-stream 模块删除了。</p>

<p>这个模块的攻击行为也很隐蔽，首先他只有引用了 event-stream 这个库，并且依赖引用了 flatmap-stream，用户在编译自己的项目时，才会感染恶意代码。</p>

<p>感染恶意代码的程序，也不会全部发作。只有COPAY钱包运行时，他才会悄悄的窃取用户信息，并发送到下面这几台服务器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>copayapi.host
</span><span class='line'>51.38.112.212
</span><span class='line'>145.249.104.239
</span><span class='line'>111.90.151.134</span></code></pre></td></tr></table></div></figure>


<p>我不知道截止到现在黑客获取了多少币，但整个事件非常惊悚。而且这个漏洞刚刚被发现，我认为还会持续有消息不灵通的受害者。</p>

<p>另外，如果想查看自己的项目是否受到影响，可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm ls event-stream flatmap-stream...flatmap-stream@0.1.1...</span></code></pre></td></tr></table></div></figure>


<p>如果在输出里面包含了 flatmap-stream 则说明你也可能被攻击。</p>

<p>如果使用 yarn 则可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yarn why flatmap-stream</span></code></pre></td></tr></table></div></figure>


<h2>区块链历史中的传奇HACK手段</h2>

<p>我在以前的文章中多次感叹所谓的区块链技术出来后，简直是黑客的黄金年代！大概从2011年开始，精彩的HACK事件层出不穷，如果要全部整理出来，可能会是一部让所谓的<code>区块链专家</code>和<code>区块链投资者</code>冷汗直流，后怕不已的手册。</p>

<p>撇开这几天的市场动荡，币价大跌不提，单单从技术上评估，能有多少人意识到他们所谓的投资的技术风险！</p>

<p>我随意的说几件印象非常深刻的HACK事件。</p>

<h4>整个国家DNS 流量劫持事件</h4>

<p>我记得大概是2015年，巴西的骨干网DNS整个被黑客劫持了，导致当时的blockchain.info 在线钱包有几个小时的流量完全被导向了钓鱼网站，这次事件导致的丢币数目不可统计。</p>

<p>但是给你一个启示，当利益足够大的时候，任何设施，包括国家设施都是不可信、不安全的。结合这两天发现的jd.com流量返利劫持，你就知道：网络世界里，有的组织或者个人，完全可以劫持一个国家的网络流量，这不是天方夜谭。</p>

<h4>官方域名劫持事件</h4>

<p>今年二月份的时候，有人花大价钱买了&#8221;electrumltc.org&#8221;这个域名，仿照&#8221;<a href="https://electrum-ltc.org/">https://electrum-ltc.org/</a>&ldquo;官网，精心炮制了一个以假乱真的网站，然后把下载链接改成了恶意钱包，并且做了Google SEO，把自己的骗子网站搜索结果推到了第一名；有人因此丢了2399个LTC，那个时候可是不少钱。</p>

<p>很讽刺的是，恰恰是因为真正的开发者买不起这个域名，才搞了一个山寨的域名发布自己的软件，让骇客有机可乘。</p>

<p>讽刺吧，原作者辛辛苦苦开发，却因为没钱买域名不得已搞个屌丝网站，骇客财大气粗，直接买下第一官方域名然后钓鱼，并且真的获取巨大收益。</p>

<p>这种钓鱼手法在多个钱包、多个网站上面一再重演，受害小白不计其数！</p>

<p><code>杀人放火金腰带，修桥补路无尸骸。</code>这个世界就是这样。</p>

<p>整个事件回顾：</p>

<p><a href="https://github.com/pooler/electrum-ltc/issues/176">https://github.com/pooler/electrum-ltc/issues/176</a></p>

<h4>~~~~</h4>

<p>这么罗列下去，我可以轻易列举出更多的涉及上亿美元的hack事件。每个事件说起来好像天方夜谭一样，不明技术的小白可能会惊叹：怎么可能有这种事情？！</p>

<p>但是事实就是这样，而且将来这样的悲剧会一再重复下去，说再多也没用，人的安全意识总敌不过懒惰、贪婪等等等等，可悲的人性啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoind Conf Template]]></title>
    <link href="https://happy123.me/blog/2018/11/26/bitcoind-conf-template/"/>
    <updated>2018-11-26T14:51:43+08:00</updated>
    <id>https://happy123.me/blog/2018/11/26/bitcoind-conf-template</id>
    <content type="html"><![CDATA[<p>bitcoin core 0.17版本开始废弃了不少RPC调用，另外RPC配置增加了test.rpcport参数，存一份模板:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=127.0.0.1
</span><span class='line'>rpcport=18332
</span><span class='line'>test.rpcport=8332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>walletnotify=/usr/bin/python3 /xxx.py</span></code></pre></td></tr></table></div></figure>


<p>另外<code>getaddressesbyaccount</code>即将废弃，可以使用<code>getaddressesbylabel</code>代替</p>

<p><code>signrawtransaction</code>即将废弃，实在要用的话只能在启动命令行中加deprecatedrpc指定。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/bitcoind --conf=/xxx/bitcoin.conf --datadir=/xxx/blockdata/mainnet --deprecatedrpc=signrawtransaction</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-1]]></title>
    <link href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/"/>
    <updated>2018-11-23T18:48:39+08:00</updated>
    <id>https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1</id>
    <content type="html"><![CDATA[<p>在我们前面的文章中，我们提到，从建设银行转账到工商银行10w元，过程其实是这样的:</p>

<ol>
<li>建设银行发送报文到人行CNAPS系统</li>
<li>人行CNAPS发送转账报文到工商银行</li>
<li>工商银行发送响应报文给人行CNAPS</li>
<li>人行发送响应报文给建设银行</li>
<li>转账成功，建设银行、人行、工商银行各自更新账本</li>
</ol>


<p>整个过程中，有几个很有趣的事实：</p>

<!-- more -->


<ol>
<li>所谓的转账交易，不过是账本上数字的加加减减</li>
<li>我们的账户，除了各自在工行、建行开设的户头之外，在人行还有一个总账；人行是所有银行的妈，你在任何银行开设的账户，人行都有一个总账；所以打印征信的时候我们要到人行打印</li>
<li>建设银行和工商银行间的转账需要人行做清算，人行提供了信用；建行和工行相信人行不会造假</li>
<li>我们需要信任三个机构：人行、工行、建行，我们相信他们不会造假</li>
<li>人行是所有账目的中心节点，人行的账本对不上了，中国的金融系统就乱套了</li>
</ol>


<p>然后作为对比，我们来看看比特币是怎样设计的。</p>

<p>中本聪创造比特币之初，在<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis Block</a>里面付了一句有名的话:&ldquo;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&#8221;。在白皮书中他很自豪的宣称:&#8221;We have proposed a system for electronic transactions without relying on trust. &rdquo; 去中心化一直是比特币的指导纲领，那么问题来了，如果让我们来设计一个去中心化的账本，将会面临哪些技术问题，又该如何解决呢？</p>

<p>很自然的，我们设想的是一个类似于分布式数据库的系统，整个系统维护着唯一的账本，每个节点（node）都是一个副本（Replica Set），每个副本保有完全的账本数据，并且节点间相互同步数据，如果部分节点挂掉，不影响整个系统的运行。</p>

<p>用户转账的行为，其实就是这个分布式账本的增删查改。当然，为了简化设计，我们这个账本可以只支持账目写入，不支持删改。</p>

<p>我们开始思考这个分布式账本要解决的两个核心问题：</p>

<h4>什么样的交易是一笔合法的交易</h4>

<ul>
<li>一笔交易中，如何保证交易账户的完全所有权；如果保证用户A的资金不会被用户B盗用</li>
<li>用户A本来有1000元，如何保证他不会转出2000元？</li>
</ul>


<h4>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</h4>

<ul>
<li>如果有部分节点是不诚实的，它就会有动机去伪造不存在的交易来获取利益，如何识别并排除不诚实的节点？(拜占庭将军问题)</li>
<li>如果A的账户有1000元，发送了1000元给B，由于是分布式系统，部分节点收到了这笔交易，这时候A又发送了1000元给C，另一部分收到了这笔交易，这时候该如何处理？如何保证一笔钱不会被花两次？ (双重支付问题)</li>
</ul>


<p>为了解决这两个问题，比特币引入了三个核心技术：UTXO交易模型、POW工作量证明、blockchain数据结构组织。且让我们一一道来。</p>

<h2>初版交易设计</h2>

<p>如果读了之前我们的&lt;比特币HD钱包>系列文章；天然的，我们意识到非对称加密方法是在分布式账本中建立账户的天选之术；</p>

<h4>存款</h4>

<p>用户A想要建立一个账户，只要在帐目中增加一笔 <code>公钥+金额</code> 的记录就可以了。我们用一个表格表示整个账本，用户A以及用户B各存入50个币的动作可以记作:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50)</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50)</td>
</tr>
</tbody>
</table>


<p>这个原始存入的资金我们先不去纠结怎么来的，总之此时账本中有两笔交易，代表着A以及B各自有50个币</p>

<h4>验证</h4>

<p>在账目1中，如何验证A确实是这笔资金的拥有者呢？非常简单，就是账户资金增加的时候，A对这笔交易数据的摘要用私钥做一个签名，然后再把公钥附在后面就可以了，这样账目就变成了这样:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
</tbody>
</table>


<p>任何一个要验证账户A的节点或第三方，对其所有权证明用公钥解密，然后对照摘要(digest)即可。</p>

<h4>转账</h4>

<p>如果A要向B转账20个币呢，我们最简单的设计，就是构造Trans1 &ndash; 20，然后同样的方法构造签名即可，这样账本如下:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
<tr>
<td>3 </td>
<td> Trans3:Trans1-20 &ndash;> B</td>
<td> signature(digest(Trans1 &ndash; 20 &ndash;> B))+A公钥</td>
</tr>
<tr>
<td>4 </td>
<td> Trans4:存入(B公钥+20) </td>
<td> signature(digest(Trans4))+B公钥</td>
</tr>
</tbody>
</table>


<p>看起来一切还好，但是这个时候我们发现了一些缺点</p>

<ol>
<li>收到汇款的时候因为要添加所有权证明，账户拥有者得一直在线监控自己的账户地址</li>
<li>收款人还得验证汇款人的合法性，感觉都点怪；我收钱就好了，还得去管这个钱合不合法？</li>
<li>如果多重转账，或者一对多，或多对一，这个记录格式就复杂了</li>
<li>用户B要验证一笔交易合法性的时候，可能要回溯到账本非常深的位置，因为上一笔交易可能发生在很久之前，这种交易记录的存储设计很难高效查询</li>
<li>最后，这个账目设计中，所有账户的公钥是暴漏在外的；虽然椭圆曲线算法目前看来牢不可破，但是整个安全体系只依赖一个非对称加密算法，比较脆弱</li>
</ol>


<p>解决方法其实也简单，换个思路，就是A转账给B，B是不需要验证的，只要A提供账户所有权的证明就好了，想想我们平时转账，不也是这样的吗？</p>

<p>那么最简洁的设计，就是借鉴现实世界。每一笔交易都看作是硬币的流转，硬币其实没有特征，它只是从A的保险箱转移到了B的保险箱而已，那么，采用什么办法来表示：<code>这是A的保险箱中的一笔资金币</code>这个譬喻呢？</p>

<h2>进阶交易设计</h2>

<h4>UTXO 模型</h4>

<p>比特币的账本世界，构筑在UTXO (Unspent Transaction Output)之上；其实每个UTXO代表着未花费的一笔硬币(数额可大可小，没有限制)；一个账户的资金，其实就是一堆UTXO的集合；转账交易，就是一个或多个UTXO的输入再输出为另外的UTXO而已。你可以想象成现实世界中金银铸币的流通。</p>

<p>那么一个UTXO中包含什么呢？如何作为输入呢？如何构造输出呢？这就是比特币交易的核心技术。</p>

<ul>
<li>我们用下面一张图来表示<code>A保险箱里面的50个硬币</code> 这件事：</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg1.jpg" alt="img" /></p>

<p>把它想象成一个邮筒构造的保险箱，在不打开的前提下，投币是只进不出的。可以注意到，我们并没有直接将Public Key明晃晃暴露在外面，而是先HASH一下，然后贴到保险箱子上面，想要存币的人，只要知道这个HASH值，作为保险箱的ID，就可以直接投币进去啦。</p>

<p>但是保险箱的锁在哪里呢？</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg2.jpg" alt="img" /></p>

<ul>
<li>这张图中，我们引入了一个脚本，称之为 <code>Pubkey Script</code>；具体内容是:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>呵呵，像天书吧，不要怕；这是我们特有的保险锁构造。细节会在后面讲到。这里你可以这样简单理解：</p>

<p>为了锁住这个保险箱里的资金，比特币系统设置了一个谜题作为锁。解开这个谜题，才能转移里面的资金。</p>

<p>这个谜题是这样构造的:</p>

<ol>
<li>记录了A的公开的<code>Public key hash</code>值，开锁的人，需要提供A的<code>full public key</code>，同时验证 <code>hash160(public key) == Public key hash</code></li>
<li>需要提供A的私钥基于这笔交易的签名Signature, 这样系统可以用<code>full public key</code>来验证公私钥是否匹配</li>
</ol>


<p>这个过程是通过上面的脚本指令通过入栈出栈执行的，这也为比特币系统验证更复杂的交易逻辑提供了基础，甚至能作为一个简单的虚拟机执行更复杂的组合指令。</p>

<p>整个过程组织如下图：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg3.jpg" alt="img" /></p>

<p>当我提供一个signature以及full public key的时候，就可以开锁了，开锁下一步自然就是转移资金啦。我们给B汇款50个币，而B的保险箱又是怎么表示的呢？和A保险箱是一样的。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg4.jpg" alt="img" /></p>

<ul>
<li><p>带有<code>public key hash</code> ID的保险箱是一个UTXO，这个保险箱用<code>public key hash</code>上锁，而提供<code>signature</code>和<code>full public key</code>开锁，转移资金的过程，就是花费UTXO的过程，其实就是把A的UTXO转移到B的UTXO的过程，这就是比特币最简单的一笔交易</p></li>
<li><p>我们可以继续拓展下去，可以1对多支付，多对1支付，多对多支付，更复杂的多签名支付，延迟支付等等，今后我们会详细介绍</p></li>
</ul>


<p>这个系统有如下优点:</p>

<ol>
<li>所有的交易都抽象为了UTXO的转移，你可以想象一下，一堆硬币在几个保险箱之间转移的样子</li>
<li>用户其实可以不检查交易的合法性，只要运行分布式账本的所有节点检查通过合法后，确保写入账本就保证资金的安全转移了</li>
<li>每个账户的拥有者在真正花费UTXO之前，是不用暴露公钥的</li>
<li>验证UTXO交易合法行的函数，抽象为几个指令的集合，这个验证行为指令通用化，为智能合约编写创造了条件</li>
<li>这样的交易记录非常容易组织，我们以后可以看到；把这些交易批量打包，组织成名为blockchain的精巧数据结构，有许多优点</li>
<li>一个用户A可以用一个私钥加密多个保险箱，或者多个私钥加密多个保险箱，非常灵活</li>
</ol>


<h2>小结</h2>

<p>好啦，看到这里，我们对比特币的最简单的交易构造已经有感性认识了。但是俗话说得好: <code>光说不练假把式</code>，下篇文章我们就会手工构造一笔完整的交易，让你搞明白其中细节。</p>

<p>另外，我们前面提出了好几个问题:</p>

<ul>
<li>原始资金从何处来？</li>
<li>节点如何解决拜占庭将军问题？</li>
<li>节点如何解决双重支付问题？</li>
</ul>


<p>后面我们会一一解答，那么，下次再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币、支付、清算漫谈]]></title>
    <link href="https://happy123.me/blog/2018/11/19/huo-bi-%2C-zhi-fu-%2C-qing-suan-man-tan/"/>
    <updated>2018-11-19T16:55:29+08:00</updated>
    <id>https://happy123.me/blog/2018/11/19/huo-bi-,-zhi-fu-,-qing-suan-man-tan</id>
    <content type="html"><![CDATA[<p>又看了一遍 <a href="https://book.douban.com/subject/26802686/">The book of Satoshi</a> 这本书，果然常读常新啊；又有很多想法冒出来，结合最近的BCH分叉事件，我不禁又开始思考金融系统的两大环节：清算和支付，究竟会如何发展？</p>

<p>我从事银行业务系统监控很长时间，结合咱的职业生涯所学，再重新梳理一遍支付和清算的发展史吧。</p>

<!-- more -->


<p>除了支付和清算，还有一个拓展概念，即结算。看一下权威机构的定义:</p>

<p>按照国际清算银行支付结算委员会的定义，所有涉及到资金转移的行为，都可视作支付行为，支付的概念最大，清算和结算属于支付过程中的特定环节，其中，清算是发生在结算前的支付环节，该环节的功能主要是为了提高结算的标准化水平和结算的效率。</p>

<ul>
<li><p>支付：完成付款人向收款人转移可以接受的货币债权的过程，包括交易过程、清算过程和结算过程等三个过程。</p></li>
<li><p>清算：包含了在收付款人金融机构之间交换支付工具以及计算金融机构之间待结算的债权，支付工具的交换也包括交易撮合、交易清分、数据收集等。</p></li>
<li><p>结算：该过程是完成债权最终转移的过程，包括收集待结算的债权并进行完整性检验、保证结算资金具有可用性、结清金融机构之间的债券债务以及记录和通知各方。</p></li>
</ul>


<h2>史前阶段</h2>

<p>支付清算的历史其实要比货币历史久远的多，但货币的演变是支付清算体系发展的原动力。</p>

<p>在货币产生前，物物交换其实就是一种支付行为，比如原始人甲有桃子，但喜欢苹果，而此时刚好碰到原始人乙，乙有苹果，但喜欢桃子，这样两个人就刚好满足双方的需求，甲向乙支付桃子，得到苹果，乙向甲支付苹果，得到桃子。这就是最原始的“支付”。随着持有香蕉的原始人丙也加入上述交易，那么必须形成需求的闭环，而且随着交易的物品数量、种类逐渐增多，就需要再找一个不参与交易的原始人丁专门做交易的分类、计数和记录，并且甲乙丙在丁面前都作出承诺：一是手里的桃子、苹果、香蕉都是真实存在的。二是交易的意愿都是真实的，不会拿了人家的东西却不给出自己的东西。那么丁做的事情就是最原始的“清算”。之后，桃子、苹果、香蕉交割到了新的主人手中，此时丁宣布交易成功结束，甲乙丙三方各不相欠&mdash;最原始的“结算”。</p>

<p>此时丁付出信用，承担了清算的网关。当然，这种清算是非常粗糙的，作为一个支付行为的环节不明显。</p>

<p>后来随着商品交换规模的扩大，统一的支付媒介就出现了。从最原始的贝壳，到铁铜铸币，再到金银物品，形成了人们统一承认的货币媒介。实物货币如金银货币的出现极大地提升了商品交易的成功率，形成了以货币为核心和交易媒介的支付清算体系雏形，极大地推动了贸易和经济社会发展。</p>

<p>此时的清算其实和支付行为频率差不多的，因为当时的贸易市场并不繁荣，货币媒介还很粗笨，可以说每一笔支付就伴随着一笔清算，清算如此重要，以至于此时的货币市场上最重要的并不是货币本身，而是记账的权力，最经典的例子就是我们前面文章中提到的雅浦岛的石币故事。</p>

<h2>纸币阶段</h2>

<p>但随着商品交易规模和范围的不断扩大，金银货币越来越不能更好地满足贸易经济大规模发展的需要，人们就开始尝试以收兑金银之后的收据代替金银实物进行流通，随着这种收据广为人们接受，纸币就此诞生了&mdash;这是货币发展史上的一个重要突破。当然，纸币是要与其背后的金银货币的成色、数量挂钩的，也就是金银本位制，而且发行纸币的单位是多样的，可以是国家，也可以是有实力有信誉的金银铸造商等等。这时的纸币仅仅只是一种“表征货币”。纸币的出现极大地提升了支付的便利性，但由于纸币的伪造难度和成本比金银货币低太多，如何避免收到假冒伪劣的纸币甚至防止纸币超发成为突出的难题。自此，支付的便利性与安全性因为支付工具（如纸币）从交易媒介（如金银货币）分离独立而始终成为一对矛盾。</p>

<p>纸币阶段其实和金银实体是并存的，这个时候的清算行为其实更好分辨；拿我们熟悉的晋商作为例子：</p>

<blockquote><p>早在清道光（1823年）年间，山西平遥商人就创立了“日升昌”等专门办理汇款业务的票号（古代的票号、钱庄就是现代银行的雏形）。
著名的红顶商人胡雪岩就是做票号生意起家的。
当时的票号支持异地汇款业务：客户来日升昌汇款，交了银子之后，票号就开出汇票给客户。
跟银行一样，票号也有总号和分号，客户可以携带汇票或者把票寄给亲人，只要凭票就可以到日升昌全国各地的分号兑出银子，分号给客户兑换之后先记内部账，日后再和总号清算债务。
从此之后，商人在城市之间贸易可以不用携带大量的银子。而汇票在不同城市的各个分号之间流转也形成了很多债务，有大量的银子需要周转，镖局就专为票号来运送银子以及为商人运送票据，有点类似于现在为银行押钞的威豹，不过镖局的手续费可是高达5%！</p></blockquote>

<p>整个过程中，每个月或年底各个分号之间周转银子，轧平账目的过程就是清算。虽然清算是整个支付环节的一部分，但是清算的频率比较低，平均下来多笔支付可能才发生一笔清算，所以此时表面上看货币是非常活跃的，清算作为一种记账行为默默引申到了后台。</p>

<h2>信用阶段</h2>

<p>牛顿爵士开创了金本位，其实在整个货币史上不过短短一段时间，然后我们现在就飞速的跳跃到了信用货币阶段，信用货币发展的技术基础，就是越来越完善普及的电子设备。可以想象，将来即使在非洲，持有一个智能电子钱包(不一定是手机)的成本也会小于持有纸币的成本，所以货币电子化的趋势不可逆转。</p>

<p>铸币信用化，表现形式电子化之后，最明显的一个改变，就是<code>清算</code>这个行为，夹杂在整个支付过程中越来越频繁了；</p>

<ul>
<li>原来钱庄分号之间轧账，周期可能半年一年记</li>
<li>金银铸币时代，两国之间的轧账，也可能持续几周</li>
<li>纸币化之后，可能国际汇兑、债券市场之间的清算，通过电报以及联行信件，就缩短到几天了</li>
<li>到了今天，跨行汇款，已经缩短到分钟级别了；移动支付，都可以到秒级了</li>
</ul>


<p>此时清算的次数又大致跟支付行为一个量级了，记账的技术又开始一轮飞跃；</p>

<p>放到我国来，伴随着改革开放，我们的金融市场30年走完了欧美100年的历史，其中支付清算系统的发展就是经典的代表，这段历史我比较熟悉，下面就我国的支付清算系统建设流水账一番;</p>

<h3>全国手工联行系统 (1949-1990)</h3>

<p>建国初期的银行是比较LOW的，那个时候的银行是沿袭历史发展过来的。因此银行之间的资金往来(通存通兑)，其实跟晋商时代的票号差不多，每个银行都和其它大行之间签订协议，开设备付金账户，实现互兑。</p>

<p>比如三家银行： 工行、建行、招行，他们每家银行都要在另外两家银行开设账户，存入准备金，不同银行间的业务往来像票号一样定期轧账。</p>

<p>此时，每家银行都是一个清算机构，为银行间的资金往来做清算。</p>

<p>这种清算方式无疑是低效的，每成立一家银行，要开启业务，都得一家家的在同行那里开设账户，费时费力。所幸那个时候的银行少，而且计划经济金融业务少，这么多年就凑合过来了。</p>

<p>一直到1984年中国人民银行专门行使中央银行职能之后，我们国家确立了法定存款准备金制度。央行的备付金系统正式确立。此时，银行跨行的资金清算有两种选择：</p>

<ul>
<li>用老办法，在所有有往来的银行开立清算账户清算</li>
<li>所有金融机构都在央行开立清算账户，由央行为商业银行统一清算</li>
</ul>


<p>显然大家都想用第二个方案。然而在那个时代，央行能承担的职责是很有限的，各银行内部数据还没有集中，没有电子化的记账系统，国内甚至都还没有银行卡，客户要转账也没有满大街的ATM。总之一句话，国内的金融环境还没有达到让央行推行全国统一结算制度的客观条件。</p>

<p>为了满足跨行结算的需求，央行当时提出商业银行要“自成联行系统，跨行直接通汇，相互发报移卡，及时清算资金”。也就是说同一家银行的总行及分支机构称为“联行系统”。同一联行内的资金结算，由联行总行自己做。这样，建行深圳分行和建行北京分行之间的资金清算由建行自己内部解决。跨银行之间要能支持直接汇款。跨行业务可以由央行清算，也可以由商业银行自己清算。</p>

<p>这是个各家银行系统很不智能，体验很差的时期，我们称为“全国手工联行”时期。于是，每家银行都可以接受跨行的汇款，银行每天自行轧差，各种交易汇总计算后，需要告知其他行的交易信息写成一张张特定的公文，加盖印鉴后在银行间送来送去。这种公文叫做联行信件，而收发联行信件就是当时邮电局的重要业务。</p>

<h3>全国电子联行系统EIS (1989-2005)</h3>

<p>随着银行业的不断发展，银行每天处理各类跨行业务的数量增多，各家银行之间的债权债务关系变得非常复杂，由各家银行自行轧差进行清算变得非常困难。这种状况要求央行必须承担起一个全国清算中心的角色。于是，央行在1989年12月6日，发布了“关于改革联行清算制度的通知”。</p>

<p>随后在1990年，中国人民银行清算中心建成，专门为金融机构提供支付清算服务。这个清算中心包括NPC和CCPC：</p>

<ul>
<li>NPC（National Process Center，国家金融清算总中心）</li>
<li>CCPC（City Clearing Processing Center，城市处理中心）</li>
</ul>


<p>1991年4月1日，基于金融卫星通讯网的应用系统——全国电子联行系统（EIS）开始试运行。EIS是人民银行专门用于处理异地（包括跨行和行内）资金清算和资金划拨的系统。它连接了商业银行、央行、NPC和CCPC。</p>

<p>假设客户在深圳建行汇款给北京工行，通过EIS处理一次跨行汇款的流程如下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg1.png" alt="img" /></p>

<p>可以看到，清算中心在各地建立了一个个分站，分站和总中心通过卫星网络互联，总站和分站共同构成了清算网络，为其它接入EIS的各家商业银行提供清算服务。</p>

<p>从此之后，各个银行之间的跨行汇款，以及同一银行的异地分行，就可以直接通过这样的电子化操作来完成了，客户的资金在途时间缩短到了一两天，这也算是中国金融系统的一大里程碑了。</p>

<p>PS: 直到2015年，我都在一些银行的老系统中见过EIS，这个东东真的很经典，生命力很顽强啊。</p>

<h3>现代支付系统CNAPS (1991-现在)</h3>

<p>1991年EIS试运行后，又发生了两件大事：</p>

<ul>
<li><p>各大银行核心系统投产，各家商业银行的内部联网系统纷纷建成投产</p>

<p>  银行内部资金划转都可以通过自己的核心系统解决了。这意味着各大行都可以做电子化的行内清算了，行内异地转账就不用再依赖EIS。笔者跑过许多银行，见识了许多核心系统的投产，几乎所有的核心系统设计都是一个套路，将来有时间可以再有一篇文章细说一下。</p></li>
<li><p>中国现代化支付系统（CNAPS）开始设计</p>

<p>  1991年10月，中国开始着手建设中国国家金融通信网（CNFN）和中国现代化支付系统（CNAPS，China National Automatic Payment System）。从此，全国电子联行（EIS）系统逐步向CNAPS过渡。到了二十一世纪，IT技术飞速发展，央行的CNAPS一代系统（大小额支付系统）也开始走上历史舞台。中国的支付清算步入了现代化支付系统CNAPS的时代。</p></li>
</ul>


<p>CNAPS值得我们大说特说，今天银行的主力业务都跑在它的基础上，它的发展历史上有几件大事:</p>

<ol>
<li>2002年，央行大额实时支付系统（HVPS）投产，用于处理同城和异地的商业银行跨行之间（也包括行内一定金额以上的）大额贷记业务。</li>
<li>2005年，央行小额批量支付系统（BEPS）投产，用来处理同城和异地纸凭证截留的借记支付业务以及每笔金额在5万以下的小额贷记支付业务。</li>
</ol>


<p>这两个业务统称为大小额系统，我们平时的跨行转账，走的就是这两个系统，他们之间有如下区别:</p>

<ul>
<li>首先，大小额的开放时间不同</li>
</ul>


<p>大额系统是工作日的 8:30 ~ 17:00，所以在节假日经常会收到银行通知说某些业务暂停了经常就是因为央行在节假日对大额系统做维护。小额系统全年无休，7*24小时工作。</p>

<ul>
<li>业务处理上不同</li>
</ul>


<p>大额是每笔交易都实时发送，实时清算的，所以基本上能实时到账，跨行资金零在途。小额系统是在收集若干笔交易后打一个包统一处理，定时清算。所以，用小额系统转账经常要几分钟甚至半个小时才能到账，银行间头寸交割也是非实时的。尽管理论上跨行转账业务不管用大额还是小额，一般在几分钟内都能到账，但是因为要经过央行，所以在这一时期基本没有银行敢向客户承诺资金多久能到账。比如我们早期银行卡转账，一半会发现一个<code>两小时内到账</code>的提醒，这就说明他走的是小额支付系统。</p>

<ul>
<li>金额不同</li>
</ul>


<p>大额系统没有金额限制，小额系统支持的单笔金额上限是5万元。从用途上讲，大额系统侧重于资金转移的时效性，主要用于资本市场、货币市场交易和大额贸易资金结算。小额系统对数据吞吐量要求较高，主要用于小额贸易支付和个人消费服务。</p>

<p>下面一张图就说明了CNAPS大小额的业务实现:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg3.png" alt="img" /></p>

<p>目前大部分手机网银跨行转账都没有手续费。所以如果你在晚上10点想跨行转账10万元，此时大额转账系统已经关闭了，建议你分成两个5万并且用加急方式来转账。</p>

<p>不管怎么说，现在我们的跨行汇款速度总算提高到小时级别了。</p>

<p>PS: 大小额支付的协议细节非常复杂，协议规范有上千页文档，是我去现场部署监控系统时永远的痛啊~~~</p>

<h3>第二代现代支付系统CNAPS2 (2013-现在)</h3>

<p>大小额系统已经很好用了，但是随着金融市场发展，业务需求是无穷无尽的；2013年10月6日，央行的第二代支付系统(CNAPS2)正式投产运行，其中包括2010年就推出的网上支付跨行清算系统（俗称“超级网银”）。超级网银是对大小额支付系统的一个补充，有两大亮点：</p>

<ul>
<li><p>接入机构不再限于银行</p>

<p>  支付宝、财付通等第三方支付也可以接入，所以有的第三方支付给商户提供的提现代发功能就是基于超级网银做的。</p></li>
<li><p>7*24小时实时到账，单笔上限5万元</p>

<p>  这就相当于在非工作日非营业时间增加了一种大额支付系统特性的渠道了。只不过金额限制是跟小额系统一致的。</p></li>
</ul>


<p>最后来一张总体架构图:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg2.jpg" alt="img" /></p>

<p>PS: 现场协议监控部署，<code>人行二代支付</code>是我听了上万遍的词汇啊，睡觉都无法摆脱~~~</p>

<h3>三方支付渠道</h3>

<p>人行的CNAPS2为不同银行间提供了清算服务，银行内部的核心系统为自己不同的分行间提供了清算服务。这两块已经覆盖了大多数的银行业务场景，包括:</p>

<ul>
<li>银行柜台&mdash;直接大小额转账</li>
<li>手机网银&mdash;大小额转账+超级网银</li>
</ul>


<p>但是还有一部分商业市场没有涉及到，就是我们常说的三方支付。我把它又分为两个场景:</p>

<ol>
<li>ATM 刷卡取款和POS机刷卡</li>
<li>网银支付</li>
</ol>


<p>在支付宝普及之前，POS机刷卡以及ATM取款都是我们日常生活中比较常见的资金流转渠道。相信大家都有不少储蓄卡及信用卡有着<code>银联</code>标识。这个银联又是何方神圣？</p>

<p>银联全称<code>中国银联银行卡跨行支付系统</code>，英文缩写为CUPS；我们说支付市场是很大而且油水很足的，人行作为银行的妈，建设清算系统主要是政治考量，而商业银行进军支付领域是要挣钱，所以2002年3月26日，经中国人民银行批准,各大发卡行的商业银行参股，成立了银联。</p>

<p>银联的目的就是提供人行二代支付之外的资金清算渠道，在支付场景捞油水。我们看一下ATM刷卡和POS机业务中，银联发挥的作用。</p>

<h4>POS机刷卡</h4>

<p>POS机刷卡的参与方比较多。以你在星巴克刷卡为例：</p>

<ul>
<li>持卡人——你</li>
<li>发卡行——你办这张卡的银行，我们假设是工行</li>
<li>商户——星巴克，我们假设星巴克的账户开在建行</li>
<li>收单行——星巴克的刷卡机的归属银行，假设也是建行</li>
<li>转接机构——银联</li>
<li>清算机构——银联和人行</li>
</ul>


<p>于是，当你用工行卡在星巴克消费的时候，资金流和现金流是这样发生的：</p>

<ol>
<li>你在收单行（建行）的POS机上刷卡消费</li>
<li>建行将消费报文发送给银联</li>
<li>银联交易系统记录交易数据，将消费报文给你的发卡行（工行）</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行的POS机</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
<li>银联通过小额支付系统或当地票据交换系统，完成建行和星巴克结算账户的资金划拨（收单清算）</li>
</ol>


<p>在这个过程中，银联提供两种清算：</p>

<p>1.建行和工行的清算叫“跨行清算”；
2.建行和星巴克的建行账户之间的清算叫“收单清算”；</p>

<p>无论是跨行清算还是收单清算，银联都是作为CNAPS的一个特许参与者，使用大小额支付清算系统，完成银行卡业务的资金划拨。本质上，银联提供交易转接、清分和对账，人行提供结算。</p>

<h4>ATM跨行取款</h4>

<p>你拿着一张工行卡去建行的ATM取了100元，这个跨行业务在CNAPS体系中的过程如下：</p>

<ol>
<li>你在建行ATM上输入100元按下取款按钮</li>
<li>建行将报文信息发送给银联</li>
<li>银联交易系统记录交易数据，将报文给你的发卡行(工行)</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行ATM</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
</ol>


<p>我们看到，ATM和POS渠道，是由银联的CUPS来对接各大商业银行做支付转接，解决信息流问题；银联同时提供清分和对账服务，对完账之后再调用央行大小额系统解决资金流问题；</p>

<p>当央行系统升级的时候，通过银行柜台和手机银行是不能做跨行转账的，但是通过ATM和POS却可以跨行取款和跨行支付，这是因为银联暂且处理了清分和对账，等到央行系统升级完毕后，他们才进行清算；</p>

<p>所以一般央行挑放假的日子升级系统，这个时候一般没有对公业务，但是我们平常的刷卡消费可以正常进行。</p>

<p>另外，我们说，资金跨行清算的发展中，出现了一位豪杰，就是三方支付的大佬：支付宝</p>

<h4>支付宝等势力的发展</h4>

<p>支付宝早期为了服务淘宝客户和商家，不可避免的要跟银联抢生意，对接各大银行的支付接口。</p>

<p>银联作为既得利益者，绝不会开放接口给支付宝的。所以当时支付宝拿到支付牌照之后，苦逼的一家一家跟跟银行洽谈对接，值得注意的是，支付宝对接的各机构间跨行转账，没有走人行的大小额系统，而是走的支付宝内部资金池。</p>

<p>支付宝积硅步以至千里，慢慢的接入的银行多了，服务竟然能叫板银联了。</p>

<p>印象特别深刻的是，有一年国庆节人行系统升级，当时的小额转账竟然有大多数交易走的支付宝渠道，这时候支付宝已经有能力作为第三大清算网关服务大众了;</p>

<p>另外举一个有趣的例子，因为支付宝早期转账有免费的短信留言服务，所以有人用每笔1分钱的转账服务聊天！而发条短信都1毛钱呢，这跟如今的bitmessage、memocash记录信息何其相似。</p>

<p>我后来工作走了不少地方性的小银行，因为供应商不一样，他们每家的对接方案都不同，支付宝竟然有耐心一家一家的啃下来了，不得不佩服他们下的苦功夫。</p>

<p>当然，后来微信支付也异军突起，三方支付平台各路神仙纷纷跳出来分蛋糕，银联节节败退之后，祭出杀手锏；找央妈诉苦。于是为了平衡各方利益，一纸文件下来，决定建立网联平台，大家之前的自留地接入废除，各方统一接入网联，利益均沾。支付宝之前的平台建设就完成历史使命了。</p>

<p>网联平台的建设由于有阿里和腾讯的研发力量加入，开发异常顺利。2017年开始逐步上线，2018年双十一，就在前几天，官方号称TPS超过了9万笔。实在了得。不得不承认，我国的交易金融系统处理能力在世界上已经是单独一档了。</p>

<h4>小结</h4>

<p>上面长篇大论了我国支付清算系统的建设和发展，无非说明几个问题:</p>

<ol>
<li>金融越发达，支付行为越多，清算所占的比例也水涨船高</li>
<li>清算的速度越来越快，处理效率越来越高</li>
<li>虽然清算接入的机构越来越多，但是清算网关呈现大一统的趋势</li>
<li>清算的交易笔数指数级增长，中国支付清算协会发布《中国支付清算行业运行报告（2018）》称，2017年，国内商业银行共处理移动支付业务375多亿笔，非银行支付机构共处理移动支付业务2390多亿笔，这之中大部分都包含有清算行为</li>
</ol>


<h2>区块链时代</h2>

<p>我认为区块链技术诞生后，清算技术又是一个进化。但是这个进化过程初期表现十分笨拙，以至于看起来像是退化。</p>

<p>在比特币诞生之前，Ripple网络其实已经在传统清算网关的基础上，基于中心化的共识，提出了新的清算网关方案。他们的技术其实很有意思，也非常创新。我们打算放到其它篇章来介绍。目前我们单独谈谈比特币的技术方案。</p>

<h4>容量</h4>

<p>首先比特币由于是去中心化的网络，处理能力是非常低的；即使引入了Segwit附带一点扩容效果，目前也不过是3~4 TPS，和中心化的清算网关相比，简直可怜。</p>

<p>但是比特币系统的特殊之处就在于，他没有集中的账户管理节点，这意味着网络中的每个全节点都承担清算网关的职能，每一笔支付必然带有一笔清算，清算率100%。</p>

<p>这实在是像极了早期雅浦岛上的石头货币系统，我们一再强调这个寓言故事，因为它和比特币如此相像；比特币系统简直是雅浦岛的石币系统的电子版！连处理能力也是如此相似的性能低下！</p>

<p>值得庆幸的是，雅浦岛上的居民限于物理条件，系统性能提升有极限；而现代的电子设备性能提升，横向扩展的话，几乎是无穷尽的。</p>

<p>当前比特币的扩容方案主要是两大流派，经济利益夹杂着技术讨论，是是非非就不评说了，我们撇开矿霸、专利、以及阴谋论，只是整理一下他们目前的发展状况</p>

<h5>闪电网络链下扩容</h5>

<p>主要路线是Segwit 解决交易延展性问题，然后在此基础上实现二层闪电网络。目前来看，Segwit已经占了主网交易的半壁江山，估计最终能扩容到4-8 TPS，这当然不够用。所以二层网络的闪电网络至关重要。</p>

<p>闪电网络目前还是处于试验阶段，虽然推出了一些应用，但总体还是和比特币早期发展一样，只是部分Geek在使用。</p>

<p>优点:</p>

<ol>
<li>中转节点越多，处理能力越强</li>
<li>如果两个节点间能形成比较短的支付路径，理论上它的处理能力会很惊人的，至少是比现在几个数量级的提升</li>
<li>微支付通道里面的交易记录不上主网，这样跑全节点的开销只会线性增长，有利于比特币的去中心化</li>
</ol>


<p>缺点:</p>

<ol>
<li>收款需要保持在线</li>
<li>形成微支付通道需要双方缴纳保证金</li>
<li>建立和销毁微支付通道都需要主网广播，如果支付笔数少，建立通道的得不偿失；因为这个原因，目前来看闪电网络的实际应用不多</li>
<li>闪电网络的中转节点需要大量的保证金，会天然的会向大公司、集权化发展，这也是区块扩容党最诟病的一点</li>
</ol>


<h5>大区快链上扩容</h5>

<p>优点:</p>

<ol>
<li>代码简单，即刻扩容</li>
<li>技术方面来讲，扩容到32M-128M其实开销也不大；根据硬件设备的发展，长远来看，1GB的大区快可能也行得通</li>
<li>有人认为Segwit引入了复杂度，原本的交易格式更改了，技术上有洁癖的人接受不了，大区快扩容没有技术债</li>
</ol>


<p>缺点：</p>

<ol>
<li>有人认为今天32MB，明天更多，扩容起来无穷无尽，早晚只有矿场才会运行全节点，这样去中心化吃枣药丸</li>
<li>交易延展性问题早晚得解决，目前来看Segwit解决方案还是比较成功的，扩容党只是嘴硬，早晚得上</li>
<li>扩容再多，性能也比上闪电网络</li>
</ol>


<h4>总结</h4>

<p>近日BCH社区又经历了一场硬分叉斗争，有利益相争的地方就有恩怨，有恩怨就有江湖；很有可能大家搞来搞去，Bitcoin就搞死了，很正常。</p>

<p>其实看到最后，最核心的分歧其实就是Bitcoin 主网是否每个节点该继续承担清算的工作，这其实和现实中的货币发展十分相似：</p>

<ol>
<li>市场初期不是那么繁荣，即使交易一次清算一次，货币的物理特性也能顶住，这和bitcoin初期很相似，每个全节点都是清算网关，每笔交易都有一笔清算，安安稳稳跑了十年</li>
<li>市场爆发，原有的清算体系扛不住了，这个时候需要升级技术方案解决；有分歧了，需要把全部交易都上主网吗？买杯咖啡需要记录到主链上吗？毕竟今天区块链还是非常金贵的资源，这个系统每天消耗的电力资金数以亿计了，在上面画画写诗实在是有点浪费；从历史来看，引入闪电网络，小笔交易不再并入主网，变成两个特殊清算节点之间的轧账比较合适</li>
<li>分歧就在这里，有人觉得硬件性能增长完全可以让主网记录人类所有的交易；有人说扯犊子，买咖啡不应该上主网</li>
</ol>


<p>目前的情况来看：</p>

<ol>
<li>闪电网络还是处于实验阶段，有力使不上，主网一直满负荷</li>
<li>扩容派各种斗争，要上位还很远</li>
</ol>


<p>看不清未来方向；其实历史是波浪式前进的，如果顶层设计，我可能倾向于:</p>

<p>先区块扩容一点(提高清算能力)&ndash;>Segwit+闪电网络(集中清算)&ndash;>硬件性能跟上了，继续扩容(再分布式清算)</p>

<p>但是现实斗争就是这么残酷哦，技术最优不代表市场最优，技术市场最优不代表拳头最大~~~所以说历史发展是随机的；像基督教分为犹太教、新教、天主教等等，佛教搞成藏传、南派北派等等，人类就是折腾中前进，比特币出来以后，一度把清算技术搞成了教派斗争，这挺有意思的</p>

<h4>更丰富的商业场景</h4>

<p>不管怎么说，我对于技术的前进还是乐观的，不管是传统的清算中心，还是区块链，如果将来我们的清算能力再有一个指数级飞升，我觉得又会有新的商业模式出现</p>

<ul>
<li>现在的保险行业，比如车险，保险的时段只能一整块时段，同样买了一辆车，有的几个司机合伙24*365天天在外跑，有的上下班每周就几个小时的使用时间，交一样的钱其实不公平；未来可能只有你的引擎发动之后，真正在路上跑了，按照分钟收费，你的钱要一点一点打到保险公司账户上，这样比较合理</li>
<li>娱乐消费行业，目前也是整段时间收费，未来你听一首歌，可能按照 0.0000001元/秒的速度慢慢付款给音乐公司</li>
<li>公益行业: 真正的贫困人口可以开设经过认证的账号，这样土豪捐款的时候可以绕过红十字会，平均账户发放救济金之类，而且可以有各种算法监控，比如每个月固定发个100元，这个账户之后走的是哪个清算单元，进行了什么消费，杜绝骗子的不正当用途</li>
<li>资金审计: 将来的所有公益和对公账户，审计不再是一个问题了，因为你可以追踪所有的清算单元，用智能算法来判断资金最终的流向和目的，财务造假的难度大大增加</li>
</ul>


<h4>引用：</h4>

<p><a href="http://www.gongxiangcj.com/posts/1478">http://www.gongxiangcj.com/posts/1478</a></p>

<p><a href="https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf">https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf</a></p>

<p><a href="https://www.zhihu.com/question/22148261">https://www.zhihu.com/question/22148261</a></p>
]]></content>
  </entry>
  
</feed>
