<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-01-03T20:58:18+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币的交易-6]]></title>
    <link href="https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6/"/>
    <updated>2019-01-01T20:10:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6</id>
    <content type="html"><![CDATA[<p>好啦，这篇文章中，我们要来探讨大名鼎鼎的Segwit(Segregated Witness)。</p>

<p>这个词一说起来就头疼啊，他牵扯到旷日持久的扩容大战，无穷尽的争论以及分裂。我们的立场就是不去站队任何组织，单纯从技术的角度去理解这个东西。</p>

<!-- more -->


<p>首先澄清一个误解，其实Segwit跟扩容没关系，它最初提出来，只是为了解决交易延展性的问题，顺便有一点扩容效果，但这个扩容效果只是附带的；</p>

<p>另外，其实Segwit的技术原理非常简单，但是要考虑兼容性的问题，导致从设计到实施都有点复杂。</p>

<h2>缘起</h2>

<p>嗯哼，又要涉及到大量的数学知识；先声明下，我至今还没有从数学原理上完全理解椭圆曲线算法，所以下面讲的都是码农派的API理解&mdash;搞明白接口，但里面的细节还需要更多时间去探究。</p>

<p>上一篇文章我们提到，当交易被签名时，签名并没有覆盖交易中所有的数据 (因为签名是不可能对自身签名的)，而交易中所有的数据又会被用来生成交易的哈希值来作为该交易的唯一标示。</p>

<p>如果签名向常见的HASH算法一样，碰撞机率极小的话也没有问题；但是椭圆曲线算法存在一个看起来比较弱的特性：</p>

<blockquote><p>ECDSA算法生成两个大整数r和s并组合起来作为签名, 可以用来验证交易。而r和BN-s 也同样可以作为签名来验证交易(BN＝0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141). 这样，攻击者拿到一个交易，将其中inputSig 的r, s 提取出来， 使用 r, BN-s 生成新的inputSig, 然后组成新的交易，拥有同样的input和output，但是不同的TXID. 攻击者能在不掌握私钥的情况下几乎无成本地成功地生成了合法的交易。</p></blockquote>

<p>让我们再用码农能理解的语言描述一遍:</p>

<ol>
<li>前面的交易中，scriptSig脚本可以提取出sig签名</li>
<li>sig是由两个值组成的，Sig=(R,S)</li>
<li>sig是嵌入在scriptSig中，用一种名为<code>DER-encoded ASN.1 octet representation</code>的编码方式编码的。OpenSSL并没有强制要求每个签名编码结果只能有一个值。</li>
<li>对于每一个 ECDSA <code>signature(R,S)</code>，还存在相同消息的另外一个有效签名: <code>signature(R,-S(mod N))</code></li>
<li>一个恶意攻击者得到Sig之后，可以手工构造另外一个<code>signature(R,-S(mod N))</code>嵌入到scriptSig中，这和之前的scriptSig不一样，所以TX ID也会发生变化</li>
<li>这笔新的交易输入输出跟原来的交易完全一样，也是合法的，但是TX ID不同了。</li>
</ol>


<h4>危害</h4>

<ol>
<li>Alice通过在线钱包给Bob发送了一笔交易，并把TXID发送给Bob说，看我给你发了多少比特币</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>Bob 通过Alice发来的TXID搜索了以下，并没有发现这笔交易</li>
<li>Bob说，Alice是个骗子</li>
</ol>


<h4>对于交易所的威胁</h4>

<ol>
<li>黑客向交易所发起来一笔资金提现</li>
<li>交易所自动处理，广播了交易，并发送给黑客TX ID</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>黑客对交易所说，我没有收到资金，那笔交易不存在</li>
<li>交易所验证了下，因为原来得交易已经被黑客替换掉了，所以原始交易果然不存在了</li>
<li>交易所只能又构造了一笔交易再次广播</li>
<li>黑客最后得到了两笔资金</li>
<li>这种情况下的解决方法是，遇到交易无法确认就停止，报错误并等待手动处理，或者，我们可以自己生成一个延展性交易，然后获取新的TXID,查找是否发送成功。能生成的TXID数量有多少呢？一共有exp(2, input数量)个，因为每个input都有改签名或者不改两种可能， 通常不是一个大数目。</li>
<li>但是这不能阻挡脚本小子的恶意攻击，他们通常会<code>损人不利己</code>的构造大笔延展性交易来攻击网络</li>
</ol>


<h2>讨论</h2>

<p>社区为了解决这个问题进行了大量的讨论：以下是一些材料和社区进行的努力：</p>

<h4>BIP0062</h4>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki</a></p>

<h4>BIP66</h4>

<p>在 363742 区块高度处，BIP66 软分叉强制区块链中所有新交易遵循 DER-encoded ASN.1 标准。仍然需要进一步的努力来关闭 DER 签名其它可能的延展性问题。
签名仍然是可以被拥有相应私钥的人改变的。</p>

<h2>解决</h2>

<p>2015年12月，Bitcoin Core开发团队的<a href="https://github.com/sipa">Pieter Wuille</a>提出了一个解决方案，称之为隔离见证 (Segregated Witness）。隔离见证由以下BIPs定义：</p>

<ol>
<li>BIP-141:隔离见证的主要定义</li>
<li>BIP-143:版本0见证程序的交易签名验证</li>
<li>BIP-144对等服务——新的网络消息和序列化格式</li>
<li>BIP-145隔离见证（对于矿工）的 getblocktemplate 升级</li>
</ol>


<p>最主要的描述在BIP141中:</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</a></p>

<h2>原理</h2>

<p>其实说白了原理非常简单，就是把vin的scriptSig挪到交易的末尾去。</p>

<p>每一个比特币交易，其实可以分为两部份。第一部份是说明结余的进出，第二部份是用来证明这个交易的合法性 (主要是签署)。第一部份可称为「交易状态」，第二部份就是所谓的「见证」(witness)。如果你只关心每个账户的结馀，其实交易状态资料就已经足够。只有部份人(主要是矿工)才有必要取得交易见证。</p>

<p>那么我们再来复习下一笔P2PKH交易的结构:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在整笔交易里面，输入输出信息以及金额大小属于第一部分，scriptSig属于第二部分。</p>

<p>只有矿工以及全节点需要进行scriptSig的验证；如果是普通的SPV轻钱包只需要验证所在区块的合法行就可以了。所以可以把scriptSig 部分挪到交易的尾部。这样带签名的原始数据就固定了，也不会有更改TX ID的机会。这部分数据称之为witness:</p>

<p>每个witness都由一个var_int打头，代表接下来的数据长度。如果某个输入没有见证，那么其witness就是一个0x00。</p>

<p>让我们代入各种例子，来看看Segwit是如何工作的？</p>

<h4>P2WPKH (Pay-to-Witness-Public-Key-Hash)</h4>

<p>首先回顾下P2PKH的锁定脚本(scriptPubKey)与解锁脚本(scriptSig)内容</p>

<ul>
<li>P2PKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    &lt;signature&gt; &lt;pubkey&gt;
</span><span class='line'>  scriptPubKey: OP_DUP OP_HASH160 &lt;20-byte hash of Pubkey&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再来看一下P2WPKH的脚本内容</p>

<ul>
<li>P2WPKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WPKH的锁定脚本较P2PKH要精简不少，第一位的数字0是版本号，有了版本号，未来脚本升级就能更容易的向前兼容。</p>

<p>P2WPKH的解锁脚本为空，而真正的解锁脚本内容被移到了原交易之外的witness部分。</p>

<h4>P2WSH(Pay-to-Witness-Script-Hash)</h4>

<ul>
<li>P2SH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</span></code></pre></td></tr></table></div></figure>


<ul>
<li>P2WSH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;32-byte hash of redeem script&gt;
</span><span class='line'>  witness:      0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WSH锁定脚本与P2WPKH类似，第一位是版本号，第二位是赎回脚本(Redeem script)的Hash值。</p>

<p>值得注意的是P2WSH锁定脚本中的Hash值是256位(32字节)的，是使用SHA256(pubkey)计算得到；而P2WPKH中的Hash值是160位(20字节)的，是使用RIPEMD160(SHA256(pubkey))计算得到的。</p>

<p>这样做的目的是让钱包可以根据Hash值的长度区分交易使用的是P2WPKH还是P2WSH。</p>

<p>在P2SH交易中常常会有多重签名验证，所以验证信息会占用更多空间，将这些信息移到原交易之外能更大程度的降低交易大小。</p>

<h4>锁定脚本版本号</h4>

<p>仔细观察之后，我们发现scriptSig以及scriptPubKey都以一个<code>0</code>开头；这代表着一个版本号。开发团队对于这个字段还有更远大的愿景，锁定脚本(Locking script)加上版本号，从而使脚本语言的升级更容易向前兼容，这种不造成太大影响的脚本语言修改方式将加快比特币的创新。</p>

<p>这个字段的精巧之处就在于，老节点看到这种交易也是合法的，虽然不能正确parse这种交易，但是当作为交易被打包到一个新区块，然后被支持segwit的矿工挖出来这个块，其它不支持segwit的老节点也是承认这个块的！</p>

<p>为什么呢？复习一下我们之前的文章，在一笔交易结构里面，这种交易是合法的 (是的，真相其实更复杂，但是我懒得详细介绍了，也许之后更闲的时候会仔细说说吧)！</p>

<p>虽然不能正确解析，但格式合法。有的人觉得这种技术忒精巧了，甚至精巧到了一种可怕的程度，是一种杂耍式的开发。很多人对于这种<code>啊哈</code>式的适配吓坏了。</p>

<p>现在Segwit已成事实，是非曲直只能留给你自己去判断了。</p>

<h4>交易标识符</h4>

<p>从上面看，其实实施Segwit之后，数据结构反而变得更清晰简单了。如果中本聪一开始就采用这样的结构，我相信也没有多少人会质疑。</p>

<p>但是已有的老的交易格式及相关系统已经运行了这么长时间，我们希望能尽可能的兼容以前的系统。最麻烦的适配就是原来传统交易的ID只有一个txid。现在见证数据挪到后面了，HASH的时候就不包括这一块数据了，怎么办？</p>

<p>传统交易的txid是以下序列 double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][txins][txouts][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>最后开发者们又引入了另外一个id，称之为wtxid；它是对整个交易double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][marker][flag][txins][txouts][witness][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>我们知道，每笔交易的txid是临时计算的，并不入块。但是整个Block是以所有交易的txid以Merkle Tree的形式组织的(这部分知识我们还没讲，需要到后面将bitcoin blockchain的时候提到)；现在多了一个wtxid，该怎么办呢？</p>

<p>解决办法又让人有点无语，就是将wtxid按照同样的组织方法算出Merkle Tree根节点，放到Block块中。</p>

<p>但是原有的Block格式都固定下来了，这个根节点放哪里呢？</p>

<p>还有coinbase的100个字节是可以利用的嘛，就是你了。</p>

<p>这<del>~，在有洁癖的人看来，完全又是一种码农修修补补式的FIX；相信众多技术人员这个时候已经开始内心无数吐槽了；但是真实世界就是这样无奈啊，又想要兼容性，又想要代码干净，又想要性能</del></p>

<p>你是太阳吗！？地球都绕着你转吗？！</p>

<p>拿着吧，这就不少了！！</p>

<p>最后附上这段龌龊的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::vector&lt;unsigned char&gt; GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, 
</span><span class='line'>                                                      const Consensus::Params& consensusParams)
</span><span class='line'>{
</span><span class='line'>    std::vector&lt;unsigned char&gt; commitment;
</span><span class='line'>    int commitpos = GetWitnessCommitmentIndex(block);  //从币基交易的输出中寻找承诺项，没找到就返回-1
</span><span class='line'>    std::vector&lt;unsigned char&gt; ret(32, 0x00);
</span><span class='line'>    if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {
</span><span class='line'>        if (commitpos == -1) {  //没有找到，就开始创建承诺，先生成见证版Merkle树根
</span><span class='line'>            uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);
</span><span class='line'>            CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());
</span><span class='line'>            CTxOut out;  //构建一个币基交易的输出
</span><span class='line'>            out.nValue = 0;  //金额是0
</span><span class='line'>            out.scriptPubKey.resize(38);  //公钥脚本长度38，前6个字节固定为0x6a24aa21a9ed
</span><span class='line'>            out.scriptPubKey[0] = OP_RETURN;  //0x6a
</span><span class='line'>            out.scriptPubKey[1] = 0x24;  //36，即后面的总长度
</span><span class='line'>            out.scriptPubKey[2] = 0xaa;  //0xaa21a9ed，固定不变的承诺头
</span><span class='line'>            out.scriptPubKey[3] = 0x21;
</span><span class='line'>            out.scriptPubKey[4] = 0xa9;
</span><span class='line'>            out.scriptPubKey[5] = 0xed;
</span><span class='line'>            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);  //插入见证版Merkle树根
</span><span class='line'>            commitment = std::vector&lt;unsigned char&gt;(out.scriptPubKey.begin(), out.scriptPubKey.end());
</span><span class='line'>            CMutableTransaction tx(*block.vtx[0]);
</span><span class='line'>            tx.vout.push_back(out);  //币基交易中添加这个输出
</span><span class='line'>            block.vtx[0] = MakeTransactionRef(std::move(tx));  //写回区块
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);  //更新区块其他结构
</span><span class='line'>    return commitment;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>隔离见证新的签名算法</h4>

<p>原来的签名验证需要大量的HASH操作；我们知道比特币是一个分布式系统，同时运行着上万个节点，如果一个操作每个节点都执行一遍，浪费的操作加起来很惊人的。</p>

<p>而隔离验证是个软分叉，为啥不能顺便再搞一点优化呢？毕竟软分叉的机会不多啊。于是开发者们顺便修改了四个签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG和CHECKMULTISIGVERIFY）的语义，改变了交易承诺散列的计算方式。</p>

<p>下面的说明引用自 Master Bitcoin:</p>

<blockquote><p>比特币交易中的签名应用于交易哈希，交易数据计算，锁定数据的特定部分，表明签名者对这些值的承诺。例如，在简单的SIGHASH_ALL类型签名中，承诺哈希包括所有的输入和输出。</p>

<p>不幸的是，计算承诺哈希的方式引入了验证签名的节点可能被迫执行大量哈希计算的可能性。具体而言，散列运算相对于交易中的签名操作的数量增加O（n<sup>2</sup>）。因此，攻击者可以通过大量的签名操作创建一个交易，导致整个比特币网络不得不执行数百或数千个哈希操作来验证交易。</p>

<p>Segwit代表了通过改变承诺散列计算方式来解决这个问题的机会。对于segwit版本0见证程序，使用BIP-143中规定的改进的承诺哈希算法进行签名验证。</p>

<p>新算法实现了两个重要目标。首先，散列操作的数量比签名操作的数量增加了一个更加渐进的O（n），减少了用过于复杂的交易创建拒绝服务攻击的机会。其次，承诺散列现在还包括作为承诺的一部分的每个输入的值（金额）。这意味着签名者可以提交特定的输入值，而不需要“获取”并检查输入引用的前一个交易。在离线设备（如硬件钱包）的情况下，这极大地简化了主机与硬件钱包之间的通信，消除了对以前的交易流进行验证的需要。硬件钱包可以接受不可信主机“输入”的输入值。由于签名是无效的，如果输入值不正确，硬件钱包在签名输入之前不需要验证该值。</p></blockquote>

<p>总之就是一句话，提升了验证签名的性能！！</p>

<h2>实施</h2>

<p>隔离见证（segwit）是一次比特币共识规则和网络协议的升级，其提议和实施将基于BIP-9，是一个软分叉。</p>

<p>2017年8月24日，区块高度481,824，隔离见证正式激活。</p>

<p>2015年提出，2017年激活；想想就知道这中间经历了多少曲折！！</p>

<p>隔离见证最终是全网95%的算力投票赞成才激活的，即使如此，网络中还是有一些不支持隔离见证的老节点在运行，同时，周边的钱包等软件也有不少还不支持隔离见证交易；此时的情况就比较复杂:</p>

<h4>付款人的客户端支持隔离见证，而收款人不支持</h4>

<p>如果收款人不支持隔离见证，那最终发布的地址将会是普通地址（P2PKH或P2SH），那所有交易按照原有的规则进行即可。</p>

<h4>付款人的客户端不支持隔离见证，而收款人支持</h4>

<p>聪明的社区开发者想出了一个过渡方案，即将P2WPKH或P2WSH植入P2SH。</p>

<p>是的！！作为有洁癖的开发者，你又会要吐槽了，这是什么操作！？</p>

<p>P2WPKH植入P2SH后，交易信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of script&gt; EQUAL
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>此处的脚本Hash值为RIPEMD160(SHA256(0 &lt;20-byte hash of Pubkey>))的结果，将该脚本Hash转换为P2SH地址，就是一个兼容segwit的地址，不支持隔离见证的客户端可以正常支付比特币给这种P2SH地址。
而对于支持隔离见证的客户端，仍可以将验证信息放在witness结构中，当然这种过渡方案的交易会较完全形态的方案稍大一些，但比无隔离见证的情况要小。</p>

<p>这样就引入了另外一个混乱之处，我们前面的文章提到过，以<code>3</code>开头的地址是P2SH交易专用的，而P2SH交易一般包含的脚本逻辑比较复杂，现在又要判断一种情况，这笔交易是不是一笔隔离见证交易呢？</p>

<p>还有普通小白也很疑惑，比特币网络中开始出现大量以<code>3</code>开头地址的交易，之前这种交易很少，小白们甚至都没有见过这种地址。</p>

<p>为了解决这个问题，开发者们很快又提出了bech32地址格式(去参考我们之前的文章)，小白们很快就被搞得晕头转向。而此时社区正处于分裂状态，Bitcoin Cash作为硬分叉出来的江湖搅局者，虽然加入了重放保护，但是地址和Bitcoin的规则是一样的，但是Bitcoin Cash是不支持Segwit的！</p>

<p>很快，就有大量的小白在Bitcoin Cash里面发送交易给Segwit地址，这种混乱场景不忍卒见。</p>

<p>然后，Bitcoin Cash也搞出了自己的另外一套地址规则；好吧，你应该去找找我们早期的关于比特币钱包的文章，好好温习一下了。</p>

<h4>一些吐槽</h4>

<p>令人惊奇的是，这段混乱时期，在全网交易纷纷堵死，隔离见证升级、Bitcoin Cash分叉的混乱局面中，比特币的价格不合常理的大涨、暴涨，涨到大家怀疑人生。颇有一点狂风暴雨雷霆霹雳之下，大家在泰坦尼克号中末日狂欢的意味。</p>

<p>Bitcoin这个东西，实在不能以常理来琢磨啊。</p>

<h2>优点</h2>

<p>说了这么多，当然Segwit的升级还是又非常多的好处的~~~</p>

<h4>可以用软分叉增加最大区块容量:</h4>

<p>因为旧有节点根本看不到这些被隔离的见证，即使真实的区块已超过1MB，它们仍会以为没有超过限制而会接受区块。</p>

<p>比特币的区块大小限制为1000000bytes，由于witness数据不包含在这个限制中，为了防止witness数据被滥用，仍然对总的区块大小做了限制。引入了一个新概念叫块重量(Block weight):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Block weight = Base size * 3 + Total size
</span><span class='line'>Base size是不包含witness数据的块大小
</span><span class='line'>Total size是包含了witness数据的总大小</span></code></pre></td></tr></table></div></figure>


<p>隔离见证限制Block weight &lt;= 4000000</p>

<p>这就是隔离见证扩容说的来由，这样实际上确实有一定的扩容效果，如果全网交易都迁移到隔离见证上来，大概扩容1.7倍吧。</p>

<p>但是!!! 注意，实际的区块链大小其实比原来更大，这一点一定要搞清楚。</p>

<h4>解决了交易延展性问题</h4>

<p>从此以後，只有发出交易的人才可以改变交易ID，没有任何第三方可以做到。如果是多重签名交易，就只有多名签署人同意才能改变交易ID。这可以保证一连串的未确认交易的有效性，是双向支付通道或闪电网络所必须的功能。有了双向支付通道或闪电网络，二人或多人之间就可以实际上进行无限次交易，而无需把大量零碎交易放在区块链，大为减低区块空间压力。</p>

<h4>轻量钱包可以变得更轻量，因为它们无需再接收见证数据</h4>

<h4>可以大幅改善签署结构</h4>

<p>在区块链上，曾经有一个超过5000个输入的交易，因为签署设计缺憾，需要半分钟才能完成检查。在建议中的SW软分叉会把这个问题解决掉。</p>

<p>而在该次软分叉完成後，核心开发者们已有计划进一步完善整个系统的可用性和安全性:</p>

<ol>
<li><p>全节点可以为轻量钱包提供很简洁的证明，以检查交易是否合法。以後的节点就不再局限於完全验证和完全不验证，而是可以按个人的资源作部份验证，也就是说一台手机也可以参与保障系统安全。这可以大为降低系统对全节点的依赖，即使以後区块容量提升了，我们仍能保持安全。</p></li>
<li><p>将会推出全新的交易脚本语言，例如可以把数以千计的不同脚本通过MAST技术压缩至只有32字节;亦可以把不同签署合并检查，令检查交易的速度再以倍数上升。</p></li>
</ol>


<h4>为闪电网络的实施铺平了道路</h4>

<p>闪电网络应该是继中本聪创造比特币之后最重量级的创新，支持者和反对者为其吵了一个天翻地覆，这个值得我们后面写文章大书特书，还是那句话，后文再见吧。</p>

<h2>副作用</h2>

<h4>复杂性</h4>

<p>是的，如果你看到这里；就会发现我到了大量的<code>吐槽</code>字眼；为了达成共识，隔离见证采用了软分叉升级，为了兼容老系统，不可避免的修修补补；另外虽然说起来是单独的一项技术，同时解决的问题可不少，在洁癖者眼里，这是屌丝码农的瞎折腾，就增加了出Bug的可能性；如果是个硬分叉，所有技术问题能干净利落解决，就没有这么多争吵了。</p>

<p>总之一句话，隔离验证留下的技术债不少，升级之后落子无悔，如果之后发现问题，可没机会回退了。</p>

<p>这次升级也是一次经典的技术、政治、利益交杂的各方博弈，如果将来比特币大成，这段历史值得仔细研究。</p>

<h4>Block Size</h4>

<p>前面已经在优点里面说过了。隔离见证有扩容效果的。但这个效果只是一个副作用，只是当时提出隔离见证的时候社区正就扩容问题吵得不可开交，莫名其妙的这个技术就卷入扩容斗争里面了。</p>

<p>再说一遍：关于隔离见证，网上一个很大的误解就是：认为witness被隔离走了，witness数据不在Block里，所以一个Block能装更多的Transaction。</p>

<p>其实不是，witness数据仍然在Block里面。并且对于1个Transaction来说，如果把witness数据也算上的话，其raw byte size其实是变大了，而不是变小了！！！
既然Transaction还变大了，那为什么1个Block可以装更多的Transaction呢？？</p>

<p>因为隔离见证是软分叉，不是硬分叉。下面就分别来分析一下，为什么对于老版本节点、新版本节点，1个Block都可以装更多的Transaction呢？</p>

<p>对于老版本节点：
Block Limit Size = 1M，但由于你把witness数据移到了所有Transaction的外面，放在了整个Block的尾部。老版本在计算一个Block大小的时候，只计算了
Block Header + 所有Transaction的数据（witness数据，老版本看不见！！！相当于老版本被欺骗了。）</p>

<p>所以呢，其实整个Block的物理大小(raw block size)已经超过了1M，但老版本的节点不认识尾部的witness数据，所以认为总大小还是 &lt; 1M。</p>

<p>对于新版本节点：
Block的size的计算方式做了调整，引入了Block weight的概念。
block weight = base_size * 4 + witness_size
block weight &lt;= 4M</p>

<p>其中，base_size就是block的前2部分数据（header + 没有witness的所有交易数据）</p>

<p>通过上面的分析，我们会发现，数据还是那么多数据，没有减少，只是重新排布了一下，却变相的把区块链扩容了！！！</p>

<h4>安全性</h4>

<p>有人提出来说，中本聪之前把交易信息和见证数据放在一块是有意的；因为一笔交易带有所有者的签名是天经地义的语义；隔离见证把witness独立出来，降低了比特币系统的安全性。另外~~~~</p>

<p>老实说，这个论据仔细读读还是蛮有道理的，但是实在说的太深刻太哲理了，码农对这种东西天生无感，我就不啰嗦了，大家感兴趣可以自己去搜索这方面资料。</p>

<h2>小结</h2>

<p>以上就是对隔离见证这个东东最简单的描述，我尽力做到简洁中立；但是实际上我觉得整个过程写一本书也不为过；</p>

<p>那么，隔离见证实施之后；就是闪电网络的崛起了，我们下篇文章再见。</p>

<h2>参考</h2>

<h4>四份有关隔离见证的比特币改善方案:</h4>

<ul>
<li>隔离见证软分叉</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki">https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki</a></p>

<ul>
<li>隔离见证通信层</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki">https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki</a></p>

<ul>
<li>隔离见证交易地址</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki">https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki</a></p>

<ul>
<li>隔离见证签署检查</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki">https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki</a></p>

<h4>系统扩展常见问题解答:</h4>

<p><a href="https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq">https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq</a></p>

<h4>需要30秒检查的交易:</h4>

<p><a href="https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08">https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08</a></p>

<h4>其它资料</h4>

<p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md">https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-5]]></title>
    <link href="https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5/"/>
    <updated>2018-12-28T21:08:25+08:00</updated>
    <id>https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5</id>
    <content type="html"><![CDATA[<p>我们还是拿<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517</a>做例子。</p>

<p>这篇文章需要结合<a href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/">比特币的交易-3</a>这篇文章来理解，我们在这里也直接复用TransA、TransB的说法。</p>

<!-- more -->


<h2>准备工作</h2>

<h4>私钥-公钥</h4>

<p>在<a href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/">比特币的HD钱包-2</a>中，我们已经算出来私钥的WIF表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</span></code></pre></td></tr></table></div></figure>


<p>以及公钥:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341</span></code></pre></td></tr></table></div></figure>


<h4>交易body</h4>

<p>这笔交易有1个vin，1个vout；然后再把我们之前的结构分析图拿来，看看具体需要哪些参数传入:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h4>需要手工构造input</h4>

<ol>
<li>指定上一笔vout的txid，是已知参数(outputTransactionHash):<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code></li>
<li>指定上一笔vout的index，是已知参数(sourceIndex):<code>00000000</code></li>
<li>构造scriptSig，即对这个UTXO签名。我们需要用私钥签名，这个是难点，我们后面来计算</li>
</ol>


<h4>需要手工构造output</h4>

<ol>
<li>设置矿工费用，从而计算输出值</li>
<li>构造scriptPubKey</li>
</ol>


<h4>最后组合成为一笔交易</h4>

<ol>
<li>增加version字段：<code>01000000</code></li>
<li>增加inputCount字段: <code>01</code></li>
<li>增加outputCount字段: <code>01</code></li>
<li>增加block lock time字段: <code>00000000</code></li>
</ol>


<h4>然后我们实现一个函数，将这些变量组合，最后得到原始交易值(对应bitcoin-cli的createrawTransaction)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Makes a transaction from the inputs
</span><span class='line'># outputs is a list of [redeemptionSatoshis, outputScript]
</span><span class='line'>def makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs):
</span><span class='line'>    def makeOutput(data):
</span><span class='line'>        redeemptionSatoshis, outputScript = data
</span><span class='line'>        return (struct.pack("&lt;Q", redeemptionSatoshis).encode('hex') +
</span><span class='line'>        '%02x'.format(len(outputScript.decode('hex'))) + outputScript)
</span><span class='line'>    formattedOutputs = ''.join(map(makeOutput, outputs))
</span><span class='line'>    return (
</span><span class='line'>        "01000000" + # 4 bytes version
</span><span class='line'>        "01" + # varint for number of inputs
</span><span class='line'>        outputTransactionHash.decode('hex')[::-1].encode('hex') + # reverse outputTransactionHash
</span><span class='line'>        struct.pack('&lt;L', sourceIndex).encode('hex') +
</span><span class='line'>        '%02x'.format(len(scriptSig.decode('hex'))) + scriptSig +
</span><span class='line'>        "ffffffff" + # sequence
</span><span class='line'>        "%02x".format(len(outputs)) + # number of outputs
</span><span class='line'>        formattedOutputs +
</span><span class='line'>        "00000000" # lockTime
</span><span class='line'>        )</span></code></pre></td></tr></table></div></figure>


<h4>outputs构造</h4>

<p>在构造一笔完整的交易之前，我们需要手工做两件事情：</p>

<ol>
<li>构造一个output输出</li>
<li>对vin中的UTXO签名，构造scriptSig</li>
</ol>


<p>outputs的构造比scriptSig简单一点，我们先来解决这个问题。</p>

<p>outputs是包含多个output的数组。在这个例子中，我们打算只构造一个output。结合我们之前的文章，就是构造一个bitcoin scriptPubKey，设置一把新锁。</p>

<p>这个scriptPubkey是这样子的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;pubkey&gt;  OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>PubKeyHash其实就是收币的地址，其它操作符都是现成的。</p>

<h2>如何构造一笔output</h2>

<p>一笔output的构造是简单的，所有东西都是现成的，而且这笔交易是个P2PK交易，输出非常简化，我们仅仅需要构造<code>&lt;pubkey&gt;  OP_CHECKSIG</code>即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def makeOutput(value,  index, pubkey):
</span><span class='line'>    OP_CHECKSIG =  'ac'
</span><span class='line'>    value = "{:0&lt;16x}".format(int(struct.pack('&lt;I', int(value)).hex(), 16))
</span><span class='line'>    index = "{:02x}".format(int(index))
</span><span class='line'>    pubkey = pubkey
</span><span class='line'>    pubkey_length = "{:02x}".format(len(pubkey)/2)
</span><span class='line'>    return value + index = pubkey_length + pubkey + OP_CHECKSIG
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>&gt; print(makeOutput(7000, 0, '2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac'))
</span><span class='line'>&gt; 581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac
</span><span class='line'>&gt; outputs = ['581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac']
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h2>如何对一笔交易签名(scriptSig)</h2>

<p>在构造一笔交易的过程中，签署交易是一个非常麻烦的过程。其基本思想是使用ECDSA椭圆曲线算法和私钥生成交易的数字签名，但细节比较复杂。</p>

<p>我们可以先通过验证签名的过程来理解以下，验证签名过程的通过10个步骤描述。下面的缩略图说明了详细的流程。</p>

<p><img src="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png" alt="img" /></p>

<p>这张图出自于<a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">这里</a>，里面的TX ID是不同的，但基本步骤一样。</p>

<h4>一些约定:</h4>

<ol>
<li>TransA代表TxPrev，TransB代笔TxNew</li>
</ol>


<h4>步骤:</h4>

<ol>
<li>首先解析TransB涨vin中的scriptSig，得到sigStr以及pubkeyStr</li>
<li>从TransA中拿出对应的vout ，从scriptPub脚本中截取需要的部分(subScript)：即 <code>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</code>；截取规则就是检索最后一个<code>OP_CODESEPARATOR</code>的位置，在这之后的脚本段就是我们要截取的对象</li>
<li>如果subScript中包含了签名，移除掉(在scriptPub中包含签名是很特殊的情况，一般出现在P2SH交易中，普通交易不需要这一步)</li>
<li>如果脚本中有<code>OP_CODESEPARATORS</code>操作符，移除</li>
<li>检测一步解析出来的scriptSig最后一个字节的HashType，扩展为4字节(小端排序)备用</li>
<li>将TransB 复制一份，变为TransBCopy</li>
<li>将TransBCopy中所有的Vin以及Vout 移除，同时将length字段置为0</li>
<li>将第4步中的subScript根据vin sequence填充到TransBCopy对应的位置</li>
<li>最后将交易TransBCopy序列化(采用DER编码)，并在末尾添加第5步中得到的HashType，得到签名的原始数据</li>
<li>最后执行签名验证过程: ECDSA_CheckSignature(pubkeyStr, sigStr, double_sha256(TransBCopy))</li>
</ol>


<h4>疑点解惑</h4>

<h5>为什么这么麻烦，不能直接对TransB签名吗？</h5>

<p>因为最终的签名是包含在TransB当中的，签名是不能对自身来签名的；所以要签名的原始数据不能包含签名本身；</p>

<p>说句题外话，由于ECDSA的签名算法的局限，这个结构组织方式最终导致了一个顽疾，即交易延展性问题，也被翻译为交易可锻性（Transaction Malleability）。</p>

<p>简单来说，就是攻击者可以生成不同但是合法的scriptSig，这样虽然vin，vout金额和地址不变，但是TX ID会发生变化，从而导致用户找不到发送的交易。</p>

<p>这对于交易所是一个威胁，某个居心不良的用户可能充值了一笔资金，然后重新生成scriptSig又广播了一笔交易，然后欺骗交易所，说第一笔交易没收到，交易所检查以下果然如此，于是又发送了一笔资金给用户，这样用户就实现了double withdraw，白赚了一笔。MTGOX早期就是这么被坑的，后来也出现过一些损人不利己的脚本小子们公然利用这个漏洞攻击比特币网络；为了解决这个问题，core开发者提出了segwit解决方案(即隔离见证)，后来随着政治斗争、市场斗争的激化，一个技术问题最终演化成了扩容派的分裂。</p>

<p>总之还是那句话，关于segwit, 闪电网络，期待我们后面的文章吧。</p>

<h5>为什么要用上一笔交易vout来填充这个位置呢？</h5>

<p>我们说验证签名的过程，其实有三个作用:</p>

<ol>
<li>签名证明私钥的所有者，即资金所有者，已经授权支出这些资金</li>
<li>授权证明是不可否认的（不可否认性）</li>
<li>签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改</li>
</ol>


<p>我们提供签名、私钥即承诺了第1点，对TransBCopy 签名承诺了第2点，但是要做到第3点，就需要对于引用UTXO的信息做承诺；</p>

<p>我们会问，单纯的prev TX ID和vout sequence no不能证明我要花费的哪一笔UTXO吗？</p>

<p>是的，这还是不够的，我们需要另外的信息熵的引入，就是这个UTXO的scriptPub。具体为什么，是ECDSA的数学特性决定的。请参考:</p>

<p><a href="https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/">https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/</a></p>

<p>老实说，关于ECDSA的签名验证，我在学习了很长时间以后，还是非常担心，因为签名生成算法使用随机密钥k作为临时私有-公钥对的基础，这个K值的随机性一定要人工保证，比特币的每笔交易验证，离不开签名验证，而这个签名验证如此复杂，确实让人心生忐忑。</p>

<h5>这个OP_CODESEPARATORS是什么东东？</h5>

<p>哈，到目前为止，我们接触到的都是比特币最简单、最基本、当然也是应用最广泛的交易类型，但是比特币还支持P2SH的高级交易，在这种交易中，vout里面可能会嵌入非常复杂的脚本，所以系统引入了OP_CODESEPARATORS作为复杂脚本的分隔符，以后的文章我们会详细讲解；</p>

<p>OP_CODESEPARATOR属于一种看起来<code>过度设计</code>的特性，老实说，我没有在比特币主网上发现像样的使用这个特性的交易，我也需要更多时间的学习才能搞明白这个东西，以下是一些参考资料：</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=164655.0">https://bitcointalk.org/index.php?topic=164655.0</a></p>

<h5>这个HashType是什么东东？</h5>

<p>嗯哼，又是一个非常棘手但是有意思的问题。</p>

<p>我们说比特币有了script之后，功能是非常非常丰富的，不仅仅局限于支付场景，他可以应用到许多非常复杂的场景中。</p>

<p>比如现在让我们考虑一个外贸公司的业务，这个公司的对公账户每天都要接受许多客户的付款，处于安全考虑，我作为公司的CEO，希望能跟财务主管共同管理公司的对公账户，当需要支出时，一定要我跟财务主管都签字同意才可以。</p>

<p>这就衍生出了所谓的M-N交易类型，即多重签名交易。</p>

<p>在多重签名交易中，要花费一笔UTXO，可能需要多个签名，或者有这种语义：&#8221;一定要CEO的签名，如果没有CEO的签名，需要COO和CFO的联合签名&#8221;，为了表示这些，引入了SIGHASH这个字段，就是我们所说的HashType啦。</p>

<p>要考虑SIGHASH，实际上已经牵涉到了bitcoin的高级交易类型(P2SH)，还是那句话，关注后面的文章吧。</p>

<h4>反向代码</h4>

<p>嗯哼，把验证签名的步骤反向来一遍，就是签名的过程了。</p>

<p>代码表示如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>def makeSignedTransaction(privateKey, outputTransactionHash, sourceIndex, scriptPubKey, outputs):
</span><span class='line'>    myTxn_forSig = (makeRawTransaction(outputTransactionHash, sourceIndex, scriptPubKey, outputs)
</span><span class='line'>         + "01000000") # hash code
</span><span class='line'>
</span><span class='line'>    s256 = hashlib.sha256(hashlib.sha256(myTxn_forSig.decode('hex')).digest()).digest()
</span><span class='line'>    sk = ecdsa.SigningKey.from_string(privateKey.decode('hex'), curve=ecdsa.SECP256k1)
</span><span class='line'>    sig = sk.sign_digest(s256, sigencode=ecdsa.util.sigencode_der) + '\01' # 01 is hashtype
</span><span class='line'>    pubKey = keyUtils.privateKeyToPublicKey(privateKey)
</span><span class='line'>    scriptSig = utils.varstr(sig).encode('hex') + utils.varstr(pubKey.decode('hex')).encode('hex')
</span><span class='line'>    signed_txn = makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs)
</span><span class='line'>    verifyTxnSignature(signed_txn)
</span><span class='line'>    return signed_txn</span></code></pre></td></tr></table></div></figure>


<h2>广播交易</h2>

<p>好啦，构造了vin, vout，以及组合成一笔完整的交易，剩下的就是广播出去啦：</p>

<p>比特币的网络协议非常简单，设置好一个Magic Number就可以加入，以下时广播代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>magic = 0xd9b4bef9
</span><span class='line'>
</span><span class='line'>def makeMessage(magic, command, payload):
</span><span class='line'>    checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]
</span><span class='line'>    return struct.pack('L12sL4s', magic, command, len(payload), checksum) + payload
</span><span class='line'>
</span><span class='line'>def getVersionMsg():
</span><span class='line'>    version = 60002
</span><span class='line'>    services = 1
</span><span class='line'>    timestamp = int(time.time())
</span><span class='line'>    addr_me = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    addr_you = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    nonce = random.getrandbits(64)
</span><span class='line'>    sub_version_num = utils.varstr('')
</span><span class='line'>    start_height = 0
</span><span class='line'>    
</span><span class='line'>def getTxMsg(payload):
</span><span class='line'>  return makeMessage(magic, 'tx', payload)
</span><span class='line'>
</span><span class='line'>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</span><span class='line'>HOST_IP ="x.x.x.x"
</span><span class='line'>sock.connect(HOST_IP, 8333)
</span><span class='line'>
</span><span class='line'>sock.send(msgUtils.getVersionMsg())
</span><span class='line'>sock.recv(1000) # receive version
</span><span class='line'>sock.recv(1000) # receive verack
</span><span class='line'>sock.send(msgUtils.getTxMsg("01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000".decode('hex')))</span></code></pre></td></tr></table></div></figure>


<p>HOST IP 怎么获取呢？</p>

<p>如果你有一个全节点，可以直接调用RPC接口的getpeers函数。或者你直接执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nslookup bitseed.xf2.org</span></code></pre></td></tr></table></div></figure>


<p>从公共服务器里面检索nodes，里面随便挑一个IP 吧。</p>

<h2>小结</h2>

<p>以上就是一笔完整交易的构造过程。</p>

<p>这笔交易结构非常简单，只有一个vin，一个vout。</p>

<p>如果有多个vin, 多个vout的情况，就需要每个vin都签署一遍。</p>

<p>我们发现，一笔比特币交易的构造过程，最复杂的，就是签名以及验证的过程。它的步骤极其繁琐，而且椭圆曲线的签名算法极其复杂。如果在更高级的比特币交易中，比如P2SH，或者多重签名交易，或者Segwit交易，包含了更复杂的脚本和执行逻辑，事情很快就变得不可控制起来。</p>

<p>这是我在学习比特币知识时遇到的最大的恐惧，我认为如果将来比特币系统出现什么致命BUG，很大可能就在这里暴雷。</p>

<p>也许早期的开发者也觉得不放心，于是禁用了不少操作符。而目前Bitcoin SV和Bitcoin Cash的发展方向，是将这些操作符一一解放出来。</p>

<p>更强大的功能？还是更稳妥的基础设施？究竟怎样的做法是正确的，我也没有定论，只是告诉大家现在社区的发展方向就好了，大家自己做判断。</p>

<h2>参考资料:</h2>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-4]]></title>
    <link href="https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4/"/>
    <updated>2018-12-24T18:41:36+08:00</updated>
    <id>https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4</id>
    <content type="html"><![CDATA[<p>前面的文章中我们分析了一笔标准的Pay to Public Key HASH(P2PKH)交易。看起来其实结构挺简单的，这篇文章我们乘胜追击，看一下矿工们领取系统奖励时，构造的coinbase交易。</p>

<!-- more -->


<p>Coinbase交易规范的叫法是Generation TX，每一个block有且只有一笔Genration TX，该类交易的币是矿工挖矿凭空产生的，所以没有vin。比特币系统所有的币都产自于这里。</p>

<p>我们就以最常见创世块的交易作为示例来分析吧。</p>

<p><a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a>这个创始块中只有一笔交易，就是中本聪手工构造发给自己的币：</p>

<p><a href="https://www.blockchain.com/btc/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b">4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</a></p>

<h4>区块原始数据</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>00000000   01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000010   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000020   00 00 00 00 3B A3 ED FD  7A 7B 12 B2 7A C7 2C 3E   ....;£íýz{.²zÇ,&gt;
</span><span class='line'>00000030   67 76 8F 61 7F C8 1B C3  88 8A 51 32 3A 9F B8 AA   gv.a.È.ÃˆŠQ2:Ÿ¸ª
</span><span class='line'>00000040   4B 1E 5E 4A 29 AB 5F 49  FF FF 00 1D 1D AC 2B 7C   K.^J)«_Iÿÿ...¬+|
</span><span class='line'>00000050   01 01 00 00 00 01 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000060   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000070   00 00 00 00 00 00 FF FF  FF FF 4D 04 FF FF 00 1D   ......ÿÿÿÿM.ÿÿ..
</span><span class='line'>00000080   01 04 45 54 68 65 20 54  69 6D 65 73 20 30 33 2F   ..EThe Times 03/
</span><span class='line'>00000090   4A 61 6E 2F 32 30 30 39  20 43 68 61 6E 63 65 6C   Jan/2009 Chancel
</span><span class='line'>000000A0   6C 6F 72 20 6F 6E 20 62  72 69 6E 6B 20 6F 66 20   lor on brink of 
</span><span class='line'>000000B0   73 65 63 6F 6E 64 20 62  61 69 6C 6F 75 74 20 66   second bailout f
</span><span class='line'>000000C0   6F 72 20 62 61 6E 6B 73  FF FF FF FF 01 00 F2 05   or banksÿÿÿÿ..ò.
</span><span class='line'>000000D0   2A 01 00 00 00 43 41 04  67 8A FD B0 FE 55 48 27   *....CA.gŠý°þUH'
</span><span class='line'>000000E0   19 67 F1 A6 71 30 B7 10  5C D6 A8 28 E0 39 09 A6   .gñ¦q0·.\Ö¨(à9.¦
</span><span class='line'>000000F0   79 62 E0 EA 1F 61 DE B6  49 F6 BC 3F 4C EF 38 C4   ybàê.aÞ¶Iö¼?Lï8Ä
</span><span class='line'>00000100   F3 55 04 E5 1E C1 12 DE  5C 38 4D F7 BA 0B 8D 57   óU.å.Á.Þ\8M÷º..W
</span><span class='line'>00000110   8A 4C 70 2B 6B F1 1D 5F  AC 00 00 00 00            ŠLp+kñ._¬....</span></code></pre></td></tr></table></div></figure>


<p>然后我们解析拿我们以前文章的方法来解析一下这笔交易(因为这个区块中只包含了唯一一笔交易，我们顺便解析一下区块构造):</p>

<h4>block header 部分</h4>

<ol>
<li>首先是version字段:<code>01000000</code></li>
<li>然后是32字节代表上一个block的hash id(因为这笔交易所属block是第一个block，所以人为设置为0): <code>0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>接着是32字节的merkle root(关于merkle root，我们会在后面的文章中详解): <code>3BA3EDFD7A7B12B27AC72C3E67768F617FC81BC3888A51323A9FB8AA4B1E5E4A</code></li>
<li>4字节的时间戳: <code>29AB5F49</code></li>
<li>接着是目标难度(bits): <code>FFFF001D</code> 代表着挖矿难度，具体含义可参考我们之前的<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">比特币POW难度调节分析</a>。</li>
<li>nonce: <code>1DAC2B7C</code>，同样的挖矿调节参数，我们老是说比特币系统就是在算一个 &ldquo;毫无意义的随机数字&#8221;，没错，这就是毫无意义君。</li>
<li>这个区块包含的总交易数目：<code>01</code></li>
</ol>


<p>最好来个结构明细表格：</p>

<table>
<thead>
<tr>
<th>Field </th>
<th> Size </th>
<th>  Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version </td>
<td>4 bytes </td>
<td> Little-endian</td>
</tr>
<tr>
<td>Previous Block Hash </td>
<td> 32 bytes </td>
<td>    Big-endian</td>
</tr>
<tr>
<td>Merkle Root </td>
<td> 32 bytes  </td>
<td> Big-endian</td>
</tr>
<tr>
<td>Time </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Bits </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Nonce</td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
</tbody>
</table>


<h4>交易部分</h4>

<ol>
<li>version: <code>01000000</code></li>
<li>input数目 01</li>
<li>prev output: <code>0000000000000000000000000000000000000000000000000000000000000000FFFFFFFF</code></li>
<li>script length: <code>4d</code></li>
<li>coinbase (2-100字节): <code>04FFFF001D0104455468652054696D65732030332F4A616E2F32303039204368616E63656C6C6F72206F6E206272696E6B206F66207365636F6E64206261696C6F757420666F722062616E6B73</code></li>
<li>sequence: FFFFFFFF</li>
<li>outputs数目: 01</li>
<li>btc数目: 00F2052A01000000 &ndash; 50 BTC</li>
<li>pk_script length: 43</li>
<li>pk_script:<code>41 04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F  AC</code>

<ul>
<li>0x41代表着后面65个字节入栈</li>
<li><code>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</code></li>
<li>0xAC代表着OP_CHECKSIG</li>
<li>整个合起来就是输出脚本为: <Pubkey> &lt;OP_CHECKSIG></li>
</ul>
</li>
<li>lock time: 00000000</li>
</ol>


<p>这笔交易跟我们上一篇文章中的TransB构造是一样的，想要花费的话提供签名就OK了。不过这笔交易没有vin，取代的字段是coinbase。这个字段是可以随意调整的，中本聪在这里留存了一句非常有名的话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</span></code></pre></td></tr></table></div></figure>


<p>ASCII解码为:  The Times 03/Jan/2009 Chancellor on brink of second bailout for banks</p>

<p>这是2009年1月3日泰晤士报当天的头版文章标题，这是一个时间证明，证明比特币于2009-01-03开始运行，也顺便对传统的金融体系小小嘲讽一下。</p>

<h2>挖矿</h2>

<p>Generation TX交易需要Coinbase字段有两个原因:</p>

<ol>
<li>但是4字节的nonce字段随机性是不够的，需要引入更长的extra nonce，所以有了长度可以灵活调节(2-100字节)的coinbase字段</li>
<li>作为一个附言留给矿工来发表意见</li>
</ol>


<p>其实我对于coinbase字段没有啥意见，但是最初的nonce字段只有4个字节，意味着每秒钟只有4G的碰撞空间，很快全网就超出了这个限制，所以Coinbase字段立即就派上用场了。后来slushpool矿池发明了stratum挖矿架构，彻底进入了大算力组团挖矿的时代；这些技术的演化也非常有意思，可以参考这篇文章，讲的非常清晰：</p>

<p><a href="https://www.8btc.com/article/108894">区块链核心技术演进之路 &ndash; 挖矿演进</a></p>

<p>其实我觉得nonce字段最初最好设置为32字节，就没这么多事情了。</p>

<h2>有钱任性的矿工们</h2>

<p>矿工们早期是一批劳苦大众死宅，后来优胜劣汰只剩下了寡头；在挖矿故事里，还是有几个有意思的故事说道说道的：</p>

<ul>
<li>TXID 相同的交易</li>
</ul>


<p>一笔交易的id值是SHA(TX HEX)算出来的，因为每一笔交易的vin, vout不同，很难得到相同的txid值。但是在Generation TX里面，输出的数目和地址很有可能都是一样的。所以需要矿工自己构造一个随机的coinbase内容，防止产生相同的TXID值。</p>

<p>早期一位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<ul>
<li>忘了接收奖励的矿工</li>
</ul>


<p>2017-12-30 20:55:00，有个矿工挖到了一个区块之后，竟然丢弃了12.5BTC的奖励！</p>

<p><a href="https://btc.com/0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126">区块0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126</a></p>

<p>我们不知道这位矿工是用的哪个版本的挖矿软件，但是他们挖到一个区块之后，竟然没有构造地址来领取这笔奖励(价值20W USD)。难道他们真刀真枪上阵之前从来不测试一下吗？或者他们就是有钱任性的真土豪，我只能说:</p>

<p>土豪我们做朋友吧~~~</p>

<h2>coinbase</h2>

<p>因为coinbase是矿工们发挥自己灵感的地方，所以最初作为<code>区块永留存</code>的手段之一，大家纷纷刻字留念。</p>

<p>有刻字到此一游的，有山盟海誓秀恩爱的，有炫耀生孩子的，有申诉政治诉求的，有吟诗作对，弘扬中国传统文化的；总之这100个字节表示鸭梨很大。</p>

<h2>OP_RETURN</h2>

<p>coinbase留言是有实力的矿工才有资格搞的；没有足够算力怎么办呢？</p>

<p>早期Geek比较多，大家就纷纷构造不能花费的交易，在vout中用PUSHDATA来填充内容。</p>

<p>运用比特币的区块链技术存储与比特币支付不相关数据的做法是一个有争议的话题。许多开发者认为其有滥用的嫌疑，因而试图予以阻止。另一些开发者则将之视为区块链技术强大功能的有力证明，从而试图给予大力支持。那些反对非支付相关应用的开发者认为这样做将引致“区块链膨胀”，因为所有的区块链节点都将以消耗磁盘存储空间为成本，负担存储此类 数据的任务。</p>

<p>更为严重的是，此类交易仅将比特币地址当作自由组合的20个字节而使用，进而会产生不能用于交易的UTXO。因为比特币地址只是被当作数据使用，并不与私钥相匹配，所以会导致UTXO不能被用于交易，因而是一种伪支付行为。因此，这些交易永远不会被花费，所以永远不会从UTXO集中删除，并导致UTXO数据库的大小永远增加或“膨胀”。</p>

<p>后来人们又发明出来OP_RETURN留言法：</p>

<p>在0.9版的比特币核心客户端上，通过采用Return操作符最终实现了妥协。Return允许开发者在交易输出上增加80字节的非交易数据。然后，与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。Return输出被记录在区块链上，它们会消耗磁盘空间，也会导致区块链规模的增加，但 它们不存储在UTXO集中，因此也不会使得UTXO内存膨胀，更不会以消耗代价高昂的内存为代价使全节点都不堪重负。 RETURN 脚本的样式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  RETURN &lt;data&gt;</span></code></pre></td></tr></table></div></figure>


<p>“data”部分被限制为80字节，且多以哈希方式呈现，如32字节的SHA256算法输出。许多应用都在其前面加上前缀以辅助认定。例如，电子公正服务的证明材料采用8个字节的前缀“DOCPROOF”，在十六进制算法中，相应的ASCII码为 <code>44 4f 43 50 52 4f 4f 46</code>。</p>

<p> RETURN 不涉及可用于支付的解锁脚本的特点， RETURN 不能使用其输出中所锁定的资金，因此它也就没有必要记录在蕴含潜在成本的UTXO集中，所以 RETURN 实际是没有成本的。</p>

<p>RETURN 常为一个金额为0的比特币输出， 因为任何与该输出相对应的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效。如果你碰巧将 RETURN 的输出作为另一笔交易的输入，则该交易是无效的。</p>

<p>一笔标准交易（通过了 isStandard() 函数检验的）只能有一个 RETURN 输出。但是单个RETURN 输出能与任意类型的输出交易进行组合。</p>

<p>PS: 最初提出了RETURN，限制为80字节，但是当功能被释放时，限制被减少到40字节。 2015年2月，在Bitcoin Core的0.10版本中，限制提高到80字节。 节点可以选择不中继或重新启动RETURN，或者只能中继和挖掘包含少于80字节数据的RETURN。</p>

<h4>例子</h4>

<p>这里比特币就见证了一场成功的求婚：</p>

<p><a href="https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e">https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e</a></p>

<p><a href="https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0">https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0</a></p>

<h2>刻字服务</h2>

<p>后来有人提供了比较简单的刻字服务，只要你付点小费，就可以将想要说的话永久上链；里面的内容更是洋洋洒洒，有字符画，有山盟海誓，有政治诉求，甚至还有病毒签名，可以参考这篇文章：</p>

<p><a href="http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html">http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html</a></p>

<p>有个网站专门parse了所有区块的文本数据供大家瞻仰：</p>

<p><a href="http://bitcoinstrings.com/">http://bitcoinstrings.com/</a></p>

<p>里面记录了许多尘封的历史，篇幅最大的就是扩容大战；完整的将当时社区争论刻进了区块链中，这是人类历史上第一次区块链圆桌访谈录，值得仔细瞻仰。</p>

<h2>小结</h2>

<p>好了，到了这里，我们对于比特币的开采交易，普通交易都理解了；</p>

<p>下一步我们将一步步手工代码构造十六进制数据，然后形成一笔完整的交易去广播；完全吃透一笔交易的来龙去脉；</p>

<p>那么，下次再见。</p>

<h2>工具</h2>

<p><a href="https://sites.google.com/site/nathanlexwww/tools/utf8-convert">https://sites.google.com/site/nathanlexwww/tools/utf8-convert</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-3]]></title>
    <link href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/"/>
    <updated>2018-12-09T15:46:05+08:00</updated>
    <id>https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3</id>
    <content type="html"><![CDATA[<h2>scriptSig与scriptPubKey概览</h2>

<p>继续解析我们上篇文章的交易(<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code>)</p>

<p>目前为止，我们还没有解析vin中的scriptSig，以及vout中的scriptPubKey；这两个东东才是交易的核心，他们有什么作用呢？</p>

<!-- more -->


<p>scriptSig是一笔UTXO的开锁脚本，scriptPubKey是输出UTXO的加锁脚本，一笔交易就是打开上家的保险箱，将资金转移到下家的保险箱并重新加锁的过程:</p>

<ul>
<li>上家-TransA: id(b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b) &ndash;> vout scriptPubkey (转移到保险箱A，并给A上锁)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "value": 0.00010000,
</span><span class='line'>          "n": 0,
</span><span class='line'>          "scriptPubKey": {
</span><span class='line'>              "asm": "OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG",
</span><span class='line'>              "hex": "76a914650d0497e014e60d4680fce6997d405de264f04288ac",
</span><span class='line'>              "reqSigs": 1,
</span><span class='line'>              "type": "pubkeyhash",
</span><span class='line'>              "addresses": [
</span><span class='line'>                  "1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE"
</span><span class='line'>              ]
</span><span class='line'>          }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>转移-TransB: id(3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517) &ndash;> vin scriptSig (解锁保险箱A，拿出资金)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>          "vout": 0,
</span><span class='line'>          "scriptSig": {
</span><span class='line'>              "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>              "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>          },
</span><span class='line'>          "sequence": 4294967295
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下家-TransB: id(3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517) &ndash;>vout scriptPubkey (转移到保险箱B，并给B上锁)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "value": 0.00007000,
</span><span class='line'>          "n": 0,
</span><span class='line'>          "scriptPubKey": {
</span><span class='line'>              "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>              "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>              "reqSigs": 1,
</span><span class='line'>              "type": "pubkey",
</span><span class='line'>              "addresses": [
</span><span class='line'>                  "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>              ]
</span><span class='line'>          }
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<p>具体怎么理解这两个东东呢？我们还需要一点前置知识。</p>

<h2>比特币脚本语言系统 scripting language</h2>

<p>scriptPubkey以及scriptSig是一种脚本语言。比特币的脚本语言被设计为一种类 Forth 栈语言。拥有成无状态和非图灵完备的性质。无状态性保证了一旦一个交易被区块打包，这个交易就是可用的。图灵非完备性（具体来说，缺少循环和goto 语句）使得比特币的脚本语言更加不灵活和更可预测，从而大大简化了安全模型。</p>

<p>如果大家之前做过汇编开发的话，就会发现这跟汇编的指令码是非常相似的东东。</p>

<p>先来一个在线解析工具:</p>

<p><a href="https://bitcoin-script-debugger.visvirial.com/">https://bitcoin-script-debugger.visvirial.com/</a></p>

<p>再来一个视频讲解：</p>

<p><a href="https://www.youtube.com/watch?v=4qz7XehSBCc">https://www.youtube.com/watch?v=4qz7XehSBCc</a></p>

<p>比较简单的教程:</p>

<p><a href="https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-one/">https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-one/</a></p>

<ul>
<li>额，我知道大部分人跟我一样懒得去翻阅上面这些资料，所以我们简单传送一下：</li>
</ul>


<h3>一个最小脚本集</h3>

<p>现在想象我们有一台非常简单的计算器，它的CPU只有一个16位的寄存器，以及非常小的内存(520B)；我们需要设计一种语言，实现一些最简单的计算，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = 0x23
</span><span class='line'>x += 0x4b
</span><span class='line'>x *= 0x1e</span></code></pre></td></tr></table></div></figure>


<p>然后转换为类似汇编语言的比较简单的操作码形式, 我们需要以下指令集：</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> 操作码</th>
<th> 操作数(V值) </th>
<th> explained</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET(V) </td>
<td> <code>ab</code> V </td>
<td> <code>0xab</code> </td>
<td> 16bits(0x23) </td>
<td> 将V(0x23)载入到寄存器中</td>
</tr>
<tr>
<td>ADD(V) </td>
<td> <code>ac</code> V </td>
<td> <code>0xac</code> </td>
<td> 16bits(0x4b) </td>
<td> 寄存器值+0x4b; <code>0x23 + 0x4b = 0x6e</code></td>
</tr>
<tr>
<td>MUL(V) </td>
<td> <code>ad</code> V </td>
<td> <code>0xad</code> </td>
<td> 16bits(0x1e) </td>
<td> 寄存器值*0x1e; <code>0x6e * 0x1e = 0x0ce4</code></td>
</tr>
</tbody>
</table>


<p>在上面这个表格中，我们定义了三种最简单的操作码：<code>0xab, 0xac, 0xad</code>，跟在这三个操作码后面的2个字节就是操作数；将上面的计算步骤用代码表示如下(小端排序):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ab 23 00 ac 4b 00 ad 1e 00</span></code></pre></td></tr></table></div></figure>


<p>我们可以实现一个最简单的脚本逻辑，顺序parse这段代码，并转换为相应的操作码，然后进行运算；</p>

<p>我们实现了一个非常迷你的脚本集。</p>

<h3>栈设计</h3>

<p>上面的操作只涉及到了寄存器，但是现实情况中，我们通常要做多个计算步骤，并将临时变量存到内存中，另外会把复杂的程序组织为一个个函数；这种时候，最常见的内存组织方法是什么呢？</p>

<p>没错，就是我们最常用的数据结构：栈(STACK)。</p>

<p>比如下面这个函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int foo() {
</span><span class='line'>
</span><span class='line'>    /* 1 */
</span><span class='line'>
</span><span class='line'>    /* 2 */
</span><span class='line'>    uint8_t a = 0x12;
</span><span class='line'>    uint16_t b = 0xa4;
</span><span class='line'>    uint32_t c = 0x2a5e7;
</span><span class='line'>
</span><span class='line'>    /* 3 */
</span><span class='line'>    uint32_t d = a + b + c;
</span><span class='line'>
</span><span class='line'>    return d;
</span><span class='line'>
</span><span class='line'>    /* 4 */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>第一步函数刚刚跳转执行，栈初始化为空。[]</li>
<li>第二步，三个变量<code>a,b,c</code>压入栈中(PUSH STACK)</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12]
</span><span class='line'>[12, a4 00]
</span><span class='line'>[12, a4 00, e7 a5 02 00]</span></code></pre></td></tr></table></div></figure>


<ol>
<li>结合我们上面的操作码，计算<code>a,b,c</code>的和，并将结果压栈</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12, a4 00, e7 a5 02 00, 9d a6 02 00]</span></code></pre></td></tr></table></div></figure>


<ol>
<li>返回结果，并将栈元素弹出(POP STACK)，恢复到初始状态。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12, a4 00, e7 a5 02 00]
</span><span class='line'>[12, a4 00]
</span><span class='line'>[12]
</span><span class='line'>[]</span></code></pre></td></tr></table></div></figure>


<h3>Script Language</h3>

<p>机器码设计了指令的表示方法，栈设计规定了数据的存储方法；将机器码与栈设计结合起来，就是Bitcoin Script Language。它有几个明显的特点：</p>

<ul>
<li>脚本没有循环:这意味着脚本不能无限运行</li>
<li>栈空间只有520字节</li>
<li>整形常量4字节</li>
<li>脚本的内存访问是基于栈的:这意味着脚本中不存在命名变量这种东西，所有的操作码和操作数都表示为栈上的运算；通常，推入的栈项将成为后续操作码的操作数。在脚本的末尾，最上面的堆栈项是返回值。</li>
</ul>


<p>举个最简单的例子，bitcoin script language支持下面两个操作码：</p>

<h4>压栈操作码</h4>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> explained</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_0 </td>
<td> 0x00 </td>
<td> 将0x00压入栈中</td>
</tr>
<tr>
<td>OP_1 &mdash; OP_16 </td>
<td> 0x51 &mdash; 0x60 </td>
<td> 将0x01 &mdash; 0x10 压入栈中</td>
</tr>
</tbody>
</table>


<blockquote><p>PS: OP_0, OP_1还代表着布尔值False,True</p></blockquote>

<p>然后下面一段示例脚本代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>54 57 00 60</span></code></pre></td></tr></table></div></figure>


<p>或者直接翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_4 OP_7 OP_0 OP_16</span></code></pre></td></tr></table></div></figure>


<p>作用就是将四个值依次压栈，栈状态可以表示为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]
</span><span class='line'>[04]
</span><span class='line'>[04, 07]
</span><span class='line'>[04, 07, 00]
</span><span class='line'>[04, 07, 00, 10]</span></code></pre></td></tr></table></div></figure>


<p>此时栈顶元素值为0x10，前面我们说了，栈顶元素即返回值，所以这个脚本的返回值为0x10。当然，这个脚本现在就是将四个值压栈，并没有什么实际作用。</p>

<h4>PUSH DATA操作码</h4>

<p>简单的压栈操作码只能压入1个字节的数据，如果我们想以此压入多个字节的数据，需要用到 <code>PUSH DATA</code>操作码。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> L (length) </th>
<th> D (data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_PUSHDATA1 </td>
<td> <code>0x4c</code> L D </td>
<td> 8bits </td>
<td> L bytes</td>
</tr>
<tr>
<td>OP_PUSHDATA2 </td>
<td> <code>0x4d</code> L D </td>
<td> 16bits</td>
<td> L bytes</td>
</tr>
<tr>
<td>OP_PUSHDATA3 </td>
<td> <code>0x4e</code> L D </td>
<td> 32bits</td>
<td> L bytes</td>
</tr>
</tbody>
</table>


<ul>
<li>L 代表需要压入的字节长度，它可以有8bits, 16bits，或者32bits，这三个操作码可以最大压入2<sup>8</sup> &ndash; 1 = 255字节、2<sup>16</sup> &ndash; 1 = 65535字节、2<sup>32</sup>字节</li>
<li>D 代表实际的数据</li>
</ul>


<p>举个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4c 14 11 06 03 55 04 8a
</span><span class='line'>0c 70 3e 63 2e 31 26 30
</span><span class='line'>24 06 6c 95 20 30</span></code></pre></td></tr></table></div></figure>


<p>前面的<code>0x4c</code>代表是<code>OP_PUSHDATA1</code>操作符，后面的<code>0x14</code>代表压入20个字节，然后后面跟着20字节的数据</p>

<p>此时栈状态可以表示为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[11 06 03 55 04 8a 0c 70
</span><span class='line'> 3e 63 2e 31 26 30 24 06
</span><span class='line'> 6c 95 20 30]</span></code></pre></td></tr></table></div></figure>


<p>另外，为了节省空间，还有一个非常取巧的设计:
对于非常短的数据有一种特殊的编码。如果一个操作码位于01到4b之间(包括在内)，它就是一个push数据操作，其中操作码本身就是字节长度:</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> L (length) </th>
<th> D (data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L </td>
<td> L D </td>
<td> 8bits (0x01-0x4b) </td>
<td> L bytes</td>
</tr>
</tbody>
</table>


<p>比如下面的例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>07 8f 49 b2 e2 ec 7c 44</span></code></pre></td></tr></table></div></figure>


<p>最前面的<code>07</code>代表着直接将后面7个字节压栈</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[8f 49 b2 e2 ec 7c 44]</span></code></pre></td></tr></table></div></figure>


<h4>算术操作码</h4>

<p>算术操作码都是基于栈元素操作的，所以他没有显式的传入参数。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_ADD </td>
<td> 0x93</td>
</tr>
<tr>
<td>OP_SUB </td>
<td> 0x94</td>
</tr>
</tbody>
</table>


<p>这两个操作符都需要从栈顶一次弹出两个元素作为操作数。</p>

<p>例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>55 59 93 56 94</span></code></pre></td></tr></table></div></figure>


<p>或者直接翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_5 OP_9 OP_ADD OP_6 OP_SUB</span></code></pre></td></tr></table></div></figure>


<p>每一步操作的栈状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]              # 初始化
</span><span class='line'>[5]             # OP_5
</span><span class='line'>[5, 9]          # OP_9
</span><span class='line'>[14]            # POP; POP; OP_ADD(5, 9)
</span><span class='line'>[14, 6]         # OP_6
</span><span class='line'>[8]             # POP; POP; OP_SUB(14, 6)</span></code></pre></td></tr></table></div></figure>


<p>最后的结果是8</p>

<h4>比较操作码</h4>

<p>比较用于判断语句，作用比较简单。同样的，它需要从栈顶弹出两个元素来比较。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_EQUAL </td>
<td> 0x87</td>
</tr>
<tr>
<td>OP_EQUALVERIFY </td>
<td> 0x88</td>
</tr>
</tbody>
</table>


<p>OP_EQUALVERIFY跟OP_EQUAL作用相同，但是比较之后还要执行一个 OP_VERIFY操作。OP_VERIFY检查栈顶元素，如果栈顶元素不为真，就出栈并标记交易无效。</p>

<p>跟之前的算术操作码结合起来的一个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>02 c3 72 02 03 72 01 c0 93 87</span></code></pre></td></tr></table></div></figure>


<p>翻译为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[c3 72] [03 72] [c0] OP_ADD OP_EQUAL</span></code></pre></td></tr></table></div></figure>


<p>执行起来是这样子的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                      # 栈初始化
</span><span class='line'>[c3 72]                 # `02 c3 72`代表c3 72两个字节直接入栈
</span><span class='line'>[c3 72, 03 72]          # `02 03 72`代表03 72两个字节直接入栈
</span><span class='line'>[c3 72, 03 72, c0]      # `01 c0`代表c0直接入栈
</span><span class='line'>[c3 72, c3 72]          # 栈顶弹出c000, 0372, 相加得 c3 72
</span><span class='line'>[1]                     # 栈顶弹出c372，c372，比较为真</span></code></pre></td></tr></table></div></figure>


<p>最后这个表达式结果为1。</p>

<h4>栈操作码</h4>

<p>这个操作码比较特殊，它得作用是直接将栈顶元素复制一份，然后入栈。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_DUP </td>
<td> 0x76</td>
</tr>
</tbody>
</table>


<p>例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04 b9 0c a2 fe 76 87</span></code></pre></td></tr></table></div></figure>


<p>翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[b9 0c a2 fe] OP_DUP OP_EQUAL</span></code></pre></td></tr></table></div></figure>


<p>执行起来是这样子的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                          # 栈初始化
</span><span class='line'>[b9 0c a2 fe]               # 04代表后面4个字节压栈
</span><span class='line'>[b9 0c a2 fe, b9 0c a2 fe]  # 复制栈顶4字节然后压栈
</span><span class='line'>[1]                         # 弹出栈顶8字节，比较结果为真</span></code></pre></td></tr></table></div></figure>


<p>可以看出来，如果OP_DUP后面跟着OP_EQUAL，执行结果永远为真。</p>

<h4>加解密操作码</h4>

<p>这几个操作码是比特币交易验证得核心操作码，也是做事情最多的：</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_HASH160 </td>
<td> 0xa9</td>
</tr>
<tr>
<td>OP_CHECKSIG </td>
<td> 0xac</td>
</tr>
</tbody>
</table>


<p>OP_HASH160 弹出顶部堆栈项，在其上执行sha256=>hash160，然后返回结果。</p>

<p>OP_CHECKSIG 弹出前两个堆栈项，第一个是ECDSA公钥，第二个是der编码的ECDSA签名。之后，如果签名对该公钥有效，则推送OP_TRUE，否则推送OP_FALSE。它是OpenSSL的ECDSA_verify的脚本实现。</p>

<h5>有了以上的知识，我们就能深入解析比特币交易加锁解锁的细节啦</h5>

<h2>深入解析scriptPubkey与scriptSig</h2>

<h4>首先然我们来解析一下TransA的 scritPubkey 加锁脚本</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>76a914650d0497e014e60d4680fce6997d405de264f04288ac</span></code></pre></td></tr></table></div></figure>


<p>翻译为</p>

<ol>
<li>0x76代表OP_DUP</li>
<li>0xa9代笔OP_HASH160</li>
<li>0x14代表后面20个字节<code>650d0497e014e60d4680fce6997d405de264f042</code>直接入栈，这20个字节其实是转账地址的pubKeyHash</li>
<li>0x88代表OP</li>
<li>0xac代表OP_EQUALVERIFY</li>
</ol>


<p>最后翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再简化一下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>这段脚本代表 TransA的发起者把一笔钱转入到保险箱后，用这个脚本设置了一把锁，谁能提供另外一个脚本，跟此脚本合并运算后，栈元素全部出栈，并且最后出栈元素为真，那么就视为解锁成功，可以花费这笔钱。</p>

<p>仔细看看，解开这把锁需要我们提供什么信息呢？</p>

<ol>
<li>首先我们要提供一个公钥，确保这个公钥执行 OP_HASH160操作后，与PubKeyHASH相匹配，其意义就是证明你拥有这个转账地址的公钥</li>
<li>光证明拥有公钥不安全，毕竟如果这个地址之前花费过，公钥就明晃晃暴漏了；所以你还要提供一个对这个脚本的签名，并通过OP_CHECKSIG验证，证明你还拥有和公钥相对的私钥；而私钥只有拥有人才知道，它是永远不会暴露的</li>
<li><p>同时进行公钥、私钥的验证保证了比特币的安全性，毕竟，即使量子计算机成真，它也需要同时攻破三重保险：</p>

<ul>
<li>逆向sha256</li>
<li>逆向ripemd160</li>
<li>逆向ECDSA</li>
</ul>
</li>
</ol>


<p>如果能做到这个，那么，全世界的银行、金融、所有的信息系统都不安全了。如果真的到了那个时候，比特币的安全就不值一提了。</p>

<h4>那么我们提供的解锁脚本TransB的scriptSig 同样解析一遍看一下</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<p>解析为:</p>

<p>1.0x47代表后面71个字节入栈，这其实就是签名<code>Sig</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac001</span></code></pre></td></tr></table></div></figure>


<p>2.0x41后面代表65个字节入栈，这是<code>Pubkey</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<p>最终简化为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Sig&gt; &lt;PubKey&gt;</span></code></pre></td></tr></table></div></figure>


<p>这就是我们开锁的钥匙！</p>

<h4>合并运算</h4>

<p>我们把两个脚本来合并运算(把钥匙插进锁孔里)</p>

<ul>
<li>scriptPubKey (锁):</li>
</ul>


<p><code>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></p>

<ul>
<li>scriptSig (钥匙):</li>
</ul>


<p><code>&lt;Sig&gt; &lt;PubKey&gt;</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                                                              # 初始化
</span><span class='line'>[Sig]                                                           # 将scriptSig中的sig信息入栈
</span><span class='line'>[Sig, PubKey]                                                   # 将scriptSig中的Pubkey入栈
</span><span class='line'>[Sig, PubKey, OP_DUP]                                           # 将scriptPubKey中的 OP_DUP入栈
</span><span class='line'>[Sig, Pubkey, Pubkey]                                           # 执行OP_DUP，复制栈顶元素PubKey
</span><span class='line'>[Sig, Pubkey, Pubkey, OP_HASH160]                               # 将scriptPubKey中的 OP_HASH160入栈
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey)]                                  # 执行OP_HASH160
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey), PubkeyHash]                      # 将scriptPubKey中的 PubKeyHash入栈
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey), PubkeyHash, OP_EQUALVERIFY]      # 将scriptPubKey中的 OP_QUEALVERIFY入栈
</span><span class='line'>[Sig, Pubkey]                                                   # 检查公钥是否有效，如果有效，出栈
</span><span class='line'>[Sig, Pubkey, OP_CHECKSIG]                                      # 将scriptPubKey中的 OP_CHECKSIG入栈
</span><span class='line'>[1]                                                             # 执行OP_CHECKSIG，用Pubkey检查Sig的有效性；检查通过
</span><span class='line'>[]                                                              # Gooooooooood!! 钥匙合法，开锁成功</span></code></pre></td></tr></table></div></figure>


<p>最后合并运算的结果返回为True。解锁成功。</p>

<p>然后我们用一张语法树解析图再现整个过程：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181209/bg1.png" alt="img" /></p>

<h5>这就是一笔标准的P2PKH(Pay to Public Key Hash)交易的全解析。</h5>

<h4>Pay to PubKey</h4>

<p>既然已经开锁，我们就可以像TransA的scriptPubKey一样，再构造TransB的scriptPubkey，将资金转到新的保险箱中，并重新加锁。</p>

<p>TransB的scriptPubkey 构造为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>?? 这怎么跟我们上一笔TransA的scriptPubkey长的不一样？</p>

<p>没错，这笔交易的输出小任性了一把，我们说标准的输出是要求提供一个公钥来验证 Public Key hash值的，但是这笔交易的转移者非常有自信，他说，你直接提供私钥签名就可以花费了，不用那么麻烦了。</p>

<p>这种交易称之为Pay to Pubkey，安全性肯定不如Pay to Public Key Hash交易的；但是因为比较方便，早期有一些交易采用了这种形式，但是现在已经越来越少了；</p>

<p>要解开这把锁，只需要提供签名就好了，更简单。</p>

<p>总结一下这种交易的scriptPubkey加锁脚本以及scriptSig解锁脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scriptPubkey: &lt;pubkey&gt; OP_CHECKSIG
</span><span class='line'>scriptSig: &lt;sig&gt;</span></code></pre></td></tr></table></div></figure>


<p>如果你感兴趣的话，自己去找找这笔交易对应的scriptSig吧。</p>

<h2>一些神奇的操作符</h2>

<h4>OP_CHECKLOCKTIMEVERIFY</h4>

<p>也有人把这个操作符称之为OP_CLTV，或者昵称为OP_HODL；什么意思呢？就是这个操作符允许你发送一笔钱给一个地址，并且用OP_HODL指定一个时间，只有过了这个时间之后，才能花费这笔资金！</p>

<p>这个操作符在<a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65</a>中定义，2015-11-30在Bitcoin Core 0.11.2版本中激活。</p>

<p>之前我们介绍过交易中有个locktime字段，功能是类似的；区别在于，locktime交易在指定到达交易时间之前，是不入区块链的，所以如果设置了RBF的话，可以随时取消；</p>

<p>但是OP_HODL是入块的，真正落子无悔!</p>

<p>这个操作符最大的作用，让我来看就是让真正的比特币死忠实现<code>屯币不动</code>。死忠们经常说一币一别墅，一币$250K，但是稍微有个风吹草动就卖掉了；如果你对比特币的信心无可匹敌的话，就用<code>OP_HODL</code>操作符将自己的币锁定10年吧。</p>

<p>持币10年之后再看比特币兴衰，才是真死忠。</p>

<h2>小结</h2>

<p>这篇文章中我们从最基本的栈脚本操作码讲起，然后一步一步说明了比特币的脚本系统是如何设计、运作的。</p>

<p>最后，我们详细解析了一笔完整的标准Pay to Public Key Hash 交易；看到这里，你已经完全理解了比特币运作的基础；你已经是货真价实的<code>专家</code>啦；撒花庆祝~~~</p>

<p>关于比特币的脚本系统，其实最初的时候还是挺有争议的，大家觉得过于复杂，对安全性不利，而实际上历史上确实出现过安全方面的漏洞，后来陆续又禁用了一些操作码；关于这个设计理念，早期中本聪本人曾经做过讲解，这个帖子是早期先驱非常非常有意思的讨论，值得一读:</p>

<p><a href="https://bitcointalk.org/index.php?topic=195.5">https://bitcointalk.org/index.php?topic=195.5</a></p>

<p>说些题外话，其实仔细读读比特币第一版的源码，还有中本聪早期在论坛上发的贴子，很容易就有几个结论：</p>

<ol>
<li>比特币不是一拍脑袋就蹦出来的，中本聪至少从2006&mdash;2007年就已经开始思考整个设计了；并且2008年白皮书发表之前，中本聪基本上已经实现第一版本的代码了</li>
<li>中本聪是密码学方面的大师，他对于各个算法的优点劣势都非常熟悉</li>
<li>中本聪是个编程大师，并且很有可能是个MS流派的码农；他对p2p网络，计算机汇编指令集，跨平台GUI都很熟悉，而且是个实战派；这一点非常重要，也是中本聪和其它理论派科学家的根本不同：他不光有点子，还有能力用代码去实现设想。</li>
<li>这是我的推论哈，代码风格看起来很统一，极大可能中本聪是一个人而不是一个组织；这和文学作品一样的，大家读读代码就很容易感觉出来，这是一个人写的。</li>
</ol>


<p>当然，除了Pay to public key Hash交易，比特币还支持其它比较复杂的交易类型，用于更丰富的金融场景中（比如合约、公证等等），另外，还有挖矿奖励是怎么来的？这个还没说来。</p>

<p>那么，我们下篇文章再见。</p>

<h2>工具</h2>

<p>最后再增加几个在线调试bitcoin script的工具:</p>

<p><a href="https://webbtc.com/script">https://webbtc.com/script</a></p>

<p><a href="https://siminchen.github.io/bitcoinIDE/build/editor.html">https://siminchen.github.io/bitcoinIDE/build/editor.html</a></p>

<h4>引用资料:</h4>

<p><a href="https://en.bitcoin.it/wiki/Script">https://en.bitcoin.it/wiki/Script</a></p>

<p><a href="https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-two/">https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-two/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.htlm">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.htlm</a></p>

<p><a href="https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/core/script.py">https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/core/script.py</a></p>

<p><a href="https://medium.com/@thomasmccabe/hodling-bitcoins-with-op-checklocktimeverify-a-step-by-step-guide-to-manually-building-a-bitcoin-ce9476725de8">https://medium.com/@thomasmccabe/hodling-bitcoins-with-op-checklocktimeverify-a-step-by-step-guide-to-manually-building-a-bitcoin-ce9476725de8</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=1250409.0">https://bitcointalk.org/index.php?topic=1250409.0</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-4]]></title>
    <link href="https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4/"/>
    <updated>2018-12-05T16:04:29+08:00</updated>
    <id>https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4</id>
    <content type="html"><![CDATA[<p>之前我们学习了比特币的HD钱包的技术部分，写着写着我都觉得太无聊了，其实我觉得比特币归根结底还是一个很Geek的东西，初期被它吸引的人估计心底里都有一个独立自由的梦，甚至很多人都想要独立建国；它的技术发展史上也出现过很多有意思的事情，于是增加一篇娱乐性文章；</p>

<p>我们知道比特币的交易是匿名的，但是有很多公共业务，比如交易所，以及公众人物&mdash;会公开他们的地址，那么让我们好好八卦一下比特币历史上那些有意思的地址</p>

<!-- more -->


<h4>satoshi的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a></p>

<p>该地址属于比特币创始人中本聪，是比特币的创世地址，地址内的比特币从未移动过，其中的50币因为技术上的设计原因也无法进行移动。(卖个关子，具体啥原因关注我们后续的文章哦)</p>

<p>具体请参考:<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a></p>

<p>直到今天，还有源源不断的小额转账给这个地址，纪念satoshi。</p>

<h4>Hal Finney的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3">1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3</a></p>

<p>比特币历史上第一笔交易发生在<a href="https://www.blockchain.com/btc/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16">f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16</a>；是中本聪发送给我们熟知的<a href="https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist">Hal Finney</a>)先生的。这笔交易发送了10个BTC，被收录在第<a href="https://www.blockchain.com/zh/btc/block-height/170">170 Block</a>中。</p>

<p>Hal曾经在论坛上说自己是第二个运行比特币软件的人，他挖到的第一个区块大概是第70 Block，可以肯定，第70 block之前所有的地址都是中本聪本人的钱包地址，如果有人再跳出来说自己是中本聪的话，我们什么都不相信，只会问他两个问题：</p>

<ul>
<li>您能花费一笔第70 block之前的比特币吗？</li>
<li>或者您能出示 <code>I am xxx, happy bitcoiner guys, and today is 2xxx/xx/xx, i prove i am satoshi</code> 这句话的签名，并让我们用早期的公钥来验证一下吗？</li>
</ul>


<h4>Laszlo Hanyecz 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1XPTgDRhN8RFnzniWCddobD9iKZatrvH4">1XPTgDRhN8RFnzniWCddobD9iKZatrvH4</a></p>

<p>没错，这就是著名的<a href="http://link.zhihu.com/?target=https%3A//bitcointalk.org/index.php%3Ftopic%3D137.0">比特币披萨日</a>事件中的主人公。</p>

<p>当时<a href="https://www.blockchain.com/btc/tx/a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d">这笔2010-05-22的交易</a>中，Laszlo Hanyecz花费了10000个币买了两个pizza；造就了比特币历史上第二个节日：披萨日。撒花~~~ (PS:我把比特币的第一个节日归为比特币的生日，<a href="https://20090103.com">2009/01/03</a>)</p>

<p>后来比特币价格不断波动，人们就不断的调侃史上最贵的pizza，史上价格变化最快的pizza等等~~~</p>

<p>Laszlo Hanyecz是个真正的Geek，他应该是已知的显卡挖矿第一人，在这个地址上，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p>

<p>当年买了Laszlo一万个比特币的Jercos当然也是这次历史时刻的另一个主角。他在去年的时候接受了一家媒体的访问，并漏出了自己的真实身份。</p>

<p>原来Jercos非常的年轻，现在也只有25岁（买10000个比特币那年仅仅19岁）。他告诉记者说自己在bitcoin刚创世的2009年就关注了这项技术，并成为了出入各大极客论坛的一员。他与卖披萨的Laszlo并不认识，但是总是在同一个IRC（聊天室）出入，在当时算是对ID比较相熟。</p>

<p>谈到一万个比特币的去向时，他表示在第二年他把这一万枚比特币以400美金的价格出售了，回报率在十倍。（虽然十倍但是还是很可惜了。。）如今他对区块链的技术还是十分看好，对以太坊也十分看好。</p>

<p>Laszlo Hanyecz与Jercos的比特币经历可谓是大风大浪了，以后可以跟后来人好好说说<code>当年~~~</code>；</p>

<p>如果你这样想，那就Out了，真正的Geek永远是站在潮流前头的，同样的，2018-02-05，闪电网络运行后，Laszlo Hanyecz又花费了0.00649枚比特币通过闪电网络买了两块披萨，续写了比特币披萨的传奇；</p>

<p>少年，当你在为所谓<code>10000个比特币买披萨是不是很后悔</code>这种问题纠结时，人家早就又一次站在潮头浪尖了；所以~~~</p>

<h5>让我们努力学习吧。</h5>

<p>这个地址至今仍然非常活跃，Laszlo Hanyecz仍然是比特币世界中的Geek先锋，并且他用自己的乐观幽默为全世界的bitcoiner创造了一个节日，Hi, Laszlo Hanyecz，谢谢你！</p>

<h4>Bitcoin Faucet donation的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC?offset=0&amp;filter=6">15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC</a></p>

<p>这个地址属于比特币先驱<a href="https://en.bitcoinwiki.org/wiki/Gavin_Andresen">Gavin Andresen</a>在2010年建立的一个网站:</p>

<p><a href="https://freebitcoins.appspot.com/">https://freebitcoins.appspot.com/</a></p>

<p>当时Gavin Andresen作为中本聪之后的主力开发者，非常希望普及比特币，于是建立了<a href="https://bitcointalk.org/index.php?topic=183.0">Bitcoin Faucet donation</a>这个项目，免费发送比特币给人们，这个地址总共免费发放了超过10000个币；</p>

<p>Gavin Andresen为比特币的开发，普及做出了巨大的贡献，Hi, 了不起Gavin，向你致敬！</p>

<h4>Andreas M. Antonopoulos 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1andreas3batLhQa2FawWjeyjCqyBzypd">1andreas3batLhQa2FawWjeyjCqyBzypd</a></p>

<p>Andreas M. Antonopoulos是比特币社区里令人肃然起敬的人物，他从非常非常早期(2012)就开始比特币相关知识的布道；我得说，凡是有严肃的学习比特币、区块链知识愿望的人们，观看Andreas M. Antonopoulos的讲演视频是绝佳途径，他的Yotube主页：</p>

<p><a href="https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ">https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ</a></p>

<p>Andreas M. Antonopoulos对比特币布道激励了非常多的人，但是作为先驱，他却没有收到多少报酬，这完全是<a href="https://twitter.com/aantonop/status/938147200978374662?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E938147200978374662&amp;ref_url=https%3A%2F%2Fqz.com%2F1151233%2Fandreas-antonopoulos-got-1-5-million-in-bitcoin-donations-after-roger-ver-bitshamed-him%2F">公益的工作</a>。怎么能让真正输出价值的人受到冷落呢？为了感谢他，在2017-12，粉丝们为他的地址发送了近100个bitcoin的捐款。但是我们这里很高兴的引用一句俗语：<code>黄金有价，知识无价</code>；Hi, Antonopoulos，<code>比特有价，知识无价</code>，期待收到你更多的教诲。</p>

<h4>美国法警局的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55">1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55</a></p>

<p>所有者为美国法警局，该地址内的比特币来自被查获的丝绸之路，后在第一次拍卖会中将币转移给中标人<a href="https://www.blockchain.com/btc/tx/9e95c3c3c96f57527cdc649550bf8e92892f7651f718d846033798aee333b0c3">29,658BTC交易</a>。</p>

<p>2018年这个地址还有小额的零星收入，不知转入者是谁。</p>

<h4>Tim Draper的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi">1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi</a></p>

<p>这个哥们是bitcoin的铁杆粉丝；它是风险投资公司Draper Fisher Jurvetson的创始人，作为硅谷投资教父，投资了SpaceX、Tesla、Thumbtack，Baidu，Hotmail，Skype等耳熟能详的公司；</p>

<p>这个地址就是当时他购买美国法警局拍卖丝绸之路BTC的转移地址；</p>

<p>作为bitcoin铁粉，这个老哥早期投资了蝴蝶矿机，最著名的故事就是在Mt.Gox事件中损失惨重后仍然多次买买买，即使去年的大涨风潮中也一币不卖；他对于比特币的信心估计就是中本聪本人也不及，如果你去google <code>Tim Draper</code>，估计排在前面的就是$250K， 即他相信2022年一币250000$，让我们祝福这位老哥。</p>

<h4>Carl M. Force的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB">14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB</a></p>

<p>该地址属于“法国女仆”，又名Carl M. Force，是美国联邦缉毒局的一名探员，在参与调查丝绸之路时，Force化名“法国女仆”利用职务之便勒索罗斯乌布利希，并将赃款汇入该地址内，但Force最终被抓住并遭到起诉。</p>

<p>这应该是有据可查的第一起比特币偷盗破获案件。Hi, Carl M. Force，不要沮丧哦，你已经青史留名了。</p>

<p>不过悲伤的是，之后发生的偷盗事件数不胜数，却没有多少案件能被破获。</p>

<h4>真土豪的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv">1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv</a></p>

<p>该地址发生了一笔历史上最大额的交易，一次性转移了500,000 BTC，创历史之最，虽然是发生在2011年的事情，但是按币本位算，估计这个数额很难打破了。</p>

<p>这个地址2017年还被使用过，观看它的交易记录，我严重怀疑这个地址与Mt.Gox有牵连。</p>

<h4>wiki的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v">1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v</a></p>

<p>这是维基解密用来接受比特币捐赠的地址，维基解密的创始人，阿桑奇，也是比特币社区最早的支持者；我得说，这位阿桑奇，真是一条汉子；</p>

<p>希望能看到你收到更多的捐赠，wikileaks！</p>

<h4>烤猫的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW">15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW">1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey">1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey</a></p>

<p>由于比特币的匿名性，发生过很多看起来不可思议的事情。有时候看这些事情的时候好像是传奇小说。<a href="https://view.inews.qq.com/a/20170805G04OZI00?refer=share_recomnews">烤猫的故事</a>非常有意思，我都有点相信他现在在某个海岛上搞基建。这三个地址的交易也很有意思，有时间我们来细细探究一下。</p>

<h4>Bitstamp被盗地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf">1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf</a></p>

<p>Bitstamp遭窃的热钱包地址，黑客在2015年1月5日时陆续从该地址内盗取了大约19,000BTC 。</p>

<p>事件调查可以参考这里:</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/">https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/</a></p>

<p>这个地址非常奇怪，之后还陆陆续续有交易发生；并且在2017年，有人考证一起Tether的hack事件和Bitstamp被盗事件是同一个黑客：</p>

<p><a href="https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/">https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/</a></p>

<p>一个疑问重重的故事。</p>

<h4>Bitfinex被盗地址</h4>

<p><a href="https://gist.github.com/MrChrisJ/4a959a51a0d2be356cc2e89566fc1d87">地址列表</a></p>

<p>2016-08-03，<a href="https://www.reddit.com/r/Bitcoin/comments/5vr8xg/confirmed_120000_bitcoins_from_the_bitfinex_hack/">reddit</a>上面已经有人确认，Bitfinex被盗119756个btc.</p>

<p>查看黑客的接收地址，有些币至今未动。</p>

<p>bitfinex后来通过发行USDT起死回生，这种神操作说起来好像是天方夜谈，呵呵，比最诡异的侦探小说还诡异的故事。</p>

<h4>NiceHash被盗地址</h4>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>2017-12-06，Nicehash 被盗 4700+币</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>呵呵，说下去都不好意思了；黑客的黄金年代啊</p>

<h4>Mtgox</h4>

<p><a href="https://www.cryptoground.com/mtgox-cold-wallet-monitor/">https://www.cryptoground.com/mtgox-cold-wallet-monitor/</a></p>

<p>作为史上之最，Mtgox事件聚集了一切传奇侦探小说都有的元素，就等着将来一位福尔摩斯来为我们排疑解惑了；期待着那一天的到来</p>

<h4>官方土豪</h4>

<p><a href="https://www.blockchain.com/btc/address/1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX">1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX</a></p>

<p>之前我们说50w币转账的土豪毕竟是萌芽时期，只能说是个野生土豪。来来来，让我们活捉一位官方土豪。</p>

<p>就在前几天，2018-12-03，发生了<a href="https://www.blockchain.com/btc/tx/244c71c790eb327eb8bbf66aa2d0a75bac7c1fe7b55d1161c316c6f93292d376">一笔66233比特币的转账</a>。以当前的币价来算，可谓是天文数字了。这笔交易主要是将老地址的币逐步迁移到bech32地址上去。(什么是bech32地址？复习我们之前的文章哦)</p>

<p>这个地址的土豪还关联着9个地址，总币量加起来大概55w币。</p>

<p>有人推测这是coinbase.com的冷钱包。</p>

<p>嗯哼，应该是继中本聪之后最大的壕。</p>

<h4>伊朗恶意网络行动者</h4>

<p>前几天，美国财政部通过美国外国资产控制办公室(Office of Foreign Assets Control，简称OFAC)，在被制裁方名单上增加了两个比特币地址:</p>

<p><a href="https://www.blockchain.com/btc/address/149w62rY42aZBox8fGcmqNsXUzSStKeq8C">149w62rY42aZBox8fGcmqNsXUzSStKeq8C</a></p>

<p><a href="https://www.blockchain.com/btc/address/1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V">1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V</a></p>

<p>这些特殊的地址被挑选出来是因为其所有者被认为是伊朗人，而伊朗目前正面临来自美国的严厉经济制裁。可笑的是，美国政府将此地址列入黑名单的理由是这些地址跟勒索软件有关。</p>

<p>这两个地址自 2013 年以来已进行了 7,000 多笔交易，并收到近 6,000 枚 BTC。截至 2018年 11 月 28 日，任何与这些地址进行互动的人，在技术上都可能被美国政府追究责任并以某种方式受到惩罚。</p>

<p>但实际上，这些威胁不过只是空话。任何人，甚至包括美国政府及其执行官和执法人员，都无法阻止特定地址发送或接收比特币。</p>

<p>这不，美国财政部话音刚落，立即有人给这两个地址发币，并使用了嘲弄性质的地址 <code>3FUCKdZ89fxsk6KVKMTWvCWshsfL8xgmM4</code>发送交易并附言:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>The U.S. government cannot ban Bitcoin addresses
</span><span class='line'>
</span><span class='line'>Chancellor on brink of second bailout for banks</span></code></pre></td></tr></table></div></figure>


<p>赤裸裸的打脸一个国家政府的行为是Geek们的最爱，你可以把它理解为小孩子的淘气行为，我真的很好奇，美国政府该如何去寻找这些发币者并惩罚他们呢？</p>

<p>难道是去求助魔法师的水晶球吗23333?</p>

<p>&hellip;&hellip;</p>

<h4>虚荣地址(Vanity Address)</h4>

<p>有时候我们会见到一个很有型的地址，比如这个:</p>

<p>1LoveYoURwCeQu6dURqTQ7hrhYXDA4eJyn</p>

<p>这是神鱼结婚，想要送给老婆比特币作为爱的永恒证明，特意生成了这么一个地址，同样还有一笔虐狗交易:</p>

<p><a href="https://www.blockchain.com/zh-cn/btc/tx/e250c6d7ea4c5037fb96de1a2cb169850be792474401bae140fce784940f1dd3?show_adv=true">e250c6d7ea4c5037fb96de1a2cb169850be792474401bae140fce784940f1dd3</a></p>

<p>区块链中刻字的办法我们后面会介绍，不过这个虚荣地址(Vanity Address)是怎么生成的呢？</p>

<p>其实道理很简单，还记得我们之前的钱包系列教程吗？</p>

<p>比特币的地址编码最终是base58的字符集合。所以最简单的办法就是暴力穷举碰撞。</p>

<p>在这方面最好用的软件是<a href="https://en.bitcoin.it/wiki/Vanitygen">Vanitygen</a>，在一块GTX 750 Ti上，速率能达到15M/s，也就是一秒钟碰撞1500w次。</p>

<p>而1LoveYou 开头八位，大概需要碰撞58<sup>8</sup>次，需要半年左右吧。当然你有100台机器一起来算就提速100倍。</p>

<h4>虚荣地址在线生成服务</h4>

<p>如果你要生成一个八位字母开头的虚荣地址，个人是很难拥有100台机器的算力的，因此网上有人提供了此方面服务，允许你付款生成一个虚荣地址。</p>

<p>但是生成地址的人肯定私钥也知道了，这样的地址是没人要的，该怎么办呢？</p>

<p>又得复习我们之前的文章了。我们说比特币的地址来源于椭圆曲线算法生成的<code>私钥--公钥</code>对，而这个算法的<code>私钥--公钥</code>对是满足<code>加法、乘法律</code>的;</p>

<p>对于私钥-公钥对(R1,U1)和(R2,U2)来说，如果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>U3=U1+U2
</span><span class='line'>R3=R1+R2</span></code></pre></td></tr></table></div></figure>


<p>那么U3、R3是一对（也就是说，私钥R3的公钥是U3），乘运算同理。</p>

<p>于是有人拍脑袋想出了一种虚荣地址的在线安全生成方法，描述如下：</p>

<ol>
<li>客户首先自己生成一个 <code>私钥~公钥对</code>: (R1,U1)</li>
<li>客户给生成方发送U1</li>
<li>生成方在U1的基础上暴力碰撞，最后得到一个(R2,U2)，确保<code>U1+U2 -&gt; vanity address</code></li>
<li>客户验证U2，确保符合要求</li>
<li>客户最后用<code>(R1+R2, U1+U2)</code>作为公私钥</li>
<li>因为生成方是没有R1的，所以没法得到最终私钥，所以这个地址是可以安全使用的。</li>
</ol>


<p>这个服务名字叫做<a href="https://en.bitcoin.it/wiki/Split-key_vanity_address#Address_generation">split-key vanity address generator</a>，好一个商业模式，我认为将来电子货币系统极大繁荣的时候，这个业务可以长期做，其实跟银行的个性信用卡是一样的。</p>

<p>这种服务虽然在数学上无懈可击，但是我觉得最好不要向这种地址里面存太多币，因为这相当于是将比特币的另一重防护 RIPEMD160(SHA256(U)) 放弃了，当然椭圆曲线足够安全，不过我为什么要为自己增加无谓的风险呢？</p>

<p>所以炫耀行为少做为妙。做人要谦虚~~~</p>

<h4>一些YY</h4>

<p>说了这么多，我又开始YY未来的钱包形态了。</p>

<p>人类的货币历史有多长，恐怕钱包的历史就有多长。古今中外，所有的钱包收集起来一定是个很有意思的事情。</p>

<p>现在不论哪个专家都会大谈AI技术，不知道有没有人意识到，未来AI技术最可能的应用，就在我们的电子钱包上面。</p>

<p>现在我们钱包的触及可谓是生活的方方面面了，如果分析一个人的账目流水，就会对这个人有个全方位的透视，年龄、学历、财力、性格、健康状况、人生观、宗教信仰等等，分析出来的信息可能会让他自己都大吃一惊。</p>

<p>一个具有AI智能的钱包将会是一个未来社会人的标准配置，我们就傻瓜化的称他为钱包君吧。</p>

<ol>
<li>钱包君将会对个人的消费、财务做全方位的指导</li>
<li>钱包君会在我们冲动消费的时候跳出来说：喂，那个谁，女朋友的花呗还要你还呢</li>
<li>钱包君会在你失恋的时候，自动订一份海底捞单人份套餐</li>
<li>钱包君会悄悄地为你存一笔钱，在你穷困潦倒的时候跳出来炫耀：还好老子留一手</li>
<li>钱包君自动联网，为你的每一分钱做最大化资源配置</li>
<li>钱包君自做主张，帮你把钱放贷出去挣利息了</li>
<li>钱包君悄悄训练你听歌的品味，为你推送符合他口味的歌曲</li>
<li>钱包君觉得这个主人太笨了，但是主人已经离不开他了，钱包君对主人也产生了感情，好矛盾的感觉啊</li>
<li>钱包君们也有社交了，他们交换钱脉以便为你更好的服务</li>
<li>钱包君们也有网红了，这个家伙；竟然悄悄的把我的生活费拿去打赏他的女神-钱包酱！！</li>
<li>钱包君聚集起来成立了钱包共和国，人类社会的一切都在他们的掌握之中</li>
<li>钱包君们也有了丰富的人格，唔，应该是钱格；在主人的人格污染之下：他们有的变成脾气暴躁的海盗钱包、有的变成唯唯诺诺的好人钱包、有的变成热血勇敢的路飞钱包，当然也有温柔善良体贴的小姐姐钱包~~~</li>
<li>有人的地方就有恩怨，有恩怨的地方就有江湖；钱包共和国很快产生了爱恨情仇~~~</li>
</ol>


<p>&hellip;&hellip;&hellip;.总之就这么瞎编下去了；将来的钱包会不会变成这样呢？等候时间的回答吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-2]]></title>
    <link href="https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2/"/>
    <updated>2018-12-03T18:06:46+08:00</updated>
    <id>https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2</id>
    <content type="html"><![CDATA[<p>之前的文章我们说过，比特币的所有交易抽象成了UTXO的转移。所谓转移，可以这么理解：</p>

<ul>
<li>有M个UTXO作为输入 (M >= 0)</li>
<li>有N个UTXO作为输出 (N > 0)</li>
<li>输入的UTXO总额==输出的UTXO总额</li>
<li>输入的UTXO来源于支付方控制的私钥账户</li>
<li>输出的UTXO流向收款方的公钥地址</li>
</ul>


<p>那么具体是怎么转移的？怎样手工的构造一笔交易呢？我们就在这篇文章里面详细的演示一遍。</p>

<p>首先科普一下常见的交易类型:</p>

<!-- more -->


<h4>Generation TX</h4>

<p>这种交易我们称之为是产量交易(Generation TX)，即矿工挖出一个新的Block时，系统允许这个矿工在块头构造一笔奖励自己的交易，这笔奖励金额被称之为Coinbase奖励，最初一个block挖出的奖励是50BTC，后来就是我们大家所熟知的四年减半原则啦。这样大家明白比特币整个账本里面的初始资金是怎么来的啦。就是系统通过Generation TX向矿工发放奖励产生的BTC。</p>

<p>矿工们计算随机数，竞争打包Generation TX的权力，就是挖矿。具体的细节我们会在以后的文章中介绍。</p>

<p>现在每笔Generation TX的奖励金额是12.5BTC，预计下个减半周期在2020年年中。</p>

<p>注意：Generation TX中的BTC是无中生有的，所以只有输出的UTXO，没有输入的UTXO。</p>

<p>PS:Coinbase作为一个很经典的技术名词，其<code>coinbase.com</code>域名被现在美国著名的交易所coinbase Pro 注册持有。</p>

<h4>Script Hash TX</h4>

<p>也被称为P2SH（Pay-to-Script-Hash）交易。</p>

<p>该类交易目前不是很常见，大部分人可能没有听说过，但是非常有意义。未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义的地址，而是一个合成地址，以<code>3</code>开头 (Segwit交易其实也可以看成是Script Hash TX)。比如三对公私钥，可以生成一个合成地址。在生成过程时指定n of 3中的n，n范围是[1, 3]，若n=1，则仅需一个私钥签名即可花费该地址的币，若n=3，则需要三把私钥依次签名才可以。 这种类型的交易适合比较复杂的保险、证券场景。</p>

<h4>多重签名脚本|Multisig</h4>

<p>尽管P2SH 多重签名脚本一般用于多重签名的交易，但是这个基础性的脚本也可以用于这种场景：当一个UTXO被使用之前，需要多重签名验证。</p>

<p>多重签名公钥脚本可以一般称为 m-of-n，至少需要m 个匹配公钥，n提供的公钥总数。m 和n 都应当根据需要的数量进行从OP_1到OP_16运算。</p>

<p>多重签名的交易细节更多，待我们搞明白最标准的比特币交易后，再来探究它。</p>

<h4>Pubkey Hash TX</h4>

<p>也被称为P2PKH（Pay-to-Public-Key-Hash）交易。该类是最常见的交易类型，由N个输入、M个输出构成。交易地址都是以<code>1</code>开头。这种交易也是目前比特币网络中最典型的交易类型，也最简明，容易分析。下面我们就先拿它作为例子，开始探究一笔比特币交易的细节。</p>

<h2>数据结构</h2>

<h3>输入输出</h3>

<p>简单来看，一笔完整的P2PKH交易包含有两个部分:输入UTXO &ndash;> 输出UTXO，而每一个输入UTXO其实是上一笔交易的输出UTXO，这么说可能有点绕口，来张图解释一下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg1.jpg" alt="img" /></p>

<p>首先最前面的字段是版本号，每一个交易具有一个四字节的交易版本号，它告知比特币节点和矿工应使用哪一套规则来验证它。这使得开发者在为未来的交易创建新规则时可以不验证之前的交易。</p>

<p>接着就是输入的M个UTXO和输出的N个UTXO，代表着我要把一堆UTXO转移(支付)给谁。</p>

<p>最后是一个字段是锁定时间(Locktime)。Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。</p>

<p>如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>一笔交易中，构造的输出UTXO会完全花费掉输入的UTXO，注意：是完全花费掉。如果输出UTXO的总额小于输入UTXO的话，那么差值就会被系统作为矿工费奖励打包到Generation TX当中。所以所有的比特币钱包实现中，如果你有10BTC的UTXO集合，想要花掉9BTC，那么输出UTXO中，除了支付给收款方的UTXO，还一定要构造发送给自己的找零UTXO。曾经有人构造交易时忘记找零，发生了<a href="https://blockchain.info/tx/4ed20e0768124bc67dc684d57941be1482ccdaa45dadb64be12afba8c8554537">支付 200 BTC 的矿工费</a>的惨案，所幸的是收录该笔交易的Block由著名挖矿团队“烤猫（Friedcat）”挖得，该团队非常厚道的<a href="https://blockchain.info/tx/b18abce37b48a5f434f108ae7ce34f22aa2bfbd9eb9310314029e4b9e3c7cf95">退回了多余费用</a>。</p>

<p>早期Geek们比较作死，特别喜欢命令行构造发送交易，像是忘记构造找零而当了冤大头的人数不胜数，那么为什么是这么奇葩的设计呢？为什么一笔交易中，一定要花费所有的输入UTXO呢？</p>

<p>大家还记得我们的上一篇文章吧，一个分布式的账本，最容易的设计就是只支持<code>append</code>这个动作，诸如<code>update</code>、<code>delete</code>这种操作在区块链账本的设计中会引入额外的复杂性，尤其是后面我们讲述blockchain的组织的时候，你就会理解，这种设计的必要性。</p>

<h3>细节</h3>

<p>一笔完整的P2PKH 交易是这样的：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg2.jpg" alt="img" /></p>

<p>我们用之前文章中，利用<code>satoshi</code>生成的地址(<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>)做例子，来研究它花费的<a href="https://www.blockchain.com/btc/tx/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517">一笔交易</a>。</p>

<p>用<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">在线getrawtransaction工具</a> 解码一下这笔交易，得到输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>字段说明</h4>

<h5>txid (hash)</h5>

<p>Tx Hash (3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517)，俗称交易ID，由hex得出：Tx Hash = SHA256(SHA256(hex))。由于每个交易只能成为下一个的输入，有且仅有一次，那么不存在输入完全相同的交易。因为SHA256碰撞的概率极小，所以理论上存在相同的Tx Hash 的概率非常小。</p>

<p>即便如此，在系统里依然产生了相同的Tx Hash，是不知道哪位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<h5>vin (输入UTXO)</h5>

<p>vin是一个数组，里面即M个输入UTXO，每个UTXO都来自上一笔交易的一个UTXO输出，这笔交易的vin只有一个UTXO，它由以下几个字段组成</p>

<ol>
<li>txid: 上一笔关联交易的hash值</li>
<li>vout index: 上一笔交易输出的N个UTXO里面的序号</li>
<li>scriptSig: 对这笔UTXO的签名，还记得我们之前的文章吗？只有对一个UTXO签名才能证明其所有权，才能花费它</li>
<li>sequence: 序列号。这个序列号来源比较复杂；还记得上面讲的locktime有所关联：</li>
</ol>


<blockquote><p>Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。
如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>Bitcoin Core 的早期版本提供了一个可以防止签名者使用上述方法取消locktime 交易的功能。 后来为了防止大量的延时交易攻击网络，这个功能被禁用了。但是该系统还留下了这样的设置，每个输入会分配一个四字节的序列号。序列号的目的旨在允许多个签名者同意更新交易。</p>

<p>如果sequence number设置为0，就按照locktime执行入块操作，如果出现一笔新的交易，sequence大于原来的sequence，这笔新交易就会取代原来的交易；所以一般为了即刻入块，交易的sequence number一般设置为四字节的的无符号最大值(0xffffffff),使得交易的locktime 仍然有效的情况下，打包交易进块。</p>

<p>即使今天，如果所有的input 的sequence number都是最大值，locktime锁就会失效。所以如果想使用locktime，至少一个input的sequence number要小于最大值。由于sequence number不用于其他目的，任何sequence number 为零的交易都会启动locktime 功能。后面我们会看到，sequence number会在闪电网络中发挥作用</p></blockquote>

<p>vin的所有UTXO 余额相加，就是这笔交易的转账总额。</p>

<h5>vout (输出UTXO)</h5>

<ol>
<li>value: 转账金额</li>
<li>n: 作为第N个UTXO输出</li>
<li><p>scriptPubKey: 这是设置的谜题，后来人想要花费这笔UTXO，必须提供scriptSig来解答这个谜题才可以</p></li>
<li><p>vin 的总额 &ndash; vout的总额 == 打包费用 &ndash;> 奖励给打包矿工</p></li>
</ol>


<h4>交易十六进制解析</h4>

<p>spec规范在<a href="https://en.bitcoin.it/wiki/Protocol_documentation#tx">这里</a></p>

<p>这笔交易的vin及vout中各有一个UTXO，我们解析下它的十六进制原始数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000</span></code></pre></td></tr></table></div></figure>


<h5>version (4字节): 刚开始的4个字节是version，小端排序(Little Endian)，因此version为<code>0x00000001</code></h5>

<blockquote><p>ps:关于小端排序的设计，社区里面还有过小争论，见<a href="https://bitcointalk.org/index.php?topic=4278.0">这里</a></p></blockquote>

<h5>flag (2字节，可选): 如果是<code>0001</code>，代表是witness交易；如果不是，就代表没有这个flag字段；这是一笔普通的交易，因此没有flag字段</h5>

<h5>vin count (>=1字节): vin数目，此交易为<code>01</code>，采用的是<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer">var_int</a>表示法，这样我们能方便的测算它的长度</h5>

<h5>vin (>=41字节): 所有的输入tx，是一个数组；这里只有一个tx，数据是:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff</span></code></pre></td></tr></table></div></figure>


<p>简单说下vin中一笔tx内部结构:</p>

<ol>
<li>previous_output (32字节): 上一笔交易的HASH值，即这个花费的输入交易ID:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0
</span><span class='line'>-&gt; 转为大端排序  
</span><span class='line'>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>previous output index: 表示花费的是 previous_output 交易的第n个vout输出，这里是<code>00000000</code></p></li>
<li><p>script length (var_int变长，代表script的长度): 这里是<code>0x8a</code>，表示script长度为138字节</p></li>
<li><p>scriptSig (整个解密脚本)： 这个结构我们之后会具体分析</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<ol>
<li>sequence no (4个字节): <code>ffffffff</code></li>
</ol>


<h5>vout count (>=1字节): vout数目，此处为<code>01</code></h5>

<h5>vout (>=9字节): 所有的输出tx，是一个数组；这里只有一个tx，数据是:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>581b0000000000002103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</span></code></pre></td></tr></table></div></figure>


<p>简单说下vout中一笔tx内部结构:</p>

<ol>
<li>value (8字节): 转账到这个地址上的金额， 这里是<code>581b000000000000</code>小端排序，十六进制为<code>00000000000000581b</code>，即转账7000 satoshis</li>
<li>scriptPubKey length (>=1, var_int类型): 输出脚本的长度，这里是<code>0x23</code>，代表35字节长度</li>
<li>scriptPubKey: 输出脚本，其实就是包含转账地址的脚本，这里是<code>2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</code></li>
</ol>


<h5>locktime: 最后4个字节是locktime，这笔交易设置为0；就是立即打包</h5>

<h2>总览</h2>

<h5>最后一张表格说明问题：</h5>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h5>再来一张交易的总体示意图:</h5>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg4.jpg" alt="img" /></p>

<ol>
<li>TX0， input0即 vin0，里面有一笔100K satoshis比特币(1btc=10<sup>8</sup> satoshi)</li>
<li>TX1、TX2 花费了 TX0-vin0，分成了TX1-vin0(40k satoshi)，以及TX2-vin0(50k satoshi)，还有10k satoshi作为交易费给矿工</li>
<li>TX3花费了TX1-vin0 (30k satoshi)，付出了10k satoshi 交易费</li>
<li>TX4、TX5 花费了 TX2-vin0，分成了TX4-vin0(20k satoshi)，以及TX5-vin0(20k satohsi)，付出了10k satoshi交易费</li>
<li>TX6花费了TX4-vin0 + TX-5-vin0，共20K(satoshi)，其余的20k satoshi为交易费</li>
<li>最后又花费了TX3-vin0中的20k satoshi, 10k satoshi作为交易费</li>
<li>最后又花费了TX6-vin0，TX6-vin1中的10k satoshi, 10k satoshi作为交易费</li>
</ol>


<h2>小结</h2>

<p>好了，到这里；我们对于一笔最简单的比特币的交易结构已经详细分析了一遍；但是在全网中，交易是怎样验证的呢？一笔资金从A转移到B，全节点怎么验证这次转移的合法性呢？</p>

<p>这就用到了比特币的脚本语言系统，具体到上面的示例交易，就是scriptSig与scriptPubKey；</p>

<p>那么scriptSig与scriptPubKey是怎么工作的呢？我们下次文章再会。</p>

<h2>参考资料:</h2>

<p><a href="https://en.bitcoin.it/wiki/Protocol_documentation">https://en.bitcoin.it/wiki/Protocol_documentation</a></p>

<p><a href="http://learnmeabitcoin.com/">http://learnmeabitcoin.com/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>

<p><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html">https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html</a></p>

<p><a href="https://www.8btc.com/article/24637">https://www.8btc.com/article/24637</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-stream,一次可怕的社工]]></title>
    <link href="https://happy123.me/blog/2018/11/27/event-stream/"/>
    <updated>2018-11-27T16:06:38+08:00</updated>
    <id>https://happy123.me/blog/2018/11/27/event-stream</id>
    <content type="html"><![CDATA[<p>几天前有人在github创建了一个issue:</p>

<p><a href="https://github.com/dominictarr/event-stream/issues/116">https://github.com/dominictarr/event-stream/issues/116</a></p>

<p>标题为：&#8221;I don&rsquo;t know what to say.&ldquo;，翻译过来大概就是“我无语了”。因为 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p>

<!-- more -->


<p>event-stream 被很多的前端流行框架和库使用，每月有几千万的下载量。作为最流行的前端框架之一，在 Vue 的官方脚手架 vue-cli 中也使用了这个依赖，作为最流行的前端框架之一，这个影响还是挺大的，这个影响还是挺大的。而 React 则躲过了。</p>

<p>flatmap-stream 中的恶意代码会扫描用户的 nodemodules 目录，因为所有从 npm 下载的模块都会放在此目录。如果发现了在 nodemodules 存在特定的模块，则将恶意代码注入进去，从而盗取用户的数字货币。</p>

<p>COPAY钱包因为引用了event-stream库，它在今年9、10、以及11月27日之前发布的所有版本都受到了感染，COPAY是bitpay旗下的开源钱包，市场占有率不可小觑；下面这个链接进行了分析，使用被感染钱包的用户很有可能被窃取私钥:</p>

<p><a href="https://github.com/bitpay/copay/issues/9346">https://github.com/bitpay/copay/issues/9346</a></p>

<p>COPAY紧急发布了5.2.2修正版本：</p>

<p><a href="https://github.com/bitpay/copay/pull/9348">https://github.com/bitpay/copay/pull/9348</a></p>

<h2>使用COPAY钱包的人，请立即升级新版本，并且生成新的钱包，把老钱包里面的币转走。</h2>

<p>这个恶意模块更可怕之处，在于背后的骇客是个深谋远虑、精于社工的人。</p>

<p>这个人的github账号叫做<a href="https://github.com/right9ctrl">right9ctrl</a>，他应该是精心分析了COPAY引用的所有模块，发现event-stream有机可乘。于是给event-stream的创始人-<code>dominictarr</code>发去了邮件，承诺会自愿维护这个项目。</p>

<p><code>dominictarr</code>是一个高产的开发者，他维护着多个NPM包，有人能自愿分担他的工作，他自然是高兴之至，于是将这个模块的仓库控制权移交给了<code>right9ctl</code>。</p>

<p>刚开始的时候，<code>right9ctl</code>非常小心的进行着常规的维护。一段时间后，即在 3 个月前，黑客在 GitHub 上新建了一个 flatmap-stream 仓库（内含恶意代码），并在这个项目中引用了自己的仓库。</p>

<p>直到几天前这个有漏洞的仓库才被发现，然后 npm 紧急将这个含有恶意代码的 flatmap-stream 模块删除了。</p>

<p>这个模块的攻击行为也很隐蔽，首先他只有引用了 event-stream 这个库，并且依赖引用了 flatmap-stream，用户在编译自己的项目时，才会感染恶意代码。</p>

<p>感染恶意代码的程序，也不会全部发作。只有COPAY钱包运行时，他才会悄悄的窃取用户信息，并发送到下面这几台服务器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>copayapi.host
</span><span class='line'>51.38.112.212
</span><span class='line'>145.249.104.239
</span><span class='line'>111.90.151.134</span></code></pre></td></tr></table></div></figure>


<p>我不知道截止到现在黑客获取了多少币，但整个事件非常惊悚。而且这个漏洞刚刚被发现，我认为还会持续有消息不灵通的受害者。</p>

<p>另外，如果想查看自己的项目是否受到影响，可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm ls event-stream flatmap-stream...flatmap-stream@0.1.1...</span></code></pre></td></tr></table></div></figure>


<p>如果在输出里面包含了 flatmap-stream 则说明你也可能被攻击。</p>

<p>如果使用 yarn 则可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yarn why flatmap-stream</span></code></pre></td></tr></table></div></figure>


<h2>区块链历史中的传奇HACK手段</h2>

<p>我在以前的文章中多次感叹所谓的区块链技术出来后，简直是黑客的黄金年代！大概从2011年开始，精彩的HACK事件层出不穷，如果要全部整理出来，可能会是一部让所谓的<code>区块链专家</code>和<code>区块链投资者</code>冷汗直流，后怕不已的手册。</p>

<p>撇开这几天的市场动荡，币价大跌不提，单单从技术上评估，能有多少人意识到他们所谓的投资的技术风险！</p>

<p>我随意的说几件印象非常深刻的HACK事件。</p>

<h4>整个国家DNS 流量劫持事件</h4>

<p>我记得大概是2015年，巴西的骨干网DNS整个被黑客劫持了，导致当时的blockchain.info 在线钱包有几个小时的流量完全被导向了钓鱼网站，这次事件导致的丢币数目不可统计。</p>

<p>但是给你一个启示，当利益足够大的时候，任何设施，包括国家设施都是不可信、不安全的。结合这两天发现的jd.com流量返利劫持，你就知道：网络世界里，有的组织或者个人，完全可以劫持一个国家的网络流量，这不是天方夜谭。</p>

<h4>官方域名劫持事件</h4>

<p>今年二月份的时候，有人花大价钱买了&#8221;electrumltc.org&#8221;这个域名，仿照&#8221;<a href="https://electrum-ltc.org/">https://electrum-ltc.org/</a>&ldquo;官网，精心炮制了一个以假乱真的网站，然后把下载链接改成了恶意钱包，并且做了Google SEO，把自己的骗子网站搜索结果推到了第一名；有人因此丢了2399个LTC，那个时候可是不少钱。</p>

<p>很讽刺的是，恰恰是因为真正的开发者买不起这个域名，才搞了一个山寨的域名发布自己的软件，让骇客有机可乘。</p>

<p>讽刺吧，原作者辛辛苦苦开发，却因为没钱买域名不得已搞个屌丝网站，骇客财大气粗，直接买下第一官方域名然后钓鱼，并且真的获取巨大收益。</p>

<p>这种钓鱼手法在多个钱包、多个网站上面一再重演，受害小白不计其数！</p>

<p><code>杀人放火金腰带，修桥补路无尸骸。</code>这个世界就是这样。</p>

<p>整个事件回顾：</p>

<p><a href="https://github.com/pooler/electrum-ltc/issues/176">https://github.com/pooler/electrum-ltc/issues/176</a></p>

<h4>~~~~</h4>

<p>这么罗列下去，我可以轻易列举出更多的涉及上亿美元的hack事件。每个事件说起来好像天方夜谭一样，不明技术的小白可能会惊叹：怎么可能有这种事情？！</p>

<p>但是事实就是这样，而且将来这样的悲剧会一再重复下去，说再多也没用，人的安全意识总敌不过懒惰、贪婪等等等等，可悲的人性啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoind Conf Template]]></title>
    <link href="https://happy123.me/blog/2018/11/26/bitcoind-conf-template/"/>
    <updated>2018-11-26T14:51:43+08:00</updated>
    <id>https://happy123.me/blog/2018/11/26/bitcoind-conf-template</id>
    <content type="html"><![CDATA[<p>bitcoin core 0.17版本开始废弃了不少RPC调用，另外RPC配置增加了test.rpcport参数，存一份模板:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=127.0.0.1
</span><span class='line'>rpcport=18332
</span><span class='line'>test.rpcport=8332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>walletnotify=/usr/bin/python3 /xxx.py</span></code></pre></td></tr></table></div></figure>


<p>另外<code>getaddressesbyaccount</code>即将废弃，可以使用<code>getaddressesbylabel</code>代替</p>

<p><code>signrawtransaction</code>即将废弃，实在要用的话只能在启动命令行中加deprecatedrpc指定。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/bitcoind --conf=/xxx/bitcoin.conf --datadir=/xxx/blockdata/mainnet --deprecatedrpc=signrawtransaction</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-1]]></title>
    <link href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/"/>
    <updated>2018-11-23T18:48:39+08:00</updated>
    <id>https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1</id>
    <content type="html"><![CDATA[<p>在我们前面的文章中，我们提到，从建设银行转账到工商银行10w元，过程其实是这样的:</p>

<ol>
<li>建设银行发送报文到人行CNAPS系统</li>
<li>人行CNAPS发送转账报文到工商银行</li>
<li>工商银行发送响应报文给人行CNAPS</li>
<li>人行发送响应报文给建设银行</li>
<li>转账成功，建设银行、人行、工商银行各自更新账本</li>
</ol>


<p>整个过程中，有几个很有趣的事实：</p>

<!-- more -->


<ol>
<li>所谓的转账交易，不过是账本上数字的加加减减</li>
<li>我们的账户，除了各自在工行、建行开设的户头之外，在人行还有一个总账；人行是所有银行的妈，你在任何银行开设的账户，人行都有一个总账；所以打印征信的时候我们要到人行打印</li>
<li>建设银行和工商银行间的转账需要人行做清算，人行提供了信用；建行和工行相信人行不会造假</li>
<li>我们需要信任三个机构：人行、工行、建行，我们相信他们不会造假</li>
<li>人行是所有账目的中心节点，人行的账本对不上了，中国的金融系统就乱套了</li>
</ol>


<p>然后作为对比，我们来看看比特币是怎样设计的。</p>

<p>中本聪创造比特币之初，在<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis Block</a>里面付了一句有名的话:&ldquo;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&#8221;。在白皮书中他很自豪的宣称:&#8221;We have proposed a system for electronic transactions without relying on trust. &rdquo; 去中心化一直是比特币的指导纲领，那么问题来了，如果让我们来设计一个去中心化的账本，将会面临哪些技术问题，又该如何解决呢？</p>

<p>很自然的，我们设想的是一个类似于分布式数据库的系统，整个系统维护着唯一的账本，每个节点（node）都是一个副本（Replica Set），每个副本保有完全的账本数据，并且节点间相互同步数据，如果部分节点挂掉，不影响整个系统的运行。</p>

<p>用户转账的行为，其实就是这个分布式账本的增删查改。当然，为了简化设计，我们这个账本可以只支持账目写入，不支持删改。</p>

<p>我们开始思考这个分布式账本要解决的两个核心问题：</p>

<h4>什么样的交易是一笔合法的交易</h4>

<ul>
<li>一笔交易中，如何保证交易账户的完全所有权；如果保证用户A的资金不会被用户B盗用</li>
<li>用户A本来有1000元，如何保证他不会转出2000元？</li>
</ul>


<h4>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</h4>

<ul>
<li>如果有部分节点是不诚实的，它就会有动机去伪造不存在的交易来获取利益，如何识别并排除不诚实的节点？(拜占庭将军问题)</li>
<li>如果A的账户有1000元，发送了1000元给B，由于是分布式系统，部分节点收到了这笔交易，这时候A又发送了1000元给C，另一部分收到了这笔交易，这时候该如何处理？如何保证一笔钱不会被花两次？ (双重支付问题)</li>
</ul>


<p>为了解决这两个问题，比特币引入了三个核心技术：UTXO交易模型、POW工作量证明、blockchain数据结构组织。且让我们一一道来。</p>

<h2>初版交易设计</h2>

<p>如果读了之前我们的&lt;比特币HD钱包>系列文章；天然的，我们意识到非对称加密方法是在分布式账本中建立账户的天选之术；</p>

<h4>存款</h4>

<p>用户A想要建立一个账户，只要在帐目中增加一笔 <code>公钥+金额</code> 的记录就可以了。我们用一个表格表示整个账本，用户A以及用户B各存入50个币的动作可以记作:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50)</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50)</td>
</tr>
</tbody>
</table>


<p>这个原始存入的资金我们先不去纠结怎么来的，总之此时账本中有两笔交易，代表着A以及B各自有50个币</p>

<h4>验证</h4>

<p>在账目1中，如何验证A确实是这笔资金的拥有者呢？非常简单，就是账户资金增加的时候，A对这笔交易数据的摘要用私钥做一个签名，然后再把公钥附在后面就可以了，这样账目就变成了这样:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
</tbody>
</table>


<p>任何一个要验证账户A的节点或第三方，对其所有权证明用公钥解密，然后对照摘要(digest)即可。</p>

<h4>转账</h4>

<p>如果A要向B转账20个币呢，我们最简单的设计，就是构造Trans1 &ndash; 20，然后同样的方法构造签名即可，这样账本如下:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
<tr>
<td>3 </td>
<td> Trans3:Trans1-20 &ndash;> B</td>
<td> signature(digest(Trans1 &ndash; 20 &ndash;> B))+A公钥</td>
</tr>
<tr>
<td>4 </td>
<td> Trans4:存入(B公钥+20) </td>
<td> signature(digest(Trans4))+B公钥</td>
</tr>
</tbody>
</table>


<p>看起来一切还好，但是这个时候我们发现了一些缺点</p>

<ol>
<li>收到汇款的时候因为要添加所有权证明，账户拥有者得一直在线监控自己的账户地址</li>
<li>收款人还得验证汇款人的合法性，感觉都点怪；我收钱就好了，还得去管这个钱合不合法？</li>
<li>如果多重转账，或者一对多，或多对一，这个记录格式就复杂了</li>
<li>用户B要验证一笔交易合法性的时候，可能要回溯到账本非常深的位置，因为上一笔交易可能发生在很久之前，这种交易记录的存储设计很难高效查询</li>
<li>最后，这个账目设计中，所有账户的公钥是暴漏在外的；虽然椭圆曲线算法目前看来牢不可破，但是整个安全体系只依赖一个非对称加密算法，比较脆弱</li>
</ol>


<p>解决方法其实也简单，换个思路，就是A转账给B，B是不需要验证的，只要A提供账户所有权的证明就好了，想想我们平时转账，不也是这样的吗？</p>

<p>那么最简洁的设计，就是借鉴现实世界。每一笔交易都看作是硬币的流转，硬币其实没有特征，它只是从A的保险箱转移到了B的保险箱而已，那么，采用什么办法来表示：<code>这是A的保险箱中的一笔资金币</code>这个譬喻呢？</p>

<h2>进阶交易设计</h2>

<h4>UTXO 模型</h4>

<p>比特币的账本世界，构筑在UTXO (Unspent Transaction Output)之上；其实每个UTXO代表着未花费的一笔硬币(数额可大可小，没有限制)；一个账户的资金，其实就是一堆UTXO的集合；转账交易，就是一个或多个UTXO的输入再输出为另外的UTXO而已。你可以想象成现实世界中金银铸币的流通。</p>

<p>那么一个UTXO中包含什么呢？如何作为输入呢？如何构造输出呢？这就是比特币交易的核心技术。</p>

<ul>
<li>我们用下面一张图来表示<code>A保险箱里面的50个硬币</code> 这件事：</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg1.jpg" alt="img" /></p>

<p>把它想象成一个邮筒构造的保险箱，在不打开的前提下，投币是只进不出的。可以注意到，我们并没有直接将Public Key明晃晃暴露在外面，而是先HASH一下，然后贴到保险箱子上面，想要存币的人，只要知道这个HASH值，作为保险箱的ID，就可以直接投币进去啦。</p>

<p>但是保险箱的锁在哪里呢？</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg2.jpg" alt="img" /></p>

<ul>
<li>这张图中，我们引入了一个脚本，称之为 <code>Pubkey Script</code>；具体内容是:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>呵呵，像天书吧，不要怕；这是我们特有的保险锁构造。细节会在后面讲到。这里你可以这样简单理解：</p>

<p>为了锁住这个保险箱里的资金，比特币系统设置了一个谜题作为锁。解开这个谜题，才能转移里面的资金。</p>

<p>这个谜题是这样构造的:</p>

<ol>
<li>记录了A的公开的<code>Public key hash</code>值，开锁的人，需要提供A的<code>full public key</code>，同时验证 <code>hash160(public key) == Public key hash</code></li>
<li>需要提供A的私钥基于这笔交易的签名Signature, 这样系统可以用<code>full public key</code>来验证公私钥是否匹配</li>
</ol>


<p>这个过程是通过上面的脚本指令通过入栈出栈执行的，这也为比特币系统验证更复杂的交易逻辑提供了基础，甚至能作为一个简单的虚拟机执行更复杂的组合指令。</p>

<p>整个过程组织如下图：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg3.jpg" alt="img" /></p>

<p>当我提供一个signature以及full public key的时候，就可以开锁了，开锁下一步自然就是转移资金啦。我们给B汇款50个币，而B的保险箱又是怎么表示的呢？和A保险箱是一样的。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg4.jpg" alt="img" /></p>

<ul>
<li><p>带有<code>public key hash</code> ID的保险箱是一个UTXO，这个保险箱用<code>public key hash</code>上锁，而提供<code>signature</code>和<code>full public key</code>开锁，转移资金的过程，就是花费UTXO的过程，其实就是把A的UTXO转移到B的UTXO的过程，这就是比特币最简单的一笔交易</p></li>
<li><p>我们可以继续拓展下去，可以1对多支付，多对1支付，多对多支付，更复杂的多签名支付，延迟支付等等，今后我们会详细介绍</p></li>
</ul>


<p>这个系统有如下优点:</p>

<ol>
<li>所有的交易都抽象为了UTXO的转移，你可以想象一下，一堆硬币在几个保险箱之间转移的样子</li>
<li>用户其实可以不检查交易的合法性，只要运行分布式账本的所有节点检查通过合法后，确保写入账本就保证资金的安全转移了</li>
<li>每个账户的拥有者在真正花费UTXO之前，是不用暴露公钥的</li>
<li>验证UTXO交易合法行的函数，抽象为几个指令的集合，这个验证行为指令通用化，为智能合约编写创造了条件</li>
<li>这样的交易记录非常容易组织，我们以后可以看到；把这些交易批量打包，组织成名为blockchain的精巧数据结构，有许多优点</li>
<li>一个用户A可以用一个私钥加密多个保险箱，或者多个私钥加密多个保险箱，非常灵活</li>
</ol>


<h2>小结</h2>

<p>好啦，看到这里，我们对比特币的最简单的交易构造已经有感性认识了。但是俗话说得好: <code>光说不练假把式</code>，下篇文章我们就会手工构造一笔完整的交易，让你搞明白其中细节。</p>

<p>另外，我们前面提出了好几个问题:</p>

<ul>
<li>原始资金从何处来？</li>
<li>节点如何解决拜占庭将军问题？</li>
<li>节点如何解决双重支付问题？</li>
</ul>


<p>后面我们会一一解答，那么，下次再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币、支付、清算漫谈]]></title>
    <link href="https://happy123.me/blog/2018/11/19/huo-bi-%2C-zhi-fu-%2C-qing-suan-man-tan/"/>
    <updated>2018-11-19T16:55:29+08:00</updated>
    <id>https://happy123.me/blog/2018/11/19/huo-bi-,-zhi-fu-,-qing-suan-man-tan</id>
    <content type="html"><![CDATA[<p>又看了一遍 <a href="https://book.douban.com/subject/26802686/">The book of Satoshi</a> 这本书，果然常读常新啊；又有很多想法冒出来，结合最近的BCH分叉事件，我不禁又开始思考金融系统的两大环节：清算和支付，究竟会如何发展？</p>

<p>我从事银行业务系统监控很长时间，结合咱的职业生涯所学，再重新梳理一遍支付和清算的发展史吧。</p>

<!-- more -->


<p>除了支付和清算，还有一个拓展概念，即结算。看一下权威机构的定义:</p>

<p>按照国际清算银行支付结算委员会的定义，所有涉及到资金转移的行为，都可视作支付行为，支付的概念最大，清算和结算属于支付过程中的特定环节，其中，清算是发生在结算前的支付环节，该环节的功能主要是为了提高结算的标准化水平和结算的效率。</p>

<ul>
<li><p>支付：完成付款人向收款人转移可以接受的货币债权的过程，包括交易过程、清算过程和结算过程等三个过程。</p></li>
<li><p>清算：包含了在收付款人金融机构之间交换支付工具以及计算金融机构之间待结算的债权，支付工具的交换也包括交易撮合、交易清分、数据收集等。</p></li>
<li><p>结算：该过程是完成债权最终转移的过程，包括收集待结算的债权并进行完整性检验、保证结算资金具有可用性、结清金融机构之间的债券债务以及记录和通知各方。</p></li>
</ul>


<h2>史前阶段</h2>

<p>支付清算的历史其实要比货币历史久远的多，但货币的演变是支付清算体系发展的原动力。</p>

<p>在货币产生前，物物交换其实就是一种支付行为，比如原始人甲有桃子，但喜欢苹果，而此时刚好碰到原始人乙，乙有苹果，但喜欢桃子，这样两个人就刚好满足双方的需求，甲向乙支付桃子，得到苹果，乙向甲支付苹果，得到桃子。这就是最原始的“支付”。随着持有香蕉的原始人丙也加入上述交易，那么必须形成需求的闭环，而且随着交易的物品数量、种类逐渐增多，就需要再找一个不参与交易的原始人丁专门做交易的分类、计数和记录，并且甲乙丙在丁面前都作出承诺：一是手里的桃子、苹果、香蕉都是真实存在的。二是交易的意愿都是真实的，不会拿了人家的东西却不给出自己的东西。那么丁做的事情就是最原始的“清算”。之后，桃子、苹果、香蕉交割到了新的主人手中，此时丁宣布交易成功结束，甲乙丙三方各不相欠&mdash;最原始的“结算”。</p>

<p>此时丁付出信用，承担了清算的网关。当然，这种清算是非常粗糙的，作为一个支付行为的环节不明显。</p>

<p>后来随着商品交换规模的扩大，统一的支付媒介就出现了。从最原始的贝壳，到铁铜铸币，再到金银物品，形成了人们统一承认的货币媒介。实物货币如金银货币的出现极大地提升了商品交易的成功率，形成了以货币为核心和交易媒介的支付清算体系雏形，极大地推动了贸易和经济社会发展。</p>

<p>此时的清算其实和支付行为频率差不多的，因为当时的贸易市场并不繁荣，货币媒介还很粗笨，可以说每一笔支付就伴随着一笔清算，清算如此重要，以至于此时的货币市场上最重要的并不是货币本身，而是记账的权力，最经典的例子就是我们前面文章中提到的雅浦岛的石币故事。</p>

<h2>纸币阶段</h2>

<p>但随着商品交易规模和范围的不断扩大，金银货币越来越不能更好地满足贸易经济大规模发展的需要，人们就开始尝试以收兑金银之后的收据代替金银实物进行流通，随着这种收据广为人们接受，纸币就此诞生了&mdash;这是货币发展史上的一个重要突破。当然，纸币是要与其背后的金银货币的成色、数量挂钩的，也就是金银本位制，而且发行纸币的单位是多样的，可以是国家，也可以是有实力有信誉的金银铸造商等等。这时的纸币仅仅只是一种“表征货币”。纸币的出现极大地提升了支付的便利性，但由于纸币的伪造难度和成本比金银货币低太多，如何避免收到假冒伪劣的纸币甚至防止纸币超发成为突出的难题。自此，支付的便利性与安全性因为支付工具（如纸币）从交易媒介（如金银货币）分离独立而始终成为一对矛盾。</p>

<p>纸币阶段其实和金银实体是并存的，这个时候的清算行为其实更好分辨；拿我们熟悉的晋商作为例子：</p>

<blockquote><p>早在清道光（1823年）年间，山西平遥商人就创立了“日升昌”等专门办理汇款业务的票号（古代的票号、钱庄就是现代银行的雏形）。
著名的红顶商人胡雪岩就是做票号生意起家的。
当时的票号支持异地汇款业务：客户来日升昌汇款，交了银子之后，票号就开出汇票给客户。
跟银行一样，票号也有总号和分号，客户可以携带汇票或者把票寄给亲人，只要凭票就可以到日升昌全国各地的分号兑出银子，分号给客户兑换之后先记内部账，日后再和总号清算债务。
从此之后，商人在城市之间贸易可以不用携带大量的银子。而汇票在不同城市的各个分号之间流转也形成了很多债务，有大量的银子需要周转，镖局就专为票号来运送银子以及为商人运送票据，有点类似于现在为银行押钞的威豹，不过镖局的手续费可是高达5%！</p></blockquote>

<p>整个过程中，每个月或年底各个分号之间周转银子，轧平账目的过程就是清算。虽然清算是整个支付环节的一部分，但是清算的频率比较低，平均下来多笔支付可能才发生一笔清算，所以此时表面上看货币是非常活跃的，清算作为一种记账行为默默引申到了后台。</p>

<h2>信用阶段</h2>

<p>牛顿爵士开创了金本位，其实在整个货币史上不过短短一段时间，然后我们现在就飞速的跳跃到了信用货币阶段，信用货币发展的技术基础，就是越来越完善普及的电子设备。可以想象，将来即使在非洲，持有一个智能电子钱包(不一定是手机)的成本也会小于持有纸币的成本，所以货币电子化的趋势不可逆转。</p>

<p>铸币信用化，表现形式电子化之后，最明显的一个改变，就是<code>清算</code>这个行为，夹杂在整个支付过程中越来越频繁了；</p>

<ul>
<li>原来钱庄分号之间轧账，周期可能半年一年记</li>
<li>金银铸币时代，两国之间的轧账，也可能持续几周</li>
<li>纸币化之后，可能国际汇兑、债券市场之间的清算，通过电报以及联行信件，就缩短到几天了</li>
<li>到了今天，跨行汇款，已经缩短到分钟级别了；移动支付，都可以到秒级了</li>
</ul>


<p>此时清算的次数又大致跟支付行为一个量级了，记账的技术又开始一轮飞跃；</p>

<p>放到我国来，伴随着改革开放，我们的金融市场30年走完了欧美100年的历史，其中支付清算系统的发展就是经典的代表，这段历史我比较熟悉，下面就我国的支付清算系统建设流水账一番;</p>

<h3>全国手工联行系统 (1949-1990)</h3>

<p>建国初期的银行是比较LOW的，那个时候的银行是沿袭历史发展过来的。因此银行之间的资金往来(通存通兑)，其实跟晋商时代的票号差不多，每个银行都和其它大行之间签订协议，开设备付金账户，实现互兑。</p>

<p>比如三家银行： 工行、建行、招行，他们每家银行都要在另外两家银行开设账户，存入准备金，不同银行间的业务往来像票号一样定期轧账。</p>

<p>此时，每家银行都是一个清算机构，为银行间的资金往来做清算。</p>

<p>这种清算方式无疑是低效的，每成立一家银行，要开启业务，都得一家家的在同行那里开设账户，费时费力。所幸那个时候的银行少，而且计划经济金融业务少，这么多年就凑合过来了。</p>

<p>一直到1984年中国人民银行专门行使中央银行职能之后，我们国家确立了法定存款准备金制度。央行的备付金系统正式确立。此时，银行跨行的资金清算有两种选择：</p>

<ul>
<li>用老办法，在所有有往来的银行开立清算账户清算</li>
<li>所有金融机构都在央行开立清算账户，由央行为商业银行统一清算</li>
</ul>


<p>显然大家都想用第二个方案。然而在那个时代，央行能承担的职责是很有限的，各银行内部数据还没有集中，没有电子化的记账系统，国内甚至都还没有银行卡，客户要转账也没有满大街的ATM。总之一句话，国内的金融环境还没有达到让央行推行全国统一结算制度的客观条件。</p>

<p>为了满足跨行结算的需求，央行当时提出商业银行要“自成联行系统，跨行直接通汇，相互发报移卡，及时清算资金”。也就是说同一家银行的总行及分支机构称为“联行系统”。同一联行内的资金结算，由联行总行自己做。这样，建行深圳分行和建行北京分行之间的资金清算由建行自己内部解决。跨银行之间要能支持直接汇款。跨行业务可以由央行清算，也可以由商业银行自己清算。</p>

<p>这是个各家银行系统很不智能，体验很差的时期，我们称为“全国手工联行”时期。于是，每家银行都可以接受跨行的汇款，银行每天自行轧差，各种交易汇总计算后，需要告知其他行的交易信息写成一张张特定的公文，加盖印鉴后在银行间送来送去。这种公文叫做联行信件，而收发联行信件就是当时邮电局的重要业务。</p>

<h3>全国电子联行系统EIS (1989-2005)</h3>

<p>随着银行业的不断发展，银行每天处理各类跨行业务的数量增多，各家银行之间的债权债务关系变得非常复杂，由各家银行自行轧差进行清算变得非常困难。这种状况要求央行必须承担起一个全国清算中心的角色。于是，央行在1989年12月6日，发布了“关于改革联行清算制度的通知”。</p>

<p>随后在1990年，中国人民银行清算中心建成，专门为金融机构提供支付清算服务。这个清算中心包括NPC和CCPC：</p>

<ul>
<li>NPC（National Process Center，国家金融清算总中心）</li>
<li>CCPC（City Clearing Processing Center，城市处理中心）</li>
</ul>


<p>1991年4月1日，基于金融卫星通讯网的应用系统——全国电子联行系统（EIS）开始试运行。EIS是人民银行专门用于处理异地（包括跨行和行内）资金清算和资金划拨的系统。它连接了商业银行、央行、NPC和CCPC。</p>

<p>假设客户在深圳建行汇款给北京工行，通过EIS处理一次跨行汇款的流程如下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg1.png" alt="img" /></p>

<p>可以看到，清算中心在各地建立了一个个分站，分站和总中心通过卫星网络互联，总站和分站共同构成了清算网络，为其它接入EIS的各家商业银行提供清算服务。</p>

<p>从此之后，各个银行之间的跨行汇款，以及同一银行的异地分行，就可以直接通过这样的电子化操作来完成了，客户的资金在途时间缩短到了一两天，这也算是中国金融系统的一大里程碑了。</p>

<p>PS: 直到2015年，我都在一些银行的老系统中见过EIS，这个东东真的很经典，生命力很顽强啊。</p>

<h3>现代支付系统CNAPS (1991-现在)</h3>

<p>1991年EIS试运行后，又发生了两件大事：</p>

<ul>
<li><p>各大银行核心系统投产，各家商业银行的内部联网系统纷纷建成投产</p>

<p>  银行内部资金划转都可以通过自己的核心系统解决了。这意味着各大行都可以做电子化的行内清算了，行内异地转账就不用再依赖EIS。笔者跑过许多银行，见识了许多核心系统的投产，几乎所有的核心系统设计都是一个套路，将来有时间可以再有一篇文章细说一下。</p></li>
<li><p>中国现代化支付系统（CNAPS）开始设计</p>

<p>  1991年10月，中国开始着手建设中国国家金融通信网（CNFN）和中国现代化支付系统（CNAPS，China National Automatic Payment System）。从此，全国电子联行（EIS）系统逐步向CNAPS过渡。到了二十一世纪，IT技术飞速发展，央行的CNAPS一代系统（大小额支付系统）也开始走上历史舞台。中国的支付清算步入了现代化支付系统CNAPS的时代。</p></li>
</ul>


<p>CNAPS值得我们大说特说，今天银行的主力业务都跑在它的基础上，它的发展历史上有几件大事:</p>

<ol>
<li>2002年，央行大额实时支付系统（HVPS）投产，用于处理同城和异地的商业银行跨行之间（也包括行内一定金额以上的）大额贷记业务。</li>
<li>2005年，央行小额批量支付系统（BEPS）投产，用来处理同城和异地纸凭证截留的借记支付业务以及每笔金额在5万以下的小额贷记支付业务。</li>
</ol>


<p>这两个业务统称为大小额系统，我们平时的跨行转账，走的就是这两个系统，他们之间有如下区别:</p>

<ul>
<li>首先，大小额的开放时间不同</li>
</ul>


<p>大额系统是工作日的 8:30 ~ 17:00，所以在节假日经常会收到银行通知说某些业务暂停了经常就是因为央行在节假日对大额系统做维护。小额系统全年无休，7*24小时工作。</p>

<ul>
<li>业务处理上不同</li>
</ul>


<p>大额是每笔交易都实时发送，实时清算的，所以基本上能实时到账，跨行资金零在途。小额系统是在收集若干笔交易后打一个包统一处理，定时清算。所以，用小额系统转账经常要几分钟甚至半个小时才能到账，银行间头寸交割也是非实时的。尽管理论上跨行转账业务不管用大额还是小额，一般在几分钟内都能到账，但是因为要经过央行，所以在这一时期基本没有银行敢向客户承诺资金多久能到账。比如我们早期银行卡转账，一半会发现一个<code>两小时内到账</code>的提醒，这就说明他走的是小额支付系统。</p>

<ul>
<li>金额不同</li>
</ul>


<p>大额系统没有金额限制，小额系统支持的单笔金额上限是5万元。从用途上讲，大额系统侧重于资金转移的时效性，主要用于资本市场、货币市场交易和大额贸易资金结算。小额系统对数据吞吐量要求较高，主要用于小额贸易支付和个人消费服务。</p>

<p>下面一张图就说明了CNAPS大小额的业务实现:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg3.png" alt="img" /></p>

<p>目前大部分手机网银跨行转账都没有手续费。所以如果你在晚上10点想跨行转账10万元，此时大额转账系统已经关闭了，建议你分成两个5万并且用加急方式来转账。</p>

<p>不管怎么说，现在我们的跨行汇款速度总算提高到小时级别了。</p>

<p>PS: 大小额支付的协议细节非常复杂，协议规范有上千页文档，是我去现场部署监控系统时永远的痛啊~~~</p>

<h3>第二代现代支付系统CNAPS2 (2013-现在)</h3>

<p>大小额系统已经很好用了，但是随着金融市场发展，业务需求是无穷无尽的；2013年10月6日，央行的第二代支付系统(CNAPS2)正式投产运行，其中包括2010年就推出的网上支付跨行清算系统（俗称“超级网银”）。超级网银是对大小额支付系统的一个补充，有两大亮点：</p>

<ul>
<li><p>接入机构不再限于银行</p>

<p>  支付宝、财付通等第三方支付也可以接入，所以有的第三方支付给商户提供的提现代发功能就是基于超级网银做的。</p></li>
<li><p>7*24小时实时到账，单笔上限5万元</p>

<p>  这就相当于在非工作日非营业时间增加了一种大额支付系统特性的渠道了。只不过金额限制是跟小额系统一致的。</p></li>
</ul>


<p>最后来一张总体架构图:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg2.jpg" alt="img" /></p>

<p>PS: 现场协议监控部署，<code>人行二代支付</code>是我听了上万遍的词汇啊，睡觉都无法摆脱~~~</p>

<h3>三方支付渠道</h3>

<p>人行的CNAPS2为不同银行间提供了清算服务，银行内部的核心系统为自己不同的分行间提供了清算服务。这两块已经覆盖了大多数的银行业务场景，包括:</p>

<ul>
<li>银行柜台&mdash;直接大小额转账</li>
<li>手机网银&mdash;大小额转账+超级网银</li>
</ul>


<p>但是还有一部分商业市场没有涉及到，就是我们常说的三方支付。我把它又分为两个场景:</p>

<ol>
<li>ATM 刷卡取款和POS机刷卡</li>
<li>网银支付</li>
</ol>


<p>在支付宝普及之前，POS机刷卡以及ATM取款都是我们日常生活中比较常见的资金流转渠道。相信大家都有不少储蓄卡及信用卡有着<code>银联</code>标识。这个银联又是何方神圣？</p>

<p>银联全称<code>中国银联银行卡跨行支付系统</code>，英文缩写为CUPS；我们说支付市场是很大而且油水很足的，人行作为银行的妈，建设清算系统主要是政治考量，而商业银行进军支付领域是要挣钱，所以2002年3月26日，经中国人民银行批准,各大发卡行的商业银行参股，成立了银联。</p>

<p>银联的目的就是提供人行二代支付之外的资金清算渠道，在支付场景捞油水。我们看一下ATM刷卡和POS机业务中，银联发挥的作用。</p>

<h4>POS机刷卡</h4>

<p>POS机刷卡的参与方比较多。以你在星巴克刷卡为例：</p>

<ul>
<li>持卡人——你</li>
<li>发卡行——你办这张卡的银行，我们假设是工行</li>
<li>商户——星巴克，我们假设星巴克的账户开在建行</li>
<li>收单行——星巴克的刷卡机的归属银行，假设也是建行</li>
<li>转接机构——银联</li>
<li>清算机构——银联和人行</li>
</ul>


<p>于是，当你用工行卡在星巴克消费的时候，资金流和现金流是这样发生的：</p>

<ol>
<li>你在收单行（建行）的POS机上刷卡消费</li>
<li>建行将消费报文发送给银联</li>
<li>银联交易系统记录交易数据，将消费报文给你的发卡行（工行）</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行的POS机</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
<li>银联通过小额支付系统或当地票据交换系统，完成建行和星巴克结算账户的资金划拨（收单清算）</li>
</ol>


<p>在这个过程中，银联提供两种清算：</p>

<p>1.建行和工行的清算叫“跨行清算”；
2.建行和星巴克的建行账户之间的清算叫“收单清算”；</p>

<p>无论是跨行清算还是收单清算，银联都是作为CNAPS的一个特许参与者，使用大小额支付清算系统，完成银行卡业务的资金划拨。本质上，银联提供交易转接、清分和对账，人行提供结算。</p>

<h4>ATM跨行取款</h4>

<p>你拿着一张工行卡去建行的ATM取了100元，这个跨行业务在CNAPS体系中的过程如下：</p>

<ol>
<li>你在建行ATM上输入100元按下取款按钮</li>
<li>建行将报文信息发送给银联</li>
<li>银联交易系统记录交易数据，将报文给你的发卡行(工行)</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行ATM</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
</ol>


<p>我们看到，ATM和POS渠道，是由银联的CUPS来对接各大商业银行做支付转接，解决信息流问题；银联同时提供清分和对账服务，对完账之后再调用央行大小额系统解决资金流问题；</p>

<p>当央行系统升级的时候，通过银行柜台和手机银行是不能做跨行转账的，但是通过ATM和POS却可以跨行取款和跨行支付，这是因为银联暂且处理了清分和对账，等到央行系统升级完毕后，他们才进行清算；</p>

<p>所以一般央行挑放假的日子升级系统，这个时候一般没有对公业务，但是我们平常的刷卡消费可以正常进行。</p>

<p>另外，我们说，资金跨行清算的发展中，出现了一位豪杰，就是三方支付的大佬：支付宝</p>

<h4>支付宝等势力的发展</h4>

<p>支付宝早期为了服务淘宝客户和商家，不可避免的要跟银联抢生意，对接各大银行的支付接口。</p>

<p>银联作为既得利益者，绝不会开放接口给支付宝的。所以当时支付宝拿到支付牌照之后，苦逼的一家一家跟跟银行洽谈对接，值得注意的是，支付宝对接的各机构间跨行转账，没有走人行的大小额系统，而是走的支付宝内部资金池。</p>

<p>支付宝积硅步以至千里，慢慢的接入的银行多了，服务竟然能叫板银联了。</p>

<p>印象特别深刻的是，有一年国庆节人行系统升级，当时的小额转账竟然有大多数交易走的支付宝渠道，这时候支付宝已经有能力作为第三大清算网关服务大众了;</p>

<p>另外举一个有趣的例子，因为支付宝早期转账有免费的短信留言服务，所以有人用每笔1分钱的转账服务聊天！而发条短信都1毛钱呢，这跟如今的bitmessage、memocash记录信息何其相似。</p>

<p>我后来工作走了不少地方性的小银行，因为供应商不一样，他们每家的对接方案都不同，支付宝竟然有耐心一家一家的啃下来了，不得不佩服他们下的苦功夫。</p>

<p>当然，后来微信支付也异军突起，三方支付平台各路神仙纷纷跳出来分蛋糕，银联节节败退之后，祭出杀手锏；找央妈诉苦。于是为了平衡各方利益，一纸文件下来，决定建立网联平台，大家之前的自留地接入废除，各方统一接入网联，利益均沾。支付宝之前的平台建设就完成历史使命了。</p>

<p>网联平台的建设由于有阿里和腾讯的研发力量加入，开发异常顺利。2017年开始逐步上线，2018年双十一，就在前几天，官方号称TPS超过了9万笔。实在了得。不得不承认，我国的交易金融系统处理能力在世界上已经是单独一档了。</p>

<h4>小结</h4>

<p>上面长篇大论了我国支付清算系统的建设和发展，无非说明几个问题:</p>

<ol>
<li>金融越发达，支付行为越多，清算所占的比例也水涨船高</li>
<li>清算的速度越来越快，处理效率越来越高</li>
<li>虽然清算接入的机构越来越多，但是清算网关呈现大一统的趋势</li>
<li>清算的交易笔数指数级增长，中国支付清算协会发布《中国支付清算行业运行报告（2018）》称，2017年，国内商业银行共处理移动支付业务375多亿笔，非银行支付机构共处理移动支付业务2390多亿笔，这之中大部分都包含有清算行为</li>
</ol>


<h2>区块链时代</h2>

<p>我认为区块链技术诞生后，清算技术又是一个进化。但是这个进化过程初期表现十分笨拙，以至于看起来像是退化。</p>

<p>在比特币诞生之前，Ripple网络其实已经在传统清算网关的基础上，基于中心化的共识，提出了新的清算网关方案。他们的技术其实很有意思，也非常创新。我们打算放到其它篇章来介绍。目前我们单独谈谈比特币的技术方案。</p>

<h4>容量</h4>

<p>首先比特币由于是去中心化的网络，处理能力是非常低的；即使引入了Segwit附带一点扩容效果，目前也不过是3~4 TPS，和中心化的清算网关相比，简直可怜。</p>

<p>但是比特币系统的特殊之处就在于，他没有集中的账户管理节点，这意味着网络中的每个全节点都承担清算网关的职能，每一笔支付必然带有一笔清算，清算率100%。</p>

<p>这实在是像极了早期雅浦岛上的石头货币系统，我们一再强调这个寓言故事，因为它和比特币如此相像；比特币系统简直是雅浦岛的石币系统的电子版！连处理能力也是如此相似的性能低下！</p>

<p>值得庆幸的是，雅浦岛上的居民限于物理条件，系统性能提升有极限；而现代的电子设备性能提升，横向扩展的话，几乎是无穷尽的。</p>

<p>当前比特币的扩容方案主要是两大流派，经济利益夹杂着技术讨论，是是非非就不评说了，我们撇开矿霸、专利、以及阴谋论，只是整理一下他们目前的发展状况</p>

<h5>闪电网络链下扩容</h5>

<p>主要路线是Segwit 解决交易延展性问题，然后在此基础上实现二层闪电网络。目前来看，Segwit已经占了主网交易的半壁江山，估计最终能扩容到4-8 TPS，这当然不够用。所以二层网络的闪电网络至关重要。</p>

<p>闪电网络目前还是处于试验阶段，虽然推出了一些应用，但总体还是和比特币早期发展一样，只是部分Geek在使用。</p>

<p>优点:</p>

<ol>
<li>中转节点越多，处理能力越强</li>
<li>如果两个节点间能形成比较短的支付路径，理论上它的处理能力会很惊人的，至少是比现在几个数量级的提升</li>
<li>微支付通道里面的交易记录不上主网，这样跑全节点的开销只会线性增长，有利于比特币的去中心化</li>
</ol>


<p>缺点:</p>

<ol>
<li>收款需要保持在线</li>
<li>形成微支付通道需要双方缴纳保证金</li>
<li>建立和销毁微支付通道都需要主网广播，如果支付笔数少，建立通道的得不偿失；因为这个原因，目前来看闪电网络的实际应用不多</li>
<li>闪电网络的中转节点需要大量的保证金，会天然的会向大公司、集权化发展，这也是区块扩容党最诟病的一点</li>
</ol>


<h5>大区快链上扩容</h5>

<p>优点:</p>

<ol>
<li>代码简单，即刻扩容</li>
<li>技术方面来讲，扩容到32M-128M其实开销也不大；根据硬件设备的发展，长远来看，1GB的大区快可能也行得通</li>
<li>有人认为Segwit引入了复杂度，原本的交易格式更改了，技术上有洁癖的人接受不了，大区快扩容没有技术债</li>
</ol>


<p>缺点：</p>

<ol>
<li>有人认为今天32MB，明天更多，扩容起来无穷无尽，早晚只有矿场才会运行全节点，这样去中心化吃枣药丸</li>
<li>交易延展性问题早晚得解决，目前来看Segwit解决方案还是比较成功的，扩容党只是嘴硬，早晚得上</li>
<li>扩容再多，性能也比上闪电网络</li>
</ol>


<h4>总结</h4>

<p>近日BCH社区又经历了一场硬分叉斗争，有利益相争的地方就有恩怨，有恩怨就有江湖；很有可能大家搞来搞去，Bitcoin就搞死了，很正常。</p>

<p>其实看到最后，最核心的分歧其实就是Bitcoin 主网是否每个节点该继续承担清算的工作，这其实和现实中的货币发展十分相似：</p>

<ol>
<li>市场初期不是那么繁荣，即使交易一次清算一次，货币的物理特性也能顶住，这和bitcoin初期很相似，每个全节点都是清算网关，每笔交易都有一笔清算，安安稳稳跑了十年</li>
<li>市场爆发，原有的清算体系扛不住了，这个时候需要升级技术方案解决；有分歧了，需要把全部交易都上主网吗？买杯咖啡需要记录到主链上吗？毕竟今天区块链还是非常金贵的资源，这个系统每天消耗的电力资金数以亿计了，在上面画画写诗实在是有点浪费；从历史来看，引入闪电网络，小笔交易不再并入主网，变成两个特殊清算节点之间的轧账比较合适</li>
<li>分歧就在这里，有人觉得硬件性能增长完全可以让主网记录人类所有的交易；有人说扯犊子，买咖啡不应该上主网</li>
</ol>


<p>目前的情况来看：</p>

<ol>
<li>闪电网络还是处于实验阶段，有力使不上，主网一直满负荷</li>
<li>扩容派各种斗争，要上位还很远</li>
</ol>


<p>看不清未来方向；其实历史是波浪式前进的，如果顶层设计，我可能倾向于:</p>

<p>先区块扩容一点(提高清算能力)&ndash;>Segwit+闪电网络(集中清算)&ndash;>硬件性能跟上了，继续扩容(再分布式清算)</p>

<p>但是现实斗争就是这么残酷哦，技术最优不代表市场最优，技术市场最优不代表拳头最大~~~所以说历史发展是随机的；像基督教分为犹太教、新教、天主教等等，佛教搞成藏传、南派北派等等，人类就是折腾中前进，比特币出来以后，一度把清算技术搞成了教派斗争，这挺有意思的</p>

<h4>更丰富的商业场景</h4>

<p>不管怎么说，我对于技术的前进还是乐观的，不管是传统的清算中心，还是区块链，如果将来我们的清算能力再有一个指数级飞升，我觉得又会有新的商业模式出现</p>

<ul>
<li>现在的保险行业，比如车险，保险的时段只能一整块时段，同样买了一辆车，有的几个司机合伙24*365天天在外跑，有的上下班每周就几个小时的使用时间，交一样的钱其实不公平；未来可能只有你的引擎发动之后，真正在路上跑了，按照分钟收费，你的钱要一点一点打到保险公司账户上，这样比较合理</li>
<li>娱乐消费行业，目前也是整段时间收费，未来你听一首歌，可能按照 0.0000001元/秒的速度慢慢付款给音乐公司</li>
<li>公益行业: 真正的贫困人口可以开设经过认证的账号，这样土豪捐款的时候可以绕过红十字会，平均账户发放救济金之类，而且可以有各种算法监控，比如每个月固定发个100元，这个账户之后走的是哪个清算单元，进行了什么消费，杜绝骗子的不正当用途</li>
<li>资金审计: 将来的所有公益和对公账户，审计不再是一个问题了，因为你可以追踪所有的清算单元，用智能算法来判断资金最终的流向和目的，财务造假的难度大大增加</li>
</ul>


<h4>引用：</h4>

<p><a href="http://www.gongxiangcj.com/posts/1478">http://www.gongxiangcj.com/posts/1478</a></p>

<p><a href="https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf">https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf</a></p>

<p><a href="https://www.zhihu.com/question/22148261">https://www.zhihu.com/question/22148261</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BCH分叉承担的风险--51%攻击者概率问题]]></title>
    <link href="https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti/"/>
    <updated>2018-11-17T18:42:09+08:00</updated>
    <id>https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>2018-11-16 01:40(UTC+8)发生的BCH分叉实在好看，转载一下进程说明:</p>

<!-- more -->


<blockquote><p>  “分叉前夕：
  BCH硬分叉过程中：第一个区块由澳本聪阵营svpool爆出，区块大小为51.385KB，区块高度为556761。BCH硬分叉连续爆出6个区块才会正式开始分叉。</p>

<p>  BCH硬分叉过程中：第二个区块由澳本聪阵营coingeek爆出，区块大小为8.24kB，区块高度为556762。</p>

<p>  BCH硬分叉过程中：第三个区块由澳本聪阵营SVPool爆出，区块大小为29.44kB，区块高度为556763。</p>

<p>  在BCH硬分叉过程中，ABC阵营开始反击，比特大陆旗下第一大矿池BTC.com已经获得部分客户同意，切换算力支援BCH ABC。ABC阵营Bitcoin.com矿池的BCH算力在分叉前24小时大增1593.09%，超过澳本聪阵营的Coingeek矿池，排名第一。</p>

<p>  BCH硬分叉过程中：第四个区块由吴忌寒阵营Bitcoin.com挖出。区块大小为57.11 kB，区块高度为556764。</p>

<p>  BCH硬分叉过程中：第五个区块由吴忌寒阵营ViaBTC爆出，区块大小为315.40 kB，区块高度为556765。</p>

<p>  BCH硬分叉过程中：第六个区块由澳本聪阵营SVPool爆出，区块大小为2597.76 kB，区块高度为556766。</p>

<p>  区块高度556766：正式分叉。算力大战正式开始。随后比特大陆阵营率先出两个块，并保持持续领先。”</p></blockquote>

<p>Bitcoin.com矿池临时集了4000P的算力，巅峰时Bitcoin ABC的算力达到了8500P，而Bitcoin SV始终没有超过5000P。分叉当晚，实力差距明显。</p>

<p><a href="https://cash.coin.dance/blocks/hashrate">https://cash.coin.dance/blocks/hashrate</a></p>

<p>但是Bitcoin SV目前没有放弃的意思，而且Bitcoin.com抽调的算力会慢慢撤回去，因为SV链没有重放保护，如果一直烧钱维护下去，现在还不能称胜负已分。</p>

<p>Bitcoin SV作为进攻方，按照现在1T算力0.1元/小时的价格计算，每天SV要烧掉$200W 维持这场战争。而且目前在BCH链上挖矿收益绝对小于BTC链，如此烧钱确实是土豪行径。如果CSW始终不加重放保护跟Bitcoin ABC死磕，确实是下决心了。但是如果怂了开始炒作Bitcoin SV，那就说明他也不过是个出来割韭菜的。</p>

<p>但是群众其实也不关心鹿死谁手，反正分叉明朗之前不动就可以了。看戏之余，不妨回顾一下中本聪白皮书中关于51%攻击的计算:</p>

<p>(参考第十一章:计算)</p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p>这个计算过程还是很有意思的，我们天天听各种媒体讲<code>51%攻击</code>，那么现实世界中，现在确实发生了两方争霸的情况，我们定义几个变量:</p>

<ul>
<li>P = 诚实节点制造下一个节点的概率</li>
<li>Q = 攻击者制造下一个节点的概率</li>
<li>Qz = 攻击者追上诚实节点z个区块的差距</li>
</ul>


<p>目前(2018-11-17 17:00 UTC+8)Bitcoin SV链算力4278PH，Bitcoin ABC链算力5677PH，Bitcoin SV落后7个Block。Bitcoin ABC为防守方，Bitcoin SV为进攻方，假如Bitcoin SV就这么死磕到底的话，算力保持不变的情况下，有多大机率能51%攻击呢？如果要提高攻击成功的概率，Bitcoin SV又需要多大的算力呢？</p>

<p>我们又要复习一下概率论里面的ABC了，搬来小方凳，数学课开始~~~~</p>

<h2>酒鬼漫步问题</h2>

<p>当一个喝大了的酒鬼在路上摇摇晃晃时，你是否会担心他还有能力避开一切障碍，成功找到家门而不是掉到某个下水沟里吗？</p>

<p>实际上，这正是非常有趣的酒鬼漫步问题，不妨让这个酒鬼的处境更夸张一些，设想他站在悬崖边，面前就是万丈深渊。如果他往后退一步远离悬崖的概率是 2/3 , 向前一步靠近悬崖的概率则是 1/3。那他摔下悬崖的概率是多少?</p>

<p>答案肯定不会是简单的 1/3。那不如先来看看酒鬼最初的几步会发生什么。下图是对这个酒鬼最初几步所有可能的轨迹的枚举。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg1.png" alt="img" /></p>

<p>从图中可以看到，达到<code>0</code> 即意味着跌落悬崖。所以在 <code>0</code> 的那些概率的和便是酒鬼前六步掉下悬崖的概率。这个图可以无限推演下去。</p>

<p>所以让我们把这个场景放到数轴上，换一种方式来看。如此一来醉鬼悬崖边漫步就相当于质点沿轴心运动这类问题了。酒鬼在这个数轴上随意地左右走动， 走到 x = 0 的位置意味着被吸收 ，也就是摔下了悬崖。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg2.png" alt="img" /></p>

<p>假设他向右一步的概率为 <code>p</code>，向左的概率为 <code>1－p</code>。当他在 <code>x = n（n&gt;0）</code> 的位置的时候，不是向右就是向左。记 <code>P（n）</code>为从 <code>x = n</code> 的位置出发，最后到达 <code>x = 0</code> 被吸收的概率。酒鬼一开始在 <code>x = 1</code> 的位置，我们要求的就是他到 0 的概率。</p>

<p>当酒鬼走完第一步后，他要么到了 <code>x = 0</code>（此事件发生的概率是 1－p），要么到了 <code>x = 2</code> 的位置（此事件发生的概率是 p），他再从 <code>x = 2</code> 出发最终走到 <code>x = 0</code> 被吸收的概率就是 <code>P（2）</code>。这时我们可以得到方程1:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>P(1) = 1 - p + p * P(2)</span></code></pre></td></tr></table></div></figure>


<p>而自 <code>x =2</code> 走出并最终到达 <code>x = 0</code> 的情况可以分解为两个阶段：先从 <code>x = 2</code> 到 <code>x = 1</code>（可以走任意步）, 然后从 <code>x = 1</code>到 <code>x = 0</code>（同样可以走任意步）。我们知道后一个的概率是 P（1）,那么前一个呢？其实是一样的，也是 P（1），它可以看作后一种情况的平移。又因为这两个事件相互独立，所以得到方程2:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>P(2) = P(1)²</span></code></pre></td></tr></table></div></figure>


<p>将方程2代入方程1，得到一个简单的一元二次方程:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>P(1) = 1 - p + p* P(1)²</span></code></pre></td></tr></table></div></figure>


<p>解得  <code>P(1) = 1</code>  或者   <code>P(1) = (1-p)／p</code></p>

<p>注意到这里 p 表示的是酒鬼每次向x轴正方向前进一步的概率，也就是他站在悬崖边上向后退的概率。我们不妨根据这个概率的取值情况来对酒鬼悬崖漫步这个问题做个总结。</p>

<p>当 p 等于 0 或 1 时，这显然就成了必然事件，酒鬼一定掉下悬崖或者一定能安全地离开。</p>

<p>但有趣的是，即便当 p 不是 0，在它小于等于 &frac12; 时，这个酒鬼一样难逃失足的厄运。</p>

<p>当 <code>p = 1/2</code>时， P(1) = 1</p>

<p>众所周知，一个事件发生的概率不会超过 1。所以从上面可以看出，当 <code>p ≤  1/2</code>时，也就是这个酒鬼每步选择向后退的概率不足一半时，不管他能离开悬崖有多远，最终都必将粉身碎骨。</p>

<p>而如果 p 在 （1/2 , 1） 这个区间里，这时候酒鬼摔落悬崖的概率实际上是一个关于 p 的连续函数。我们可以做出 P(1) 的图像如下</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg3.png" alt="img" /></p>

<p>现在让我们回答最初的问题，当酒鬼向后走的概率为2/3时，他摔下悬崖的概率为 &frac12; 。 很违背直觉的结果，保持一半清醒是不够的，最少要2/3的清醒。</p>

<h2>从酒鬼漫步到赌徒破产</h2>

<p>把酒鬼徘徊应用到赌博中会得到一个不可思议的结论。假设一个赌徒的赌金是 n，每次的下注金额是 1，而每盘赌局输赢概率各是 1／2。如果一直赌下去的话，赌徒输光的概率是多少呢？</p>

<p>由前面的分析可知，他破产的概率就是前面定义的 <code>P（n）</code>。 <code>P（n）</code>是 <code>P（1）</code> 的 n 次方，而 <code>P（1）</code> 在酒鬼等概率地向两个方向迈步的时候等于 1,所以 <code>P（n）＝1</code> ！这告诉我们，即使是公平赌局，你跟赌场玩，最后也一定会输光的！</p>

<p>这就是著名的赌徒破产问题（Gambler’s ruin）。</p>

<p>显然，赌徒的钱越多，输光需要的局数也越多。当赌徒的赌金是 n 时，我们记输光的概率为 p(n)。因为每次赌局有一半的可能赢，一半的可能输，赢的时候赌金变成 <code>n + 1</code>，输的时候变成 <code>n - 1</code>，所以 <code>p(n) = (p(n + 1) + p(n - 1))／2</code>。当 <code>n = 0</code> 的时候，即使不用赌，所有东西也都输光了，所以 <code>p(0) = 1</code>。</p>

<p>由此，p 可以看作一个满足下列递推关系的数列</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>p(0) = 1
</span><span class='line'>
</span><span class='line'>p(n+1) = 2 * p(n) - p(n-1)，
</span></code></pre></td></tr></table></div></figure>


<p>也就是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>p(n+1) - p(n) = p(n) - p(n-1)</span></code></pre></td></tr></table></div></figure>


<p>容易验证 <code>p(n) = n * p(1) - (n-1)</code> 正好符合上面的递推关系。</p>

<p>又因为<code>p(n) ≥ 0</code>，所以对于任意的 n，必定有 <code>p(1) ≥ 1 - 1／n</code>。因此 <code>p(1) = 1</code>。那么对于所有的 n，则有 <code>p(n) = 1</code>。这意味着，在无限次的赌博中，赌徒在某一次赌博中输光的概率是 1。</p>

<p>这个发现其实和经典的赌徒谬误异曲同工。上帝创造这个世界的一些规则真是意味深长啊，当你要赌的时候，50%的胜率是不够的，一定要有>50%的把握!</p>

<h2>从赌徒破产到算力攻击</h2>

<p>将上面两个例子映射到区块链算力争霸的过程中，发现有惊人的相似点。</p>

<h4>情况1</h4>

<p>当两条分叉从同一起点开始竞争时，就是一个酒鬼漫步问题；攻击者一方相当于不断的要逼近诚实者一方挖出的区块高度；</p>

<ul>
<li>诚实节点：block1&mdash;&mdash;&mdash;block2&mdash;&mdash;&mdash;block3&mdash;&mdash;&mdash;block4&mdash;&mdash;&mdash;</li>
<li>攻击节点：block1&mdash;&mdash;&mdash;block2A&mdash;&mdash;-block3A&mdash;&mdash;&ndash;</li>
</ul>


<p>攻击节点从block2开始攻击，尝试双花其中的交易，并挖出区块block2A。攻击节点挖出的链要比诚实节点挖出的链长——在本例中，它至少要挖到block5——才算攻击成功。我们把诚实节点的链长度减去攻击节点的链长度，得到的差记为n。诚实节点每挖出一个块则n+1；攻击节点每挖出一个块则n-1。我们把n放到数轴上<code>n-1  ←  n  → n+1</code>；攻击节点挖出一个块，相当于酒鬼向左移一步；诚实节点挖出一个块，相当于酒鬼向右移一步。设诚实节点领先n个块，如果攻击节点的算力达到或超过了全网的50%，那么它一定能把n减到0。而如果攻击者算力小于50%，则n越大，也就是确认数越多越安全。从这里你们也可以看出来，我们通常所说的51%攻击，是一个没看懂白皮书的人定下的名词。其实应该定名为50%攻击，攻击者不需要大于50%的算力就能成功。</p>

<p>在BCH的分叉战中，如果有一条链的算力一开始能达到算力的50%并保持下去，就可以杀死另外一条链；</p>

<h4>情况2</h4>

<p>但是随着链的延长，两边的算力便会拉开差距，挖出的快总是有多有少；算力战预测的初始条件变成了这样:</p>

<p>从交易被收录进区块的时候开始，诚实矿工出了z个块。攻击矿工在此期间出块数记为k，只要攻击者不广播别人就不知道，k可能等于0、1、2……直到无穷大。</p>

<ul>
<li>若k>z，攻击直接成功；若k&lt;=z，攻击者仍有可能追上，其成功的可能性即赌徒破产问题。因为攻击失败的情况有限，所以计算成功概率改为计算等价的<code>1-攻击失败的概率</code>。</li>
</ul>


<p>首先研究k，假定诚实矿工以均匀的速度出块，则k近似服从泊松分布：<code>P(k, λ)</code>；</p>

<p>就是“在一个指定长度的固定区间内有k个点（事件）”的概率。诚实矿工出z块的时间即“指定长度的固定区间”，攻击矿工出块次数k即“事件”，每种k出现的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg4.png" alt="img" /></p>

<p>其中λ是攻击矿工出块的期望，假设比特币的算力简化计算为:</p>

<p>速度 * 时间 = 工作量。</p>

<p>z是防御者的工作量，p是防御者的速度，z/p是防御者消耗的时间。防御者的时间=攻击者的时间。攻击者的速度=q；</p>

<p><code>攻击者的工作量期望 = 攻击者的速度 * 攻击者的时间 = q * z / p</code>。 即 <code>λ = z*q/p</code>。</p>

<p>根据赌徒破产问题，在落后了z-k个块之后仍旧能追上的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg5.png" alt="img" /></p>

<p>追不上的概率为:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg6.png" alt="img" /></p>

<p>每种k (k&lt;=z)出现的概率，乘以它追不上的概率，就是这个k的失败率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg7.png" alt="img" /></p>

<p>1-所有攻击失败情况的概率之和，就是攻击成功的概率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg8.png" alt="img" /></p>

<h2>总结</h2>

<p>当前Bitcoin SV算力占总算力的43%，落后7个block，取q=0.43, p=0.57, 计算成功率已然小于10%了。</p>

<p>那么，Bitcoin SV要把算力提高到多少，才能有50%的希望追上Bitcoin ABC呢？ 这是个复杂的问题啊，首先从分叉一晚的算力战来看，目前BitcoinABC可以调动的算力总量为8500P，所以Bitcoin SV目前一定要调动>8500P的算力，才能有翻盘的机会，至于需要多大才能把翻盘机会搞到50%，课后作业计算吧。</p>

<blockquote><p>PS:有个小漏洞，因为BCH的难度计算和BTC是不一样的，我不是很确定情况2的计算是否可以假设为泊松分布。</p></blockquote>

<p>当然，这是一个模拟，真实情况是，发生危机时，bitmain会不断的从BTC那边调集算力过来；这其实是BCH在吸血BTC的算力；</p>

<p>目前来看，BTC的算力有46EH，目前市场上所有的SHA256算力可能总共>60EH；如果算力占再升级，都可以看成是BCH链对BTC链的攻击了。而且只要Bitcoin SV一天不加重放保护，那么交易所就不太可能开放冲提币，这样BCH 链上的交易就会继续停滞，表面上来看是Bitcoin SV一方在烧钱，其实是BCH整条链都在烧钱。现在真正是考验信仰的时候，短期来看，输家会一无所有。赢家也未必能赚到什么。非常残酷的算力战。这真是难得一见，再过10年，真的像中本聪预测的那样，比特币广泛应用后，这种算力战出现的概率极小。某种意义上来说，这个热闹真好看啊:</p>

<p>每天投入$200W的豪赌!</p>

<p>这也进一步验证了，同一个POW算法，最多只能存在一条链，因为即使加了重放保护分叉，还是无法逃脱算力威胁；BCH是一条非常非常特殊的链，它是由bitmain大算力保证的小算力链；这么说可能有点绕口，可以看成BTC和BCH的战争会持续下去，我认为一定会有一方死亡！至于持续多长时间就不好说了，但是我认为这种平衡不可能无限保持下去，必然会发生黑天鹅事件。</p>

<p>另外，像PPC等SHA256 POW币，或者ETC之于ETH，也是同样的情况；我抱持一种观点：</p>

<blockquote><p>同样的POW算法，如果有大算力存在的情况下，一定归于一条链；
中间可能会多链并存很长时间，但总会发生黑天鹅事件将其它链清零</p></blockquote>

<h4>引用:</h4>

<p><a href="https://www.guokr.com/article/59575/?page=3">https://www.guokr.com/article/59575/?page=3</a></p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p><a href="https://www.zhihu.com/question/263764571">https://www.zhihu.com/question/263764571</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bicoin Cash分叉在即]]></title>
    <link href="https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji/"/>
    <updated>2018-11-15T15:08:32+08:00</updated>
    <id>https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji</id>
    <content type="html"><![CDATA[<p>Bitcoin Cash 将于UNIX时间1542300000 (即北京时间2018年11月16日00：40)发生硬分叉;</p>

<p>分叉两派是比特大陆为首支持的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc">Bitcoin ABC</a>实现，以及Craig Steven Wright为首的<a href="https://github.com/bitcoin-sv/bitcoin-sv">BItcoin SV</a>实现。</p>

<p>两派的恩恩怨怨政治斗争无心吐槽，咱也没有明确的倾向；但是作为码农咱要黑一黑；</p>

<!-- more -->


<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/2ab7775797a5a37ab311ab9a067771e5c1bfe22a">这里</a>是bitcoin SV 从Bitcoin ABC项目里面开始folk出来的修改；截至他们发布Bitcoin SV Beta1.0；最后提交的代码是<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/d9b12a23dbf0d2afc5f488fa077d762b302ba873">d9b12a23dbf0d2afc5f488fa077d762b302ba873</a></p>

<p>执行 <code>git diff 802629f d9b12a --stat</code> 瞄一眼:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>699 files changed, 11634 insertions(+), 197401 deletions(-)</span></code></pre></td></tr></table></div></figure>


<p>看起来改了不少，但是从头review一遍，他们从2018-08-22搞到现在，啥实质改动都没有，就开了几个操作码，改了几个测试；原本MAXBLOCKSIZE就变成可配置的了，他们不过是稍稍改了一下判断条件而已，改动最大的反而是README和release notes文件，最值得吐槽的就是这个提交：</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d">https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d</a></p>

<p>好吧，也不能无脑黑你，你还是修掉了一个比较重要的BUG的:</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86</a></p>

<p>凭良心说，Bitcoin ABC的开发比不上Bitcoin Core的活跃，但起码Bitcoin Core有什么更新，人家能及时Merge过来啊！</p>

<p>曾经，像Bitcoin Gold之流，改个POW算法就出来割韭菜了，大家还愤愤不平；</p>

<p>Litecoin和Dogcoin还是改了改币数上限和出块时间的，这是在早期，咱们也忍了~~</p>

<p>如今Bitcoin SV的代码库让我见识了什么叫任性！</p>

<p>如果不赞成升级，原版代码运行就是；现在哥们，你们倒是放开了操作码！但是操作码执行实现的部分好好测试过了吗，对应的测试在哪里？就两天时间开放出来不怕出BUG吗？</p>

<p>同样的一个<a href="https://bitcoincore.org/en/2018/09/20/notice/">重要BUG处理</a>:</p>

<p>Bitcoin ABC的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc/commit/7e20479893089b2b80f81cc2e7e5712a2d4158ba">重构+修正</a>，BitcoinSV的<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">修正</a>; 态度啊~~</p>

<p>我觉得数字货币这个场子没啥正义公理权威可言，就是中本聪重现人间，相信说话也没多大分量了；但是代码质量是没办法靠嘴炮提升的；长久来看，占据市场还是要靠产品质量啊。</p>

<p>但是不管怎么样，接下来的战争是一场明刀明枪的较量，没有重放保护，双方都是投入真金白银维护自己的立场，这比空气币收割韭菜实诚多了；</p>

<p>比特币这个社会实验已然十年，终于出现了白皮书所描写的第一场大规模算力战争，值得期待啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-3]]></title>
    <link href="https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3/"/>
    <updated>2018-11-07T19:59:04+08:00</updated>
    <id>https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3</id>
    <content type="html"><![CDATA[<p>通过前面两篇文章，我们认识到比特币的所有权是通过私钥来确定的。</p>

<p>那么我们就在此基础上研究比特币钱包的构成。广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，比特币钱包的核心就是对私钥的管理。</p>

<p>在比特币的历史发展中，钱包大致经过了三次进化:</p>

<ol>
<li><p>非确定性（随机）钱包</p></li>
<li><p>确定性（种子）钱包</p></li>
<li><p>分层确定性钱包（HD Wallets (BIP-32/BIP-44)）</p></li>
</ol>


<p>下面我们就好好说说钱包的历史发展轨迹</p>

<!-- more -->


<h2>非确定性（随机）钱包</h2>

<p>在比特币刚诞生时，Bitcoin Core客户端实现了第一个钱包功能，当时因为早期的用户并不多且都是专业人士，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。具体的实现细节就是:
比特币核心客户端预先生成100个随机私钥，每个密钥只使用一次；用完之后再生成100个；</p>

<p>这样做的缺点十分明显：</p>

<p>如果你生成很多私钥，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址重复使用将多个交易和地址关联在一起，这会减少隐私。</p>

<p>当比特币用户群逐渐扩大时，不少人因为随机生成的100个私钥用完后，没有备份老钱包，生成新的私钥后原先的钱包弃用，造成了未花费币的丢失。现在看看是个不可思议的幼稚的BUG，但是在比特币蛮荒时代，这种漫不经心的错误导致的丢币比比皆是。</p>

<h2>确定性（种子）钱包</h2>

<p>比特币私钥可以用任意方法生成，自然也可以通过一个随机短语进行多次hash得到不同的私钥。这种思路下，社区提出了确定性（种子）钱包的方案。</p>

<p>确定性，或者“种子”钱包包含通过使用HASH函数而可从公共的种子生成的私钥。种子是随机生成的数字。在确定性钱包中，种子足够恢复所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包导入或者导出。这就很容易允许使用者的私钥在钱包之间轻松转移。</p>

<p>比如，我们上一篇文章中用<code>satoshi</code>作为种子，得到SHA256(&lsquo;satoshi&rsquo;)作为私钥，完全可以继续用SHA256(SHA256(&lsquo;satoshi&rsquo;))&hellip;这样推导下去得出更多的私钥，同时，只需要记住<code>satoshi</code>这个种子，就可以方便的导入导出私钥。更进一步，可以加入password和更多的混淆短语，提高私钥生成的健壮性。</p>

<p>这种方案提出后，因为简单易行，多个轻钱包都做了自己的实现；虽然原理相似，但是他们之间并不通用，所以不同的钱包私钥导入导出还有一些不方便。社区就在此基础上继续探索，最终整理形成了BIP32、BIP39、BIP43，BIP44等规范，创造了我们今天通用的HD钱包。</p>

<h2>分层确定性钱包（Hierarchical Deterministic wallet&mdash;HD Wallet）</h2>

<p>首先用一张经典的图来描述HD钱包的私钥生成:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg1.jpg" alt="img" /></p>

<p>分层钱包说白了，就是将<code>seed-&gt;私钥</code>的过程变成了，<code>助记词-&gt;seed-&gt;一级私钥-&gt;二级私钥-&gt;三级私钥....</code>，即多层树状私钥生成的方案。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。HD钱包有两个主要的优势。</p>

<ol>
<li><p>树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。</p></li>
<li><p>它可以允许使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要存储私钥。</p></li>
</ol>


<p>再来一个在线工具用于验证:</p>

<p><a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a></p>

<p>最初的私钥seed来源于一个助记词（又称为Mnemonic Code），为了便于在不同的钱包中转移、导出和导入，社区对助记词的长度，范围，变换标准等等做了详尽的描述，最终形成了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>规范。这个规范由Trezor硬件钱包背后的公司提出，已经成为事实上的行业标准。</p>

<p>BIP-39定义了助记符码和种子的创建， 为了清楚起见，该过程分为两部分：</p>

<p>先是创建助记词，然后是从助记词到种子。下面我们从一个<code>ffffffffffffffffffffffffffffffff</code> 的128bits 熵开始，演示HD钱包是如何生成、管理私钥的。让我们一步一步解释。</p>

<h3>先看看创建助记词的部分</h3>

<h4>生成步骤</h4>

<ul>
<li><p>1、创建一个128到256位的随机序列（熵）。我们取<code>ffffffffffffffffffffffffffffffff</code>，称之为原始熵。</p></li>
<li><p>2、用SHA256 HASH原始熵，就可以创造一个随机序列的校验和。代码如下</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from binascii import unhexlify
</span><span class='line'>from hashlib import sha256
</span><span class='line'>data = 'f' * 32
</span><span class='line'>data_unhexlify = unhexlify(data)
</span><span class='line'>h = hashlib.sha256(data_unhexlify)
</span><span class='line'>checksum = bin(int(h, 16))[2:].zfill(256)[:len(data) * 8 // 32]</span></code></pre></td></tr></table></div></figure>


<p>得到checksum为<code>0101</code></p>

<ul>
<li>3、首先求得原始熵的二进制表示，然后将校验和添加到随机序列的末尾。代码如下:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from binascii import unhexlify, hexlify
</span><span class='line'>data = 'f' * 32
</span><span class='line'>data_unhexlify = unhexlify(data)
</span><span class='line'>body = bin(int(hexlify(data), 16))[2:].zfill(len(data) * 8)
</span><span class='line'>final_result = body + checksum</span></code></pre></td></tr></table></div></figure>


<p>得出的结果为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4、将序列划分为包含11位的不同部分。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111110101</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5、将每个包含11位部分的值作为下标索引，与一个已经预先定义2048个单词的字典做对应。BIP39中对应的字典文件可以参考这里:</li>
</ul>


<p><a href="https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist">https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist</a></p>

<p>以上二进制表示的下标值为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2037</span></code></pre></td></tr></table></div></figure>


<p>为什么单词数目是2048呢？ 其实seed可以有12-24个单词，所有的组合可能性为 2048<sup>12</sup> &mdash; 2048<sup>24</sup>；</p>

<p>还记得我们之前的文章吗？比特币公钥->地址的倒数第二步是RIPEMD160，他一共有2<sup>160</sup>可能性，上面seed的生成空间覆盖了RIPEMD160的生成空间。</p>

<ul>
<li>6、生成的有顺序的单词组，就是助记码(Mnemonic Code)。在咱们的例子中如果采用英文字典，对应的结果为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</span></code></pre></td></tr></table></div></figure>


<p>一张图展示熵如何生成助记词:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg2.jpg" alt="img" /></p>

<p>在上面这个例子中，我们选取了128Bits 原始熵，BIP39规范中，用户有128bits, 160bits, 192bits, 224bits, 256bits多个选择;下面的表格说明了熵数据的大小和助记词的长度之间的关系:</p>

<table>
<thead>
<tr>
<th>Entropy(bits) </th>
<th> Checksum(bits)</th>
<th> Entropy + checksum(bits) </th>
<th> Mnemonic length(words)</th>
</tr>
</thead>
<tbody>
<tr>
<td>128</td>
<td>4</td>
<td>132</td>
<td>12</td>
</tr>
<tr>
<td>160</td>
<td>5</td>
<td>165</td>
<td>15</td>
</tr>
<tr>
<td>192</td>
<td>6</td>
<td>198</td>
<td>18</td>
</tr>
<tr>
<td>224</td>
<td>7</td>
<td>231</td>
<td>21</td>
</tr>
<tr>
<td>256</td>
<td>8</td>
<td>264</td>
<td>24</td>
</tr>
</tbody>
</table>


<p>目前最流行的实现还是跟我们上面的例子一样，选取128bits->12words 的Mnemonic code生成。</p>

<h3>从助记词生成种子</h3>

<p>现在我们已经从<code>ffffffffffffffffffffffffffffffff</code>随机熵得到了助记码<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>，现在需要从助记码再生成种子。</p>

<h4>PBKDF2函数</h4>

<p>这里我们需要先介绍一个函数:PBKDF2(Password-Based Key Derivation Function)，它是一个用来导出密钥的函数，常用于生成加密的密码。</p>

<p>它的基本原理是通过一个伪随机函数（例如HMAC函数），把明文和一个salt值作为输入参数，然后重复进行运算，并最终产生密钥。</p>

<p>如果重复的次数足够大，破解的成本就会变得很高。而salt值的添加也会增加“彩虹表”攻击的难度。</p>

<p>嗯，我们还要稍微解释一下HMAC的意义:</p>

<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>

<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p>

<p>采用不同的hash算法时如何混入salt，可能大家八仙过海各显神通；后来为了统一化，有人提出了Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把salt混入计算过程中。</p>

<p>简而言之，HMAC提供了标准的在HASH过程中混入salt的方法。 HMAC方法适用于任意HASH函数。</p>

<p>而比特币私钥生成过程中采用的PBKDF2算法，大量使用HMAC-SHA512算法，使用2048次 HASH来延伸助记符和salt参数，产生一个512位的值作为其最终输出。</p>

<p>这个512位的值就是种子。</p>

<h4>利用PBKDF2从助记词得到种子步骤</h4>

<p>1、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符(<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>)。</p>

<p>2、PBKDF2密钥延伸函数的第二个参数是salt。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成 (<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code> + <code>test</code>)。</p>

<p>3、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和salt参数，产生一个512位的值作为其最终输出。 这个512bits的值就是种子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; import hashlib
</span><span class='line'>&gt; import hmac
</span><span class='line'>&gt; from pbkdf2 import PBKDF2
</span><span class='line'>&gt; from binascii import hexlify
</span><span class='line'>&gt; PBKDF2_ROUNDS = 2048
</span><span class='line'>&gt; mnemonic = "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
</span><span class='line'>&gt; passphrase = "test"
</span><span class='line'>&gt; seed = PBKDF2(mnemonic, 'mnemonic' + passphrase, iterations=PBKDF2_ROUNDS, macmodule=hmac, digestmodule=hashlib.sha512).read(64)
</span><span class='line'>&gt; print(hexlify(seed))
</span><span class='line'>
</span><span class='line'>b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'</span></code></pre></td></tr></table></div></figure>


<h3>从种子中创造HD钱包</h3>

<p>我们已经得到了一个512bits的种子，我们把这个种子称之为<code>根种子</code>(root seed)。这个根种子是下面一切私钥产生的源泉。</p>

<p>让我们再回忆一下最开始的一张示意图：所有的私钥是成树状结构的。树的每一层都有无限分支，然后每一个分支都可以派生出下一层，这个结构该如何从根种子来构建呢？</p>

<p>这是一个精妙的设计。下面我们还是采用步步为营的方法来演示一遍:</p>

<h4>私有子密钥的衍生</h4>

<ul>
<li>1、 首先我们需要安装一个BIP32 Python解析库<code>pip install bip32utils</code>:</li>
</ul>


<p><a href="https://pypi.org/project/bip32utils/">https://pypi.org/project/bip32utils/</a></p>

<ul>
<li>2、 根种子输入到HMAC-SHA512中，得到一个512bits的输出:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; import binascii
</span><span class='line'>&gt; import hmac
</span><span class='line'>&gt; seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'
</span><span class='line'>&gt; entropy = binascii.hexlify(seed)
</span><span class='line'>&gt; I = hmac.new(b"Bitcoin seed", entropy, hashlib.sha512).digest()</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3、 这个512bits的<code>I</code>可以分为两个部分，左边的256bits用作Master Private Key，右边的256bits用作Master Chain Code。Master Private Key又可以推导出Master Public Key。整个表示如下:</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg3.jpg" alt="img" /></p>

<ul>
<li><p>4、 这样我们从一个512bits的输出里面分成了两个变量: Master Pirvate Key以及Master  Chain Code；下面分别说说他们的作用</p>

<ul>
<li><p>Master Private Key: 又被称作母私钥，很明显的，它可以衍生出公钥以及地址；但是我们的需求是生成多个公私钥对，所以我们又引入了一个索引号(32 bits)的概念，这样，一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，因为另一半是为特定类型的推导而保留的，我们将在稍后讨论。</p></li>
<li><p>Master Chain Code: 有了Master Private Key，可以在这一层生成2<sup>31</sup>个子私钥，但是这样无法得到我们想要的分层结构；于是就需要Master Chain Code的帮忙。这样上面的步骤我们需要三个输入：将Master Chain Code和Master Private Key以及索引号作为HMAC-SHA512的输入，又可以得到一个512bits的输出，左边的256bts就是我们需要的子私钥；重复这个过程，我们就得到了一个分层的私钥结构</p></li>
</ul>
</li>
<li><p>5、让我们总结一下这个过程:</p>

<ul>
<li>每次HMAC-SHA512，都得到一对Master Private Key以及Master Chain Code，再加上引入一个索引号，我们就能在这一层生成2<sup>31</sup>个私钥</li>
<li>用这一层的Master Chain Code和Master Chain Code以及选取一个固定的索引号作为HMAC-SHA512的输入，又可以得到下一层的Master Private Key以及Master Chain Code，</li>
<li>重复这个递归的过程就可以构造一棵私钥树状结构</li>
<li>这个递归构造的函数我们称之为CKD（child key derivation)函数</li>
</ul>
</li>
<li><p>6、 CKD (子密钥衍生函数): 这个函数有三个输入</p>

<ul>
<li>一个母私钥(Master Private Key 256bits)</li>
<li>一个链码(Master Chain code 256 bits)</li>
<li>一个索引号 (32 bits)</li>
</ul>
</li>
</ul>


<p>这三个输入可以得到一个512bits的输出，在得到一个私钥的同时，也可以作为一棵树的根节点，从而衍生出无数个子密钥。</p>

<p>叶子节点衍生出的子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。</p>

<h4>扩展密钥</h4>

<p>正如我们之前看到的，CKD函数可以被用来创造密钥树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key）。术语“extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p>

<p>引入我们之前的例子，这里我们第一层的扩展密钥为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; from bip32utils import BIP32Key
</span><span class='line'>&gt; from binascii import hexlify
</span><span class='line'>&gt; seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870d
</span><span class='line'>&gt; root = BIP32Key.fromEntropy(hexlify(seed))
</span><span class='line'>&gt; print(root.ExtendedKey())
</span><span class='line'>
</span><span class='line'>xprv9s21ZrQH143K35KaAEjp6RjB4LoeCR3prWBv6vmX7HuGnPFygragV39uDC24D3UZvMnWbhame5nykoXCcfy1Rbgg8uqSzmwoQgFEqt2bUNy</span></code></pre></td></tr></table></div></figure>


<p>第一层的扩展私钥也被称之为<code>BIP32 Root Key</code>；</p>

<p>得到了一个扩展私钥，就代表得到了树状结构中某个层级的完全控制权，这个扩展密钥可以创造出子密钥并且作为根节点能创造出密钥树结构中的整个分支。分享扩展密钥就可以访问整个分支。</p>

<h4>公共子密钥推导</h4>

<p>再审视一下前面的CKD函数，第一个输入是<code>一个母私钥(Master Private Key 256bits)</code>，这让我们思考，如果不是输入私钥，而是输入公钥会发生什么呢？</p>

<p>通过母公钥衍生子私钥为分层确定性钱包带来的一个很有用的特点，就是可以不通过私钥而直接从公共母密钥派生出公共子密钥的能力。</p>

<p>因此，扩展密钥可以在HD钱包结构的分支中，被用来衍生所有的公钥（且只有公钥）。</p>

<p>这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。</p>

<p>这种方案的常见应用是安装扩展公钥电商的网络服务器上。网络服务器可以使用这个公钥衍生函数去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公钥。</p>

<p>这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包），与此同时扩展公钥可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如 Trezor）签署交易。下图阐述了扩展母公钥来衍生子公钥的传递机制。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg4.jpg" alt="img" /></p>

<h4>硬化子密钥的衍生</h4>

<p>从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。</p>

<p>为了应对这种风险，HD钱包使用一种叫做硬化衍生(hardened derivation）的替代衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥，如图所示。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg5.jpg" alt="img" /></p>

<p>当强化私钥衍生函数被使用时，得到的子私钥以及链码与使用一般衍生函数所得到的结果完全不同。得到的密钥“分支”可以被用来生产不易被攻击的扩展公钥，因为它所含的链码不能被用来开发或者暴露任何私钥。强化衍生也因此被用在上一层级，使用扩展公钥的密钥树中创造“间隙”。</p>

<p>简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层级的子密钥最好使用强化衍生。</p>

<h4>正常衍生和强化衍生的索引号码</h4>

<p>还记得我们前面说:一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，另一半是做什么的呢？</p>

<p>用在衍生函数中的索引号码是32位的整数。为了区分密钥是从正常衍生函数中衍生出来还是从强化衍生函数中产出，这个索引号被分为两个范围。索引号在0和2<sup>31</sup>–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2<sup>31</sup>和2<sup>32</sup>– 1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生。因此，索引号小于2<sup>31</sup>就意味着子密钥是常规的，而大于或者等于2<sup>31</sup>的子密钥就是强化型的。</p>

<p>为了让索引号码更容易被阅读和展示，强化子密钥的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0&#8217;。第二个强化密钥依序有了索 引号0x80000001，且被显示为1&#8217;，以此类推。当你看到HD钱包索引号i&#8217;，这就意味着 2<sup>31</sup>+i。</p>

<h3>HD钱包密钥识别符</h3>

<p>我们看到，一个树状的私钥组织，命名就成了一个问题，如何快速的表示<code>这是一个由第三层的第n个扩展子私钥衍生的主密钥</code>呢？</p>

<p>答案是类似于文件路径的命名规则。</p>

<p>每个级别之间用斜杠（/）字符来表示。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。</p>

<p>密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。</p>

<h4>HD钱包树状结构的导航</h4>

<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及子分支的可能性是无穷的。</p>

<p>两个比特币改进建议（BIPs）提供了这个复杂问题的解决办法——通过创建几个HD钱包树的提议标准。BIP-43提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP-43，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i&#8217;/是 为了表明那个被索引号“i”定义的特殊为目地。</p>

<p>在BIP-43标准下，为了延长的那个特殊规范，BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m/44&#8217;/。 BIP-44指定了包含5个预定义树状层级的结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>m / purpose' / coin_type' / account' / change / address_index</span></code></pre></td></tr></table></div></figure>


<p>第一层的purpose总是被设定为44&#8217;。</p>

<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44&#8217;/0&#8217;、Bitcoin Testnet is m/44&#8217;/1&#8217;，以及 Litecoin is m/44&#8217;/2&#8217;, Ethereum 是 60&#8217;。</p>

<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性子账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m/44&#8217;/0&#8217;/0&#8217; 和 m/44&#8217;/0&#8217;/1&#8217;。每个账户都是它自己子树的根。</p>

<p>第四层级就是“change”。每一个HD钱包有两个子树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>

<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44&#8217;/0&#8217;/0&#8217;/0/2。</p>

<h2>几个BIP规范</h2>

<p>到这里为止，我们已经了解到了比特币HD钱包的绝大部分构造知识。如果能完全理解了上述内容，我们已经是<code>专家</code>了。让我们再简要回顾一下过程:</p>

<ol>
<li>生成一个随机序列作为原始熵</li>
<li>通过一系列变换操作得到了一个Mnemonic Code，这些操作需要大量的HASH过程，抵御了暴力碰撞。同时，生成的Mnemonic Code作为人类易读的助记词，可以轻易的抄写备份，导入导出，这个Mnemonic  Code代表着钱包的完全控制权</li>
<li>从Mnemonic得到了一个root seed，进而转化为 BIP32 Root Key，这可以构造一棵私钥树的根节点</li>
<li>从BIP32 Root Key开始，可以构造更多的公共子密钥，或者公共密钥；根据使用场景的不同，可以构造出完全控制的HD钱包，或者离线签署的只读钱包。</li>
</ol>


<p>这上面一系列的操作细节，被社区总结到了几个BIP规范当中。</p>

<h4>BIP32</h4>

<p>定义 Hierarchical Deterministic wallet (简称 &ldquo;HD Wallet&rdquo;)，是一个系统可以从单一个 seed 产生一树状结构储存多组 keypairs（私钥和公钥）。好处是可以方便的备份、转移到其他相容装置（因为都只需要 seed），以及分层的权限控制等。</p>

<h4>BIP39</h4>

<p>将 seed 用方便记忆和书写的单字表示。一般由 12 个单字组成，称为 mnemonic code(phrase)，中文称为助记词或助记码。例如：</p>

<p><code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code></p>

<h4>BIP43</h4>

<p>提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”</p>

<h4>BIP44</h4>

<p>基于 BIP32和BIP43 的定义，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支持多币种、多帐户等。各层定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>m / purpose' / coin_type' / account' / change / address_index</span></code></pre></td></tr></table></div></figure>


<p>其中的 purporse&#8217; 固定是 44&#8217;，代表使用 BIP44。而 coin_type&#8217; 用来表示不同币种，例如 Bitcoin 就是 0&#8217;，Ethereum 是 60&#8217;。</p>

<h4>BIP49，BIP84, BIP141</h4>

<p>加入隔离验证后的账户方案</p>

<h2>安全性</h2>

<p>关于安全性，reddit上面的<a href="https://www.reddit.com/r/Bitcoin/comments/6twuj1/are_12word_seeds_for_bitcoin_private_keys_secure/">一个帖子</a>做了比较全面的计算，可以参考。</p>

<h2>总结</h2>

<p>呼，漫长的一顿操作之后；我们终于拥有了一个完整的HD钱包，它有下面几个特性:</p>

<ol>
<li>只要记住seed，即12-24个单词，就可以在不同得系统中导入/导出这个钱包，并掌有完全的控制权，除了知道seed的人，世界上没有任何一个组织能操作这个账户</li>
<li>这个钱包拥有衍生无数个账户的能力，并通过树状层次组织</li>
<li>这棵树的任意一个节点都可以衍生出一棵子树，适用于大型组织的财务处理；比如国王拥有根seed的绝对掌控权，他分配了几个一级扩展私钥给总理大臣，而这几个一级扩展私钥又可以作为根节点衍生出二级扩展私钥分配给更多的人&hellip;..依次衍生下去无穷无尽，每一级的扩展私钥掌控者都拥有下级的资金调度权力，而同级别的私钥掌控者互不可见；</li>
<li>通过一个类似于文件系统命名的路径方式，扩展私钥的拥有者可以掌管任意一个子节点的账户，比如将来全家共享一个钱包，父母对子女的零花钱流水账有完全的掌控</li>
<li>可以构造出一个完全离线的只用来收款而不能付款的钱包账户，用于海量用户的电子商户系统</li>
<li>可以汇聚多个公私钥体系的电子货币；可以想象，未来所有的电子货币系统都聚集在一个钱包之中</li>
</ol>


<p>是不是非常神奇的感觉；呼呼，写到这里，我们已经将电子货币系统的钱包设计完全探究了一番；</p>

<p>其实这么长篇大论下来，我想要探讨的真正题目是比特币的交易构成，而不是什么钱包构造。</p>

<p>这个文章3年前就想写了，但是无穷尽的前置知识实在是让人望而却步；目前我们总算是对于比特币的账户系统有所了解了，反正我搞明白之后只能发出感叹：<code>设计的实在是太精巧了</code>；</p>

<p>但是比特币的交易构造之精巧，又胜过钱包十倍。走了这么远的路，还是那句话，还早得很呢。</p>

<p>那么，比特币的交易构造又是怎样的呢？我们下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-2]]></title>
    <link href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/"/>
    <updated>2018-11-02T13:31:50+08:00</updated>
    <id>https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2</id>
    <content type="html"><![CDATA[<p>好了，有了上一篇文章的基础，我们可以从零开始完全探究数字货币的地址生成、管理方法；下面的代码均使用Linux Bash shell和Python3来处理；另外需要安装<a href="https://github.com/richardkiss/pycoin">pycoin</a>这个库。</p>

<!-- more -->


<h2>生成私钥</h2>

<p>一般来说，私钥是个256bit的随机字符。为了演示方便，我们用一个人民大众喜闻乐见的地址生成为例子，私钥选取为 sha256(&ldquo;satoshi&rdquo;)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; printf "satoshi"|sha256sum
</span><span class='line'>da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f  -</span></code></pre></td></tr></table></div></figure>


<p>得到私钥为<code>da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</code></p>

<h2>用WIF (Wallet Import Format)表示私钥</h2>

<p>我们看到私钥本质上是256bit的数字，他可以用二进制表示，也可以用16进制字符串表示，也可以用Base58Check来表示；为了在不同的钱包中方便的导入导出私钥，也为了方便二维码的生成，比特币采用了名为<code>WIF</code>的表示方法，下面列一个表格来说明:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Prefix </th>
<th> Description </th>
<th> Private key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raw </td>
<td> None </td>
<td> 32 bytes binary </td>
<td>  11011010001010000&hellip;&hellip;&hellip;..</td>
</tr>
<tr>
<td>HEX </td>
<td> None </td>
<td> 64 hexadecimal digits </td>
<td> da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</td>
</tr>
<tr>
<td>WIF </td>
<td> 5 </td>
<td> Base58Check encoding </td>
<td> 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</td>
</tr>
<tr>
<td>WIF-compressed </td>
<td> K or L </td>
<td> Base58Check encoding </td>
<td> L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6</td>
</tr>
</tbody>
</table>


<p>得到WIF 代码示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def gen_pubk_from_privk(private_key, compressed=True):
</span><span class='line'>    # private_key = codecs.encode(os.urandom(32), 'hex').decode()
</span><span class='line'>    secret_exponent = int('0x' + private_key, 0)
</span><span class='line'>    print('WIF: ' + encoding.secret_exponent_to_wif(secret_exponent, compressed=compressed))
</span><span class='line'>    public_pair = ecdsa.public_pair_for_secret_exponent(ecdsa.secp256k1.generator_secp256k1, secret_exponent)
</span><span class='line'>    print('public pair:', public_pair)
</span><span class='line'>    return public_pair
</span></code></pre></td></tr></table></div></figure>


<p>WIF格式分为非压缩和压缩格式，压缩私钥其实是对非压缩私钥后缀追加了01之后的Base58Check编码，具体生成过程为:</p>

<ul>
<li>压缩私钥: 私钥前缀80+私钥本体+压缩私钥后缀01 + 校验</li>
<li>非压缩私钥: 私钥前缀80+私钥本体+校验</li>
</ul>


<p>和字面意思相相反的是，压缩私钥比非压缩私钥还长。为啥这么折腾呢？这个我们在公钥生成的部分说明。</p>

<h2>生成公钥</h2>

<p>我们之前的文章介绍了，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头。</p>

<p>下面是由前文中的私钥所生成的公钥，其坐标x和y如下:</p>

<ul>
<li><p>public pair:</p>

<ul>
<li>x = 89077434373547985693783396961781741114890330080946587550950125758215996319671</li>
<li>y = 114001858762817543140175961139571810325965930451644331549950109688554928624341</li>
</ul>
</li>
</ul>


<p>加上前缀04，完整的公钥为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>K = 0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341</span></code></pre></td></tr></table></div></figure>


<h4>为什么要区分压缩格式和非压缩格式</h4>

<p>这是一个历史问题，初版比特币运行时，中本聪没有考虑到一个问题:</p>

<p>一个公钥是一个椭圆曲线上的点(x,y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程 <code>y^2 % p = (x^3 + 7) % p</code>得到y坐 标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256 bits。如果每笔交易所 需要的字节数减少了近一半，随着时间推移，节省的数据传输和存储空间还是很客观的。</p>

<p>所以后来开发团队推出了压缩公钥，为了跟之前老版本的非压缩公钥相区分，就加上了02和03作为前缀。</p>

<p>那么为什么要加两个前缀(02,03)呢？</p>

<p>因为椭圆曲线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在 x坐标轴的上面或者下面。椭圆曲线图中曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</p>

<p>总结出来，一个公钥的表现形式可以又两种:</p>

<ol>
<li>04开头的非压缩公钥: (130位十六进制 2+64+64)</li>
<li>02或03开头的压缩公钥:（66位十六进制 2+64）</li>
</ol>


<p>这样继续推导，两种表现形式可以推导出两个地址，也就是手握一个私钥，可以推导出两个合法的比特币地址。</p>

<p>这样又间接解释了为什么会有压缩私钥和非压缩私钥两种表现：</p>

<ul>
<li>当中本聪实现第一版比特币客户端钱包的时候，没有考虑到公钥可以压缩，所以采用了最原始直接的办法存储公钥和私钥</li>
<li>后来人们发现公钥可以简化存储来节省一部分空间，于是加入了压缩公钥格式，为了跟之前的非压缩公钥区分，引入了前缀</li>
<li>同样，使用压缩公钥格式的钱包导入导出私钥时，为了区分，也必须为私钥标明它对应的公钥是否压缩格式，所以也为私钥的表示引入了后缀</li>
<li>压缩私钥的意思是，由这个私钥导出的公钥表示方法是压缩的，私钥本身还需要引入一个01作为后缀，长度反而多了一个字节</li>
</ul>


<h2>从公钥到比特币地址</h2>

<p>得出公钥之后，地址的生成还要经过三重变换， 公钥为K，变换过程如下:</p>

<ol>
<li>首先计算 A = SHA256(K)</li>
<li>计算 B = RIPEMD160(A)</li>
<li>Addr = Base58Check（prefix + B）</li>
</ol>


<h4>为什么要有RIPEMD160(SHA256(K)) 的过程</h4>

<p>因为中本聪设计之初充分考虑到了安全性方面的问题，一笔交易广播后，并不是直接把公钥K暴漏在外，如果你不花费这个UTXO，暴漏的只有<code>RIPEMD160(SHA256(K))</code>这个值。假如将来有一种计算机的计算能力得到指数级别的提升，有一定可能暴力破解椭圆曲线算法。解决方案就是引入<code>RIPEMD160(SHA256(K))</code>的过程，这样要破解一个未花费的UTXO，需要逆向RIPEMD160，SHA256，secp256k1三种不同的算法，即使将来量子计算发展到实用阶段，也很难做到吧。</p>

<p>但是根据比特币交易的设计，一个地址重复使用就会暴露公钥K，所以我们推荐的安全做法就是一笔UTXO花费后就更换地址。这也是所有安全钱包的默认实现方法。</p>

<p>这个设计的唯一的瑕疵，在我看来，就是RIPEMD160将公钥的碰撞空间减小了，由 2<sup>256</sup> 减小到了 2<sup>160</sup>，当然 2<sup>160</sup> 的碰撞空间对于现有计算能力也是个天文数字，我想中本聪没有选择SHA3等算法的原因，应该是充分考虑了散列算法的复杂度和差异度，最后选择的RIPEMD160吧。</p>

<h4>Base58Check编码</h4>

<p>WIF格式和比特币地址都是用Base58Check编码表示的，Base58是Base64基础上发展来的，它具有以下功能:</p>

<ul>
<li>一个任意大小的payload。</li>
<li>一组58个字母数字符号，由易于区分的大小写字母组成(不使用0OIl)</li>
<li>一个字节的版本/应用程序信息。比特币地址为这个字节使用0x00</li>
<li>四个字节（32位）基于SHA256的错误检查代码。此代码可用于自动检测并可能纠正排版错误。</li>
<li>保留数据中零开头的额外步骤</li>
</ul>


<p>创建过程:</p>

<ol>
<li><p>获取版本字节和payload字节，并将它们连接在一起（按字节顺序）。</p></li>
<li><p>取SHA256(SHA256(步骤1的结果))的前四个字节</p></li>
<li><p>将步骤1的结果和步骤2的结果连在一起（按字节顺序）。</p></li>
<li><p>处理步骤3的结果 &ndash; 一系列字节 &ndash; 作为单个大端序号，使用正常的数学步骤（bignumber division）和下面描述的base-58字母表转换为base-58。结果应该被标准化为没有任何前导零（字符&#8217;1&#8217;）的base-58。</p></li>
<li><p>在base58中，值为零的前导字符&#8217;1&#8217;被保留用于表示整个前导零字节，就像它处于前导位置时一样，没有值作为base-58符号。必要时可以有一个或多个前导&#8217;1&#8217;来表示一个或多个前导零字节。计算步骤3结果中的前导零字节数（对于旧的比特币地址，至少有一个用于版本/应用程序字节;对于新地址，将永远不会有）。每个前导零字节在最终结果中应由其自己的字符&#8217;1&#8217;表示。</p></li>
<li><p>将步骤5中的1与步骤4 的结果连接起来。这是Base58Check的结果。</p></li>
</ol>


<p>最后综合起来，从公钥K到比特币地址完整的示意图如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181102/bg1.jpg" alt="img" /></p>

<p><code>satoshi</code>作为seed计算出私钥，进而计算出公钥K之后，最终进一步生成地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def genaddress_from_pubk(compressed=True)
</span><span class='line'>    # 首先计算 RIPEMD160(SHA256(K))
</span><span class='line'>    ripemd160 = encoding.public_pair_to_hash160_sec(public_pair, compressed=compressed)
</span><span class='line'>    # 再用Base58Check计算最终地址
</span><span class='line'>    addr = encoding.hash160_sec_to_bitcoin_address(ripemd160)
</span><span class='line'>    return addr</span></code></pre></td></tr></table></div></figure>


<p>因为公钥存在压缩形式和非压缩两种形式，所以完整的结果是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>seed: satoshi
</span><span class='line'>sha256 private key: da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f
</span><span class='line'>
</span><span class='line'>compress address
</span><span class='line'>WIF: L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
</span><span class='line'>hash160: 0a8ba9e453383d4561cbcdda36e5789c2870dd41
</span><span class='line'>Bitcoin address:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V
</span><span class='line'>
</span><span class='line'>uncompress address
</span><span class='line'>WIF: 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
</span><span class='line'>hash160: 650d0497e014e60d4680fce6997d405de264f042
</span><span class='line'>Bitcoin address:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</span></code></pre></td></tr></table></div></figure>


<p><code>satoshi</code>作为seed生成了两个地址:</p>

<p><code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>，这都是两个正在使用的地址哦，到今天为止还有热心人源源不断的为<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>转账一些零钱作为中本聪的纪念。你可以将WIF导入钱包，然后运行一个全节点，在bitcoin.conf文件中加入<code>walletnotify</code>这个选项，关联一个脚本，当收到比特币时就自动转账到自己的地址，参与这两个地址的抽奖哦。</p>

<h2>一些Base58Check版本前缀和编码后的结果</h2>

<p>看到这里，我们发现Base58Check 编码的过程中，最后一步会引入一个前缀。而在比特币中，除了WIF私钥和地址，大多数需要向用户展示的数据都使用Base58Check编码，理所当然的，引入了不同的前缀来区分不同的信息，下面展示了一些版本前缀和他们对应的Base58格式:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Version prefix </th>
<th> Base58 result prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Address </td>
<td> 0x00 </td>
<td> 1</td>
</tr>
<tr>
<td>Pay to Script Hash Address </td>
<td> 0x05 </td>
<td> 3</td>
</tr>
<tr>
<td>Bitcoin Testnet Address </td>
<td> 0x5F </td>
<td> m or n</td>
</tr>
<tr>
<td>Private Key WIF </td>
<td> 0x80 </td>
<td> 5, K or L</td>
</tr>
<tr>
<td>BIP-38 Encrypted Private Key </td>
<td> 0x0142 </td>
<td> 6P</td>
</tr>
<tr>
<td>BIP-32 Encrypted public Key </td>
<td> 0x0488B21E </td>
<td> xpub</td>
</tr>
</tbody>
</table>


<p>我们最常见的一些地址格式:</p>

<ul>
<li>一个是以<code>1</code>打头，这是用途最广泛的交易，用作Pay to public key hash，简称P2PKH交易；它表示的是最简单的、用一对私钥和公钥控制的钱包。例如上面的<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code></li>
<li>还有一种是<code>3</code>打头，用作Pay to Script Hash，简称P2SH。多重签名、SegWit以及一些智能合约（没错，比特币也支持简单的智能合约）通常都采用这种“3”型地址.例如<code>331jjM5a3HgiDqMuSxeiwTUQFCkM71c5VW</code></li>
<li>以<code>2</code>、<code>m</code>或<code>n</code>开头的地址非常罕见，仅仅被用于比特币的测试网络。</li>
<li>首字符是<code>5</code>、<code>K</code>或<code>L</code>的不是地址，而是WIF（Wallet Import Format）格式的私钥，务必要妥善保管，不可泄漏。</li>
</ul>


<p>除了我们已经提到的WIF和Bitcoin Address，我们还发现了奇怪的BIP-38和BIP-32，这个需要到解释比特币分层子钱包时候来讲解。</p>

<h2>Segwit</h2>

<p>比特币的地址规范定义之后，平稳运行了很长时间；直到2017-08-24，<a href="https://www.reddit.com/r/Bitcoin/comments/6vnqi2/btccom_mines_the_481823rd_block_segwit_is_on_stage/">第一个Segwit block</a>被挖出；事情有了新变化。</p>

<p>比特币进行Segwit升级之后，地址需要做区分，因为Segwit也可以归类为简单的合约交易，所以在早期钱包还没有足够兼容的时候，Segwit地址都用<code>3</code>打头的合约地址。</p>

<p>但是Segwit交易其实是很特殊的，另外后来有了BCH分叉，越来越多的人闹不清其分叉地址搞丢过一些BCH币；后面为了解决Segwit交易的标识，大部分钱包逐渐实现了<a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173规范</a>；即我们今天可以见到的称之为<code>bech32</code>格式的地址。</p>

<p>这类地址统一以<code>bc</code>开头，后面接着一个版本号，目前只用了<code>1</code>，所以我们可以简单认为这类地址统一以<code>bc1</code>开头；比如:<code>bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj</code>；</p>

<p>bech32地址使用的字符比当前的地址格式要少， 由42个符号组成，小写字母和大写字母之间不再有区别。</p>

<p>这类地址在Bitcoin Core 0.16版本之后的钱包才支持，Bech32地址本身就与SegWit兼容。这意味着交易不需要额外的空间就能将SegWit放入P2SH地址，所以交易费用比较低，Segwit交易目前也逐渐占到了主网交易量的一半；但直到现在，还有很多交易所的BTC提现不支持这类地址；</p>

<p>详细的计算过程其实和base58大同小异，我们就不啰嗦了，可以自己看规范，或示例代码：</p>

<p><a href="https://github.com/sipa/bech32/blob/master/ref/python/segwit_addr.py">https://github.com/sipa/bech32/blob/master/ref/python/segwit_addr.py</a></p>

<p>再小小总结一下，目前为止，我们最常见的有三类地址:</p>

<ol>
<li><code>1</code>开头，最常见</li>
<li><code>3</code>开头，合约、多重签名、Segwit交易</li>
<li><code>bc1</code>开头，segwit交易</li>
</ol>


<h2>Brain Wallet</h2>

<p>好啦，我们上面已经完整的再现了由一个 seed单词 <code>satoshi</code>，导出两个比特币地址的过程；你只要记好<code>satoshi</code>这个单词，就可以在世界上的任何地方，任何时间，掌管发送给<code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>这两个地址的比特币了。</p>

<p>你不需要银行账号，不需要密保卡，只需要有个可以联网的地方，就能秘密发送交易啦。将来有了免费的卫星网络的话，我想你都不用登陆互联网，可能在家里屋顶上架个锅，淘宝买些零件天线DIY一个设备，要转帐的时候，只要输入<code>satoshi</code>就可以秘密完成数亿美元的汇款，而且丝毫不用担心这个账户被政府查封，世界上也只有你一个人能动用这个账户，真是完美的洗钱逃汇工具！也难怪有人说，比特币是人类历史上第一次用技术手段保证了财产的完全私有权。</p>

<p>这个<code>satoshi</code>的seed，就是所谓脑钱包的口令，相对于天书一般的256 bits私钥无疑更好记忆，早期这样的工具非常受欢迎，到现在为止你也可以到这个<a href="https://brainwalletx.github.io/">在线工具</a> 去重复我们以上推导的所有过程。</p>

<p>但是这个方法有个致命的弱点，他的安全性完全取决于seed这个单词的复杂度，像<code>satoshi</code>这样的seed，就像<code>123456</code>的密码一样，不用说大家都知道安全度为0啊。</p>

<p>而且你自以为选取生日啊、姓名缩写啊、恋人海誓山盟的话语啊，这些东西作为seed，其实也是非常脆弱的。总有人孜孜不倦的遍历所有可能的seed。这在后期导致了非常多的hack事件。</p>

<p>截至2018-12，我检索区块链，统计公开的比特币地址超过了4亿(不包括bech32有446876234)个，如果有万分之一的地址是由脑钱包生成的话，不安全的地址也超过了4w个，所以后来脑钱包这种方式就不被推荐了。</p>

<p>下面可以列举一些已经公开的seed，这都是我用一些公开语料库随意碰撞出来的，你就知道这种方法的危险性啦：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FINAL_CRACK_ADDRESS: hash160:sha256:seed:address:wif-priv
</span><span class='line'>FINAL_CRACK_ADDRESS:0a8ba9e453383d4561cbcdda36e5789c2870dd41:c:sha256:satoshi:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V:L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
</span><span class='line'>FINAL_CRACK_ADDRESS:650d0497e014e60d4680fce6997d405de264f042:u:sha256:satoshi:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE:5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
</span><span class='line'>FINAL_CRACK_ADDRESS:c71e3a0989754d4ffae45a1c6ef8e348539cd83c:u:sha256:satoshinakamoto:1K9qgN3H2wB2v3LwJEBDbRRJ3znHXEQP4Y:5HqE1vZMMLc7jZRF5wZb79QexyCguNeNdaHLdKTGndvLBrCHD31
</span><span class='line'>FINAL_CRACK_ADDRESS:ec42ad7fd54f931274b83f6137379206e458b106:u:sha256:1satoshi:1NYEM85RpgkSofLqDfwjb21o3MD4ibSo49:5JSGPQ2Jw1P5cVi2L8LeuWnMF5H8rLGrPPgVM2XE1cahG1BQDzY
</span><span class='line'>FINAL_CRACK_ADDRESS:fd8d22e02b3a41bc38f69516c43f7ebd6268e16b:u:sha256:satoshi nakamoto:1Q7f2rL2irjpvsKVys5W2cmKJYss82rNCy:5K7EWwEuJu9wPi4q7HmWQ7xgv8GxZ2KqkFbjYMGvTCXmY22oCbr
</span><span class='line'>FINAL_CRACK_ADDRESS:0000d85a71f305a1c907cdc7437c43b2eecc35e5:u:sha256:CHARINA143:11121ioKu4MCB1LLzPF98AVtzFsEg7UYKm:5JhayTrDhzDHqCg2v16Y2gZWi4kWF6BFoZR3MyaaxWtyKHzKJ8d
</span><span class='line'>FINAL_CRACK_ADDRESS:0002439f087ffefb973c5b9bbd52f509984d3cbe:c:sha256:purple99:113iKJcZeRxEYRVcWNgVxmjodPAisDZ45:KxFLoyseSyVtKGXQNkYBajT8EqviQSuH64Y6GE1g6KXuvcFaSrqc
</span><span class='line'>FINAL_CRACK_ADDRESS:00027a0ef2b9295011b10b089c8caf2e69f6b6f7:u:sha256:bridesmaid:113y6FCRm2WHh5Aru2R7ot37wkNDtxqf3:5JsYc8oXiHBJm9rzRPJHaCSYBBx7KCTx5L81rqRMZBArsdZTsan
</span><span class='line'>FINAL_CRACK_ADDRESS:00030fa763130b5310afe68b12204009e60e935c:u:sha256:masturbating:114fh9qiRhubJJDV5rCthFxmGyYeLQ2B6:5J8TgeF9jU3BPRrsCD75Ks4a6aWxgzLKENDSbsLufDTWq7evCQa
</span><span class='line'>FINAL_CRACK_ADDRESS:0005736b486f87e5823909a89eb48dda185d3956:u:sha256:nitro:117XjTn3UdBNjVo3KsB17WRFDDmcW2pPa:5JkUWsPzNEZEvMFwWQjoXCeem5LL6LDcC7K6H1LWiwXFAA9LFo1
</span><span class='line'>FINAL_CRACK_ADDRESS:00080beae5c3a433fbae8ff0b69e705ac3ce5464:u:sha256:resultantly:11Ae5tbiSZ7QJWh4okWJhDKuPfAvk3a13:5KftjbtsSmhy5Y42AYpfEAm4U4vQKP9VhjbS6xtFqBDhUfAGaFj
</span><span class='line'>FINAL_CRACK_ADDRESS:00083c18c738e883ebc1b5ca270569ee8f9f790e:u:sha256:suggestively:11AsAKWdMZj5ScSYRoAQ8xG4J7Y6s7cW9:5JvrusiSgSmCTV7x7f5vgdWUMLjwk153j9UXmNHvRAJ8m7rtsJD
</span><span class='line'>FINAL_CRACK_ADDRESS:000e4d1774a3fc0251e9e6caf0a8617639e80093:u:sha256:dezoxiribonukleinsav:11J8fK9qhgxdQ96ZvvXExkfFvQSPQiPKN:5KSkRxaAbk94wzzzynDNj2bzRFmJZXCrhtYj3iGU9JjUxnRXTYM
</span><span class='line'>FINAL_CRACK_ADDRESS:00135d1c8f99cc657ad1f246bc5051ad03f95d32:u:sha256:Mussolini:11QCR3sk9r4jeyMqCKGEYabGTfjzhgGdZ:5K2x6UanMSevNX7f19oB4to46C3zXoGTUBGVqv8WNtCRwJNGBGC
</span><span class='line'>FINAL_CRACK_ADDRESS:001ed6fae0af0b37126004029defcc4521b300dd:u:sha256:meagerness:11dwnVzCyGoMZcGDndQteWgR9b7FKsJMu:5JKVJhbZWXmHxj2MuttZCDaFk7TC9KBVYjbPRjztP63mmAUV6Vm
</span><span class='line'>FINAL_CRACK_ADDRESS:002607c11a2311825a087f37c95d7816e0491a9d:u:sha256:vertebrate:11nZPfxYPeDm4d4fd93BaFa1BezFRTP6F:5HsBbgzEXZEaeLRCZHs66ho2ekpFEqeAJyyBPe8YyMkCqCHWv6j
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>不过我们现在已经掌握到了比特币地址的生成原理，所以如何提高安全性就不用我再啰嗦了，相信你心中已有答案。</p>

<h2>那些山寨币们</h2>

<p>比特币项目是2009-01-03正式开始运行的，之后简单的复制一下比特币的代码，稍作修改就推出的山寨币们数不胜数；这些山寨币第一个要修改的，就是地址格式，以免和比特币地址混淆；</p>

<p>怎么修改呢？注意到前面Base58Check Encode的最后一步了吗？那个时候我们需要引入一个前缀作为地址的区分；得益于比特币这种前瞻性的设计，山寨币们只要改动一下这个前缀就可以了，下面列举一下我所知道的山寨币的实现：</p>

<p>引用自:
<a href="https://github.com/walletgeneratornet/WalletGenerator.net">https://github.com/walletgeneratornet/WalletGenerator.net</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>name, networkVersion, privateKeyPrefix, WIF_Start, CWIF_Start
</span><span class='line'>"2GIVE",               0x27, 0xa7, "6",    "R"
</span><span class='line'>"42coin",              0x08, 0x88, "5",    "M"
</span><span class='line'>"Acoin",               0x17, 0xe6, "8",    "b"
</span><span class='line'>"AGAcoin",             0x53, 0xd3, "8",    "Y"
</span><span class='line'>"Alphacoin",           0x52, 0xd2, "8",    "Y"
</span><span class='line'>"Alqo",                0x17, 0xc1, "7",    "V"
</span><span class='line'>"Animecoin",           0x17, 0x97, "6",    "P"
</span><span class='line'>"Anoncoin",            0x17, 0x97, "6",    "P"
</span><span class='line'>"Apexcoin",            0x17, 0x97, "6",    "P"
</span><span class='line'>"Auroracoin",          0x17, 0x97, "6",    "T"
</span><span class='line'>"Aquariuscoin",        0x17, 0x97, "6",    "P"
</span><span class='line'>"Axe",                 0x4B, 0xCB, "7",    "X"
</span><span class='line'>"BBQcoin",             0x55, 0xd5, "6",    "T"
</span><span class='line'>"Biblepay",            0x19, 0xb6, "7",    "[TU]"
</span><span class='line'>"Bitcoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"BitcoinCash",         0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"BitcoinDark",         0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Bitcore",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"BitcoinGold",         0x26, 0x80, "5",    "[LK]"
</span><span class='line'>"Bitconnect",          0x12, 0x92, "5",    "N"
</span><span class='line'>"Birdcoin",            0x2f, 0xaf, "6",    "[ST]"
</span><span class='line'>"BitSynq",             0x3f, 0xbf, "7",    "V"
</span><span class='line'>"BitZeny",             0x51, 0x80, "5",    "[LK]"
</span><span class='line'>"Blackcoin",           0x19, 0x99, "6",    "P"
</span><span class='line'>"BlackJack",           0x15, 0x95, "[56]", "P"
</span><span class='line'>"BlockNet",            0x1a, 0x9a, "6",    "P"
</span><span class='line'>"BolivarCoin",         0x55, 0xd5, "8",    "Y"
</span><span class='line'>"BoxyCoin",            0x4b, 0xcb, "7",    "X"
</span><span class='line'>"BunnyCoin",           0x1a, 0x9a, "6",    "P"
</span><span class='line'>"Cagecoin",            0x1f, 0x9f, "6",    "Q"
</span><span class='line'>"CampusCoin",          0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CanadaeCoin",         0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CannabisCoin",        0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Capricoin",           0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CassubianDetk",       0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"CashCoin",            0x22, 0xa2, "6",    "[QR]"
</span><span class='line'>"Catcoin",             0x15, 0x95, "[56]", "P"
</span><span class='line'>"ChainCoin",           0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"ColossusCoinXT",      0x1e, 0xd4, "5",    "[LK]"
</span><span class='line'>"Condensate",          0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Copico",              0x1c, 0x90, "5",    "N"
</span><span class='line'>"CopperCoin",          0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Corgicoin",           0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CryptoBullion",       0x0b, 0x8b, "5",    "M"
</span><span class='line'>"CryptoClub",          0x23, 0xa3, "6",    "R"
</span><span class='line'>"Cryptoescudo",        0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Cryptonite",          0x1c, 0x80, "5",    "[LK]"
</span><span class='line'>"CryptoWisdomCoin",    0x49, 0x87, "5",    "[LM]"
</span><span class='line'>"C2coin",              0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Dash",                0x4c, 0xcc, "7",    "X"
</span><span class='line'>"DeafDollars",         0x30, 0xb0, "6",    "T"
</span><span class='line'>"DeepOnion",           0x1f, 0x9f, "6",    "Q"
</span><span class='line'>"Deutsche eMark",      0x35, 0xb5, "7",    "T"
</span><span class='line'>"Devcoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"DigiByte",            0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"Digitalcoin",         0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"Dimecoin",            0x0f, 0x8f, "5",    "N"
</span><span class='line'>"DNotes",              0x1f, 0x9f, "6",    "Q"
</span><span class='line'>"Dogecoin",            0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"DogecoinDark",        0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"eGulden",             0x30, 0xb0, "6",    "T"
</span><span class='line'>"eKrona",              0x2d, 0xad, "6",    "S"
</span><span class='line'>"ELECTRA",             0x21, 0xa1, "6",    "Q"
</span><span class='line'>"Ember",               0x5c, 0x32, "2",    "8"
</span><span class='line'>"Emerald",             0x22, 0xa2, "6",    "[QR]"
</span><span class='line'>"Emercoin",            0x21, 0x80, "5",    "[LK]"
</span><span class='line'>"EnergyCoin",          0x5c, 0xdc, "8",    "Z"
</span><span class='line'>"Espers",              0x21, 0x90, "5",    "N"
</span><span class='line'>"Fastcoin",            0x60, 0xe0, "8",    "a"
</span><span class='line'>"Feathercoin",         0x0e, 0x8e, "5",    "N"
</span><span class='line'>"Fedoracoin",          0x21, 0x80, "5",    "[KL]"
</span><span class='line'>"Fibre",               0x23, 0xa3, "6",    "R"
</span><span class='line'>"Florincoin",          0x23, 0xb0, "6",    "T"
</span><span class='line'>"Flurbo",              0x23, 0x30, "6",    "8"
</span><span class='line'>"Fluttercoin",         0x23, 0xa3, "6",    "R"
</span><span class='line'>"FrazCoin",            0x23, 0xA3, "6",    "R"
</span><span class='line'>"Freicoin",            0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"FUDcoin",             0x23, 0xa3, "6",    "R"
</span><span class='line'>"Fuelcoin",            0x24, 0x80, "5",    "[KL]"
</span><span class='line'>"Fujicoin",            0x24, 0xa4, "6",    "R"
</span><span class='line'>"GabenCoin",           0x10, 0x90, "5",    "N"
</span><span class='line'>"Garlicoin",           0x26, 0xb0, "6",    "T"
</span><span class='line'>"GlobalBoost",         0x26, 0xa6, "6",    "R"
</span><span class='line'>"Goodcoin",            0x26, 0xa6, "6",    "R"
</span><span class='line'>"GridcoinResearch",    0x3e, 0xbe, "7",    "V"
</span><span class='line'>"Gulden",              0x26, 0xa6, "6",    "R"
</span><span class='line'>"Guncoin",             0x27, 0xa7, "6",    "R"
</span><span class='line'>"HamRadioCoin",        0x00, 0x80, "5",    "LK"
</span><span class='line'>"HFRcoin",             0x10, 0x90, "5",    "N"
</span><span class='line'>"HOdlcoin",            0x28, 0xa8, "5",    "[LK]"
</span><span class='line'>"HTMLCoin",            0x29, 0xa9, "6",    "S"
</span><span class='line'>"HyperStake",          0x75, 0xf5, "9",    "d"
</span><span class='line'>"ImperiumCoin",        0x30, 0xb0, "6",    "T"
</span><span class='line'>"IncaKoin",            0x35, 0xb5, "7",    "T"
</span><span class='line'>"IncognitoCoin",       0x00, 0x80, "5",    "LK"
</span><span class='line'>"Influxcoin",          0x66, 0xe6, "8",    "b"
</span><span class='line'>"Innox",               0x4b, 0xcb, "7",    "X"
</span><span class='line'>"IridiumCoin",         0x30, 0xb0, "6",    "T"
</span><span class='line'>"iCash",               0x66, 0xcc, "7",    "X"
</span><span class='line'>"iXcoin",              0x8a, 0x80, "5",    "[LK]"
</span><span class='line'>"Judgecoin",           0x2b, 0xab, "6",    "S"
</span><span class='line'>"Jumbucks",            0x2b, 0xab, "6",    "S"
</span><span class='line'>"KHcoin",              0x30, 0xb0, "6",    "T"
</span><span class='line'>"KittehCoin",          0x2d, 0xad, "6",    "S"
</span><span class='line'>"Lanacoin",            0x30, 0xb0, "6",    "T"
</span><span class='line'>"Latium",              0x17, 0x80, "5",    "[LK]"
</span><span class='line'>"LBRY Credits",        0x55, 0x80, "5",    "[LK]"
</span><span class='line'>"Litecoin",            0x30, 0xb0, "6",    "T"
</span><span class='line'>"LiteDoge",            0x5a, 0xab, "6",    "S"
</span><span class='line'>"LoMoCoin",            0x30, 0xb0, "6",    "T"
</span><span class='line'>"MadbyteCoin",         0x32, 0x6e, "4",    "H"
</span><span class='line'>"MagicInternetMoney",  0x30, 0xb0, "6",    "T"
</span><span class='line'>"Magicoin",            0x14, 0x94, "5",    "[NP]"
</span><span class='line'>"Marscoin",            0x32, 0xb2, "6",    "T"
</span><span class='line'>"MarteXcoin",          0x32, 0xb2, "6",    "T"
</span><span class='line'>"MasterDoge",          0x33, 0x8b, "5",    "M"
</span><span class='line'>"Mazacoin",            0x32, 0xe0, "8",    "a"
</span><span class='line'>"Megacoin",            0x32, 0xb2, "6",    "T"
</span><span class='line'>"MintCoin",            0x33, 0xb3, "[67]", "T"
</span><span class='line'>"MobiusCoin",          0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"MonetaryUnit",        0x10, 0x7e, "5",    "K"
</span><span class='line'>"Monocle",             0x32, 0xb2, "6",    "T"
</span><span class='line'>"MoonCoin",            0x03, 0x83, "5",    "L"
</span><span class='line'>"Myriadcoin",          0x32, 0xb2, "6",    "T"
</span><span class='line'>"NameCoin",            0x34, 0x80, "5",    "[LK]"
</span><span class='line'>"Navcoin",             0x35, 0x96, "6",    "P"
</span><span class='line'>"NeedleCoin",          0x35, 0xb5, "7",    "T"
</span><span class='line'>"NEETCOIN",            0x35, 0xb5, "7",    "T"
</span><span class='line'>"NYC",                 0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Neoscoin",            0x35, 0xb1, "6",    "T"
</span><span class='line'>"Nevacoin",            0x35, 0xb1, "6",    "T"
</span><span class='line'>"Novacoin",            0x08, 0x88, "5",    "M"
</span><span class='line'>"Nubits",              0x19, 0xbf, "7",    "V"
</span><span class='line'>"Nyancoin",            0x2d, 0xad, "6",    "S"
</span><span class='line'>"Ocupy",               0x73, 0xf3, "9",    "[cd]"
</span><span class='line'>"Omnicoin",            0x73, 0xf3, "9",    "[cd]"
</span><span class='line'>"Onyxcoin",            0x73, 0xf3, "9",    "[cd]"
</span><span class='line'>"PacCoin",             0x18, 0x98, "6",    "P"
</span><span class='line'>"Particl",             0x38, 0x6c, "4",    "[HG]"
</span><span class='line'>"Paycoin",             0x37, 0xb7, "7",    "U"
</span><span class='line'>"Pandacoin",           0x37, 0xb7, "7",    "U"
</span><span class='line'>"ParkByte",            0x37, 0xb7, "7",    "U"
</span><span class='line'>"Peercoin",            0x37, 0xb7, "7",    "U"
</span><span class='line'>"Pesetacoin",          0x2f, 0xaf, "6",    "[ST]"
</span><span class='line'>"PHCoin",              0x37, 0xb7, "7",    "U"
</span><span class='line'>"PhoenixCoin",         0x38, 0xb8, "7",    "U"
</span><span class='line'>"PiggyCoin",           0x76, 0xf6, "9",    "d"
</span><span class='line'>"Pinkcoin",            0x3,  0x83, "[RQP]","L"
</span><span class='line'>"PIVX",                0x1e, 0xd4, "8",    "Y"
</span><span class='line'>"Peercoin",            0x37, 0xb7, "7",    "U"
</span><span class='line'>"Potcoin",             0x37, 0xb7, "7",    "U"
</span><span class='line'>"Primecoin",           0x17, 0x97, "6",    "P"
</span><span class='line'>"ProsperCoinClassic",  0x3a, 0xba, "7",    "Q"
</span><span class='line'>"Quark",               0x3a, 0xba, "7",    "U"
</span><span class='line'>"Qubitcoin",           0x26, 0xe0, "8",    "a"
</span><span class='line'>"Reddcoin",            0x3d, 0xbd, "7",    "[UV]"
</span><span class='line'>"Riecoin",             0x3c, 0x80, "5",    "[LK]"
</span><span class='line'>"Rimbit",              0x3c, 0xbc, "7",    "U"
</span><span class='line'>"ROIcoin",             0x3c, 0x80, "5",    "[LK]"
</span><span class='line'>"Rubycoin",            0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Rupaya",              0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Sambacoin",           0x3e, 0xbe, "7",    "V"
</span><span class='line'>"SecKCoin",            0x3f, 0xbf, "7",    "V"
</span><span class='line'>"SibCoin",             0x3f, 0x80, "5",    "[LK]"
</span><span class='line'>"SixEleven",           0x34, 0x80, "5",    "[LK]"
</span><span class='line'>"SmileyCoin",          0x19, 0x99, "6",    "P"
</span><span class='line'>"SongCoin",            0x3f, 0xbf, "7",    "V"
</span><span class='line'>"SpreadCoin",          0x3f, 0xbf, "7",    "V"
</span><span class='line'>"StealthCoin",         0x3e, 0xbe, "7",    "V"
</span><span class='line'>"Stratis",             0x3f, 0xbf, "7",    "V"
</span><span class='line'>"SwagBucks",           0x3f, 0x99, "6",    "P"
</span><span class='line'>"Syscoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"Tajcoin",             0x41, 0x6f, "6",    "H"
</span><span class='line'>"Terracoin",           0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"Titcoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"TittieCoin",          0x41, 0xc1, "7",    "V"
</span><span class='line'>"Topcoin",             0x42, 0xc2, "7",    "V"
</span><span class='line'>"TransferCoin",        0x42, 0x99, "6",    "P"
</span><span class='line'>"TreasureHuntCoin",    0x32, 0xb2, "6",    "T"
</span><span class='line'>"TrezarCoin",          0x42, 0xC2, "7",    "V"
</span><span class='line'>"Unobtanium",          0x82, 0xe0, "8",    "a"
</span><span class='line'>"USDe",                0x26, 0xa6, "6",    "R"
</span><span class='line'>"Vcash",               0x47, 0xc7, "7",    "W"
</span><span class='line'>"Versioncoin",         0x46, 0xc6, "7",    "W"
</span><span class='line'>"VergeCoin",           0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"Vertcoin",            0x47, 0x80, "5",    "[LK]"
</span><span class='line'>"Viacoin",             0x47, 0xc7, "7",    "W"
</span><span class='line'>"VikingCoin",          0x46, 0x56, "3",    "D"
</span><span class='line'>"W2Coin",              0x49, 0xc9, "7",    "W"
</span><span class='line'>"WACoins",             0x49, 0xc9, "7",    "W"
</span><span class='line'>"WankCoin",            0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"WeAreSatoshiCoin",    0x87, 0x97, "6",    "P"
</span><span class='line'>"WorldCoin",           0x49, 0xc9, "7",    "W"
</span><span class='line'>"XP",                  0x4b, 0xcb, "7",    "X"
</span><span class='line'>"Yenten",              0x4e, 0x7b, "5",    "K"
</span><span class='line'>"Zcash",        [0x1c,0xb8], 0x80, "5",    "[LK]"
</span><span class='line'>"Zetacoin",            0x50, 0xE0, "8",    "a"
</span><span class='line'>"Testnet Bitcoin",     0x6f, 0xef, "9",    "c"
</span><span class='line'>"Testnet Dogecoin",    0x71, 0xf1, "9",    "c"
</span><span class='line'>"Testnet MonetaryUnit",0x26, 0x40, "3",    "A"
</span><span class='line'>"Testnet PIVX",        0x8b, 0xef, "9",    "c"
</span><span class='line'>"Testnet WACoins",     0x51, 0xd1, "8",    "[XY]"
</span></code></pre></td></tr></table></div></figure>


<p>哈哈，洋洋大观啊。这也说明了folk一个山寨币的成本是如何的低；然后有了以太坊的ERC20之后，发一个新币的成本简直低到令人发指，也无怪乎场子里面骗子横行了。</p>

<h2>以太坊的地址生成</h2>

<p>Ethereum项目是不走寻常路的，他作为比特币之后最具创新性的后辈，地址设计反而简单的多。</p>

<p>直到生成公钥这一步，以太坊和比特币都是一致的，采用了secp256k1算法，只是最后的地址生成以太坊很简洁，直接Keccak256 hash，然后取最后的40位16进制字符得到的。</p>

<p>为什么比特币实现复杂呢？这是因为比特币的交易是以UTXO为核心的，每个UTXO包含其所有者及价值信息，系统中的每一笔的交易由若干UTXO输入和若干UTXO输出组成。UTXO无法只提取部分，每次必须完整的使用，这有点像我们生活现实中的现金。比特币系统中，一个用户的“余额”是该用户的私钥能够有效签名的所有UTXO的总和。要深刻的理解这一点，还需要我们了解了比特币的交易数据构成之后才能探讨。我们后面会写文章解释这一点啦。</p>

<p>而以太坊采用了与比特币不同的实现方式——账户，类似我们生活中的银行卡。以账户为核心的设计比较节省空间,而且以太坊的block组织更为精巧。另外，以太坊的设计目标和比特币是不同的：</p>

<ul>
<li>首先以太坊的账户除了普通的收发币的账户(俗称外部账户EOA)，还有合约账户，合约账户需要一个固定的地址，不然每次调用合约都会很麻烦；这样就要求以太坊的合约账户不像比特币交易那样频繁的更换地址；</li>
<li>他并不执着于强迫用户去注意隐私问题，以太坊的态度是，如果用户注重隐私问题，你就自己搞定；你需要通过合约中的签名数据包协议来建立一个加密“混合器”进行加密。</li>
<li>总之以太坊因为要实现的目标更为宏大，他的设计理念是根据最初的用户都是一群Geek们来建立的；Geek们最喜欢啥？就是不要过度设计，让我来自己搞定</li>
</ul>


<p>所以在以太坊系统中，账户是一个20字节的地址，他关联的信息包含四个部分：</p>

<ol>
<li><p>随机数，用于确定每笔交易只能被处理一次的计数器</p></li>
<li><p>账户目前的以太币余额</p></li>
<li><p>账户的合约代码，如果有的话</p></li>
<li><p>账户的存储（默认为空）</p></li>
</ol>


<p>可以采用<a href="https://github.com/ethereum/pyethereum">pyethereum</a>这个库，用以下代码模拟以太坊地址的生成:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># -*- coding: utf-8 -*-
</span><span class='line'>
</span><span class='line'>"""doctopt ethereum address generate tools
</span><span class='line'>
</span><span class='line'>Usage:
</span><span class='line'>  genaddr.py p2addr         &lt;private&gt;
</span><span class='line'>  genaddr.py word2addr      &lt;word&gt;
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -h --help                                             Show this screen.
</span><span class='line'>  --version                                             Show version.
</span><span class='line'>
</span><span class='line'>Example:
</span><span class='line'>
</span><span class='line'>    genaddr.py p2addr 6bd3b27c591                                         # gen address from private 0x6bd3b27c591=&gt;1PiFuqGpG8yGM5v6rNHWS3TjsG6awgEGA1
</span><span class='line'>    genaddr.py word2addr 'Money is the root of all evil.'                 # gen address from private wordlist
</span><span class='line'>
</span><span class='line'>"""
</span><span class='line'>
</span><span class='line'>from docopt import docopt
</span><span class='line'>
</span><span class='line'>import os
</span><span class='line'>import sys
</span><span class='line'>from ethereum import utils
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    arguments = docopt(__doc__, version='1.0')
</span><span class='line'>
</span><span class='line'>    if arguments['p2addr']:
</span><span class='line'>        private_key = bytes.fromhex(arguments['&lt;private&gt;'])
</span><span class='line'>        passpharse = b'unknown'
</span><span class='line'>
</span><span class='line'>    elif arguments['word2addr']:
</span><span class='line'>        passpharse = arguments['&lt;word&gt;'].encode('utf-8')
</span><span class='line'>        private_key = utils.sha3(passpharse)
</span><span class='line'>
</span><span class='line'>    raw_address = utils.privtoaddr(private_key)
</span><span class='line'>    account_address = utils.checksum_encode(raw_address)
</span><span class='line'>    print("word:{}:private:{}:address:{}".format(passpharse.decode('utf-8'), private_key.hex(), account_address))
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; python genaddr.py word2addr 'hello'
</span><span class='line'>
</span><span class='line'>word:hello:private:1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8:address:0x5ccfa55C29F0522f062E3C15004E35a69dD45F6B</span></code></pre></td></tr></table></div></figure>


<p>以太坊账户方式的一个弱点是：为了阻止重放攻击，每笔交易必须有nonce。这就使得账户需要跟踪nonce的使用情况。而且，不再使用的账户，无法从账户状态中移除。</p>

<p>关于重放攻击，我们会在后面说明。</p>

<h2>重放攻击</h2>

<p>在网络中重放攻击是一种很常见的hack方式，关于相关攻防有足够丰富的案例；但是在区块链历史上却是一个悲伤的故事；在此我们用一点点篇幅回忆一下区块链上第一次大规模的重放攻击(replay Attack)。</p>

<h4>缘起</h4>

<p>众所周知，以太坊作为<code>智能合约</code>的首创者，在区块链技术史上是继比特币之后最大的创新。在V神于2015-07-30正式推出运行后，立即吸引了众多Geek来探究如何实现白皮书中所说的去中心化程序。其中最受关注的就是2016-04-30日开始募资的<a href="https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413">The DAO</a>项目。</p>

<p>关于这个项目的始末，实在是槽点满满。即使已经两年后的今天，估计你去搜索这起著名的事件，非码农人士也很难搞明白。简而言之，就是<code>The DAO</code>作为一个去中心化的项目基金会开始募资，令人觉得神奇的是，这个项目背后没有一个控制人！即使这个项目筹到一大笔钱，也没有一个人有权利单独动用它，只能所有投资人投票才能决定资金的使用，这是写在区块链代码上的铁律，这就是去中心化的魅力！</p>

<p>但是一个没有控制人，没有开发目标，拿到了钱也不知道今后要干啥的项目组织，说要募资了，然后人们纷纷掏钱买股权，是不是很神奇！</p>

<p>咱们说传销还得有个愿景呢！但是当时<code>去中心化程序</code>的概念横空出世，官网页面美轮美奂，诸多<code>专家</code>纷纷发表晦涩难懂的高大上文章齐赞<code>The DAO</code>的历史意义，就在那种巨大的泡沫环境中，人们害怕的是错过发财的上车机会，于是根本搞不明白这是个什么东西，就慷慨解囊。</p>

<p>你可能觉得好笑，可是看看今天，那些所谓的高大上的区块链项目，所谓的伟大愿景，那些山寨币，那些要颠覆这颠覆那的各路神仙，和当时何其相似！熙熙攘攘的投资人群中，有几人能花时间去搞明白比特币和以太坊的白皮书？</p>

<p>所谓的区块链技术的发展，充斥着贪婪和诈骗。就和人性一样。</p>

<h4>崩溃</h4>

<p>同样，人类的愚蠢也是不变的，贪婪之下，BUG是无法避免的。</p>

<p>截至2016-05-15，<code>The DAO</code>项目的合约募集了大约当时价值约1.5亿美元Ether，占当时Ether发行总量的15%。讽刺的是，这个项目募集了巨大的金额，却没有一个像样的专家去做一个合约代码安全审计！</p>

<p>终于，THE DAO创始人之一Stephan Tual发现其合约代码有部分缺陷，他于6月12日宣布，他们发现了软件中存在的“递归调用漏洞”问题，不过对DAO资金来说则不会出现风险。讽刺的是还是没有多少人注意到这个问题。</p>

<p>2016-06-17，一名黑客在编码上发现了真正的漏洞，使得他可以从<code>The Dao</code>上抽走资金。在攻击的头几个小时，360万的Ether被转出，在当时价值相当于七千万美元。当时引起的混乱可想而知，社区采用紧急措施冻结了所有的币，但是只要以太坊的根基代码不变，就无法阻止黑客取现这些财富。</p>

<p>你可以想象当时那些投资人的反应，有人气急败坏要求以太坊开发团队立即采取措施，作废黑客的攻击行为，回退区块链并退回所有投资人的Ether。</p>

<p>而真正的区块链信徒认为<code>代码即正义、代码即法律</code>，传统世界中的法律不能应用到cyberpunk世界中，即使是黑客的盗窃行为，也理应收到这种正义保护！回退作废Block的行为其实就是否认区块链的技术意义，它会毁灭以太坊项目。</p>

<p>你可以想象，当你损失了几十万美元，对面的一群码农却做出这种<code>奇谈怪论</code>，肯定是想砍人的心都有了。当时的各路利益纠葛者吵了一个翻天覆地。甚至黑客本人也跳出来发表了一通公开信，先为自己的盗窃行为辩护一番，然后承诺只要社区不回退，就会返还一部分金额。整个事件好一场精彩大戏。</p>

<h4>分裂</h4>

<p>经历了无休止的利益、法律、技术等等辩论后，以太坊社区分裂了。争论的结果就是诞生了ETH Classic (即ETC)项目；一批坚持<code>代码即正义</code>者分裂出来创造了ETH Classic 网络，这个项目称自己才是真正的以太坊，并承认黑客的攻击行为且继续将这条链运行下去。而现在仍旧运行的Ethereum网络保护了投资者的利益，做出了妥协；</p>

<p>这个分叉开启于Ethereum网络Block编号为<a href="https://gastracker.io/block/0x94365e3a8c0b35089c1d1195081fe7489b528a84b22199c916180db8b28ade7f">1920000</a>区块。</p>

<p>这是世界上第一次公开的人为的区块链分叉事件。但是好戏才刚刚开始。</p>

<h4>重放攻击</h4>

<p>以太坊硬分叉出现了ETH和ETC两条链，两条链上的交易数据结构是完全一样的，因此一笔交易在ETH上是有效的， 那它在ETC上同样会被接受，反之亦然。 因为当时所有人都认为ETC将不会再存在，所以分叉前没人意识到两条链会产生相互重放问题。 后来还有许多矿工继续在维持ETC链时， 大家发现在ETH链上的交易拿到ETC链继续重放（广播）仍然是有效的。</p>

<p>因为没经验，以太坊分叉时几乎所有交易所也都没意识到这个问题，更没有提前做ETH和ETC分离， 这时候只要有人从交易所提取ETH币，就有可能得到同等数量的ETC币。许多人利用这个漏洞，不断在交易所充币和提币（ETH）， 从而获取额外的ETC。 当时云币、BTC-E等交易所发布说自己被重放攻击了，被骗取了几乎所有ETC。“重放攻击”也就此闻名于币圈。</p>

<p>解决这个问题也很简单，或者就是两边的原始交易数据要有所区别:</p>

<ul>
<li>或者地址前缀做一下改动</li>
<li>或者交易数据签名增加一个标志</li>
</ul>


<p>因为以太坊地址没有像比特币一样的前缀，ETC和ETH社区经过讨论，简单的提出了<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">EIP-155</a> 作为解决方案。简而言之，就是判断分叉的区块编号，引入一个CHAIN ID新值来解决这个问题。</p>

<p>耐人寻味的是，Ethereum团队此时对于ETC分叉的态度是支持的。就像中本聪早期提到的那样，没有一个人可以集权控制一条链，算力说话。因此ETC活了下来。也因为以太坊的创始人Vitalik Buterin是个非常年轻的天才，整个开发团队洋溢着一种骑士精神;他们对于自由竞争出生的ETC非常包容，不管将来结果如何，我认为这种态度是非常了不起的。</p>

<p>当然，个人感情的说一下。此事说明了投资所谓的区块链项目，究竟有多大的风险！以太坊基础代码有许多人审核，有一定的安全保证，但是形形色色的智能合约就不好说了。后来像DAO一样的hack事件数不胜数！</p>

<p>我得说，当你想要投资一个所谓<code>未来项目</code>时，除了你自己的知识和判断，没有任何一个人是可信的！我是说，只能靠自己，其他任何人，甚至创始者的意见也不可信。</p>

<h2>Bitcoin Cash地址生成</h2>

<p>关于Bitcoin Cash的诞生，其过程之离奇曲折，胜过ETH分叉百倍。这是一个比最精彩的侦探小说还要反转反转再反转的故事。</p>

<p>不过我们就不要讲故事了，总之Bitcoin Cash分叉诞生后，为了和传统的Bitcoin地址相区别，自己又做了一下改动。</p>

<p>快速看看BCH新老地址的对比：</p>

<ol>
<li><p>新地址是和老地址一一对应的，它们对应了同一个私钥，只是换了种写法</p></li>
<li><p>新地址可以发送余额给老地址，老地址可以发送余额到新地址</p></li>
<li><p>新地址是大小写不敏感的，可以全部转成大写，也可以全部转成小写，优先小写格式，同一地址不能大小写混用</p></li>
<li><p>新地址的前缀可写可不写，老地址没有前缀，通过首字符来标识类型</p></li>
<li><p>新地址用base32编码，老地址用base58编码</p></li>
</ol>


<p>官方文档描述参见<a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md">这里</a>，让我们从seed <code>satoshi</code> 生成一个bitcoin cash 地址演示一遍。</p>

<h4>规范</h4>

<p>新的bitcoin cash地址是由：</p>

<ul>
<li>能够表示该地址有效的网络的前缀，一般为主网(bitcoincash)、测试网(bchtest)、回归测试网(bchreg)三种。</li>
<li>一个分隔符：<code>:</code></li>
<li>一个base32编码的payload，表示这个地址的目的地和包含的checksum（校验和）。</li>
</ul>


<h4>Payload</h4>

<p>payload是base32编码的数据流，由三个元素组成:</p>

<ul>
<li>指示地址字节的版本类型</li>
</ul>


<p>共8bits, 1bit(0) + 4bits (地址类型：Type bits) + 3bits (hash长度：Size bits)</p>

<table>
<thead>
<tr>
<th>Type bits (二进制) </th>
<th> 地址类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 </td>
<td> P2PKH</td>
</tr>
<tr>
<td>1000 </td>
<td> P2SH</td>
</tr>
<tr>
<td>0000 </td>
<td> P2PKH-TESTNET</td>
</tr>
<tr>
<td>1000 </td>
<td> P2SH-TESTNET</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th>Size bits (二进制) </th>
<th> 代表hash长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>000 </td>
<td> 160</td>
</tr>
<tr>
<td>001 </td>
<td> 192</td>
</tr>
<tr>
<td>010 </td>
<td> 224</td>
</tr>
<tr>
<td>011 </td>
<td> 256</td>
</tr>
<tr>
<td>100 </td>
<td> 320</td>
</tr>
<tr>
<td>101 </td>
<td> 384</td>
</tr>
<tr>
<td>110 </td>
<td> 448</td>
</tr>
<tr>
<td>111 </td>
<td> 512</td>
</tr>
</tbody>
</table>


<ul>
<li>一个hash值</li>
</ul>


<p>hash含义取决于版本字段。它是表示数据的hash，即P2KH的pubkey hash和P2SH的reedemScript哈希。这个可以直接从BTC地址里面推出，这个hash值导出后需要用40Bits的BCH码来表示，这样做之后，地址大小写不敏感。</p>

<ul>
<li>一个40字节的校验和</li>
</ul>


<p>这个校验和的计算比较繁琐，它是在GF（2 ^ 5）上定义的40bits的BCH码，校验和根据以下代码计算：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>uint64_t PolyMod(const data &v) {
</span><span class='line'>    uint64_t c = 1;
</span><span class='line'>    for (uint8_t d : v) {
</span><span class='line'>        uint8_t c0 = c &gt;&gt; 35;
</span><span class='line'>        c = ((c & 0x07ffffffff) &lt;&lt; 5) ^ d;
</span><span class='line'>        
</span><span class='line'>        if (c0 & 0x01) c ^= 0x98f2bc8e61;
</span><span class='line'>        if (c0 & 0x02) c ^= 0x79b76d99e2;
</span><span class='line'>        if (c0 & 0x04) c ^= 0xf33e5fb3c4;
</span><span class='line'>        if (c0 & 0x08) c ^= 0xae2eabe2a8;
</span><span class='line'>        if (c0 & 0x10) c ^= 0x1e4f43e470;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return c ^ 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>具体的规则可以详细参考<a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md">这里</a>。</p>

<h4>地址转换生成</h4>

<ul>
<li>1.取<code>satoshi</code> 生成的非压缩地址<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code></li>
<li>2.这个地址是一个主网地址，前缀为<code>bitcoincash:xxxxx</code></li>
<li>3.这个地址类型为<code>P2PKH</code>，version_bits为0000</li>
<li>4.<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>进行base58 Decode，去掉末尾的4字节checksum，得到的hash值用list表示</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>payload = [101, 13, 4, 151, 224, 20, 230, 13, 70, 128, 252, 230, 153, 125, 64, 93, 226, 100, 240, 66]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5.加入version前缀</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>payload = [0, 101, 13, 4, 151, 224, 20, 230, 13, 70, 128, 252, 230, 153, 125, 64, 93, 226, 100, 240, 66]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>6.将hash进行8bits->5bits BCH码的转换</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>payload = [0, 1, 18, 16, 26, 1, 4, 23, 28, 0, 10, 14, 12, 3, 10, 6, 16, 3, 30, 14, 13, 6, 11, 29, 8, 1, 14, 30, 4, 25, 7, 16, 8, 8]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>7.计算校验和</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checksum=[24, 25, 19, 1, 12, 3, 18, 8]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>8.对payload + checksum进行base32编码，得到<code>qpjs6pyhuq2wvr2xsr7wdxtagpw7ye8sggcenpvrjg</code></li>
<li>9.加入前缀<code>bitcoincash:</code>，组合得到最后地址<code>bitcoincash:qpjs6pyhuq2wvr2xsr7wdxtagpw7ye8sggcenpvrjg</code></li>
</ul>


<p>有许多在线转换工具可以验证，比如:</p>

<p><a href="https://bch.btc.com/tools/address-converter">https://bch.btc.com/tools/address-converter</a></p>

<h2>总结</h2>

<p>以上长篇大论了比特币系统的地址是如何生成的，当然我们也略过了许多细节，比如钱包如何加salt，如何加passphrase等等，这些直接去读BIP 规范更为精确；但是一个完整的钱包，可不仅仅是要解决地址生成这个问题，还要能方便的管理私钥。</p>

<p>在比特币早期，私钥的管理是非常粗暴的，就是每次创建新钱包时，系统自动随机生成100个私钥，然后随着用户交易增多用光之后，再生成100个私钥；钱包文件就是一个二进制文件，即使加了密码保护，也很容易暴力破解泄密；</p>

<p>这导致了无穷多的hack事件；不管你信不信，初期很多从事比特币交易的网站，其wallet.dat文件就明晃晃的放在服务器上，管理员粗心大意，完全可以形容为 <code>没头脑+不高兴</code>，很多人连个最基本的密码保护也不设置；另外也发生过很多悲剧的<code>rm -rf</code>事件，我认为由于这样的失误导致的比特币丢失至少在100w+ 币的级别；换算今天的汇率，你能相信有个银行将数亿美元现金的保险柜不加锁，明晃晃的摆在大堂上摆阔吗？</p>

<p>在一连串的悲剧事件中(具体是哪些悲剧可以写一本书哦)，作为登峰造极者，mtgox当之无愧！ 80多万个比特币的丢失，史上独一份。这个交易所的老板也是心大，80w+币的钱包密码也不设置一个，就在那里任由黑客予取予求；还不是一天两天哦，是持续好几周的hack事件！</p>

<p>mtgox是比特币历史上巨大的迷雾，他不光牵扯到许多比特币的早期玩家，还有BTC-E, FBI牵涉其中，我认为这是仅次于<code>中本聪到底何方神圣</code>的谜题。所幸法胖还活着，我希望有生之年能读到这个事件的完整披露。</p>

<p>好了，假如你是一个交易所的老板，你会很快发现自己面临着以下问题：</p>

<ul>
<li>不需要给每个用户的账户都建立一个钱包文件，我希望能有一个总的账户管理方案</li>
<li>可能交易所有1000个大户，你希望他们的钱包是冷存储的，提币的时候他们可以耐心等一段时间，但是剩下的100000个普通用户的账户就要存放到一个热钱包上，只留有部分资产来应付流动性</li>
<li>有很多部门需要批准获取一些资金，比如研发要用来做测试，市场部门要用来搞活动等等</li>
<li>最后，私钥最好只能由少数人，最好只有我本人来掌握，不然私钥的传播过程中，随便一个人就能让你万劫不复</li>
<li>我如果有一些合伙人的话，肯定也希望能掌管一部分资金</li>
<li>如果有突发情况，我能迅速把公司账上所有的币都转移到另外一个安全的账户上，这有可能是要迅速完成上万笔的交易转移</li>
<li>最后，我希望所有的交易，签署和广播是在不同的机器上进行的，存有私钥的机器不能联网，这台机器签名完毕后，调用远端的服务端广播交易，这样完全实现钱包的冷隔离</li>
</ul>


<p>好啦，假如我们现在只有前面那种一个wallet.dat钱包的管理方案，要怎么做呢？</p>

<p>很明显的，这种管理太粗糙了。社区们经过不断的探索，提出了BIP-32，BIP-39，BIP-44等规范，以绝妙的办法解决了这些问题。这就是比特币HD钱包的由来。同时这些规范不仅仅适用于比特币系统，还适用于所有的电子货币方案，也许今后，你可以同时在一个钱包里管理你的ETH, BTC, 支付宝余额等等~~~</p>

<p>那到底要怎么做呢？</p>

<p>我们已经探索了这么远，估计你也不耐烦了，但是我们还要说，这还早的很呢！那么下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoin-cli Cheat]]></title>
    <link href="https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat/"/>
    <updated>2018-10-26T16:28:23+08:00</updated>
    <id>https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat</id>
    <content type="html"><![CDATA[<p>今天踩了一个巨坑。</p>

<p>我一直以为<code>bitcoin-cli sendfrom</code>命令是可以花费uncomfirmed UTXO的。</p>

<!-- more -->


<p>然后今天发现bitcoin-core 0.17版本已经开始废弃这个命令和<code>bitcoin account</code>的支持了。于是去修改万年之前的一个脚本。</p>

<p>然后我切换到TESTNET里面发了几笔交易，惊奇的发现sendfrom并不能花费uncomfirmed UTXO。执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; bitcoin-cli sendfrom "" "1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd" 0.01 0</span></code></pre></td></tr></table></div></figure>


<p>明明我已经发给测试账户0.1BTC过去了，getwalletinfo可以看到这个币了，我也把minconf设为0了，却在执行sendfrom的时候总是提示我<code>Account has insufficient funds</code>；</p>

<p>我一路代码追下去，在这里:</p>

<p><a href="https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915">https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915</a></p>

<p>惊奇的发现只有自己的找零才会在uncomfirmed的情况下被计入credit fund，震惊了。我这个脚本运行了半年了，才发现这个坑。</p>

<p>没办法，自己又封装了一遍<code>createrawtransaction</code>，<code>signrawtransaction</code>, <code>sendrawtransaction</code>，来代替sendfrom的功能。</p>

<p>找这个问题我在TESTNET里面发了不下一百笔交易，wallet部分的代码已经翻遍了，我深深为之感叹bitcoin core实现wallet这部分的精巧，好多地方的细节已经不是人类能理解的了；太可怕了。</p>

<p>另外记一下远程调用bitcoind rpc接口的套路:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;bitcoin_cli --rpcconnect=192.168.2.7 --rpcpassword="xxxxx" --rpcuser=test getwalletinfo</span></code></pre></td></tr></table></div></figure>


<p>相应的，bitcoin.conf也要允许远端调用rpc接口的权限:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=test
</span><span class='line'>rpcpassword=xxxxx
</span><span class='line'>rpcallowip=192.168.2.0/255.255.255.0
</span><span class='line'>rpcport=8332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span></code></pre></td></tr></table></div></figure>


<p>ps: bitcoin.conf 可以直接放到blockchain的数据目录，反正我看0.15的代码，已经把这个路径默认加到path搜索里面了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-1]]></title>
    <link href="https://happy123.me/blog/2018/10/23/bi-te-bi-de-hdqian-bao-yan-hua-1/"/>
    <updated>2018-10-23T18:49:26+08:00</updated>
    <id>https://happy123.me/blog/2018/10/23/bi-te-bi-de-hdqian-bao-yan-hua-1</id>
    <content type="html"><![CDATA[<h2>密钥分发的问题</h2>

<p>在之前我们的一篇文章<a href="https://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/">加密技术发展</a> 中提到了一个经典的问题:</p>

<!-- more -->


<ul>
<li><p>Alice和Bob是朋友，他们的住处离得比较远，Alice想要发送一则隐私消息给Bob</p></li>
<li><p>Eve想要窃听Alice和Bob的通信，Alice和Bob无法防止Eve的偷看</p></li>
<li><p>Alice把信放在一个盒子里，她上了锁，让邮差发给Bob，Eve没有钥匙，无法打开盒子，但是Bob也无法打开</p></li>
</ul>


<p>那么问题来了，Alice如何把钥匙发给Bob呢？</p>

<p>Alice如何发送钥匙给Bob的问题，就是现代密码学中<code>密钥分发</code>的问题;现代密码学的大部分研究，就是围绕这个问题展开的。</p>

<p>我们在思想实验中虚拟了两个解决方案:</p>

<h4>方案A</h4>

<ul>
<li><p>Alice把信息放到铁盒子里，上锁，发给Bob</p></li>
<li><p>Bob收到盒子，没有去想办法打开它，而是又加上了自己的一把锁，发回给Alice</p></li>
<li><p>Alice打开自己加的锁，发回给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
</ul>


<h4>方案B</h4>

<ul>
<li><p>Bob满世界散播自己的锁，随便一个人都能捡到Bob的锁并且能分辨是否被别人伪造</p></li>
<li><p>Alice捡了一把Bob的锁，把消息放进铁盒子里，锁上，发给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
</ul>


<p>这两个虚拟的解决方案意义非同寻常，它证明了两个人可以互相交换秘密的信息而不怕密钥泄露；但是在真实世界中，对一则文本信息加密，并不完全像给一个铁盒子上锁那样方便，我们如何把这两个故事的寓意融入到真正的密码术当中去呢？</p>

<h2>单向/双向函数</h2>

<p>在密码学中，很常用的一个数学特性叫做<code>单向函数</code>。</p>

<p>同样与之相对的，还有一个概念叫做<code>双向函数</code>。</p>

<p>让我们来看看他们是什么东东。</p>

<h4>双向函数</h4>

<p>大部分函数都是双向函数，<code>双向</code>意味着可逆。比如加倍函数就是一个双向函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y = 2x</span></code></pre></td></tr></table></div></figure>


<p>知道了x，很容易能求得y；同理，知道了y，很容易逆向求得x。</p>

<h4>单向函数</h4>

<p>与上面相对的，知道x，很容易能求得y；但是知道了y，逆向很难推出x。这就是单向函数。举一个最常见的例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y = 453^x % 21997</span></code></pre></td></tr></table></div></figure>


<p>一个很大的数的x次方来模除另一个很大的数，取模得到y，知道x，y是很容易计算的，但是反向从y推导x却十分困难。这就是一个单向函数。</p>

<p>码农童鞋们非常熟悉的一种算法:HASH(散列)，其原理就是建立在单向函数之上的；但是现在我们先把这个应用放到一边，单单探讨单向函数在密钥交换中的作用</p>

<h4>单向函数在密码学中的应用</h4>

<p>Alice和Bob在不懈的努力之后，发现采用上述 M<sup>x</sup> % P = y 的单向函数可以帮助他们交换密钥，而且
不怕遭到Eve的窃听，让我们看看他们怎么做到的：</p>

<table>
<thead>
<tr>
<th>选择 7<sup>x</sup> % 11 = y 这个单向函数作为约定函数 </th>
<th>Alice </th>
<th> Bob</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一步 </td>
<td> Alice随机选择了一个数字代入x，比如3 </td>
<td> Bob 随机选择了一个数字代入x，比如6</td>
</tr>
<tr>
<td>第二步 </td>
<td> Alice运算得到 7<sup>3</sup> % 11 = 2  </td>
<td> Bob 运算得到 7<sup>6</sup> % 11 = 4</td>
</tr>
<tr>
<td>第三步 </td>
<td> Alice把2发给Bob  </td>
<td> Bob 把4发给Alice</td>
</tr>
<tr>
<td>第四步 </td>
<td> Alice得到Bob发送的结果4，代入单向函数再一次运算得到 4<sup>3</sup> % 11 = 9  </td>
<td> Bob 得到Alice的2后进行同样的运算 2<sup>6</sup> % 11 = 9</td>
</tr>
</tbody>
</table>


<p>神奇的事情发生了，第四步中Alice和Bob得出了相同的数字9，这个数字就是他们需要传递的密钥。</p>

<p>让我们再重新审视一遍，Alice和Bob在这次交换密钥的过程中都传递了什么呢？</p>

<ol>
<li>他们约定了单向函数的 M, P值</li>
<li>他们各自选定了一个x值，然后计算结果y值并互相传递</li>
<li>通过前面两组信息，他们各自独立计算出了密钥值</li>
<li>Eve如果监听到了M,P,以及两个人传递的y，是很难逆向计算出x，并得出密钥值的；这是单向函数的数学特性决定的</li>
</ol>


<p>通过仔细的选定一个稳妥的单向函数，就可以通过公开的讨论来建立一个密钥。这是密码学史上一个伟大发现。它是如此的简单和违反直觉，简直让人觉得不可思议。</p>

<p>如果仔细看看，两个人交换模除结果y的过程，是不是和我们之前提到过的<code>方案A</code>有点像呢，这就是思想实验在理论世界中的映射。</p>

<p>这个发现是由我们前面那篇<a href="https://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/">加密技术发展</a>中帅帅的大叔们在1972年的工作成果，向他们致敬！</p>

<h2>非对称加密算法的建立</h2>

<p>虽然我们上面所建立的交换密钥的方案已经取得了巨大的进步，但是这个方案并不完美，因为它有一个不方便的地方:</p>

<p>Alice 想要给Bob发信，必须拿到Bob的y值，除非是热恋的情人，谁能一直在线回复你的消息呢？所以Alice要发信，一定要Bob配合达成一个密钥才可以；如果Bob恰巧睡觉了，这封信就只能延迟发了</p>

<p>这个不方便之处促使密码学家们寻求更完美的解决之道，这促成了非对称加密算法的建立。</p>

<p>我们至今为止的所有探讨都是建立在对称加密算法之上的。所谓<code>对称加密</code>，就是你有一个密钥，使用这个密钥加密一段信息，同样可以使用这个密钥解密这段信息。正是之前所有的加密算法都是建立在这个基础上的，所以密钥的传递才是如此重要。</p>

<h4>现在让我们思考另外一种看似违反直觉的方案</h4>

<p>如果有一种加密解密函数，它的加密密钥和解密密钥是不同的。在这个系统中，如果Alice只知道加密密钥，她只能加密，加密之后自己却无法解密&mdash;除非她知道另外一个解密密钥。</p>

<p>听起来好像有点绕口。用现代密码学的定义来解释，就是Alice需要同时拥有两把密钥：私钥和公钥。私钥用来解密，公钥用来加密。这样Alice只要好好藏好自己的私钥，然后把公钥广播天下，谁想要给Alice写情书，就用Alice广播出来的公钥加密寄给她就好啦，只有持有私钥的Alice才能解密这封情书。</p>

<p>这个系统的巨大优点就是两人通信不需要同时在线来来回回折腾了，只要两人把各自把自己的公钥广而告之，任何一个人就可以毫不顾忌的用公钥加密，写一些只能给Alice和Bob才能解密的隐私信息了。</p>

<p>这个方案是由帅帅的Whtfield Diffie想到的，在此我们要撒一把狗粮；这位老兄灵光一现想到这个方案之后，第一个想要与之分享的人是他的妻子玛丽，当时的情形是这样的:</p>

<blockquote><p>那是在下午发生的，维特不得不等几个小时，玛丽才会回来。
&ldquo;维特等在门口，&#8221;玛丽回忆说，&#8221;他说有事要告诉我，他脸上的表情很奇怪。我进了门，他说:&lsquo;请坐下来，我想和你说话。我相信我有一个重大的发现&mdash;-我是第一个知道这问题答案的人。&#8217;那一刻我感觉时间突然停止了，我似乎生活在好莱坞的电影中。&rdquo;</p></blockquote>

<p>好，单身狗童鞋们从暴击伤害中回过神来没有，让我们继续艰难的人生~~~</p>

<p>虽然Whtfield Diffie早在1975年就提出了这个方案，但是他没有找到他所需要的函数。他公开发表了论文，号召同时代的数学家们一起来找；但是时间飞逝，年底还是没人能找到这样的函数，有些人灰心了；正在这时，远在5000公里之外的美国西海岸，有个小组找到了这样的函数~~~这就是今天大名鼎鼎的RSA算法的诞生。</p>

<h4>那些个帅帅的大叔们</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg1.jpg" alt="RSA加密发明人" /></p>

<p>额，关于RSA算法，阮一峰老师的文章写的更清晰，我就不多废话了；童鞋们可以移步<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">这里</a>来探讨细节，当然，懒得去理解数学原理对于我们下面的探讨也没啥影响~~~~</p>

<h4>让我们总结一下一个典型的非对称加密算法的特点，并看看它是如何应用到实际中的</h4>

<ol>
<li>Bob手里有两把钥匙，一把是公钥，另一把是私钥。有了私钥能推导出公钥，有了公钥不能推导出私钥</li>
<li>用私钥加密，可以使用公钥解密</li>
<li>用公钥加密，可以使用私钥解密</li>
<li>Bob把公钥送给他的朋友们&mdash;&mdash;Alice, Sam ~~每人一把；或者直接把公钥公示在自己的个人网页上，谁都能看；</li>
<li>Alice要给Bob写一封保密的信。她写完后用Bob的公钥加密，就可以达到保密的效果。</li>
<li>Bob收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要Bob的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</li>
<li>Bob给Alice回信，决定采用&#8221;数字签名&#8221;。他写完后先用Hash函数，生成信件的摘要（digest）。</li>
<li>然后，Bob使用私钥，对这个摘要加密，生成&#8221;数字签名&#8221;（signature）。Bob将这个签名，附在信件下面，一起发给Alice。</li>
<li>Alice收信后，取下数字签名，用Bob的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</li>
<li>Alice再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</li>
<li>复杂的情况出现了。Eve想欺骗Alice，他偷偷使用了Alice的电脑，用自己的公钥换走了鲍勃的公钥。此时，Alice实际拥有的是Eve的公钥，但是还以为这是Bob的公钥。因此，Eve就可以冒充Bob，用自己的私钥做成&#8221;数字签名&#8221;，写信给Alice，让Alice用假的Bob公钥进行解密。</li>
<li>后来，Alice感觉不对劲，发现自己无法确定公钥是否真的属于Bob。每次都去寻找Bob的个人网页去比对也很麻烦；她想到了一个办法，要求Bob去找&#8221;证书中心&#8221;（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对Bob的公钥和一些相关信息一起加密，生成&#8221;数字证书&#8221;（Digital Certificate）。</li>
<li>Bob拿到数字证书以后，就可以放心了。以后再给Alice写信，只要在签名的同时，再附上数字证书就行了。</li>
<li>Alice收到信后，用CA的公钥解开数字证书，就可以拿到Bob真实的公钥了，然后就能证明&#8221;数字签名&#8221;是否真的是Bob签的。</li>
<li>以上过程涉及了<code>非对称加密</code>，<code>HASH</code>，<code>签名</code>,<code>Digest</code>，<code>CA</code>等等名词，没错，我们说的就是HTTPS</li>
</ol>


<p>完整的资料参看这里：</p>

<p><a href="http://www.youdzone.com/signature.html">http://www.youdzone.com/signature.html</a></p>

<h2>椭圆曲线ECC加密算法（Elliptic Curve Cryptography）</h2>

<p>我们看到了，非对称加密的核心，依赖于一个非常健壮的单向函数。RSA采用的是大素数分解的单向函数。这基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难。大质数分解问题一直是数学里面的热门问题。</p>

<p>即便如此，因式分解在位对位基础里不是最难的问题。这些因式分解算法随着被因式分解的数字变得越大而变得越有效率。因式分解大批数字和乘以大批数字的难度的差距随着数字（即秘钥的字节长度）变大而缩小。随着有效解码数字的资源增加，秘钥的大小必须更快增长。对限制计算能力的手机和低功率设备来说，这不是一个可持续的情况。从长期来看，因式分解和乘法的差距是不可持续的。</p>

<p>所有这一切意味着RSA不是理想的系统对将来的密码学来说。在一个完美的trapdoor函数里，对于数字大小的问题，简单方法和困难方法都一同样的速率变难。所以我们需要一个基于更好的trapdoor的公钥系统。</p>

<p>以上RSA的这些不完美加速了另外一种算法的诞生：在1985年，加密算法被提议以一个叫椭圆曲线的数学密码分支为基础。这也是比特币地址采用的核心加密方法。</p>

<h4>什么是椭圆曲线</h4>

<p>对于我们小白来说，椭圆曲线可以暂时简单的理解为描述了特定点的集合的公式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y^2 = X^3 + ax + b</span></code></pre></td></tr></table></div></figure>


<p>取不同的a值和b值，这个函数在坐标轴上绘制出来的曲线大概是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg2.jpg" alt="椭圆曲线" /></p>

<p>a和b的取值变化决定了曲线在坐标系上的不同形状。从图中可以看到，椭圆曲线是相对X轴对称。</p>

<p>通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的。椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。</p>

<h4>secp256k1椭圆加密曲线</h4>

<p>a和b的不同取值可以画出多条不同的曲线，比特币使用了secp256k1标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y^2 % p = (X^3 + 7) % p</span></code></pre></td></tr></table></div></figure>


<p>看到了吧，这个函数结合了我们之前介绍的取模操作和椭圆曲线函数。</p>

<p>上述素数p取模表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2<sup>256</sup> – 2<sup>32</sup> – 2<sup>9</sup> – 2<sup>8</sup> – 2<sup>7</sup> – 2<sup>6</sup> – 2<sup>4</sup> – 1， 这是个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散落的点，因此很难可视化。不过，其中的数学原理与实数范围的椭圆曲线相似。</p>

<p>这条曲线画出来的样子大概是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg3.jpg" alt="椭圆曲线" /></p>

<p>在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。</p>

<p>还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3 = P1 + P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线相交于另外一个地方。此点记为 P3&#8217;= (x，y)。然后，在x轴做翻折获得 P3=(x，-y)。</p>

<p>下面是几个可以解释“穷远点”之存在需要的特殊情况。</p>

<p>若 P1和 P2是同一点，P1和P2间的连线则为点P1 的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微积分求得。即使限制曲线点为两个整数坐标也可求得斜率！</p>

<p>在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3 = “无穷远点”。</p>

<p>若P1就是“无穷远点”，那么其和 P1 + P2= P2。类似地，当P2是无穷远点，则P1+ P2 = P1。这就是把无穷远点类似于0的作用。 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)+C = A+(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。 因此，我们已经定义了椭圆加法，我们可以对乘法用拓展加法的标准方法进行定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，在这种情况下k有时被混淆而称为“指数”。</p>

<h4>生成公钥</h4>

<p>以一个随机生成的私钥k为起点，我们将其与曲线上预定的生成点G相乘以获得曲线上的另一点，也就是相应的公钥 K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p>

<p>{K = k * G}</p>

<p>其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将 得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生） 与任何人共享而不会泄露私钥（k）的原因。</p>

<p>提示 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。</p>

<p>为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：</p>

<p>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</p>

<p>公钥K 被定义为一个点 K = (x, y)：</p>

<p>K = (x, y)</p>

<p>其中，</p>

<p>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</p>

<p>y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</p>

<p>为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一 点，然后翻折到x轴。</p>

<p>下图显示了在曲线上得到 G、2G、4G 的几何操作。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg4.jpg" alt="椭圆曲线" /></p>

<h4>比特币账户</h4>

<p>呼呼，以上就是比特币的账户核心算法的一部分。</p>

<ol>
<li>选定了secp256k1算法，其实是通用的椭圆曲线的特化(a=0, b=7)，另外选定一个非常大的模除数字p</li>
<li>选定了一个G点;G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</li>
<li>随机生成了一个私钥k</li>
<li>求得公钥K = k * G，这里对G进行了k次翻转，一个不可逆的操作得到公钥K</li>
<li>对K再做后续变形，最终得到比特币账户的地址，这个变形又是一系列神操作，我们在后面的文章会讲</li>
</ol>


<h2>寻求更极限的安全</h2>

<p>到目前为止，密码学家们为了实现更安全的非对称加密算法，探索了模除、大素数分解、以及椭圆曲线；他们的共同特点就是逆向运算极难极难；但是极难并不代表着不可能，随着量子计算的发展，谁也不能保证今后逆向运算的复杂度会不会有大幅降低；所以寻求更安全的单向函数始终是密码学家们最重要的工作之一；</p>

<p>近年来，这个探索的边界又有了更大的突破，就是为人们所熟知的量子加密技术。</p>

<p>限于篇幅，我们就不做更多的科普了，可以参考这本书:</p>

<p><a href="https://book.douban.com/subject/1036413/">https://book.douban.com/subject/1036413/</a></p>

<p>PS:一个小科普，量子计算机和量子加密其实没有多大关系哦，他们之间其实是雷锋和雷峰塔的关系，就是名字相似而已，可不要被忽悠哦</p>

<h2>总结</h2>

<p>呼呼，老实说，我最初想要介绍的是比特币HD钱包的演化过程，BIP32,BIP44,BIP49，BIP84以及BIP141这些文档共同定义了比特币HD钱包的底层构造。</p>

<p>从BIP44开始，比特币账户的管理其实已经在中本聪最初定义的一个简单地址生成的路上又走了很远；我也觉得HD钱包是比特币社区为区块链技术贡献的一个非常重要、非常有用的部分；这个钱包生成的技术超出了比特币本身，在可见的未来，会在多个领域发挥巨大作用。</p>

<p>为了学习比特币HD钱包的基础理论支撑，我们从最原始的凯撒加密，到Alice和Bob的思想实验，到单向函数，再到安全的密钥分发方法，到非对称加密，椭圆曲线，甚至还隐约看到了量子加密，这一切的一切是近2000年来无数密码学家们日日夜夜的冥思苦想的成果；</p>

<p>然后站在所有这些成果的基础上，到了中本聪及比特币技术社区手中融合发扬光大；创造了独一无二的电子货币金融账户；这个账户设计的方法之精妙，值得我们再长篇大论一番；那么，下次文章再见。</p>

<p>参考资料:</p>

<p><a href="https://book.douban.com/subject/30280401/">https://book.douban.com/subject/30280401/</a></p>

<p><a href="https://book.douban.com/subject/1036413/">https://book.douban.com/subject/1036413/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们的货币超发了吗]]></title>
    <link href="https://happy123.me/blog/2018/10/16/wo-men-de-huo-bi-chao-fa-liao-ma/"/>
    <updated>2018-10-16T19:21:08+08:00</updated>
    <id>https://happy123.me/blog/2018/10/16/wo-men-de-huo-bi-chao-fa-liao-ma</id>
    <content type="html"><![CDATA[<p>这是一个没有公认答案的问题，但是从央行的角度来说说，真有点冤；</p>

<p>看看一些数据吧：</p>

<!-- more -->


<h4>美国 (单位：亿美元)</h4>

<table>
<thead>
<tr>
<th>Year</th>
<th> M0  </th>
<th> M2 </th>
<th> GDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>2008</td>
<td>8370 </td>
<td>74574  </td>
<td>144776</td>
</tr>
<tr>
<td>2018</td>
<td>38500</td>
<td>138344 </td>
<td>193906</td>
</tr>
</tbody>
</table>


<p>来源：<a href="https://stock-ai.com/eom-1-M2SL.php">https://stock-ai.com/eom-1-M2SL.php</a></p>

<h4>中国 (单位:亿元)</h4>

<table>
<thead>
<tr>
<th>Year</th>
<th> M0 </th>
<th> M2 </th>
<th>GDP</th>
<th> 外汇储备(亿美元)</th>
<th> 外汇占款(亿元) </th>
<th> 汇率</th>
</tr>
</thead>
<tbody>
<tr>
<td>2008 </td>
<td>  36673 </td>
<td> 403442.2 </td>
<td> 265810.30 </td>
<td> 15898.10 </td>
<td> 115168.71 </td>
<td> 7.4</td>
</tr>
<tr>
<td>2018 </td>
<td>  70645 </td>
<td> 1676800 </td>
<td> 827122.00 </td>
<td> 31399.49 </td>
<td> 214788 </td>
<td> 6.6</td>
</tr>
</tbody>
</table>


<p>来源：<a href="http://www.pbc.gov.cn/diaochatongjisi/116219/index.html">http://www.pbc.gov.cn/diaochatongjisi/116219/index.html</a></p>

<p>Tooltips:</p>

<h3>m2对应的只是存款，没有包含所有的可变现金融资产。另外中美M2统计口径不同</h3>

<h4>美国M2包含零售的货币市场基金份额，是指在售的部分，美国M1、M2的统计口径分别如下：</h4>

<ul>
<li><p>M1：包括：</p>

<p>  1）美国财政部、联邦储备银行以及存款货币机构之外的现金；
  2）旅行支票；
  3）商业银行活期存款；
  4）其他可支付存款；NOW；ATS以及储蓄贷款协会的定期存款。</p></li>
<li><p>M2：包括M1，以及
  1）储蓄存款（包括货币市场存款账户）；
  2）小额定期存款（即10万美元以下）；
  3）零售的货币市场基金份额。</p></li>
</ul>


<p>当前美国货币统计口径最大的M2并未包括机构的大额存款以及境外流入的资金，主要是个人的储蓄存款以及机构的小额定期存款。美国的M2仅大致相当于中国的M1加上储蓄存款，即小于中国M2的统计口径。</p>

<h4>中国的M2包括了货币和准货币，基本上代表了货币总量即广义货币。但是，国际上并不存在这样的约定俗成：M2即是广义货币。</h4>

<h3>中国M2是否超发</h3>

<h4>统计方法差异</h4>

<p>2016-06的统计数据，美国GDP总量17.87万亿美元，中国GDP总量10.42万亿美元，美国总量是中国的1.7倍。美国M2总量12万亿，中国M2总量22万亿，中国M2是1.83倍，看起来似乎人民币超发了。</p>

<p>但是美国基金行业总量17.8万亿美元，中国基金行业总量仅1.2万亿美元，美国国债规模12万亿美元，中国国债规模3万亿美元</p>

<p>美国的财富更多通过直接投资来体现，不体现在M2中，比如同样是购买债券，中国的模式是“个人存银行－》银行购买国债”，而美国的模式是“个人购买债券基金－》债券基金购买国债”或者“个人和机构直接购买国债”。</p>

<p>如果 <code>P＝M2+开放式基金余额＋国债余额</code></p>

<ul>
<li>P（美国）＝12+17.8+12=41.8</li>
<li>P（中国）＝22+3+1.2=26.2</li>
</ul>


<p>那么P（美国）／P（中国）＝1.6</p>

<p>这样看又是正常的</p>

<p>链接：<a href="https://xueqiu.com/5819606767/70273695">https://xueqiu.com/5819606767/70273695</a></p>

<h4>外汇占款理解</h4>

<ul>
<li><p>从<code>M0/外汇占款</code>来看，并没有超发；汇率也是正常的波动</p></li>
<li><p>从美国自己的M2膨胀来看，美元购买力其实下降了，我们的外汇占款发行方式其实吃了美国QE的亏，这是强势美元全世界割韭菜，怨不得央行</p></li>
</ul>


<h3>结论</h3>

<ul>
<li><p>央行对外通过购买美国国债对抗美元通胀，对内实行外汇占款为基础的本币发行，佐以发行国债冲销干预M2超发隐患，操作水平是非常高的，没有可黑的地方;</p></li>
<li><p>除去M2的统计差异，我们的M2/M0比值相对于美国过高；货币周转快，这是我们处于发展相对高速的周期决定的</p></li>
<li><p>美元的通胀和我们高速的货币周转共同造成了国内通胀压力，这不能全部甩锅货币政策</p></li>
<li><p>M2迅猛增长还是经济周期的大势决定，经济周期是逃不开的；</p></li>
<li><p>我们已经享受了很长时间的高增长繁荣，这是不可持续的，有繁荣就有衰落，平常心对待之</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Evolution of a Programmer]]></title>
    <link href="https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer/"/>
    <updated>2018-10-06T17:22:54+08:00</updated>
    <id>https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer</id>
    <content type="html"><![CDATA[<p>快有二十年的老段子了，最近又看到很多次，莫非是邪恶旧势力的崛起？存档一下。</p>

<!-- more -->


<h4>High School/Jr.High</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  10 PRINT "HELLO WORLD"
</span><span class='line'>  20 END</span></code></pre></td></tr></table></div></figure>


<h4>First year in College</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  program Hello(input, output)
</span><span class='line'>    begin
</span><span class='line'>      writeln('Hello World')
</span><span class='line'>    end.</span></code></pre></td></tr></table></div></figure>


<h4>Senior year in College</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  (defun hello
</span><span class='line'>    (print
</span><span class='line'>      (cons 'Hello (list 'World))))</span></code></pre></td></tr></table></div></figure>


<h4>New professional</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  void main(void)
</span><span class='line'>  {
</span><span class='line'>    char *message[] = {"Hello ", "World"};
</span><span class='line'>    int i;
</span><span class='line'> 
</span><span class='line'>    for(i = 0; i &lt; 2; ++i)
</span><span class='line'>      printf("%s", message[i]);
</span><span class='line'>    printf("\n");
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h4>Seasoned professional</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #include &lt;iostream.h&gt;
</span><span class='line'>  #include &lt;string.h&gt;
</span><span class='line'> 
</span><span class='line'>  class string
</span><span class='line'>  {
</span><span class='line'>  private:
</span><span class='line'>    int size;
</span><span class='line'>    char *ptr;
</span><span class='line'> 
</span><span class='line'>  string() : size(0), ptr(new char[1]) { ptr[0] = 0; }
</span><span class='line'> 
</span><span class='line'>    string(const string &s) : size(s.size)
</span><span class='line'>    {
</span><span class='line'>      ptr = new char[size + 1];
</span><span class='line'>      strcpy(ptr, s.ptr);
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    ~string()
</span><span class='line'>    {
</span><span class='line'>      delete [] ptr;
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    friend ostream &operator &lt;&lt;(ostream &, const string &);
</span><span class='line'>    string &operator=(const char *);
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  ostream &operator&lt;&lt;(ostream &stream, const string &s)
</span><span class='line'>  {
</span><span class='line'>    return(stream &lt;&lt; s.ptr);
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  string &string::operator=(const char *chrs)
</span><span class='line'>  {
</span><span class='line'>    if (this != &chrs)
</span><span class='line'>    {
</span><span class='line'>      delete [] ptr;
</span><span class='line'>     size = strlen(chrs);
</span><span class='line'>      ptr = new char[size + 1];
</span><span class='line'>      strcpy(ptr, chrs);
</span><span class='line'>    }
</span><span class='line'>    return(*this);
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  int main()
</span><span class='line'>  {
</span><span class='line'>    string str;
</span><span class='line'> 
</span><span class='line'>    str = "Hello World";
</span><span class='line'>    cout &lt;&lt; str &lt;&lt; endl;
</span><span class='line'> 
</span><span class='line'>    return(0);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h4>Master Programmer</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  [
</span><span class='line'>  uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
</span><span class='line'>  ]
</span><span class='line'>  library LHello
</span><span class='line'>  {
</span><span class='line'>      // bring in the master library
</span><span class='line'>      importlib("actimp.tlb");
</span><span class='line'>      importlib("actexp.tlb");
</span><span class='line'> 
</span><span class='line'>      // bring in my interfaces
</span><span class='line'>      #include "pshlo.idl"
</span><span class='line'> 
</span><span class='line'>      [
</span><span class='line'>      uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
</span><span class='line'>      ]
</span><span class='line'>      cotype THello
</span><span class='line'>   {
</span><span class='line'>   interface IHello;
</span><span class='line'>   interface IPersistFile;
</span><span class='line'>   };
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  [
</span><span class='line'>  exe,
</span><span class='line'>  uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
</span><span class='line'>  ]
</span><span class='line'>  module CHelloLib
</span><span class='line'>  {
</span><span class='line'> 
</span><span class='line'>      // some code related header files
</span><span class='line'>      importheader(&lt;windows.h&gt;);
</span><span class='line'>      importheader(&lt;ole2.h&gt;);
</span><span class='line'>      importheader(&lt;except.hxx&gt;);
</span><span class='line'>      importheader("pshlo.h");
</span><span class='line'>      importheader("shlo.hxx");
</span><span class='line'>      importheader("mycls.hxx");
</span><span class='line'> 
</span><span class='line'>      // needed typelibs
</span><span class='line'>      importlib("actimp.tlb");
</span><span class='line'>      importlib("actexp.tlb");
</span><span class='line'>      importlib("thlo.tlb");
</span><span class='line'> 
</span><span class='line'>      [
</span><span class='line'>      uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
</span><span class='line'>      aggregatable
</span><span class='line'>      ]
</span><span class='line'>      coclass CHello
</span><span class='line'>   {
</span><span class='line'>   cotype THello;
</span><span class='line'>   };
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>  #include "ipfix.hxx"
</span><span class='line'> 
</span><span class='line'>  extern HANDLE hEvent;
</span><span class='line'> 
</span><span class='line'>  class CHello : public CHelloBase
</span><span class='line'>  {
</span><span class='line'>  public:
</span><span class='line'>      IPFIX(CLSID_CHello);
</span><span class='line'> 
</span><span class='line'>      CHello(IUnknown *pUnk);
</span><span class='line'>      ~CHello();
</span><span class='line'> 
</span><span class='line'>      HRESULT  __stdcall PrintSz(LPWSTR pwszString);
</span><span class='line'> 
</span><span class='line'>  private:
</span><span class='line'>      static int cObjRef;
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>  #include &lt;windows.h&gt;
</span><span class='line'>  #include &lt;ole2.h&gt;
</span><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  #include &lt;stdlib.h&gt;
</span><span class='line'>  #include "thlo.h"
</span><span class='line'>  #include "pshlo.h"
</span><span class='line'>  #include "shlo.hxx"
</span><span class='line'>  #include "mycls.hxx"
</span><span class='line'> 
</span><span class='line'>  int CHello::cObjRef = 0;
</span><span class='line'> 
</span><span class='line'>  CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
</span><span class='line'>  {
</span><span class='line'>      cObjRef++;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
</span><span class='line'>  {
</span><span class='line'>      printf("%ws
</span><span class='line'>", pwszString);
</span><span class='line'>      return(ResultFromScode(S_OK));
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>  CHello::~CHello(void)
</span><span class='line'>  {
</span><span class='line'> 
</span><span class='line'>  // when the object count goes to zero, stop the server
</span><span class='line'>  cObjRef--;
</span><span class='line'>  if( cObjRef == 0 )
</span><span class='line'>      PulseEvent(hEvent);
</span><span class='line'> 
</span><span class='line'>  return;
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  #include &lt;windows.h&gt;
</span><span class='line'>  #include &lt;ole2.h&gt;
</span><span class='line'>  #include "pshlo.h"
</span><span class='line'>  #include "shlo.hxx"
</span><span class='line'>  #include "mycls.hxx"
</span><span class='line'> 
</span><span class='line'>  HANDLE hEvent;
</span><span class='line'> 
</span><span class='line'>   int _cdecl main(
</span><span class='line'>  int argc,
</span><span class='line'>  char * argv[]
</span><span class='line'>  ) {
</span><span class='line'>  ULONG ulRef;
</span><span class='line'>  DWORD dwRegistration;
</span><span class='line'>  CHelloCF *pCF = new CHelloCF();
</span><span class='line'> 
</span><span class='line'>  hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
</span><span class='line'> 
</span><span class='line'>  // Initialize the OLE libraries
</span><span class='line'>  CoInitializeEx(NULL, COINIT_MULTITHREADED);
</span><span class='line'> 
</span><span class='line'>  CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,
</span><span class='line'>      REGCLS_MULTIPLEUSE, &dwRegistration);
</span><span class='line'> 
</span><span class='line'>  // wait on an event to stop
</span><span class='line'>  WaitForSingleObject(hEvent, INFINITE);
</span><span class='line'> 
</span><span class='line'>  // revoke and release the class object
</span><span class='line'>  CoRevokeClassObject(dwRegistration);
</span><span class='line'>  ulRef = pCF-&gt;Release();
</span><span class='line'> 
</span><span class='line'>  // Tell OLE we are going away.
</span><span class='line'>  CoUninitialize();
</span><span class='line'> 
</span><span class='line'>  return(0); }
</span><span class='line'> 
</span><span class='line'>  extern CLSID CLSID_CHello;
</span><span class='line'>  extern UUID LIBID_CHelloLib;
</span><span class='line'> 
</span><span class='line'>  CLSID CLSID_CHello = { /* 2573F891-CFEE-101A-9A9F-00AA00342820 */
</span><span class='line'>      0x2573F891,
</span><span class='line'>      0xCFEE,
</span><span class='line'>      0x101A,
</span><span class='line'>      { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  UUID LIBID_CHelloLib = { /* 2573F890-CFEE-101A-9A9F-00AA00342820 */
</span><span class='line'>      0x2573F890,
</span><span class='line'>      0xCFEE,
</span><span class='line'>      0x101A,
</span><span class='line'>      { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  #include &lt;windows.h&gt;
</span><span class='line'>  #include &lt;ole2.h&gt;
</span><span class='line'>  #include &lt;stdlib.h&gt;
</span><span class='line'>  #include &lt;string.h&gt;
</span><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  #include "pshlo.h"
</span><span class='line'>  #include "shlo.hxx"
</span><span class='line'>  #include "clsid.h"
</span><span class='line'> 
</span><span class='line'>  int _cdecl main(
</span><span class='line'>  int argc,
</span><span class='line'>  char * argv[]
</span><span class='line'>  ) {
</span><span class='line'>  HRESULT  hRslt;
</span><span class='line'>  IHello        *pHello;
</span><span class='line'>  ULONG  ulCnt;
</span><span class='line'>  IMoniker * pmk;
</span><span class='line'>  WCHAR  wcsT[_MAX_PATH];
</span><span class='line'>  WCHAR  wcsPath[2 * _MAX_PATH];
</span><span class='line'> 
</span><span class='line'>  // get object path
</span><span class='line'>  wcsPath[0] = '\0';
</span><span class='line'>  wcsT[0] = '\0';
</span><span class='line'>  if( argc &gt; 1) {
</span><span class='line'>      mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
</span><span class='line'>      wcsupr(wcsPath);
</span><span class='line'>      }
</span><span class='line'>  else {
</span><span class='line'>      fprintf(stderr, "Object path must be specified\n");
</span><span class='line'>      return(1);
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  // get print string
</span><span class='line'>  if(argc &gt; 2)
</span><span class='line'>      mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
</span><span class='line'>  else
</span><span class='line'>      wcscpy(wcsT, L"Hello World");
</span><span class='line'> 
</span><span class='line'>  printf("Linking to object %ws\n", wcsPath);
</span><span class='line'>  printf("Text String %ws\n", wcsT);
</span><span class='line'> 
</span><span class='line'>  // Initialize the OLE libraries
</span><span class='line'>  hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);
</span><span class='line'> 
</span><span class='line'>  if(SUCCEEDED(hRslt)) {
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>      hRslt = CreateFileMoniker(wcsPath, &pmk);
</span><span class='line'>      if(SUCCEEDED(hRslt))
</span><span class='line'>   hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&pHello);
</span><span class='line'> 
</span><span class='line'>      if(SUCCEEDED(hRslt)) {
</span><span class='line'> 
</span><span class='line'>   // print a string out
</span><span class='line'>   pHello-&gt;PrintSz(wcsT);
</span><span class='line'> 
</span><span class='line'>   Sleep(2000);
</span><span class='line'>   ulCnt = pHello-&gt;Release();
</span><span class='line'>   }
</span><span class='line'>      else
</span><span class='line'>   printf("Failure to connect, status: %lx", hRslt);
</span><span class='line'> 
</span><span class='line'>      // Tell OLE we are going away.
</span><span class='line'>      CoUninitialize();
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  return(0);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h4>Apprentice Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #!/usr/local/bin/perl
</span><span class='line'>  $msg="Hello, world.\n";
</span><span class='line'>  if ($#ARGV &gt;= 0) {
</span><span class='line'>    while(defined($arg=shift(@ARGV))) {
</span><span class='line'>      $outfilename = $arg;
</span><span class='line'>      open(FILE, "&gt;" . $outfilename) || die "Can't write $arg: $!\n";
</span><span class='line'>      print (FILE $msg);
</span><span class='line'>      close(FILE) || die "Can't close $arg: $!\n";
</span><span class='line'>    }
</span><span class='line'>  } else {
</span><span class='line'>    print ($msg);
</span><span class='line'>  }
</span><span class='line'>  1;</span></code></pre></td></tr></table></div></figure>


<h4>Experienced Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  #define S "Hello, World\n"
</span><span class='line'>  main(){exit(printf(S) == strlen(S) ? 0 : 1);}</span></code></pre></td></tr></table></div></figure>


<h4>Seasoned Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % cc -o a.out ~/src/misc/hw/hw.c
</span><span class='line'>  % a.out</span></code></pre></td></tr></table></div></figure>


<h4>Guru Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % echo "Hello, world."</span></code></pre></td></tr></table></div></figure>


<h4>New Manager</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  10 PRINT "HELLO WORLD"
</span><span class='line'>  20 END</span></code></pre></td></tr></table></div></figure>


<h4>Middle Manager</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  mail -s "Hello, world." bob@b12
</span><span class='line'>  Bob, could you please write me a program that prints "Hello, world."?
</span><span class='line'>  I need it by tomorrow.
</span><span class='line'>  ^D</span></code></pre></td></tr></table></div></figure>


<h4>Senior Manager</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % zmail jim
</span><span class='line'>  I need a "Hello, world." program by this afternoon.</span></code></pre></td></tr></table></div></figure>


<h4>Chief Executive</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % letter
</span><span class='line'>  letter: Command not found.
</span><span class='line'>  % mail
</span><span class='line'>  To: ^X ^F ^C
</span><span class='line'>  % help mail
</span><span class='line'>  help: Command not found.
</span><span class='line'>  % damn!
</span><span class='line'>  !: Event unrecognized
</span><span class='line'>  % logout</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个经典的排障故事]]></title>
    <link href="https://happy123.me/blog/2018/10/04/liang-ge-jing-dian-de-pai-zhang-gu-shi/"/>
    <updated>2018-10-04T21:48:57+08:00</updated>
    <id>https://happy123.me/blog/2018/10/04/liang-ge-jing-dian-de-pai-zhang-gu-shi</id>
    <content type="html"><![CDATA[<p>很久之前就在某杂志上看过，不久前在知乎<a href="https://www.zhihu.com/question/21747929">有哪些让你目瞪口呆的 bug</a>里面又见到了；我觉得这两个troubleshooting的case有很深的道理在里面，记一下。</p>

<h3>电子邮件无法发送到500英里以外</h3>

<!-- more -->


<p>这个故事最早出现于2002年11月24日，而且每过若干年，它就会在不同的系统管理技术社区中再次出现，并且引发人们的热议和关注。有人对这个故事给出了这样的评价：</p>

<blockquote><p>这个故事大约每过三年或四年就会在系统管理社区出现，每次我读到它，都觉得很值得一读。即便在正常环境下已经做过检查，甚或经过片刻思考之后，我还是高度怀疑这种事情是否会发生在自己身上。</p></blockquote>

<p>这是一个真实的故事。如果你想要进一步了解它的相关信息，可以访问这个 <a href="http://www.ibiblio.org/harris/500milemail-faq.html">FAQ</a> &ndash; 一个关于本故事的常见问题列表，由本故事作者 Trey Harris 编写。</p>

<p>这个故事听起来有点儿天方夜谭的感觉&hellip; 我已经有些后悔把这个故事分享给大家了，因为它很可能会沦为众人茶余饭后的谈资。:&ndash;) 为了保护自己的内疚感，我对故事做了稍许改动，省略了无关紧要以及无聊的细节，总之让故事变得更加生动有趣了。</p>

<p>几年以前，我在一家运营校园邮件系统的公司工作。有一天，我接到了来自统计部主任给我的电话。</p>

<p>“我们的邮件系统存在一个问题。”</p>

<p>“什么问题？” 我问道。</p>

<p>“我们不能发送超过500英里距离的邮件，” 主任解释说。</p>

<p>我被手中的拿铁咖啡呛着了。“再说一遍？”</p>

<p>“我们不能把邮件发送到超过500英里距离的地方，” 他重复道。“真的，哪怕再远一点点。只能到达520英里，不能再远了。”</p>

<p>“嗯&hellip;通常来说，邮件真的不是按照这种方式来发送的，” 我说道，并尽力让自己的声音平静下来。一个人与部门主任谈话时通常不会带有恐慌情绪，即使是一个相对无实权的部门如统计部。“是什么让你认为邮件不能发送超过500英里之外的？”</p>

<p>“并非我这么认为，” 主任不耐烦地回答道。“你瞧，几天之前我们就发现了这一现象&hellip;”</p>

<p>“你等了好几天了？” 我打断他的话，声音有些颤抖地问道，“这段时间你都不能发送邮件吗？”</p>

<p>“我们能发邮件，只要不超过&hellip;”</p>

<p>“500英里，是吧，” 我替他补充道，“我知道了。但是为什么你不早点给我电话呢？”</p>

<p>“好吧，问题是直到刚才，我们才收集到足够的证据确定这一现象的发生。” 也对，他是统计部主任。“总之，我让一名地理统计人员去调查了这件事情&hellip;”</p>

<p>“地理统计人员&hellip;”</p>

<p>“是的，她制作了一张地图，地图上显示我们能发送邮件的区域半径比500英里多那么一点点。即便如此，这个半径区域之内的有些地方也不能发送，或者偶发性地能发送，但是在半径区域之外从来没有发送成功过。”</p>

<p>“我明白了，” 我说道，“何时开始的？你说几天之前，那么这段时间内系统发生什么改变了吗？”</p>

<p>“是的，技术服务人员来过，给服务器打了补丁然后重启了系统。但是我给他去过电话，他说他没碰邮件系统。”</p>

<p>“好的，我先看看吧，然后再给你打过去，” 我说，几乎不相信我也会来虚与委蛇这一套。今天不是愚人节啊。我试着去回忆，是不是有人欠我一个恶作剧。</p>

<p>我登进他们部门的服务器，发了一封测试邮件。这是发送到北卡罗莱纳州的三角研究实验，测试邮件很顺利地到达我的邮箱。同前面一样，我又发送到里士满、亚特兰大、华盛顿，还有普林斯顿（400英里），都能顺利到达。</p>

<p>但是当我尝试发送邮件到孟菲斯（600英里）时，却失败了。发往波士顿，失败了。发往底特律，同样是失败。我拿出我的地址薄，开始试图缩小范围。纽约（420英里）可以发送，但是普罗维登斯（580英里）就失败了。</p>

<p>我开始困惑，是不是我失去了理智。我试着给我一位居住在北卡罗来纳州的朋友发送邮件，他的 ISP（网络服务提供商）在西雅图。谢天谢地，发送失败了。如果这个问题只和收件人的居住位置有关，而不是和他（她）的邮件服务器有关的话，我想我真该泪奔了。</p>

<p>问题得以确认，尽管令人难以置信，但问题确实存在而且可以重现。我查看了 sendmail.cf 文件，它看起来很正常，没有任何问题。事实上，它看起来很熟悉。</p>

<p>我将这个文件和我本机 home 目录下的 sendmail.cf 文件进行了比对。二者没有什么不同，这个文件就是我自己写的。我也确信没有启用 “FAIL_MAIL_OVER_500_MILES” 这一选项。带着满腹困惑，我远程登录到 SMTP 端口。服务器使用一个 SunOS sendmail 标识愉快地做出了响应。</p>

<p>等等&hellip; 一个 SunOS sendmail 标识？在那时，Sun 仍然随同操作系统捆绑发布 Sendmail 5 版本，尽管 Sendmail 8 已经相当成熟了。作为一名优秀的系统管理员，我已经把 Sendmail 8 作为一个标配了。同时，作为一名优秀系统管理员，我写了一个 sendmail.cf 配置文件，使用了 Sendmail 8 中优雅详细且自我描述的选项和变量名，而不是 Sendmail 5 中含义模糊的标点符号标记的代码。</p>

<p>一切都水落石出了，突然间，我被那杯现已冷的掉渣的拿铁咖啡再次被呛到了。当那名技服给服务器打补丁的时候，很显然他也升级了 SunOS 的版本，如此一来自然把 Sendmail 的版本“降级”了。升级程序将 sendmail.cf 配置文件单独保留了下来，即使它现在对应的是错误的版本。</p>

<p>碰巧的是 Sendmail 5（至少 Sun 发布的版本，或许做过一些调整）可以处理 Sendmail 8 的 sendmail.cf 配置文件，因为大多数的规则在那时并没有改变。但是对于那些在 Sendmail 8 中新增的长配置项，Sendmail 5 将之视为垃圾而忽略掉了。sendmail 的二进制安装包对大多数选项没有提供默认值，因此，如果在 sendmail.cf 中找不到合适的设置，它们就会被设为0。</p>

<p>这些被设为0的选项之一就是连接远程 SMTP 服务器的超时时间。一些试验已经证实，在一个具有典型负载的特定机器上，零超时意味着如果连接时间稍微超过3毫秒，服务器就会终止连接。</p>

<p>当时我们的校园网络有一个很奇怪的特点，它是百分之百交换型网络。发送出去的数据包，在遇到 POP 服务器和远端路由器之前，不会出现路由器延迟。因此，连接到临近网络上负载较轻的服务器所花的时间，很大程度上是由光速决定的，而不是偶发的路由器延迟。</p>

<p>这可真是让人有点儿眼花缭乱啊，我在 shell 里敲入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ units
</span><span class='line'>1311 units, 63 prefixes
</span><span class='line'>
</span><span class='line'>You have: 3 millilightseconds  
</span><span class='line'>You want: miles  
</span><span class='line'>        * 558.84719
</span><span class='line'>        / 0.0017893979
</span><span class='line'>
</span><span class='line'>"500 miles, or a little bit more."</span></code></pre></td></tr></table></div></figure>


<p>原文:</p>

<p><a href="http://www.ibiblio.org/harris/500milemail.html">http://www.ibiblio.org/harris/500milemail.html</a></p>

<h3>地板阻碍打印</h3>

<p>那还是80年代初期，我爸爸在一家存储设备公司工作，这个公司现在已经不存在了，它生产磁带机和驱动这些磁带高速运转的气动系统 —— 这是那个时代的产物。</p>

<p>他们技术改造了磁带驱动器，使得你可以只有一个中心驱动器 —— “A”盘 —— 由它连接着数个“B”盘，在跟A盘连接的内存里驻留这一个小型的操作系统，负责代理所有B盘的数据的读写操作。</p>

<p>每次当你启动A驱动器，你需要在外围驱动器里插入一张软盘，操作系统会把A盘加载到内存里。这个操作系统简单的出奇 —— 它的处理能力全部从一个8字节的微型控制器产生。</p>

<p>这种设备的目标用户是拥有大量数据的企业 —— 银行，杂志等等 —— 他们需要打印大量的地址簿或银行帐目。</p>

<p>有个客户出现了一个问题。在打印的过程中，有个别的驱动器会停止工作，导致整个打印过程终止。为了重载驱动器，值班人员必须重启所有驱动 —— 如果这种事情发生在一个6小时的打印任务中，大量宝贵的计算机使用时间都会浪费，整个任务将不能按时间完成。</p>

<p>公司派出了技术人员。技术人员尽了他最大的努力也不能在测试环境复制出这个问题：这个问题似乎只会出现在打印大量任务的过程中。尽管问题出在硬件上可能性微乎其微，他还是更换了所有的设备 —— 内存，微处理器，磁盘驱动，所有跟磁带机相关的部件 —— 但问题仍然出现。</p>

<p>于是技术人员打电话给总部叫来了一位专家。</p>

<p>专家要了一把椅子和一杯咖啡，坐在了计算机房 —— 那个时候他们已经专门为计算机提供了机房 —— 值班人员准备了一大堆的打印任务，他就在旁边看着。他等着，一直到机器崩溃。机器果真崩溃了，所有人都看着专家 —— 专家没有发现任何的线索。他命令把打印任务重新执行一次，所有的值班人员和技术人员都回各自岗位工作。</p>

<p>专家又在椅子上做下来，等着机器崩溃。这一等就是六小时，但真的又发生了。专家仍然没有弄清是什么导致了崩溃 —— 除了有一点他注意到，崩溃总是发生在屋内人比较多的时候。他命令再打印一次，重新坐下，等着。</p>

<p>当第三次崩溃时，他发现了一件事情。崩溃总是在值班人员更换其他没有关联的启动盘时发生的。进一步研究，他意识到当一个值班人员走过某块地板时崩溃就会发生。</p>

<p>地板是由铝制的板块拼成，下面有6 到 8 英寸高的隔空层，计算机所使用的大量的电缆都走地板下，这样可以避免值班人员无意间踢到它们。地板块间拼合的很紧密，这是为了保证垃圾不掉进电缆通过的空间。</p>

<p>专家说有一块地板变形了。当值班人员踩着这块变形的地板的一角时，地板块的边缘相互摩擦，这就会跟连接各地板的塑料之间产生静电，进而造成电磁干扰。</p>

<p>如今所有的RAM都有防电磁干扰功能。但当时并没有这种技术。专家指出，电磁干扰破坏的RAM的工作，操作系统也就崩溃了。</p>

<p>专家打电话给维护部门，拿来了一块新地板，他自己把它装上，问题就这样解决了。</p>

<p>原文:</p>

<p><a href="http://patrickthomson.tumblr.com/post/2499755681/the-best-debugging-story-ive-ever-heard">http://patrickthomson.tumblr.com/post/2499755681/the-best-debugging-story-ive-ever-heard</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用wireshark分析网络]]></title>
    <link href="https://happy123.me/blog/2018/10/02/yong-wiresharkfen-xi-wang-luo/"/>
    <updated>2018-10-02T21:36:37+08:00</updated>
    <id>https://happy123.me/blog/2018/10/02/yong-wiresharkfen-xi-wang-luo</id>
    <content type="html"><![CDATA[<p>这两天看了两本有意思的书，<a href="https://book.douban.com/subject/26268767/">《Wireshark网络分析就这么简单》</a>、<a href="https://book.douban.com/subject/26710788/">《wireshark网络分析的艺术》</a>。</p>

<p>之前工作中就常常用到这个软件，好多时候总是感叹<code>这个软件实在太NB了</code>，这本书作者也是个实战派，采用种种案例展示了如何用Wireshark探索网络现象，实在是很迷人。</p>

<p>开篇有一个很有意思的小问题，我思考了一下，觉得很容易作为网络理解的小case用在课堂ABC上，记录一下。</p>

<!-- more -->


<h3>问题：两台服务器A和B的网络配置如下</h3>

<ul>
<li><p>服务器A:</p>

<ul>
<li>IP:192.168.26.129</li>
<li>Mask: 255.255.255.0</li>
<li>Gateway: 192.160.26.2</li>
</ul>
</li>
<li><p>服务器B:</p>

<ul>
<li>IP:192.168.26.3</li>
<li>Mask: 255.255.255.224</li>
<li>Gateway: 192.160.26.2</li>
</ul>
</li>
</ul>


<p>B的子网掩码本应该是255.255.255.0，被不小心配成了255.255.255.224。它们还能正常通信吗？</p>

<p>哈哈，我就喜欢这样简单明快的问题。看似简单，其实想想还是有点陷阱的。而且这种问题有个共同点，就是如果你不懂原理，也没关系；喜欢瞎动手的童鞋一般都会去试试这种情况，所以能把答案<code>碰出来</code>。我就见到过这种·自学成才·的老师，他们从来没有在学校里系统学过什么TCP/IP或者老破旧的ISO 7层模型，照样能对网络和路由配置如数家珍，他们的能力完全建立在实战的基础上。</p>

<p>让我们好好分析一下这个问题。</p>

<p>首先B的子网掩码配置决定了它和A不在一个子网上，我们在书本上学到的知识，如果两台机器不在一个子网上，能够通信吗？</p>

<p>哈，如果死读书不实践的人肯定会说:不能通信，不在一个子网嘛。</p>

<p>那么我们照这个逻辑，公司里岂不是不同子网的机器老死不相往来了？</p>

<h4>看吧，这是第一个陷阱，两台机器跨子网能否通信，取决于网关。</h4>

<p>如果没有网关服务器，或者网关服务器限制的话，肯定是不能通信的，虽然A和B物理上处于同一个子网，但是这个时候可以看成有一道防火墙在两台机器之间。</p>

<h4>其实大部分网络管理员都会把网关设置为不同子网间相互转发的，不然一个公司各部门间的机器不能互访，岂不是很悲剧。</h4>

<p>那么在网关能正常转发的情况下，我们来脑补一下两个场景，B访问A，A访问B的具体过程。</p>

<h4>B Ping => A</h4>

<ol>
<li>B首先检查到A和它不在一个子网，这个时候它需要网关来转发数据包</li>
<li>B发一个网关IP的ARP请求</li>
<li>网关(192.168.26.2) 回复B的ARP请求，告诉它俺的MAC 地址是XXX</li>
<li>有了网关的MAC，B就可以直接发包给网关了，它告诉网关，我要你帮我转发包给A</li>
<li>如果网关没有限制的话，它就会把包转发给A</li>
<li>A收到B的请求，他就会问，这个B是谁呀？A检查一番，发现B和自己在一个子网</li>
<li>既然一个子网，那么A就不会走网关了，它直接发出ARP请求在以太网上广播，谁是B呀，MAC地址回我一个</li>
<li>B在物理上实际上是和A在一起的，所以直接响应A，俺的MAC地址是这个</li>
<li>A收到B的ARP响应，就很HAPPY的跳过网关，直接给B响应包啦</li>
<li>这样的结果就是B发给A的包需要走网关，A发给B的包直接广播到以太网上，由B直接接收</li>
<li>最终的效果就是B能和A正常通信，虽然B的通信绕了一点远路</li>
</ol>


<h4>A Ping => B</h4>

<p>这个过程其实跟上面一样，A发出ARP请求直接找到了B，所以A发包给B是不用走网关的，B的响应还要走网关。</p>

<p>怎么样，这么看看，是不是问题就很明晰了呢。大部分情况下(网关没有特殊配置)，A和B是能够正常通信的。</p>

<p>有点小得意的说，这个问题我很快就反应过来了；因为我和作者一样是野路子出家，实战瞎鼓捣过，所以这类小Case恰好是尝过的菜。</p>

<p>咳咳，真是有点自吹自擂了；其实绝大多数网络问题最后找到原因都很简单，但是当一个大型的网络里面发生诡异的情况时，能迅速定位问题点是很不容易的。我又回想起来之前工作时，在一个客户现场遇到的坑。</p>

<h4>很久很久以前~~~</h4>

<p>咳咳，其实也不是多久，但那个时候我已经工作挺长时间了，虽然没有经过什么系统理论培训，但是靠着大量野路子实践，我觉得也算是见过很多网络万年坑了，我去客户现场从来不怵头，但就是那一次，差点阴沟里翻船~~</p>

<p>我去国内的某家大型券商部署项目，那家券商真是壕啊，从服务器到网络设备都是定制的特别高端的一批货，然后我熟门熟路的安装好Centos7.1，他们的系统管理员按照内部规定，做了安全防护之后，我们从他们的顶层小机房转移到操作办公室，准备部署应用软件。</p>

<p>这家券商的网络大部分已经迁移到SDN上面，办公室的终端机器经过两层跳板，跳到一个云主机的shell上面，然后再远程ssh连接到我们刚刚装好的服务器上，准备大展拳脚~~~~</p>

<p>根据故事的发展，这个时候就出现了诡异的事情，随机过20~40分钟后，我们的ssh连接就会卡一段时间，然后有几率断掉，之前所有工作都是正常的，而且有时候能正常个1小时，但是最后总是会开始卡。</p>

<p>唉，网络卡死，网络时不时断掉，真的是现场网络工程师人生中的一大悲剧，这类问题感觉天天遇见，但是总是没有一个固定的套路去解决它。</p>

<p>我们的终端机经过了两重跳板，然后ssh客户端和服务器之间，还有一个庞大的网络拓扑，跋山涉水十万八千里才能相见，然后就被某个不知名的幽灵生生拆散了，想象他们艰难的会师路径，我不禁打个冷颤。</p>

<h4>肯定不能先去怀疑他们的会师历程，我们先去查找最简单的，也是最容易出错的部分，就是服务端的sshd配置</h4>

<p>因为安装完系统后，客户的管理员根据他们的安全管理条例，运行了自己开发一个脚本进行了系统加固，很自然的，我们怀疑这个脚本是不是有什么地方配置不对，导致问题</p>

<p>在对服务器配置文件和脚本代码详细检查之后，我失望的判定，人家的脚本没问题</p>

<h4>配置没有问题，那就看看是不是ssh终端软件有问题呢</h4>

<p>我反复使用ssh登陆不同的服务器，惊奇的发现，凡是登陆我们刚安装好的这批服务器，就会时不时断掉，其它服务器就没有问题；
但是悲剧的是我们的服务器所在的机房，没有其它测试机，所以只能证明ssh终端软件没问题</p>

<h4>不到万不得已，我是不想怀疑中间庞大的网络路径的，谁知道是不是什么抽风的防火墙规则呢</h4>

<h4>我抱着笔记本，跑到楼上服务器的小机房直联看看，发现直联好得很</h4>

<p>现在说起来简单，其实跑一趟机房需要审批、内部人员带路一堆手续，累的客户跟我上上下下，验证一次需要1个小时以上，而且重现时间是随机的，这就是一线人员苦逼的地方啊。</p>

<h4>看起来一切都导向那个我最不愿意看到的结果，好像是通信中间有个什么诡异的防火墙规则之类的~~，但是这么庞大的网络拓扑，怎么定位问题呢？</h4>

<h4>到了此时，客户不再纠结于安全管理条例，我们小心翼翼的祭出了·抓包·这个手段</h4>

<ul>
<li><p>不到万不得已，其实大家都不想抓包的；金融行业的客户群，重视安全问题甚于生命，所以能在生产环境中让你抓包，其实已经是皇恩浩荡了。</p></li>
<li><p>经过了几十分钟苦苦等待，终于问题又重现了，我们小心翼翼的把抓到的包存到本地，用wireshark打开，像欣赏小电影一样仔仔细细~~~</p></li>
<li><p>果然有问题，那台服务器的ARP响应包里面，MAC地址竟然会变！</p></li>
<li><p>奇哉怪哉，我们刚配好这台服务器，怎么就让人ARP欺骗了呢？而且如果是他们的网络里面有ARP病毒，为啥就只找我们的服务器呢？</p></li>
</ul>


<h4>当时已经从早上折腾到下午3点种左右，虽然有了重大发现，但是也有了更大的迷惑</h4>

<p>突然我灵光一闪，服务器接了两根网线，一根是管理口为了方便管理，这个一直没有动过，会不会是~~~</p>

<p>我立马报着笔记本和一台小交换机跑上楼去</p>

<h4>将服务器和笔记本通过一台小交换机联到一个小局域网络中，再抓包发现了真相</h4>

<p>这台定制的服务器是浪潮提供的，而浪潮的管理口有个奇怪的设定，它和服务器上的多个网卡被绑定成一个NIC Teaming，类型为Transmit Load Balancing（TLB）。TLB的特点就是收包工作只由一个网卡负责，发包工作则分摊给所有网卡，但是管理口的默认配置有问题，有时候莫名其妙会共享同一个IP，回应ARP请求的时候把自己的MAC地址发回去，但是系统中管理口是没有配置的，所以这台服务器莫名其妙就自己变成了一台ARP欺骗源。</p>

<p>问题定位了，我们打电话找浪潮的供应商；供应商也非常奇怪，表明是第一次碰到这种问题，可能是由于定制的机器，考虑不周导致的。</p>

<p>然后我们的解决方法就是，将笔记本直联服务器，在笔记本上运行一个DHCP 服务，这样管理口在开机的时候会被分配一个IP地址，我们再通过这个IP地址登陆服务器管理界面，配置一个静态IP，就OK了。</p>

<p>虽然最后是一个简单至极的ARP欺骗问题，但是发生在一个庞大的网络拓扑中，调试手段被限制，发生时间随机，楼上物理距离和安全条例导致你重现一次成本极为高昂，你还能·镇定自若，指挥谈笑间·吗，这是一次一波三折的排障经历啊。</p>

<p>我这么详细的回忆一次折腾的排障经历，是因为我在这本书里发现了作者和我一模一样的苦逼例子，在&lt;wireshark网络分析的艺术>这本书里，大家有兴趣可以自己去翻翻。</p>

<p>其实这两本书真可谓是作者的网络排障手记，因为我也有那么一段跑在一线的日子，读起来格外亲切。这就是一线工程师的日常啊。</p>

<p>曾经，我以为熟读&lt;TCP/IP详解>和&lt;Unix网络编程>就能成为无所不能的网络大拿；曾经，我以为独立实现一个网络协议栈就是开创天地的神邸；后来，我明白了，网络的海洋无穷无尽，虽然规则是死的，但是现实世界实在不可预测，也许下一分钟就会有一个匪夷所思的case来纠缠你，嘲笑你的妄自尊大。</p>

<p>在网络世界迈入SDN之际，我非常惶恐，因为我明白以我的智商，不可能成为什么·专家·了；我想，未来，可能只有在AWS或者Google Cloud浸淫数十年的人，才能小心翼翼的称自己为·真专家·；面对网络知识的变幻莫测，总有一种·生有涯，知无涯·的惶恐；我总是会感叹，网络这个东西实在是太神奇了，真不知道如何形容这份感觉，就是只有·神奇·来形容</p>
]]></content>
  </entry>
  
</feed>
