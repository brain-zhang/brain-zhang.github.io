<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-08-03T20:41:30+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import ctypes
</span><span class='line'>import logging
</span><span class='line'>
</span><span class='line'>try:
</span><span class='line'>    ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</span><span class='line'>except Exception:
</span><span class='line'>    ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</span><span class='line'>
</span><span class='line'>def check_result(val, func, args):
</span><span class='line'>    if val == 0:
</span><span class='line'>        raise ValueError
</span><span class='line'>    else:
</span><span class='line'>        return ctypes.c_void_p(val)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'># ssl_library.EC_KEY_new.restype = ctypes.c_void_p
</span><span class='line'>ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
</span><span class='line'>ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result
</span><span class='line'>
</span><span class='line'>k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)
</span><span class='line'>
</span><span class='line'>if ssl_library.EC_KEY_generate_key(k) != 1:
</span><span class='line'>    raise Exception("internal error")
</span><span class='line'>ssl_library.EC_KEY_free(k)</span></code></pre></td></tr></table></div></figure>


<p>这段代码在多线程的时候会出现segmentation fault error； 是openssl1.0.0的实现问题，参考:</p>

<p><a href="https://bugs.python.org/issue29340">https://bugs.python.org/issue29340</a></p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒LXC技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->


<h2>文档操作</h2>

<h4>增加一条记录</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PUT /website/_doc/1
</span><span class='line'>{
</span><span class='line'>  "title": "My 2 blog entry",
</span><span class='line'>  "text":  "I am starting to get the hang of this...",
</span><span class='line'>  "date":  "2014/01/02"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>修改</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POST /website/_update/1
</span><span class='line'>{
</span><span class='line'>   "doc" : {
</span><span class='line'>      "tags" : [ "testing..." ],
</span><span class='line'>      "views": 0
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>查询</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>
</span><span class='line'>GET /website/_source/1
</span><span class='line'>
</span><span class='line'>GET /website/_mget 
</span><span class='line'>{
</span><span class='line'>    "ids" : [ "2", "1" ]    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>GET /_search
</span><span class='line'>{
</span><span class='line'>    "query": YOUR_QUERY_HERE
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>删除</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DELETE /website/_doc/1</span></code></pre></td></tr></table></div></figure>


<h2>文档功能API</h2>

<h4>获取映射信息</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_mapping</span></code></pre></td></tr></table></div></figure>


<h4>测试分析器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_analyze
</span><span class='line'>{
</span><span class='line'>  "field": "tweet",
</span><span class='line'>  "text": "Black-cats" 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>多层级对象用扁平化的方法来存储，比如</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "gb": {
</span><span class='line'>    "tweet": { 
</span><span class='line'>      "properties": {
</span><span class='line'>        "tweet":            { "type": "string" },
</span><span class='line'>        "user": { 
</span><span class='line'>          "type":             "object",
</span><span class='line'>          "properties": {
</span><span class='line'>            "id":           { "type": "string" },
</span><span class='line'>            "gender":       { "type": "string" },
</span><span class='line'>            "age":          { "type": "long"   },
</span><span class='line'>            "name":   { 
</span><span class='line'>              "type":         "object",
</span><span class='line'>              "properties": {
</span><span class='line'>                "full":     { "type": "string" },
</span><span class='line'>                "first":    { "type": "string" },
</span><span class='line'>                "last":     { "type": "string" }
</span><span class='line'>              }
</span><span class='line'>            }
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>会被转换为如下内部对象:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "tweet":            [elasticsearch, flexible, very],
</span><span class='line'>    "user.id":          [@johnsmith],
</span><span class='line'>    "user.gender":      [male],
</span><span class='line'>    "user.age":         [26],
</span><span class='line'>    "user.name.full":   [john, smith],
</span><span class='line'>    "user.name.first":  [john],
</span><span class='line'>    "user.name.last":   [smith]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2>查询</h2>

<h4>查询语句的结构</h4>

<ul>
<li>一个查询语句 的典型结构：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    QUERY_NAME: {
</span><span class='line'>        ARGUMENT: VALUE,
</span><span class='line'>        ARGUMENT: VALUE,...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>如果是针对某个字段，那么它的结构如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    QUERY_NAME: {
</span><span class='line'>        FIELD_NAME: {
</span><span class='line'>            ARGUMENT: VALUE,
</span><span class='line'>            ARGUMENT: VALUE,...
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一条复合语句</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "bool": {
</span><span class='line'>        "must": { "match":   { "email": "business opportunity" }},
</span><span class='line'>        "should": [
</span><span class='line'>            { "match":       { "starred": true }},
</span><span class='line'>            { "bool": {
</span><span class='line'>                "must":      { "match": { "folder": "inbox" }},
</span><span class='line'>                "must_not":  { "match": { "spam": true }}
</span><span class='line'>            }}
</span><span class='line'>        ],
</span><span class='line'>        "minimum_should_match": 1
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>实战查询</h4>

<ul>
<li>精确查询</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>  "query": {
</span><span class='line'>    "constant_score" : {
</span><span class='line'>      "filter":{
</span><span class='line'>        "term": {
</span><span class='line'>          "title": "helloworld"
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>多词组合</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>    "query": {
</span><span class='line'>        "match": {
</span><span class='line'>            "title": {      
</span><span class='line'>                "query":    "BROWN DOG!",
</span><span class='line'>                "operator": "and"
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>短语匹配</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>    "query": {
</span><span class='line'>        "match_phrase": {
</span><span class='line'>            "title": "quick brown fox"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>混合短语匹配</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>    "query": {
</span><span class='line'>        "match_phrase": {
</span><span class='line'>            "title": {
</span><span class='line'>                "query": "quick fox",
</span><span class='line'>                "slop":  1
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>正则查询 (性能慢)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /my_index/_search
</span><span class='line'>{
</span><span class='line'>    "query": {
</span><span class='line'>        "wildcard": {
</span><span class='line'>            "postcode": "W?F*HW" 
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>智能匹配</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /my_index/_search
</span><span class='line'>{
</span><span class='line'>    "query": {
</span><span class='line'>        "match_phrase_prefix" : {
</span><span class='line'>            "brand" : {
</span><span class='line'>                "query":          "johnnie walker bl",
</span><span class='line'>                "max_expansions": 50
</span><span class='line'>                }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>控制精度</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>  "query": {
</span><span class='line'>    "match": {
</span><span class='line'>      "title": {
</span><span class='line'>        "query":                "quick brown dog",
</span><span class='line'>        "minimum_should_match": "75%"
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>  "query": {
</span><span class='line'>    "bool": {
</span><span class='line'>      "should": [
</span><span class='line'>        { "match": { "title": "brown" }},
</span><span class='line'>        { "match": { "title": "fox"   }},
</span><span class='line'>        { "match": { "title": "dog"   }}
</span><span class='line'>      ],
</span><span class='line'>      "minimum_should_match": 2 
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>按受欢迎度提升权重</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /blogposts/post/_search
</span><span class='line'>{
</span><span class='line'>  "query": {
</span><span class='line'>    "function_score": { 
</span><span class='line'>      "query": { 
</span><span class='line'>        "multi_match": {
</span><span class='line'>          "query":    "popularity",
</span><span class='line'>          "fields": [ "title", "content" ]
</span><span class='line'>        }
</span><span class='line'>      },
</span><span class='line'>      "field_value_factor": { 
</span><span class='line'>        "field": "votes" 
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>微调:
</span><span class='line'>https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html</span></code></pre></td></tr></table></div></figure>


<h4>排障</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_validate/query?explain
</span><span class='line'>{
</span><span class='line'>   "query": {
</span><span class='line'>      "match" : {
</span><span class='line'>         "text" : "really powerful"
</span><span class='line'>      }
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>结果排序</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /website/_search
</span><span class='line'>{
</span><span class='line'>    "query" : {
</span><span class='line'>        "bool" : {
</span><span class='line'>            "filter" : { "term" : { "_id" : 1 }}
</span><span class='line'>        }
</span><span class='line'>    },
</span><span class='line'>    "sort": { "date": { "order": "desc" }}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>索引操作</h2>

<h4>增加</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PUT /my_index
</span><span class='line'>{
</span><span class='line'>    "settings": { ... any settings ... },
</span><span class='line'>    "mappings": {
</span><span class='line'>        "type_one": { ... any mappings ... },
</span><span class='line'>        "type_two": { ... any mappings ... },
</span><span class='line'>        ...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>删除</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DELETE /my_index
</span><span class='line'>DELETE /index_one,index_two
</span><span class='line'>DELETE /index_*
</span><span class='line'>DELETE /_all</span></code></pre></td></tr></table></div></figure>


<h4>配置</h4>

<ul>
<li>number_of_shards</li>
</ul>


<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
<li>number_of_replicas</li>
</ul>


<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4>重新索引</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POST _reindex
</span><span class='line'>{
</span><span class='line'>  "source": {
</span><span class='line'>    "index": "twitter"
</span><span class='line'>  },
</span><span class='line'>  "dest": {
</span><span class='line'>    "index": "new_twitter"
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>释放空间</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POST /_all/_forcemerge?only_expunge_deletes=true</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python捕获所有异常]]></title>
    <link href="https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang/"/>
    <updated>2019-06-24T12:31:08+08:00</updated>
    <id>https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang</id>
    <content type="html"><![CDATA[<p>摘自 &ndash; Python cookbook</p>

<p>老生常谈了，但是在Pyflake检查出E722错误时有时候又犯老毛病。人年纪大了越来越有老年痴呆倾向  &ndash;_&ndash; &hellip;..</p>

<h2>怎样捕获代码中的所有异常？</h2>

<!-- more -->


<h4>想要捕获所有的异常，可以直接捕获 Exception 即可：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>   ...
</span><span class='line'>except Exception as e:
</span><span class='line'>   ...
</span><span class='line'>   log('Reason:', e)       # Important!</span></code></pre></td></tr></table></div></figure>


<p>这个将会捕获除了 <code>SystemExit</code> 、 <code>KeyboardInterrupt</code> 和 <code>GeneratorExit</code> 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。</p>

<h4>讨论</h4>

<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>

<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def parse_int(s):
</span><span class='line'>    try:
</span><span class='line'>        n = int(v)
</span><span class='line'>    except Exception:
</span><span class='line'>        print("Couldn't parse")</span></code></pre></td></tr></table></div></figure>


<p>      <br/>
试着运行这个函数，结果如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; parse_int('n/a')
</span><span class='line'>Couldn't parse
</span><span class='line'>&gt;&gt;&gt; parse_int('42')
</span><span class='line'>Couldn't parse
</span><span class='line'>&gt;&gt;&gt;</span></code></pre></td></tr></table></div></figure>


<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def parse_int(s):
</span><span class='line'>    try:
</span><span class='line'>        n = int(v)
</span><span class='line'>    except Exception as e:
</span><span class='line'>        print("Couldn't parse")
</span><span class='line'>        print('Reason:', e)</span></code></pre></td></tr></table></div></figure>


<p>这时候你能获取如下输出，指明了有个编程错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; parse_int('42')
</span><span class='line'>Couldn't parse
</span><span class='line'>Reason: global name 'v' is not defined
</span><span class='line'>&gt;&gt;&gt;</span></code></pre></td></tr></table></div></figure>


<p>很明显，你应该尽可能将异常处理器定义的精准一些。</p>

<p>不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>

<h4>最可怕的例子是我们在处理临时文件的时候，用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    ....
</span><span class='line'>except:
</span><span class='line'>    os.remove(temp_file)</span></code></pre></td></tr></table></div></figure>


<p>因为碍人的E722, 有人会自作聪明的改成:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    ....
</span><span class='line'>except Exception:
</span><span class='line'>    os.remove(temp_file)</span></code></pre></td></tr></table></div></figure>


<p>正确的办法是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    ....
</span><span class='line'>except BaseException:
</span><span class='line'>    os.remove(temp_file)</span></code></pre></td></tr></table></div></figure>


<p>或者更确定的语义之下，每次都清理临时文件，这样更明确，处理更好一点:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    ....
</span><span class='line'>except BaseException:
</span><span class='line'>    logger.error(....)
</span><span class='line'>finally:
</span><span class='line'>    os.remove(temp_file)</span></code></pre></td></tr></table></div></figure>


<p>参考:</p>

<p><a href="https://github.com/PyCQA/pycodestyle/issues/703">https://github.com/PyCQA/pycodestyle/issues/703</a></p>

<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[复利是世界第八大奇迹-爱因斯坦真的说过这句话吗?]]></title>
    <link href="https://happy123.me/blog/2019/06/22/fu-li-shi-shi-jie-di-ba-da-qi-ji-ai-yin-si-tan-zhen-de-shuo-guo-zhe-ju-hua-ma/"/>
    <updated>2019-06-22T18:40:38+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/fu-li-shi-shi-jie-di-ba-da-qi-ji-ai-yin-si-tan-zhen-de-shuo-guo-zhe-ju-hua-ma</id>
    <content type="html"><![CDATA[<p>爱因斯坦说:&ldquo;复利是世界第八大奇迹&#8221;，这句话随处可见于各类理财鸡汤文中，甚至巴菲特也在纪录片中转述过这句话，但是挺奇怪的，爱因斯坦究竟是在何种情况下说出这句“名言”？</p>

<!-- more -->


<p>遍寻Google，发现只有一个地方比较详细的考证了这个事情:</p>

<p><a href="https://skeptics.stackexchange.com/questions/25330/did-einstein-ever-remark-on-compound-interest">https://skeptics.stackexchange.com/questions/25330/did-einstein-ever-remark-on-compound-interest</a></p>

<h4>第一个比较权威的引证来自于《纽约时报》1983年的一期，里面有这么一段:</h4>

<blockquote><p>Asked once what the greatest invention of all times was,Albert Einstein is said to have replied, &lsquo;&#8217;compound interest.&rsquo;&lsquo;His playful sense of humor and other aspects of his personality -as well as his genius &ndash; form the subject of a bus tour Sunday to the Institute for Advanced Study at Princeton, N.J., where the physicist worked during the last 20 years of his life</p></blockquote>

<p>看样子好像是爱因斯坦出来参观旅游至哪里的时候，幽默回答某个媒体人士的梗；毕竟当时是名人，媒体也不会一直问物理学，就像大家追着问巴菲特比特币一样;</p>

<h4>第二个比较早的引证来自于1978年的 Bank Performance Annual, Warren, Gorham &amp; Lamont, 1978, p509:</h4>

<p>这个就很直白了，有人问投资啥比较好，爱因斯坦就幽默了一把：“复利”</p>

<p>但是爱因斯坦逝世于1955年，都隔了30多年了还有人去引证这种“小故事”可信度也太低了，类似于知乎上到处都是&#8221;鲁迅先生说~~~&#8221;</p>

<h4>最近的最靠谱的引用来自于The American Mathematical Monthly, Vol. 46, No. 9, Nov., 1939, p595</h4>

<p>貌似是当时的数学刊物征集读者问题，然后爱因斯坦对某个数学题的解法发表了评论，并表示这道题更好的解法是“复利”综上所述，怎么也找不到爱因斯坦说“复利是世界第八大奇迹”这句话的原梗。</p>

<p>“以讹传讹”可能就是当今各种“xxx曾经说过”的诠释吧。</p>

<p>等待更多资料补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币是泡沫?]]></title>
    <link href="https://happy123.me/blog/2019/06/22/huo-bi-shi-pao-mo/"/>
    <updated>2019-06-22T18:31:19+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/huo-bi-shi-pao-mo</id>
    <content type="html"><![CDATA[<p>诺贝尔经济学奖得主「托马斯·萨金特」的话：客观来说，所有货币都是泡沫？</p>

<p>萨金特教授解释道：</p>

<blockquote><p>“客观来说，所有货币都是泡沫，因为当一种资产交易价格高于基础价值时候就是一种泡沫。我给你一美元，虽然它就是一张纸，但是因为你我承认其交换价值，使得这个价值得以维系。一旦有人不认同了，价值共识链条也将断裂。”</p></blockquote>

<p><a href="https://36kr.com/p/5164521">https://36kr.com/p/5164521</a></p>

<!-- more -->


<p>关键是&#8221;货币&#8221;、&#8221;泡沫&#8221;很难量化。</p>

<p>货币脱胎于商品，但是成为一般等价物之后，就丧失大部分的商品价值，变成纯粹的价格标签。</p>

<p>现在各国发行的纸币基础就是这个国家的信用，假如国破家亡，这些货币将会飞速贬值，这也是可以预见的。</p>

<p>某一国家的货币价格实际上就是这个国家长期信用的折现值。</p>

<p>问题是世界上没有一种方法能用来衡量某一国家的长期信用折现值有多大，而且货币的发行、经济的兴衰完全无法预测。</p>

<p>但是有一点可以保证，没有万世不灭的国家；从长久的尺度来说，一个国家必然灭亡，如果人均寿命远远超过一个国家货币的平均寿命，那么可以称之为泡沫。比如几十年前我们的粮票，本质上也是一种货币，持有粮票的人可能做梦也不会想到说废弃就废弃；但是有很多人家积攒的粮票来不及兑换，就变废纸了：从这方面看，粮票确实是个泡沫，而且直到废止(泡沫破灭)的那一刻，才确认是一个泡沫。</p>

<p>所以可以把货币存在的基础看作是人们无可奈何的选择：人们知道早晚有一天会变成废纸，但这个早晚可能持续几十年，并且迄今为止没有更好的选择：贵金属由于其物理上的局限性无法承担信用交换的职责，利害权衡之下现有的货币制度还是可以接受的。</p>

<p>这种现象放在任何一个高估的资产上面都是成立的，比如大家都知道房价是个泡沫，肯定会跌，但是要是100年之后才跌呢？泡沫是破了，但是和我有什么关系！？</p>

<p>然后衍生到数字货币。我们说数字货币这个东西有点像是宗教，他是建立在数学及信息技术基础上的。如果你愿意，也可以把它看成是一种邪教组织：吸引的小部分核心教众是相信数理逻辑甚于国家信用的一小撮人，其它的都是投机赌博传销企图蹭一把油水的人~~~</p>

<p>那么结论就很清晰了：</p>

<ol>
<li>数字货币在初期是一种信用抢占器，他的竞争对手是传统世界里面信用缺失的行业；比如博彩、保险、黑市、洗钱、某些投机行业等，这些行业本身及其需要信用的保证，但传统的金融手段无法提供这种保证；所以我们现在看到的是场子里面骗子横行，正说明了数字货币正以强大的吸力吸引传统诈骗行业从业人员</li>
<li>数字货币第二步的竞争对手是某些信用非常弱小的国家的法币，比如委内瑞拉、津巴布韦等等；这些国家维持泡沫的能力比较弱，所以很容易受攻击</li>
<li>数字货币第三步的竞争对手是贵金属，当其证明自己的信用吸纳能力超过一些国家的法币之后，这个系统就变成了一个正反馈&mdash;他会源源不断的吸纳信用提升价值，然后会吸引更多教众加入其中，这一点非常像传销。但是比传销更高明的是它的核心模式可能会持续非常非常久远的时间</li>
<li>到底能持续多久远呢？这其实取决于人们的理智和贪婪的比例；一旦进入到泡沫正反馈的快车道，我挺悲观的，毕竟人的贪婪是无度的；当风潮来临时，能守住清明，抵住诱惑不动的人其实很少，所以我觉得数字货币很有可能发展到下一阶段，就是跟非常强势的国家货币竞争了；到了这一步，可能就不是简单的经济问题了，而是主权争夺，这个阶段可能会有围绕意识形态的战争、国家独立、个人建国、卫星劫持以维持系统运转等等等等</li>
<li>最后，抢占所有的信用高地之后，就看数字货币本身能不能维系、甚至创造信用了，这一点不好预测</li>
</ol>


<h4>如果从千年的尺度来看，除了贵金属，毫无疑问所有货币都是泡沫。</h4>

<h4>如果从百年的尺度来看，大部分国家的货币是泡沫。</h4>

<h4>如果以十年的尺度来看，也有不少国家的货币寿命小于这个时间的。</h4>

<p>最后，比特币已经运转了10年，还能持续多少年呢？这是个很有意思的问题。</p>

<p>只要没有归零，还有全节点运转，就很难说是泡沫破灭。让我们拭目以待吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于货币的历史传说]]></title>
    <link href="https://happy123.me/blog/2019/06/22/guan-yu-huo-bi-de-li-shi-chuan-shuo/"/>
    <updated>2019-06-22T16:50:46+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/guan-yu-huo-bi-de-li-shi-chuan-shuo</id>
    <content type="html"><![CDATA[<h5>&lt;人类货币史></h5>

<p><a href="https://book.douban.com/subject/27018212/">https://book.douban.com/subject/27018212/</a></p>

<!-- more -->


<p>是的，人类社会发明了货币，但至今为止没有谁能宣称自己完全搞明白了这个东西。</p>

<p>可以跟&lt; 三千年来谁铸币>以及&lt; 货币的祸害> 结合起来读，这本书主要描述了历史上的一些货币趣闻，对其意义和作用倒也没有长篇大论，毫无疑问是谦虚明智的做法。</p>

<p>记录一些小tips吧：</p>

<p>==================================</p>

<h4>历史上曾被用作货币的物品有:</h4>

<p>● 贵金属制成的条状物（例如古代美索不达米亚、现代的国家中央银行）</p>

<p>● 盐［盐在北非、中国和地中海地区都是用于保存食物、增加风味的重要商品，曾一度充当货币；“salary”（薪水）一词源于拉丁词语sal，代表salt，意为“盐”］</p>

<p>● 牛［例如在古印度和古代非洲。“pecuniary”（金钱的）一词源于拉丁词语pecus，即“cattle”（牛）；“capital”（资本）一词源于拉丁词语capita，即“head”（头）；印度货币卢比源于rupa，即“head of cattle”（一头牛）］</p>

<p>● 奴隶（例如古罗马、古希腊、现代印度的部分地方）</p>

<p>● 可可豆、纺织物（古代墨西哥）</p>

<p>● 玛瑙贝壳（古代中国、马尔代夫）</p>

<p>● 珠子（用于非洲奴隶贸易）</p>

<p>● 羽毛（圣克鲁斯群岛、所罗门群岛）</p>

<p>● 犬牙（巴布亚新几内亚）</p>

<p>● 鲸牙（斐济）</p>

<p>● 巨型、难以移动的石盘［太平洋雅浦（Yap）岛］</p>

<p>● 刀或其他工具（非洲部分地区）</p>

<p>● 铁戒指和手镯（非洲部分地区）</p>

<p>● 铜棒［西非的蒂夫（Tiv）族］</p>

<p>● 啄木鸟头皮［加州腹地的卡罗克（Karok）人］</p>

<p>● 人头骨（苏门答腊岛）</p>

<p>● 赌场筹码［19世纪暹罗（泰国）的一些城市］</p>

<p>● 贝壳念珠珠串（美国殖民地）</p>

<p>● 烟草或库存烟草的收据（美国殖民地）</p>

<p>● 香烟（战俘集中营、战后的德国、现代监狱——香烟不受通胀影响，因为一旦价值暴跌，就会被人们立即使用）</p>

<p>● 碳排放信用额</p>

<p>● 二进制信息（例如比特币）</p>

<h4>关于货币的那些字眼：</h4>

<p>公元前300年左右，在罗马，铸币最初在朱诺·墨涅塔（Juno Moneta）的神庙里铸造。墨涅塔是负责庇护金钱的女神，墨涅塔也是“钱”（money）一词的词源。</p>

<p>贝类在历史上曾长期充当过货币的角色， 在汉字中，一般与钱财有关的字，全和贝有关：贡 财 败 贬 贩 贯 货 贫 贪 购 贮 账 贵 费 贰 贷 贺&hellip;； 在英文中，我们最熟悉的就是shell out了。</p>

<h4>货币的起源：</h4>

<p> 在 1990 年代晚期，考古学家 Stanley Ambrose 发现，在肯尼亚大裂谷的一座石头掩体中，藏着一些用鸵鸟蛋壳和贝壳碎片制成的项链。他们用（40Ar/42Ar）的氩测年法，将项链的年代确定为至少 4 万年前 。在西班牙发现的动物牙齿串珠也可以被追溯到这个年代 。在黎巴嫩（Lebanon）也发现了位于旧石器时代早期的穿孔贝壳。最近，（预备作为串珠）的完整贝壳，在南非的 Blombos 洞穴被发现，可以推前到距今 7 万 5 千年前！</p>

<p>现代考古学所发掘的最早的岩画，当属阿尔塔米拉洞；距今35000年左右，这被认为是人类艺术的开端；而文字的传播就更晚了；从这方面来看，货币其实是人类最早的语言、文化乃至艺术开端。</p>

<h4>铸币细节：</h4>

<p>通读我们提到的这三本货币史，我们发现了一个很有意思的细节：</p>

<p>早期中国的金属铸币都是带孔的，这很容易理解&mdash;古人需要用绳子串起来方便携带，所以我们的成语中才会有&#8221;腰缠万贯&#8221;这种词；而到了近代机制铸币，采用的是冲压铸币法，机器打孔导致良品率下降，而纸币开始风行，所以我们现代的硬币基本上都没有孔了；</p>

<p>国外铸币从古罗马时期开始，貌似他们的金银铸币没有打孔的习惯，这应该是铸造工艺的限制；</p>

<p>最有意思的是，能不能打孔，其实是筛选贝类货币的重要因素！早期的加工工艺粗糙，要求贝类有足够的坚韧度才能打孔，所以并不是所有的贝类都能做货币的；</p>

<p> 英格兰在 17 世纪殖民美洲之时， 他们同当地的原住民交易，仍然入乡随俗，使用贝壳货币；有个描述特别有意思：</p>

<blockquote><p>美洲的印第安人使用货币已有上千年历史，而且事实证明这些货币对初来乍到的欧洲人非常有用——就除了那些怀着 “印着大人物头像才是真钱” 偏见的人。最糟糕的是，这些新英格兰地区的原住民既不用金，也不用银，他们用的是生活环境中可见到的最合适的材料——猎物骨头中可长期保存的部分。具体一点来说就是用 venus mercenaria 等硬壳蚌类的壳做成的串珠（wampum），串成项坠。  -串珠项链。交易过程中，人们会点出珠子的数目、取出来并串到新项链上。美洲原住民的串珠有时候也会被串成腰带或其它有纪念或仪式意义的东西，表明财富或者对一些条约的承诺。-</p>

<p>这些蚌类在大海里才能找到，但这些串珠却远播内陆。美洲大陆的各个部落中都可以找到各种各样的贝壳货币。易洛魁人（Iriquois）从未到蚌类栖息地去搞过事情，他们所收集到的串珠财宝却冠于所有部落 。只有少数几个部落，比如 Narragansett 人，才精于制造串珠，但几百个部落（大多都是 狩猎-采集 部落）都以串珠为货币。串珠项链的长度有很大差别，而串珠的数量与项链长度成比例。项链也总可以剪断或串联形成与商品价格相应的长度。</p></blockquote>

<p>呵呵，这就是项链的起源；今天我们赞美这种装饰品的华丽和艺术美感，其中有多少是从原始的&#8221;财迷崇拜&#8221;心理传承下来的呢？</p>

<p>另外，在货币上打孔将其穿起来这个动作具有深远的意义！你知道我在说什么，就是现在所谓的区块链技术&mdash;同样是用一个HASH值将所有的Block穿起来；人类历史发展了上万年，在电子世代重新发明一样东西，所考虑的事情同几万年前没有什么两样，这算不算是一种惊人的巧合呢？</p>

<h4>关于货币的幻觉:</h4>

<p>弗里德曼的&lt;货币的祸害>同样是一本妙书，他开篇介绍的Yap（雅浦岛）的石币系统实在太有意思了；里面他记述了人类对于财富的度量其实不过是一种幻觉！这种幻觉的顶峰，无疑是现代的黄金储备系统。</p>

<p>我们都知道世界上最大的金库是在 下曼哈顿区(或者翻译为“曼哈顿下城”)街道下方80英尺深的地方，属于美联储；各国的财富都储藏在这里；&lt;货币的祸害>中记述了一个不可思议到可笑的故事：</p>

<blockquote><p>1932—1933年，法兰西银行害怕美国不再钉住金本位，不再按一盎司黄金兑换20.67美元的传统价格兑换黄金。于是，法兰西银行要求纽约联邦储备银行将它存在美国的大部分美元资产，转换成黄金。为了避免将黄金装船从海上运走，法兰西银行要求联邦储备银行把黄金存到法兰西银行的会计账簿上。作为一种回应，联邦储备银行的官员来到了金库，将与那笔资产等量的金锭放入了另外几个抽屉中，并且在这几个抽屉上贴了标签或是做了记号，以表明这个抽屉里的东西是法国的财产。这样，这些抽屉就像德国人在石头上做标记一样，也有可能“用黑色笔画一个十字”来标记。</p>

<p>后来的结果是，财经报纸用头条报道了这件关于“黄金的损失”以及对美国金融体系的威胁等等诸如此类的消息。美国的黄金储备开始减少，法国的黄金储备则在增加。市场认为美元走软，法郎走强。这种因法国向美国兑换黄金而造成的所谓黄金流失，是最终导致1933年银行业恐慌的众多因素之一。
联邦储备银行的看法，即由于在自己的地下室里的抽屉上做了一些标记，美元就处于一个疲软的货币地位，与雅浦岛民的看法，即由于别人在他们的石币上做了一些记号，他们就变得比以前穷了，不是异曲而同工吗？或者说，在法兰西银行的看法与雅浦家族的信念之间，即由于3000多英里以外的一个地下室里数个抽屉上的标记，法国的货币地位即增强了，与由于数百英里以外的水底下的一块石头，雅浦的家族就富裕了的看法之间，有什么真正的区别吗？就此而言，有多少人会对我们认为现存的构成自己财富的大多数东西，具有实实在在的确切的把握？我们所拥有的多数似乎是财富的东西都记录在银行的账簿上，财产要由一张称为股票的纸来确定。</p></blockquote>

<p>货币是一种神秘奇妙的发明，它关乎信用、权力、与时间的博弈，人的幻想，秩序，疯狂，稳定，跟我们的社会紧紧缠绕在一起。</p>

<p>引自：</p>

<p> <a href="https://nakamotoinstitute.org/shelling-out/">https://nakamotoinstitute.org/shelling-out/</a></p>

<p> <a href="https://book.douban.com/subject/30426677/">https://book.douban.com/subject/30426677/</a></p>

<p> <a href="https://book.douban.com/subject/1860877/">https://book.douban.com/subject/1860877/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读<投资者的心灵修炼>随想]]></title>
    <link href="https://happy123.me/blog/2019/06/22/du-tou-zi-zhe-de-xin-ling-xiu-lian-sui-xiang/"/>
    <updated>2019-06-22T16:48:28+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/du-tou-zi-zhe-de-xin-ling-xiu-lian-sui-xiang</id>
    <content type="html"><![CDATA[<h4>&lt;投资者的心灵修炼></h4>

<p><a href="https://book.douban.com/subject/27079024/">https://book.douban.com/subject/27079024/</a></p>

<!-- more -->


<p>大多数人都没有意识到的一个事实是：投资最重要的不是智商，而是情商。</p>

<p>金融市场的投资到底有多难，看看书中序言专家的总结：</p>

<blockquote><p>它需要洞悉市场在泡沫膨胀与破裂的长周期循环中处在哪个阶段，需要有一套可靠的与中短线不确定性进行“试错博弈”的方法体系，需要在第一时间对纷繁的噪声和有用信息做出鉴别，需要独立挖掘和洞悉别人看不到的重要因素，需要区别统计上的相关性与真正的因果关系，需要及时把握主要矛盾的动态变化以避免刻舟求剑，需要构建超越世俗生活的“对”与“错”的哲学观念，甚至使自己成为超越任何一个哲学流派的哲学家，需要洞悉大众人性规律和自我人性的特点，进而从本我的弱点中分离出来并战胜它……</p>

<p>简言之，要成为金融市场成功的投资者，不仅要有一套超越大众并适应市场特性的思维方法，更要磨练出超越大众和本我弱点的“高异心性”。</p></blockquote>

<p>然后看看现在无处不在的各种<code>理财秘籍</code>，汗牛充栋的炒股秘策，我们普通人只会迷失在各种噪音当中&hellip;&hellip;</p>

<p>巴菲特 1998年10月15日在佛罗里达大学商学院的演讲 值得我们一读再读，让我们再摘抄一下这位智慧老人的箴言：</p>

<blockquote><p>各位同学，你们毕业之后未来会怎样？我简单说说我的想法。各位在这所大学能学到大量关于投资的知识，你们将拥有成功所需的知识，既然各位能坐在这里，你们也拥有成功所需的智商，你们还有成功所需的拼劲。你们大多数人都会成功地实现自己的理想。</p>

<p>但是最后你到底能否成功，不只取决于你的头脑和勤奋。我简单讲一下这个道理。奥马哈有个叫彼得•基威特的人，他说他招人的时候看三点：品行、头脑和勤奋。他说一个人要是头脑聪明、勤奋努力，但品行不好，肯定是个祸害。品行不端的人，最好又懒又蠢。</p>

<p>我知道各位都头脑聪明、勤奋努力，所以我今天只讲品行。为了更好地思考这个问题，我们不妨一起做个游戏。各位都是 MBA 二年级的学生，应该很了解自己周围的同学了。假设现在你可以选一个同学，买入他今后一生之内 10% 的收入。你不能选富二代，只能选靠自己奋斗的人。请各位仔细想一下，你会选班里的哪位同学，买入他今后一生之内 10% 的收入。</p>

<p>你会给所有同学做个智商测试，选智商最高的吗？未必。你会选考试成绩最高的吗？未必。你会选最有拼劲的吗？不一定。因为大家都很聪明，也都很努力，我觉得你会主要考虑定性方面的因素。好好想想，你会把赌注压在谁的身上？</p>

<p>也许你会选你最有认同感的那个人，那个拥有领导能力，能把别人组织起来的人。这样的人应该是慷慨大方的、诚实正直的，他们自己做了贡献，却说是别人的功劳。我觉得让你做出决定的应该是这样的品质。找到了你最钦佩的这位同学之后，想一想他身上有哪些优秀品质，拿一张纸，把这些品质写在纸的左边。</p>

<p>下面我要加大难度了。为了拥有这位同学今后一生 10% 的收入，你还要同时做空另一位同学今后一生 10% 的收入，这个更好玩。</p>

<p>想想你会做空谁？你不会选智商最低的。你会想到那些招人烦的人，他们可能学成绩优秀，但你就是不想和他们打交道，不但你烦他们，别人也烦他们。为什么有人会招人烦？原因很多，这样的人可能自私自利、贪得无厌、投机取巧或者弄虚作假。类似这样的品质，你想想还有什么，请把它们写在刚才那张纸的右边。</p>

<p>看看左右两边分别列出来的品质，你发现了吗？这些品质不是把橄榄球扔出 60 米，不是 10 秒钟跑完 100 米，不是相貌在全班最出众。左边的这些品质，你真想拥有的话，你可以有。</p>

<p>这些是关于行为、脾气和性格的品质，是能培养出来的。在座的各位，只要你想要获得这些品质，没一个是你得不到的。再看一下右边的那些品质，那些令人生厌的品质，没一个是你非有不可的，你身上要是有，想改的话，可以改掉。大多数行为都是习惯成自然。我已经老了，但你们还年轻，想摆脱恶习，你们年轻人做起来更容易。</p>

<p>常言道，习惯的枷锁，开始的时候轻的难以察觉，到后来却重的无法摆脱。这话特别在理。我在生活中见过一些人，他们有的和我年纪差不多，有的比我年轻十几二十几岁，但是他们染上了一些坏习性，把自己毁了，改也改不掉，走到哪都招人烦。他们原来不是这样的，但是习惯成自然，积累到一定程度，根本改不了了。你们还年轻，想养成什么习惯、想形成什么品格，都可以，就看你自己怎么想了。</p>

<p>本•格雷厄姆，还有他之前的本•富兰克林，他们都这么做过。本•格雷厄姆十几岁的时候就观察自己周围那些令人敬佩的人，他对自己说：“我也想成为一个被别人敬佩的人，我要向他们学。”格雷厄姆发现学他敬佩的人，像他们一样为人处世，是完全做得到的。他同样观察周围遭人厌恶的人，摆脱他们身上的缺点。我建议大家把这些品质写下来，好好想想，把好品质养成习惯，最后你想买谁 10% 的收入，就会变成他。</p>

<p>你已经确定拥有自己 100% 的收入，再有别人的 10%，这多好。你选择了谁，你都可以学得像他一样。
假如有一位魔法老人问我，你今后要在投资领域成为什么样的人呢？是要巴菲特那样神奇的价值投资者？是芒格那样的智慧老人？还是彼得林奇一般的一代宗师？</p></blockquote>

<p>我想我会回答，我希望能在这个领域成为像阿甘那样的人。</p>

<p>哈，这个世界上聪明人实在太多了。人人都不想做傻子，而事实是市场上经常是聪明人赔钱，忘掉账户的那些傻子却&#8221;傻人有傻福&#8221;。我相信，阿甘到了市场上，大概率是那个有傻福的人，为什么呢？</p>

<p>他天资不高，但有着非常好的个人品质，他宅心仁厚，简单无私，同时自强不息，坚忍不拔，大概率能成就成功和快乐的人生。就像武侠小说里面的郭靖，以中下之资登武学绝顶之境。</p>

<h5>我不想学聪明，我想变简单，变得&#8221;笨一点&#8221;。</h5>

<p>最令人悲哀的事实就是，所有人都是&#8221;生而就笨&#8221;的，但经过生活的种种洗礼，我们不可避免的“越来越聪明”了，而生活和市场是心理变态的虐待狂，你越聪明，他就越会设置一个更高难度让你通关，最后你发现，变聪明了并不能让通关变得更容易。</p>

<p>这个时候我们需要重新学习“怎么变得更笨”这件事，而学习变笨在大多数人看起来就是一件荒谬的事情，在生活这个虐待狂的一次次鞭策下，我们已经忘了回家的路。更悲哀的是，要想学习&#8221;变笨&#8221;，就要先变得&#8221;更聪明&#8221;：聪明到能识别我们哪些“聪明”是多余的；这真是一个解不开的线团！</p>

<p>这本书通篇很好的提醒了我们哪些“聪明”是多余的。</p>

<p>我就我现在认识最深刻的一件”多余的聪明“写在这里供大家一乐。</p>

<h3>谬论1：你必须择时投资以获取像样的回报:</h3>

<p>在市场上投机的人最容易进入的一个心结就是，他们看着K线图，然后开始幻想：&#8221;如果我在这个低点买入，然后在那个高点抛出~~~&#8221;</p>

<p>快醒醒吧，一个最简单最惊人的统计学结论是：即使你每次都能低买高卖，在一个长期上涨的市场里面，你获取的收益大概率不如一直拿着不放的傻瓜！</p>

<p>为什么呢？这在数学上根本不成立嘛！</p>

<p>我们把事情放简单一点，如果在一个一直上涨的市场里面，每一分钟都创新高，最优的策略是什么？</p>

<p>当然是一把买入永远不动！把投资看成是储蓄，需要钱的时候取用就可以了。你每次卖出，都是抛掉便宜筹码，将来每次买入，跟历史比较起来，都是高买低卖。</p>

<p>但是市场是涨涨跌跌的啊？我每次高点抛出之后，再在低点买入更多份额不就好了吗？</p>

<p>这就涉及到另外一个统计结论，没有人能一直正确择时，甚至都没有统计结论支持这世上是否有个人能有50%的择时正确率！</p>

<p>那么这个结论已经很明显了，如果你能在你所认为的&#8221;市场低点&#8221;买入指数，拿着不动就可以了。就是这么简单。</p>

<p>但人性的”小聪明“往往会在市场动荡的时候出来骚扰你，在你耳边撒下喀耳刻海岛海妖迷人的歌声，这个时候你大概率要为聪明付出代价！</p>

<p>但是我们又迷惑了，难道永远不卖吗？万一我需要用钱的时候正好是市场低点怎么办？</p>

<h5>问得好！！这就要涉及到投资的本质，即无论是投机和投资，永远是跟时间的博弈！</h5>

<p>我们首先要明确，跟时间博弈，人是永远无法胜出的。人不可避免的衰老；不论你有多么成功的业绩，多么惊人的财富积累，最终都会被时间老人收回；在时间面前，所有人都是失败者！</p>

<p>我们能做的最好结果，就是在跟时间老人的博弈棋局中，让自己每次决定的边际效用最大化，尽可能延缓失败的到来；但在这个棋局中，人生来就是被打败的！</p>

<p>任何长期投资策略往往会受到情绪的影响。诀窍在于找到一种方法，可以在你晚上安然入睡与提高长期财务目标的实现概率之间取得平衡。</p>

<p>明白这个道理，我们就坦然了，不论是低买高卖，低买低卖，高买高卖，高买低卖，只要你不去耍小聪明，就是最大的边际效用！时间老人也会尊重你这样的对手。</p>

<p>====================================================</p>

<p>就是这么一个简单的道理，我们在寻求&#8221;变笨&#8221;的道路上摔了多少跤啊，要吃多少亏，被时间老人耍多少次才能领悟到自己那点”小聪明“是多么可笑啊！</p>

<p>悲哀的是， 人性的弱点总是充满贪婪、恐惧或者是愚蠢，这是完全可以预测的，但是我们无法预测这种人性弱点的发生顺序。 人生苦短，我们不可避免的要一次次的为自己的&#8221;聪明&#8221;付出代价。</p>

<p>让我在最后描述一个我发明的隐喻吧：</p>

<blockquote><p>我们每个人生下来都被安排到一场棋局当中，我们的对手是一个慈祥的时间老人。他公正无私的同时又是一个宽大为怀的人；他手里面有许许多多的筹码，比如财富，美貌，健康，聪慧，正直，坚韧，勇敢等等等等，你在牌局初始就被随机赐予了一些筹码，当然你可以用自己的时间一点一点来换取这些筹码，也可以用已经拥有却暂时不需要的筹码去换取你急需的；</p>

<p>每个筹码的作用和边际效用是时刻在变化的；比如对刚出生的你，时间老人是非常慷慨的，他说，你的一份时间可以换取1份财富，或者1份美貌，或者1份正直；但是随着时间流逝，时间老人可能严苛起来，这个时候可能你的1份时间可以换取10份财富，却需要10份时间才能换取1份健康；当然，你也可以用一百份财富换取1份健康；</p>

<p>当我们渐渐成长之后，棋盘旁边来了两个观棋者，生活婆婆和市场国王；看的时间长了，他们开始叽叽喳喳起来，开始对你建议：先要这个，再要那个，那个傻瓜老头算不清楚，先要这个更划算；</p>

<p>然后光靠说还不满足，他们开始偷偷往你手里塞筹码，是一些写着投机赌博、自私、欺骗等等的蓝筹，你们一时骗过了时间老人，让你用一个筹码换到了大量的财富，但是时间老人慢慢回过味儿来了，他开始严厉起来，100份时间，10000份财富也换不回一份正直了，最后，你手里面只剩下大量的自私、贪婪、赌博、财富等等，你想要一份正直，信任，倾尽所有筹码也换不回来了~~~</p></blockquote>

<p>最好的博弈策略就是，简以至纯，承认弱点、正视弱点、规避弱点。</p>

<p>无波真古井，有节是秋筠；人生如逆旅，我亦是行人。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闪电网络慢慢成长]]></title>
    <link href="https://happy123.me/blog/2019/05/21/shan-dian-wang-luo-man-man-cheng-chang/"/>
    <updated>2019-05-21T09:44:25+08:00</updated>
    <id>https://happy123.me/blog/2019/05/21/shan-dian-wang-luo-man-man-cheng-chang</id>
    <content type="html"><![CDATA[<p>学习一件事情的最好办法就是尽可能去用。</p>

<p>我在Bitcoin Testnet上面运行一个LND全节点已经有很长时间了，对现在闪电网络的进化速度都有了直观的体验：<code>积跬步，至千里</code>；</p>

<!-- more -->


<p>首先必须先承认，现在要完整的体验闪电网络，即从后台构建+前端使用整个流程，是非常麻烦的，恐怕只有对其原理有比较深入了解的人才能完成这个过程；简单说一下:</p>

<h4>1.需要Linux环境</h4>

<h4>2.需要运行一个bitcoin全节点，因为都是命令行操作，所以要<code>手工创建钱包</code> &ndash;> <code>转账确保钱包有余额</code></h4>

<ul>
<li>bitcoin.conf的配置文件模板</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxxx
</span><span class='line'>rpcpassword=xxxxx
</span><span class='line'>rpcallowip=127.0.0.1/16
</span><span class='line'>rpcport=18332
</span><span class='line'>test.rpcport=18332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>testnet=1
</span><span class='line'>zmqpubrawblock=tcp://127.0.0.1:28332
</span><span class='line'>zmqpubrawtx=tcp://127.0.0.1:28333</span></code></pre></td></tr></table></div></figure>


<ul>
<li>启动bitcoind</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin/bin/bitcoind --conf=~/bitcoin.conf --datadir=/opt/bitcoin/blockdata/ </span></code></pre></td></tr></table></div></figure>


<ul>
<li>同步后找到当前钱包收款地址</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli listaddressgroupings</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>发送一笔转账到此地址，也可以直接去<a href="https://bitcoinfaucet.uo1.net/send.php">bitcoinfaucet</a>领一些测试币</p></li>
<li><p>确认钱包余额</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli getwalletinfo</span></code></pre></td></tr></table></div></figure>


<h4>3.运行一个LND Daemon</h4>

<p>这方面有几个主流选择，lightning labs的<a href="https://github.com/lightningnetwork/lnd">lnd</a>，或者<a href="https://github.com/ElementsProject/lightning">c-lightning</a>，或者<a href="https://github.com/mit-dci/lit">lit</a></p>

<p>lnd支持比较广泛，我们用其0.6beta版本搭建；</p>

<ul>
<li>按照项目文档构建Go编译环境，编译生成lnd和lnd-cli两个可执行文件</li>
<li>启动lnd daemon(注意这里没有启用验证，在mainnet上面切不可这么做)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxxx  --bitcoind.rpcpass='xxxxx' --bitcoind.zmqpubrawblock=tcp://127.0.0.1:28332 --bitcoind.zmqpubrawtx=tcp://127.0.0.1:28333 --no-macaroons</span></code></pre></td></tr></table></div></figure>


<ul>
<li>之后lnd会通过bitcoind node同步区块头，大概需要10分钟</li>
<li>创建lnd的钱包，保存seed，便于之后恢复</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet create</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建一个segwit地址</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet newaddress np2wkh
</span><span class='line'>2NF5UC1ZgQzb8Ustm9JCTbQQTU5Ca438WWf</span></code></pre></td></tr></table></div></figure>


<ul>
<li>打一些测试币给这个地址</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/bitcoin-cli sendtoaddress 2NF5UC1ZgQzb8Ustm9JCTbQQTU5Ca438WWf 0.005</span></code></pre></td></tr></table></div></figure>


<ul>
<li>看一下钱包信息，收到款没有</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --no-macaroons --network=testnet walletbalance</span></code></pre></td></tr></table></div></figure>


<h4>4. 建立通道</h4>

<ul>
<li>直接到<a href="https://1ml.com/testnet/">1ml.com</a>找最近连接数最多的节点, 比如<a href="https://1ml.com/testnet/node/038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9">Node: aranguren.org</a>:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>node ID:038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9@203.132.95.10:9735</span></code></pre></td></tr></table></div></figure>


<ul>
<li>连接这个节点：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --no-macaroons --network=testnet connect 038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9@203.132.95.10:9735</span></code></pre></td></tr></table></div></figure>


<ul>
<li>建立通道，放一笔钱进去</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --no-macaroons --network=testnet openchannel --node_key=038863cf8ab91046230f561cd5b386cbff8309fa02e3f0c3ed161a3aeb64a643b9 40000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>需要一段时间同步，然后看一下通道状态:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listchannels</span></code></pre></td></tr></table></div></figure>


<h4>5. 支付</h4>

<ul>
<li>首先到<a href="https://testnet.satoshis.place/">testnet.satoshis.place</a>涂鸦两笔，得到一个支付地址:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lntb1pwwykwhpp5jw4tekxmsqjwepw4070em7xe7gw3v8mxtenexmsp2np3pcc40jwqdqqxqruyqrzjqfcxsh9gr28y6ngphmk90q05ejfydpq89tjjc5rl36lfmtcv424hk9e8sgqqqvsqqqqqqqlgqqqqqeqqjqjpfnq26e2flenp79ywpyyftg3najf3wtpvkwuuw2h9y3dzdn7kc3342h6uzgf69ms8sx6fxsh5j2jcwzulr3dufryn9ljadm0wuj9fcpm86fax</span></code></pre></td></tr></table></div></figure>


<ul>
<li>lnd-cli支付</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli  sendpayment --pay_req lntb1pwwykwhpp5jw4tekxmsqjwepw4070em7xe7gw3v8mxtenexmsp2np3pcc40jwqdqqxqruyqrzjqfcxsh9gr28y6ngphmk90q05ejfydpq89tjjc5rl36lfmtcv424hk9e8sgqqqvsqqqqqqqlgqqqqqeqqjqjpfnq26e2flenp79ywpyyftg3najf3wtpvkwuuw2h9y3dzdn7kc3342h6uzgf69ms8sx6fxsh5j2jcwzulr3dufryn9ljadm0wuj9fcpm86fax 500</span></code></pre></td></tr></table></div></figure>


<h4>6. 收款</h4>

<p>lnd构建一个收款节点比较麻烦，我们可以借助一个实现了lnd hub全功能的钱包来体验，推荐 <a href="https://github.com/ACINQ/eclair">elcair</a>；</p>

<p><a href="https://bluewallet.io/">BlueWallet</a>也是一个非常受欢迎的闪电网络钱包，不过他并没有实现完整的lightning hub的功能，作为想要完全掌控一切的玩家不太合适，当然对于普通用户来说，BlueWallet更易用：</p>

<p><a href="https://medium.com/bluewallet/bluewallet-brings-zero-configuration-lightning-payments-to-ios-and-android-30137a69f071">https://medium.com/bluewallet/bluewallet-brings-zero-configuration-lightning-payments-to-ios-and-android-30137a69f071</a></p>

<ul>
<li>关于 elcair如何构建一个收款地址的过程，可以参考:</li>
</ul>


<p><a href="https://medium.com/@ACINQ/enabling-receive-on-eclair-mobile-2e1b87bd1e3a">https://medium.com/@ACINQ/enabling-receive-on-eclair-mobile-2e1b87bd1e3a</a></p>

<ul>
<li>老实说，使用elcair的过程也需要一点技术，至少要搞明白我们之前讲述闪电网络技术原理的那篇文章</li>
</ul>


<h4>7. 总结</h4>

<p>好啦，相信小白看到这里已然头昏眼花，并发出怒吼：这么复杂的东西谁会用啊！</p>

<p>我得说，在使用闪电网络的过程中，我体会到了巨大的乐趣，就跟我第一次手工完成一笔比特币交易一样的乐趣！</p>

<p>回想互联网之初，发个电子邮件也需要精通命令行操作的<code>专家人士</code>来完成，跟现在闪电网络的使用体验完全一样！</p>

<p>我也相信随着产业发展，这项技术迟早会变得跟电子邮件一样，在IPAD上动动手指就完成一切，我憧憬着这一天。</p>

<p>然后我们看一下现在闪电网络面临的一些技术和实务上的挑战：</p>

<ol>
<li>目前还没有完全靠谱的，敢于宣称可安全用于生产的基础软件实现，大家都在beta版</li>
<li>目前运行一个lnd，需要配置一个bitcoin fullnode，而且是一对一的，成本比较高，虽然运行一个全节点可以取得一些手续费，但是其风险和收益不成对比；bitmex有<a href="https://blog.bitmex.com/the-lightning-network-part-2-routing-fee-economics/">一篇文章</a>详细分析了现在运行一个闪电网络节点的收益情况；</li>
<li>现在lit项目和Neutrino项目都朝着<code>运行一个支持闪电节点的SPV节点</code>这个方向努力，但距离完成还有很长时间；</li>
<li>在我们之前的文章分析中，每一个钱包，都需要一个类似<code>瞭望塔</code>的模块，来监控通道的状态；围绕这个实现，目前有两大流派：一类就是elcair 钱包自己继承这个功能，这就要求用户的钱包不能脱离网络超过两周；第二类就是BlueWallet的实现，让用户放弃掌控一切，由钱包服务商托管；这两种方案各有优劣，之后还要看市场和众多黑客们的测试结果；</li>
<li>Electrum目前也在进行闪电网络的实现，他们采用了改造ElectrumX server端，增加一个和lnd连接的中间通讯层的方法，并且ElectrumX是可以复用的，以后如果lnd实现了Neutrino，可以完成<code>ElectrumX+Lnd+Neutrino</code>的部署，估计这样成本低，运营的好的话，能赚点小钱；</li>
</ol>


<p>最后的最后：</p>

<ul>
<li><p>闪电网络的成长目前是一个非常壮丽的场景，堪比互联网发展之初；</p></li>
<li><p>终于出现了这样一种基础金融技术:</p>

<ul>
<li>可以支持个人开银行，没有任何法律、宗教、地域、政府的隔阂；</li>
<li>只要有网络和你的信用，就可以面向全球用户做一个银行家；</li>
<li>而且你的银行没有柜台、没有繁琐的开户流程，没有金碧辉煌的大楼，只需要一个联网的手机而已；但这是世界上最讲信用的，最具有扩展性的，最安全的银行；</li>
<li>你的用户也无需繁琐的身份证明，政策限制，高昂的手续费，屈服于传统银行的被冻结账户的风险，甚至都不需要物理的货币和钱包，只需要在脑子里记住一串密语而已；而对于将来的那些<code>世界银行家</code>来说，你的信用就是一切。酷!!!</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is Craig Wright Real Satoshi Nakamoto-2]]></title>
    <link href="https://happy123.me/blog/2019/05/19/is-craig-wright-real-satoshi-nakamoto-2/"/>
    <updated>2019-05-19T10:15:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/19/is-craig-wright-real-satoshi-nakamoto-2</id>
    <content type="html"><![CDATA[<p>之前我们写过两篇文章来八卦所谓的<code>澳本聪</code>的故事:</p>

<p><a href="https://happy123.me/blog/2016/05/02/is-craig-wright-real-satoshi-nakamoto/">Is Craig Wright Real Satoshi Nakamoto?</a></p>

<p><a href="https://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">Satoshi Craig Wright Is Being Sued for $10 Billion</a></p>

<p>PS: 学术界普遍怀疑其实 <a href="https://www.blogger.com/profile/16820399856274245684">Nick Szabo</a>才是中本聪；偶也50%认同；</p>

<p>最近这个故事又有了新的神转折，实在是太有意思了。现实生活中，有时候我觉得八卦那些明星太无聊了，但是在cyberspace中，偶的八卦之心熊熊燃烧，都让我有点体会那些狗崽队的心情了~~~</p>

<!-- more -->


<p>之前我们做出的推论是:</p>

<blockquote><p>Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>

<p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>

<p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p></blockquote>

<p>之后的剧情就是 David Kleiman的亲属起诉Craig Wright，声称他窃取了 本该属于  David Kleiman 的100w bitcoin；其起诉文书中公布了大量的由 Craig Wright声称其属于他和Kleiman成立的名为<code>郁金香信托</code>基金的bitcoin address;</p>

<p>参见<a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion">这里</a>， <a href="https://www.reddit.com/r/Bitcoin/comments/80e2l9/10_billion_lawsuit_filed_against_craig_wright/">这里</a></p>

<p>很快，就有人对其文件中所列出的地址做了详细分析；认为其地址根本就是 Craig Wright 随便在bitcoin blockchain找的大额未动币的地址，根本和他没关系；当然，跟David Kleiman也没关系；两拨人马完全是在为<code>一笔完全不存在的财富</code>纠缠不清；</p>

<p>甚至，这些地址中，有一个地址是Mtgox小偷的地址！ 如果这份文件是真的，那么岂不是说Craig Wright自己承认是Mtgox的窃贼！</p>

<p>参考<a href="https://blog.wizsec.jp/2018/02/kleiman-v-craig-wright-bitcoins.html">这里</a>；</p>

<p>地址分析：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>12tLs9c9RsALt4ockxa1hB4iTCTSmxj2me: unknown
</span><span class='line'>1933phfhK3ZgFQNLGSDXvqCn32k2buXY8a: MtGox user
</span><span class='line'>1FeexV6bAHb8ybZjqQMjJrcCrHGW9sb6uF: first major MtGox theft
</span><span class='line'>1f1miYFQWTzdLiCBxtHHnNiW7WAWPUccr: unknown
</span><span class='line'>1MHdm5XZMrfoZFoUktEaGhYevmdiXoc4x4: unknown (early miner)
</span><span class='line'>18JPragfuDVHWWG8ABQ15cghJFetnXUjBD: MtGox user
</span><span class='line'>1LXc28hWx1t8np5sCAb2EaNFqPwqJCuERD: unknown
</span><span class='line'>1FpqQnKQCgDkJFMC94JL8FpRyHTZ3uRVZ1: unknown (early miner)
</span><span class='line'>1F34duy2eeMz5mSrvFepVzy7Y1rBsnAyWC: from MyBitcoin.com
</span><span class='line'>1JtpgqCf3SSeCeYWEDJjkfYFH7Ruhy4Vp1: unknown (early miner)
</span><span class='line'>18k9tin39LKegFzHe8rxSgvJXDpuMriGJq: unknown
</span><span class='line'>1HtTw9zR9wWFfgV8Jy8MqsaeVi7ZXrjdq6: part of a long chain of transactions that send minor amounts into a BTC-e deposit address
</span><span class='line'>18pn4NQ7NgsJjeuFjazeTdVRnsmfw5ofTz: unknown
</span><span class='line'>12fZ2HxkLjG9zn1u44XYsFFYKHM4A2zCea: MtGox user
</span><span class='line'>12tkqA9xSoowkzoERHMWNKsTey55YEBqkv: unknown (early miner)
</span><span class='line'>16Ls6azc76ixc9Ny7AB5ZPPq6oiEL9XwXy: MtGox cold storage
</span><span class='line'>12HddUDLhRP2F8JjpKYeKaDxxt5wUvx5nq: MtGox cold storage
</span><span class='line'>1P3S1grZYmcqYDuaEDVDYobJ5Fx85E9fE9: MtGox cold storage
</span><span class='line'>1MyGwFAJjVtB5rGJa32M6Yh46cGirUta1K: MtGox cold storage
</span><span class='line'>145YHsQU7HMzkRnD5SBSuFAzQgCYnAnLkN: unknown (early miner)
</span><span class='line'>16TPVCpvtJ6FkV5xNKBp35aMo4BWFGxiEY: unknown
</span><span class='line'>1KbrSKrT3GeEruTuuYYUSQ35JwKbrAWJYm: unknown
</span><span class='line'>1FLFnbN7m5psLfvLEwYfRUUjJ34YkmV3dM: donation recipient
</span><span class='line'>1A6SDef1TJAM8Saw2SqmqFGhkWR1y3qMx2: MtGox deposit address
</span><span class='line'>16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT: MtGox user
</span><span class='line'>12ib7dApVFvg82TXKycWBNpN8kFyiAN1dr: unknown (early miner)</span></code></pre></td></tr></table></div></figure>


<p>呵呵，就在前几天，有人用<code>16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT</code>这个地址的私钥，签名发布了一段消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Address 16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT does not belong to Satoshi or to Craig Wright.
</span><span class='line'>Craig is a liar and a fraud.</span></code></pre></td></tr></table></div></figure>


<p>这段消息的签名是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>G39S6i4XsfQnixN5ePMjVPboWvGXdnW8xFFAXiwEriZFCclflbD7umP58u3Sl+dvvXC5BxBrRNkTMNf92O1UIXw=</span></code></pre></td></tr></table></div></figure>


<p>这段签名可以用Electrum的工具验证无误；懂一点技术的人自然明白这意味这什么。</p>

<p>那么问题又来了，为什么这位英雄好汉不在去年早点揭露这件事呢？</p>

<p>也许是法律文件太过冗长，没什么人仔细去研究，更不用说作为一个早期的Bitcoiner Hodler了；</p>

<p>嗯，这个理由很合理；但是~~~~</p>

<p>马上又有人挖出了更大的瓜，这个地址是Roger Ver控制的；</p>

<p><a href="https://www.reddit.com/r/btc/comments/bpdac1/address_16cou7ht6wjtzufydbnht9hmvxytg6xdvt_does/">https://www.reddit.com/r/btc/comments/bpdac1/address_16cou7ht6wjtzufydbnht9hmvxytg6xdvt_does/</a></p>

<p><a href="https://www.reddit.com/r/btc/comments/7cehzo/roger_ver_45000_bitcoin_moved_to_exchange/">https://www.reddit.com/r/btc/comments/7cehzo/roger_ver_45000_bitcoin_moved_to_exchange/</a></p>

<p>之前在Bitcoin扩容之争的时候，Roger Ver还用这个地址投过票；</p>

<p>而Roger Ver与Craig Wright的关系也是百转千回~~</p>

<ul>
<li><p>Craig Wright初次宣布自己是Satoshi, Roger Ver 坚持黑；</p></li>
<li><p>BCH分叉， Craig Wright投入BCH阵营， Roger Ver 粉；</p></li>
<li><p>BSV分叉， Craig Wright自立门户， Roger Ver 出来掀桌了；</p></li>
</ul>


<p>真相目前不得而知，但是可以确认的有一件事情：</p>

<p>像所有的区块链项目以及牵涉其中的人一样， Craig Wright, Roger Ver， 所谓的<code>郁金香信托</code>， Mtgox， BCH, BSV 等等，他们之间充斥着谎言中的谎言，是迷宫中的迷宫；</p>

<p>我觉得所谓的<code>区块链行业</code>有个铁律：</p>

<h4>有区块链的地方一定会有骗子。</h4>

<p>这再一次提醒我们，在区块链世界中，任何人都不值得信任，唯一可以依靠的只有自己的知识和判断：</p>

<h2>Don&rsquo;t Trust. Verify.</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[永远都算不准的指数PE]]></title>
    <link href="https://happy123.me/blog/2019/05/12/yong-yuan-du-suan-bu-zhun-de-zhi-shu-pe/"/>
    <updated>2019-05-12T10:49:33+08:00</updated>
    <id>https://happy123.me/blog/2019/05/12/yong-yuan-du-suan-bu-zhun-de-zhi-shu-pe</id>
    <content type="html"><![CDATA[<p>看看一张2019-05-10的指数估值表:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190512/bg1.png" alt="img" /></p>

<blockquote><p>数据来源：<a href="https://xueqiu.com/u/8890498724">https://xueqiu.com/u/8890498724</a></p></blockquote>

<p>大家肯定晕了，怎么这几家算出来的PE数据都不一样啊，个人计算的就罢了，怎么中证指数和Wind算的都不一样啊，究竟谁算得准啊？</p>

<p>PE是投资的重要指标因子，基础因子不准就做投资决策，犹如盲人骑瞎马，我们有必要好好弄明白为什么各家的PE算出来的值不一样！</p>

<!-- more -->


<h2>PE是什么？</h2>

<p>PE，是市盈率（Price earnings ratio，即P/E ratio）的英文缩写。其定义是股价与每股收益的比率，也等价于总市值与净利润的比率。</p>

<p>最简单的理解，一家公司现在的股票总市值是10亿元，当年的净利润为1亿元，那么当年的PE就是<code>10/1=10</code>；</p>

<p>这么简单的算术题，为啥各路神仙还算不准？</p>

<h2>PE的几种计算方法</h2>

<p>呵呵，股票市值很容易计算，但一家公司最难搞明白的就是当年净利润；试问大家去读公司年报，有几家公司能保证其中净利润是真实的准数呢？</p>

<p>更何况还有一个预测未来的问题，公司的股票市值天天变，财报有上一年的年报，当年季度报告，历史PE好算，当前PE如何计算呢？毕竟我们不能预测未来，在1月份就能预测当年整年的净利润；</p>

<p>为了解决这个算不准的问题，就有几种折中的计算方法：</p>

<h4>静态市盈率</h4>

<p>静态市盈率又称市盈率LYR(Last Year Ratio)，是以上一年的净利润为分母计算出来的市盈率；上一年的净利润，直接找公司财报就好了，这个没什么可说的；</p>

<p>但是我们要注意一点，静态市盈率是典型的看后视镜开车；去年挣大钱不代表今年也能挣大钱，对不？如果看静态市盈率炒股，结果就是呵呵哒；</p>

<h4>滚动市盈率 TTM(Trailing Twelve Months)，</h4>

<p>静态市盈率是后视镜，不实用，自然有人去改进，这就是滚动市盈率这项指标；</p>

<p>滚动市盈率和静态市盈率的区别在于，总利润以季报为参考，因为季报是每季度跟新一次，那样相比之前拿年报的总利润的算法，实时性更好一点；</p>

<p>比如我们在2019-05计算A公司的PE，那总利润就拿 2018年第二、第三、第四、以及2019年第一季度的季报利润总和相加，作为分母计算；</p>

<p>滚动市盈率实时性好，已经是当前最科学的估算方法了，大部分软件(比如雪球)就是这么计算的；但也有缺点，就是有的高速成长的公司，他前几个季度的成长是指数级的，但后面会越来越慢；而且有的公司为了PE数字好看，还会操纵利润；单看滚动市盈率炒股，最终结果还是呵呵哒；</p>

<h4>动态市盈率</h4>

<p>滚动市盈率的计算方法已经比较严谨了；但是还有一些软件的提供商偷懒，因为计算滚动市盈率需要处理很多情况，比如公司刚上市、比如公司去年停牌了一个季度，比如公司去年财报实锤造假了，等等等等，好烦啊，所以他们计算利润的方法更简单粗暴：</p>

<p>比如现在是2019年5月份，那么我觉得你今年的利润就是 2019年第一季度的利润X4；到了9月份，我就取全年利润=半年财报利润X2</p>

<p>呵呵哒~~~~</p>

<h4>根据财报利润个人计算</h4>

<p>设身处地想一下，我自己重仓了一支股票，发现连谁算的PE比较准都搞不明白，我岂不是每天惶惶然；于是我决定自己来算PE！</p>

<p>我拿来公司季报、半年报、年报仔细一看，乐了，基本上公司都会对未来的利润率有个预估，比如明年我预计全年净利润同比增长35%-45%；那么我保守一点，用去年35%的增长来预估你今年的利润，总可以了吧！</p>

<p>看看康美药业的年报吧! 呵呵哒~~~</p>

<h2>指数PE的计算方法</h2>

<p>单个公司的PE已然如此难算，那么指数呢？囊括几百家公司的指数PE怎么算呢？</p>

<h4>指数滚动市盈率加权计算方法</h4>

<p>我们把整个指数囊括的公司看成一家公司，那么PE计算其实很简单，就是PE=总市值/总利润；</p>

<p>总市值就是指数中所有市值的相加，总理论就是所有利润的相加；当然单家公司的利润我们肯定要采用滚动市盈率(TTM)的计算方法；</p>

<p>这种相加的计算方法，也被称之为加权计算方法；</p>

<h4>指数滚动市盈率算术平均计算方法</h4>

<p>加权计算方法简单明了，但是有的人觉得有问题，因为如果指数里面有100家公司，有家公司特别大，市盈率特别低，其他99家公司虽然市盈率很高，但采取加权统计一看，都被平均低了，这个计算方法就会失真；</p>

<p>为了解决这个问题，我们采取算术平均计算方法；比如这家特别大的公司PE是5，而其他99家公司PE都是20；那么我们就不看总市值和总利润了，直接:</p>

<p>(5 + 20 * 99) /100 = 19.85</p>

<p>这是算数平均计算方法，算数平均和加权计算的结果相比，可能相差万里；</p>

<h4>总市值统计？</h4>

<p>A股市场上还有一个特殊现象，就是有些股票并不是全流通的，这个时候他的总市值是只计算流通股呢？还是全部都算呢？</p>

<p>总市值统计方法的不同，又会影响到最终PE的计算结果</p>

<h4>亏损公司的计算</h4>

<p>如果一家公司亏损呢？还应该放到指数里面统计吗？</p>

<p>根据对亏损公司的处理方法的不同，又会影响到最终PE的计算结果</p>

<h4>B股的折价计算</h4>

<p>如果指数里面有的公司还有B股，那么B股的市值也要放进来计算吗？计算的时候如何设定权重？利润如何统计？</p>

<p>相对于B股的处理方法的不同，又会影响到最终PE的计算结果</p>

<h4>A/H股的折价计算</h4>

<p>如果指数里面有的公司还有H股，那么H股的市值也要放进来计算吗？计算的时候如何设定权重？利润如何统计？</p>

<p>相对于H股的处理方法的不同，又会影响到最终PE的计算结果</p>

<h2>指数PE的历史估值计算</h2>

<p>很多软件平台提供了PE/PB的历史估值计算，比如蛋卷基金会每天更新数值，告诉我们今天沪深300的PE估值处理历史百分位的xxx%；</p>

<p>如果你认真一点，就会发现所有平台的估值百分位都不一样！</p>

<p>PE的计算就如此五花八门，历史百分位当然不一样啦。</p>

<p>且慢，即使各大平台的PE计算都一样，历史估值百分位也可能不一样！为啥？</p>

<h4>统计时长的不同</h4>

<p>一个指数，他的历史区间该如何选取呢？</p>

<p>从指数成立的那一天开始？</p>

<p>取前5年历史？前8年历史？前10年历史？</p>

<h4>估值统计算法的不同</h4>

<p>算数平均 or 加权平均 or 中位数统计？</p>

<h2>总结</h2>

<p>所以有人说他算出了一个指数的PE，我们需要问他：</p>

<ol>
<li>个股采用的啥PE计算方法？ 静态PE？动态PE？滚动PE？ 动态取的是季报？半年报？年报？还是上一期年报/季报的预测值？</li>
<li>指数是总市值加权计算还是算术平均计算？</li>
<li>亏损公司怎么处理？</li>
<li>停牌公司怎么处理？</li>
<li>B股怎么处理？</li>
<li>H股怎么处理？</li>
<li>估值采用的历史数据时间段怎么取？前3年，5年，8年，成立以来? 成立之前还根据指数编制原则计算并统计进来了？</li>
<li>指数百分比的估值算法是什么？加权统计？算数平均？中位数？</li>
</ol>


<p>看了上面这么多干扰因子，相信你已经眼花缭乱了；而且每一种因子的处理方法都会引来无穷无尽的争论~~~</p>

<p>指数PE是永远也算不准的，那一个算不准的指标有啥好参考的？相信很快会有很多人跳出来说出各种理论~~~</p>

<p>无辜的摊手，我也不知道，呵呵哒。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Berkshire's Charlie Munger Calls Bitcoin 'Noxious Poison']]></title>
    <link href="https://happy123.me/blog/2019/05/09/berkshires-charlie-munger-calls-bitcoin-noxious-poison/"/>
    <updated>2019-05-09T10:12:02+08:00</updated>
    <id>https://happy123.me/blog/2019/05/09/berkshires-charlie-munger-calls-bitcoin-noxious-poison</id>
    <content type="html"><![CDATA[<p>Berkshire annual meeting 2019 Q&amp;A，巴菲特和芒格老爷子又来Diss bitcoin了；</p>

<h4>Munger:</h4>

<blockquote><p>It’s just disgusting. Bitcoin is noxious poison.</p></blockquote>

<h4>Buffet:</h4>

<blockquote><p>It’s a gambling device… there’s been a lot of frauds connected with it. There’s been disappearances, so there’s a lot lost on it. Bitcoin hasn’t produced anything</p>

<p>It doesn’t do anything. It just sits there. It’s like a seashell or something, and that is not an investment to me</p></blockquote>

<p>两位老爷子是bitcoin社区值得敬重的对手，从一而终，一直坚定的黑；</p>

<p>和一些骑墙派比起来，这份<code>坚守自己能力圈</code>的自律的确让人敬重。</p>

<p>不管今后结果如何，要把这两位智慧老人的话牢牢记在心里；记住我们的贪婪、愚蠢、傲慢等等;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go包管理工具]]></title>
    <link href="https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju/"/>
    <updated>2019-05-01T15:25:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju</id>
    <content type="html"><![CDATA[<p>真的，Go的包管理工具之发展过程充分体现了什么叫<code>折腾</code>。 (叹气~~~)</p>

<!-- more -->


<p>想想Java的Maven， Nodejs的NPM，还有我们赞颂一万遍也不过分的Python包管理，为什么生命总要浪费在这些事情上面呢？ 陷入了深深的沉思~~</p>

<p>从Go1.11版本发布Go MODULE之后，我希望这是最后一次折腾<code>包管理</code>这件事情，神呐，诚心诚意的祈祷中~~</p>

<p>摘抄备忘下：</p>

<h2>GO111MODULE</h2>

<p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。
按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，GO111MODULE 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p>

<ul>
<li><p>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</p></li>
<li><p>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</p></li>
<li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:

<ul>
<li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li>
<li>当前目录位于包含 go.mod 文件的目录下</li>
</ul>
</li>
</ul>


<h2>go mod 命令</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>download    download modules to local cache (下载依赖的 modules 到本地 cache)
</span><span class='line'>edit        edit go.mod from tools or scripts (编辑 go.mod 文件)
</span><span class='line'>graph       print module requirement graph (打印模块依赖图)
</span><span class='line'>init        initialize new module in current directory (再当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
</span><span class='line'>tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)
</span><span class='line'>vendor      make vendored copy of dependencies (将依赖复制到 vendor 下)
</span><span class='line'>verify      verify dependencies have expected content (校验依赖)
</span><span class='line'>why         explain why packages or modules are needed (解释为什么需要依赖)</span></code></pre></td></tr></table></div></figure>


<h2>既有项目</h2>

<p>假设你已经有了一个 go 项目， 比如在$GOPATH/github.com/memoryboxes/hello下， 你可以使用go mod init github.com/memoryboxes/hello在这个文件夹下创建一个空的 go.mod (只有第一行 module github.com/memoryboxes/hello)。</p>

<p>然后你可以通过 go get ./&hellip;让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 -tags, 这样可以把 tags 的依赖都查找到)。</p>

<p>通过go mod tidy也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理tags。</p>

<p>执行上面的命令会把 go.mod 的latest版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p>

<h2>replace</h2>

<p>在国内访问golang.org/x的各个包都需要梯子，你可以在 go.mod 中使用replace替换成 github 上对应的库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>replace (
</span><span class='line'>  golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
</span><span class='line'>  golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
</span><span class='line'>  golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>依赖库中的replace对你的主 go.mod 不起作用，比如github.com/memoryboxes/hello的 go.mod 已经增加了replace, 但是你的 go.mod 虽然require了rpcx的库，但是没有设置replace的话， go get还是会访问golang.org/x。</p>

<p>所以如果想编译哪个项目，就在哪个项目中增加replace。</p>

<h2>包的版本控制</h2>

<p>下面的版本都是合法的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
</span><span class='line'>gopkg.in/vmihailenco/msgpack.v2 v2.9.1
</span><span class='line'>gopkg.in/yaml.v2 &lt;=v2.2.1
</span><span class='line'>github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
</span><span class='line'>latest</span></code></pre></td></tr></table></div></figure>


<p>版本号遵循如下规律：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
</span><span class='line'>vX.0.0-yyyymmddhhmmss-abcdefabcdef
</span><span class='line'>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
</span><span class='line'>vX.Y.Z</span></code></pre></td></tr></table></div></figure>


<p>也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p>

<p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p>

<h2>go get 升级</h2>

<ul>
<li>运行 go get -u 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li>
<li>运行 go get -u=patch 将会升级到最新的修订版本</li>
<li>运行 go get package@version 将会升级到指定的版本号version</li>
</ul>


<h2>go modules 与 vendor</h2>

<ul>
<li><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p></li>
<li><p>Go modules 支持通过go mod vendor命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用go build -mod=vendor即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p></li>
</ul>


<h2>参考:</h2>

<p><a href="https://roberto.selbach.ca/intro-to-go-modules/">https://roberto.selbach.ca/intro-to-go-modules/</a></p>

<p><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p>

<p><a href="https://windmt.com/2018/11/08/first-look-go-modules/">https://windmt.com/2018/11/08/first-look-go-modules/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指数投资策略]]></title>
    <link href="https://happy123.me/blog/2019/04/08/zhi-shu-tou-zi-ce-lue/"/>
    <updated>2019-04-08T17:55:22+08:00</updated>
    <id>https://happy123.me/blog/2019/04/08/zhi-shu-tou-zi-ce-lue</id>
    <content type="html"><![CDATA[<h4>降龙四式之亢龙有悔</h4>

<h4>谨记：一切回测有效的策略都是看后视镜开车。回测仅仅是参考，不能预测未来。</h4>

<h4>谨记：成功概率不能预测，失败风险无法回避，历史周期不断重复，时刻抱有敬畏之心。</h4>

<h1>指数特点</h1>

<ul>
<li>背靠国运，不死鸟</li>
<li>长期上涨</li>
<li>成本低</li>
<li>不择股</li>
<li>容易量化</li>
<li>大道至简</li>
</ul>


<!-- more -->


<h1>指数品种</h1>

<p>简单粗暴的分为宽基和窄基，窄基又可以细分为策略类、风格类、行业类、主题类；</p>

<h2>宽基指数</h2>

<ul>
<li>上市不满一个季度的股票不选；暂停上市的股票不选；财务上有问题的股票不选；多年亏损的股票不选。</li>
</ul>


<h4>上证50 (代码是000016)</h4>

<ul>
<li><p>上交所挑选沪市规模最大、流动性好、最具代表性的50只股票组成样本股，以综合反映沪市最具影响力的一批优质大盘企业的整体状况。2004年1月2日发布，但却是以2003年12月31日为基准日期开始运作的。</p></li>
<li><p>从2003年年底以来，国内股市发生过三轮比较明显的牛市，分别发生在2006～2007年、2009年和2015年。其余时间里股市大多波澜不惊，走平或者阴跌。</p></li>
</ul>


<h4>沪深300 (代码000300)</h4>

<ul>
<li>从上交所和深交所挑选规模最大、流动性最好的300只股票。从市值规模上来说，占到国内股市全部规模的60%以上。沪深300基本上包括上证50</li>
</ul>


<h4>中证500 (代码000905)</h4>

<ul>
<li>将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，这样可以最大限度地避免选入大公司。在剩下的公司中，选择日均总市值排名前500名的企业</li>
</ul>


<h4>创业板综指 (代码是399102)</h4>

<ul>
<li>包括创业板全部的500多家企业</li>
</ul>


<h4>创业板指数 (代码是399006)</h4>

<ul>
<li>创业板最主要的100家企业</li>
</ul>


<p>创业板指数整体公司规模较小，属于以中小型公司为主的指数。并且这些公司大多盈利没有进入稳定期，所以创业板的整体盈利数字比较低；公司开展新业务也更容易导致盈利大起大落。小公司＋盈利没有进入稳定期，创业板指数相比之前介绍的指数，更容易暴涨暴跌。</p>

<h4>上证综指(000001)</h4>

<p>综指指的是综合指数，上证综指包括了上交所全部的上市公司，目的是反映上交所所有股票的走势。</p>

<p>这个指数娱乐意义最大。</p>

<h4>中证100指数(000903)</h4>

<p>中证100指数是从沪深300指数中，再挑选出规模最大的100只股票组成的。比起上证50指数，它覆盖了深交所的大公司，所以更加全面一些。</p>

<h4>中证800指数</h4>

<p>中证500plus</p>

<h4>中证1000指数</h4>

<p>中证500plus+</p>

<h4>中证全指</h4>

<p>中证plus++</p>

<h4>恒生指数(HSL)</h4>

<ul>
<li>港上市的公司中规模最大的50家企业。因为中国香港金融市场比较开放，境外投资者很容易就能进来投资或者撤资，所以一有风吹草动，就会体现在港股价格的波动上。</li>
<li>最近3年国家先后开通了沪港通和深港通，内地资金正在夺回港股的定价权</li>
</ul>


<h4>H股指数</h4>

<ul>
<li>内地注册，但是在香港地区上市，这样的公司就是H股了。与A股关联度大，因为同股不同价，有很多精明指数前来套利。</li>
</ul>


<h4>标普500指数</h4>

<ul>
<li>巴菲特唯一指定接班人</li>
<li>需要注意的是，标普500也有一个<code>完全没有用的</code>委员会搞一些选股工作</li>
</ul>


<h4>纳斯达克100指数</h4>

<ul>
<li>纳斯达克规模最大的100家大型企业</li>
</ul>


<h4>德国30DAX</h4>

<ul>
<li>跟踪基金盘子小，误差大</li>
</ul>


<h4></h4>

<h2>行业指数</h2>

<p>行业有自己的投资特点，不能一概而论，需要针对行业的特点具体分析。所以就投资难度来说，行业指数比宽基指数要高出不少。</p>

<p>值得投资的行业，主要有两个，一个是天生赚钱更容易的行业，另一个是具有明显强周期性的行业。</p>

<p>我认为最值得关注的是消费指数和医药指数。</p>

<h4>上证消费指数</h4>

<ul>
<li>从上交所挑选必需消费行业公司。</li>
</ul>


<h4>上证消费80指数</h4>

<ul>
<li>从上交所挑选80家规模最大的必需消费行业公司。</li>
</ul>


<h4>中证消费指数</h4>

<ul>
<li>从中证800，即沪深300和中证500中挑选必需消费行业公司。</li>
</ul>


<h4>全指消费指数</h4>

<p>从所有上市公司中挑选必需消费行业公司，覆盖范围最广。</p>

<h4>300医药指数</h4>

<ul>
<li>挑选了沪深300指数里的医药行业公司。</li>
</ul>


<h4>500医药指数</h4>

<ul>
<li>挑选了中证500指数里的医药行业公司。</li>
</ul>


<h2>策略加权指数</h2>

<h4>上证50AH优选指数</h4>

<ul>
<li>基于A股、H股的聪明指数</li>
</ul>


<h4>上证红利指数 (000015)</h4>

<ul>
<li>上交所过去两年平均现金股息率最高的50只股票</li>
</ul>


<h4>中证红利指数 (000922/399922)</h4>

<ul>
<li>上交所和深交所挑选过去两年平均现金股息率最高的股票，成份股数量扩大到100只。</li>
</ul>


<h4>深证红利指数 (399324)</h4>

<ul>
<li>专门投资深交所的高现金股息率的股票，不过成份股只有40只。</li>
</ul>


<h4>红利机会指数 (501029)</h4>

<ul>
<li>传统的红利指数，一般只是挑选高股息率的股票，没有其他的要求。</li>
<li>红利机会指数有3个要求：过去3年盈利增长必须为正；过去12个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过33%。符合这3个要求的成份股才能入选，所有入选的股票再按照股息率排名选出股息率最高的100只股票，构成红利机会指数。</li>
</ul>


<h4>中证基本面50指数</h4>

<p>基本面指数中，在国内最出名的就是中证基本面50指数。这个指数是按照4个基本面指标，挑选出综合排名前50的公司。具体来说，是从上市公司过去5年的年报数据中，计算4个基本面指标。</p>

<ul>
<li>营业收入：公司过去5年营业收入的平均值。</li>
<li>现金流：公司过去5年现金流的平均值。</li>
<li>净资产：公司在定期调整时的净资产。</li>
<li>分红：公司过去5年分红总额的平均值。</li>
</ul>


<h4>深证基本面60、120指数</h4>

<p>深证基本面60、120是基本面系列指数，跟之前我们提到过的基本面50规则一样。挑选市场上收入、净利润、净资产、分红综合起来最大的公司。</p>

<p>基本面120的成分股平均市值规模，跟中证200是最接近的。所以可以作为中证200的良好替代品。</p>

<h4>沪深300价值指数</h4>

<ul>
<li>以沪深300指数样本股中价值因子评分最高的100只股票为成分股，采用价值因子数值作为权重分配依据。</li>
</ul>


<h4>中证500低波动</h4>

<ul>
<li>从中证500指数中，挑选波动率最低的150只股票组成的。 波动率越低的股票，权重越高。</li>
<li>每半年更换股票的时候，500低波动会因为成分股的更新，估值出现较大波动。</li>
</ul>


<h2>投资品种筛选</h2>

<h4>指数筛选</h4>

<ol>
<li>不择股，宽基指数优于行业指数</li>
<li>两个指数有重叠，选更宽的一个 （沪深300>上证50）</li>
<li>两个指数重叠，选策略加权的哪一个 (上证50AH优选>上证50)</li>
<li>宽基指数再用策略筛选，优先选择策略指数</li>
<li>最终组合的关联度要小</li>
</ol>


<p>综合考虑，我们选取以下指数作为标的：</p>

<ul>
<li>上证50AH</li>
<li>沪深300价值</li>
<li>中证500低波动</li>
<li>深证基本面120</li>
<li>红利机会指数</li>
<li>恒生指数</li>
<li>标普500</li>
<li>纳斯达克</li>
</ul>


<h4>指数基金筛选</h4>

<ol>
<li>选场外基金</li>
<li>选费率低的基金</li>
<li>港股指数选沪港通</li>
<li>和增强指数相比，优先选取策略指数，增强指数人为因素多，市场越成熟，增强效果越小，但是当前增强指数还是值得选择，随着市场进一步成熟，我们会慢慢转移到ETF联结基金上以降低费率；</li>
<li>盘子大，成立时间久，便于历史数据回测</li>
</ol>


<p>(整理时间:2019.04.1)</p>

<table>
<thead>
<tr>
<th>基金简称 </th>
<th> 基金代码 </th>
<th> 管理费率% </th>
<th> 托管费率% </th>
<th> 申购费率%(取10%) </th>
<th> 规模 亿  </th>
<th> 最大回撤 %</th>
</tr>
</thead>
<tbody>
<tr>
<td>华宝标普中国A股红利机会指数A</td>
<td>501029</td>
<td>0.75</td>
<td>0.15</td>
<td>0.1</td>
<td>20</td>
<td>29.36</td>
</tr>
<tr>
<td>申万菱信沪深300价值指数</td>
<td>310398</td>
<td>0.65</td>
<td>0.15</td>
<td>0.12</td>
<td>20</td>
<td>40.25</td>
</tr>
<tr>
<td>景顺中证500行业中性低波动</td>
<td>003318</td>
<td>0.5</td>
<td>0.1</td>
<td>0.12</td>
<td>8.13</td>
<td>33.5</td>
</tr>
<tr>
<td>嘉实深证120联接</td>
<td>070023</td>
<td>0.5</td>
<td>0.1</td>
<td>0.12</td>
<td>5.84</td>
<td>39.22</td>
</tr>
<tr>
<td>华夏上证50AH优选指数A</td>
<td>501050</td>
<td>0.5</td>
<td>0.1</td>
<td>0.15</td>
<td>9.17</td>
<td>23.63</td>
</tr>
<tr>
<td>国泰纳斯达克100指数</td>
<td>160213</td>
<td>0.8</td>
<td>0.25</td>
<td>0.15</td>
<td>7.34</td>
<td>22.25</td>
</tr>
<tr>
<td>博时标普500ETF联接A</td>
<td>050025</td>
<td>0.6</td>
<td>0.25</td>
<td>0.12</td>
<td>4.26</td>
<td>18.08</td>
</tr>
<tr>
<td>华夏沪港通恒生ETF联接A</td>
<td>000948</td>
<td>0.5</td>
<td>0.1</td>
<td>0.12</td>
<td>7.89</td>
<td>31.91</td>
</tr>
</tbody>
</table>


<h2>Beta因子</h2>

<h4>以下因子仅适用于宽基指数</h4>

<h4>数据永远在变，切勿刻舟求剑</h4>

<h4>收益率ROE</h4>

<p>ROE = PB/PE</p>

<p>ROE是称重机，长期来看，股票的回报率趋近于ROE。大多数时间里，宽基指数的ROE维持在10-15%左右。</p>

<h4>市净率PB</h4>

<p>同样是股权资产，有的股权资产ROE就比较高而且稳定，像消费类医药类公司；有的股权资产ROE呈周期性波动，像钢铁石油券商；有的股权资产走向了没落，ROE甚至变为负数，是赔钱货。所以针对不同资产的定价也不同。</p>

<p>从定性的角度，ROE越高、越稳定，我们要买下这份净资产，每单位净资产就要花更多的钱，也就是市净率会越高。</p>

<p>所以我们买某个指数，也可以理解为是用一定的溢价（pb的数值）去买一份盈利的资产。</p>

<p>从这点，盈利收益率实际上就是折算了pb溢价之后的ROE。</p>

<p>PB在1-1.5为低估。</p>

<h4>市盈率PE</h4>

<p>进入经济周期底部的时候，盈利增速放缓，我们为盈利增长支付的溢价比较少，PE处于低位；同时ROE也会降低，我们为资产盈利能力支付的溢价也比较少，PB也处于低位。</p>

<p>PE &lt; 10 为低估</p>

<h4>十年国债</h4>

<p>十年国债代表无风险收益率；当市面上能找到的无风险收益类产品>十年国债利率X2，卖出指数，持有此产品。</p>

<h4>一些要点</h4>

<ol>
<li>指数市盈率与市净率都是较低的时候，指数处于低估区域</li>
<li>如果遇到成分股盈利下降导致指数市盈率上升，就参考市净率，看看是不是在1-1.5之间；</li>
</ol>


<h4>正常区间</h4>

<p>全市场25 PE，意味着收益率4% (超过十年期国债)。此时全市场一般 1.5-2 PB</p>

<h4>系统性低估机会</h4>

<p>市场出现PE&lt;7、PB&lt;1、股息率>5% (ROE>18%)的品种时，属于系统性低估机会</p>

<h4>系统性高估顶部</h4>

<p>全市场整体60 PE，整体PB>5.5，哈迪斯之顶</p>

<h4>警惕</h4>

<ol>
<li>低市盈率陷阱</li>
<li>高股息陷阱</li>
</ol>


<h4>历史经验</h4>

<p>各指数的历史平均估值</p>

<p>从09年之后</p>

<ul>
<li>上证50的主要估值在9-16倍之间</li>
<li>沪深300在10-18倍之间</li>
<li>中证500在28-53倍之间</li>
<li>H股指数在9-13倍之间</li>
<li>红利指数在9-15倍之间</li>
</ul>


<p>自成立以来</p>

<ul>
<li>恒生指数在11-18倍之间</li>
<li>标普500自成立以来在10-20倍之间</li>
</ul>


<h1>低估不定期不定额策略</h1>

<p>好了，选取了品种，充分了解了历史，剩下的就是制定策略，回测执行啦</p>

<p>我们的策略制定原则：</p>

<ol>
<li>可复现、可回测</li>
<li>排除人工干扰，机器拯救人类</li>
<li>落子无悔，买定离手</li>
<li>低估买，高估卖，没有机会不动</li>
<li>资金分为100份分批投入</li>
</ol>


<h3>买入条件</h3>

<ol>
<li>市场出现系统性低估机会可以买入</li>
<li>单一标的PE、PB 处于历史30%以下可以买入</li>
<li>PE处于历史30%以下，且PB&lt;1.5可以买入</li>
<li>PB处于历史30%以下，且PE&lt;10 或 1/PE&lt;十年期国债利率X2，可以买入</li>
</ol>


<h3>卖出条件</h3>

<ol>
<li>市场出现系统性高估机会可以卖出</li>
<li>单一标的PE、PB 处于历史70%以上可以卖出</li>
<li>PE处于历史70%以上，且PB>2可以卖出</li>
<li>PB处于历史70%以上，且PE>25可以卖出</li>
<li>1/PE&lt;市场能找到的最小无风险收益率，可以卖出置换</li>
</ol>


<h3>简单持有</h3>

<p>不符合买入，也不符合卖出条件，简单持有即可。</p>

<p>若市场利率缓慢下行，可简单买入短债基金持有，其他情况不动。</p>

<h3>半凯利公式控制仓位</h3>

<p>采用<a href="https://xueqiu.com/3079173340/62032246">银行螺丝钉</a>的方法计算仓位；</p>

<p>其盈利增长率我们替换为10年ROE中位值，因为长远来看，PEG会趋近于ROE；用ROE更加保险</p>

<p>以恒生指数为例。</p>

<ul>
<li>恒生指数过去10年的ROE中位值10%左右</li>
<li>我们期望5年年化15%的收益率</li>
<li>PE历史30%大概为12，配合我们上面要求的条件，我们需要在10PE买入</li>
</ul>


<h4>凯利公式</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>F =（bp - q）/ b</span></code></pre></td></tr></table></div></figure>


<p>其中b代表赔率，p代表获胜率，q代表落败率，q = 1-p</p>

<h4>投资指数基金的赔率</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>赔率b =（卖出时估值/买入时估值）*【1+指数盈利增长率】^持有年数 =（1+你要求的年复合收益率）^持有年数
</span><span class='line'>
</span><span class='line'>b = （卖出时估值/买入时估值）* 1.1^5 = 1.15^5
</span><span class='line'>
</span><span class='line'>卖出时估值PE/10 ≈ 1.25
</span><span class='line'>
</span><span class='line'>要求卖出时估值 ≈ 12.5
</span></code></pre></td></tr></table></div></figure>


<p>这样就把我们的投资行为固化为了这样一个事件：</p>

<p>假如未来恒生指数能保持平均10%的ROE，我们在10PE买入恒生指数，要求有15%的年复合收益率，那我们“需要在5年的时间里，至少有一次机会在12.5倍以上市盈率卖出”。</p>

<h4>投资指数基金的胜率</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>胜率 = 期望卖出PE的历史估值概率</span></code></pre></td></tr></table></div></figure>


<p>5年时间里，12.5PE是大概率事件，事实上，我们要求在70%的PE上方卖出，这个值大概是15PE。</p>

<p>12.5PE在历史上大概处于 60%的位置， 所以我们的条件还是非常宽松的。</p>

<p>按照我们前面制定的的边界卖出条件 PE估值百分位 > 70%，所以如果能买到10PE以下的恒生指数，并且期望5年内年化收益15%的化，只要能持有不动，胜率>60%；</p>

<h4>计算仓位</h4>

<p>通过凯利公式计算出来的仓位， X0.5；成为半凯利公式</p>

<p>胜率60%，赔率2；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>F =（bp-q）/b = (2 * 60% - 40%)/2 = 40%
</span><span class='line'>
</span><span class='line'>F * 0.5 = 20%</span></code></pre></td></tr></table></div></figure>


<p>根据半凯利公式推出，推荐仓位为20%。</p>

<h4>一些推论</h4>

<ul>
<li>预期收益越低，胜率就会越高，仓位也会越高。如果预期收益过高，甚至仓位会是负数（也就是无法实现）</li>
<li>买入估值越低，胜率就会越高，仓位也会越高。如果买入估值过高，甚至仓位会是负数（无法赚取估值差收益）</li>
<li>指数的盈利增长率越高，对应的胜率也会越高</li>
<li>买入时不要求每次都能赢，但是一定要在赢面大的时候下大注</li>
</ul>


<h4>多指数组合计算仓位</h4>

<p>对组合中的每个指数设定 买入PE，卖出PE，持有年数，要求年复合增长率， 分别计算仓位</p>

<p>全部仓位相加，便可以决定总仓位。</p>

<h4>定投</h4>

<p>每次的总仓位即 定投总额 / 定投次数；比如5年计划投入60w，每月定投一次，那么每次总仓位1w；</p>

<p>每次计算卖出PE点大于历史估值70%即可盈利的品种，并决定仓位；然后所有仓位相加。</p>

<p>如果定投不定额， 每次仓位可以超过100%；</p>

<p>如果定投定额，每个品种的仓位比例再等分平均，最后达到100%</p>

<p>如果没有符合条件的品种或者总仓位&lt;100%，买入短债基金代替；</p>

<p>达到卖出条件分批减仓，减仓可以逆运算，也可以简单的用一个网格策略逐步卖出。</p>

<h4>不定期不定额</h4>

<p>如果我们有一个量化策略，可以直接把投入资金分为100份，在某个品种达到极高的胜率的时候计算仓位一把买入；然后在此之上， 采用价值平均策略定投，长期持有；</p>

<h4>卖出</h4>

<p>卖出的选择可以很简单，设定一个简化的网格策略，PE到了历史70%的区间每次卖掉1%，到了80%每次卖掉10%&hellip;.</p>

<p>或者可以更精确的来控制，我们买入每一份指数时都精确计算了5年后期待的PE值，你可以先等够5年，然后市场到了期待的PE之后卖出；</p>

<p>经过我的统计，大部分宽基指数(沪深300为例) 70%的区间值/30%的区间值 ≈ 1.3，而历史ROE趋近于10%，也就是说这么算下来，只要30%以下买，70%以上卖，大概率能达到我们的期待收益。</p>

<h1>回测</h1>

<p>为了验证我们的策略靠谱程度，我选取了最简单的样本集合：</p>

<table>
<thead>
<tr>
<th>指数代码 </th>
<th> 指数名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>000919.XSHG</td>
<td>300价值</td>
</tr>
<tr>
<td>399702.XSHE</td>
<td>深证F120</td>
</tr>
<tr>
<td>000905.XSHG</td>
<td>中证500</td>
</tr>
<tr>
<td>000922.XSHG</td>
<td>中证红利</td>
</tr>
</tbody>
</table>


<h3>历史PE，PB，估值统计</h3>

<p>夫以铜为镜，可以正衣冠；以古为镜，可以知兴替；以人为镜，可以明得失。让我们先看下历史估值。</p>

<p>每周采样；当前PE、PB值取自2019-04-10，市值加权算法统计</p>

<h4>时间段选取2004-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg1.jpg" alt="img" /></p>

<h4>时间段选取2009-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg2.jpg" alt="img" /></p>

<h4>时间段选取2011-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg3.jpg" alt="img" /></p>

<p>从图上可以看出，A股市场的整个PE和PB中枢逐年降低；所以用最近5年或者最近8年的历史数据来判断估值百分位比较靠谱。</p>

<p>另外一个感性结论，从图上很容易看出，只要是宽基指数，拉长时间来看，PE、PB的震荡曲线几乎是一样的；所以用我们的历史PE、PB估值法，每次买入的时间点可能基本相同，但是份额不同。</p>

<h2>量化回测</h2>

<p>是滴，我就是这么严谨；为了取得最大的普适性，我选取了华夏沪深300ETF联结基金作为标的，采取我们上述的策略，回测了一下：</p>

<ol>
<li>初始资金100000，分为20份，每份5000元</li>
<li>时间就选取2018-08-01 &mdash; 2019-04-10，这段时间内的波动比较大，容易看出我们策略的行动模式</li>
</ol>


<p>一图抵千言：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg4.jpg" alt="img" /></p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg5.jpg" alt="img" /></p>

<p>整个过程中，我们买入了17份，然后2019-04-02开始逐步卖出，卖出策略我选取了简单的网格策略；</p>

<p>当然，这个时间段实在太短，娱乐效果为主；不过我们还是看到了这个套路的一些特点：</p>

<ol>
<li>买入卖出的时间段都非常短，大概就持续半年左右的时间窗口，其他时间我们都是<code>不动</code></li>
<li>因为买的特别便宜，所以安全边际大，你可以很放心的持有不动</li>
<li>采用凯利公式判断仓位的方法不是特别有效，70%的百分比太严格，一般到了这里基本上每次买的份额都差不多，体现不出仓位管理</li>
</ol>


<h4>可以有如下改进</h4>

<ol>
<li>仓位管理引入PB因子，进一步实现<code>低估重手买</code>的策略</li>
<li>20份资金有点少，可以增大资金分数</li>
<li>多个指数组合策略，进一步降低风险，也能把握更多机会</li>
<li>70%的百分比标准可以适当放宽</li>
</ol>


<p>采用了上述优化策略之后，需要在一个较长的时间周期中回测(2010-2019)检验其靠谱程度。</p>

<h2>量化回测2</h2>

<p>调优了几个小参数：</p>

<ul>
<li>投注份额改为50份；原因：做了大量统计之后，虽然我们的买入点实在PE历史30%以下，但实际上以5年为区间，买入的时机只有1年左右，我们按周测算，总投注份额50份为佳</li>
<li>为了方便计算，总投注金额为50000元，每份1000元</li>
<li>对于卖出策略做了简单的优化</li>
<li>回测时间拉长到2012-10-01 &mdash;&ndash; 2019-04-10</li>
<li>计算PE、PB的历史估值区间选取前5年；原因：A股市场每7年就有一次大的波动，其实把这种波动放在总的统计数据里面是失真的，5年时间刚好能避开此类波动，而且我国每5年一个经济计划，一定程度上5年时间反应了一个小的经济周期</li>
</ul>


<p>代码放在这里：</p>

<p><a href="https://github.com/memoryboxes/kanglong">https://github.com/memoryboxes/kanglong</a></p>

<p>好啦，我们还是以沪深300为基准，看看这个策略和原指数的对比：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg6.jpg" alt="img" /></p>

<p>从这个画风上来看，这个策略确实是一个看后视镜开车的老司机，结果拟合相当完美；你可以把它看成是一个超级稳健、超级耐心的基金经理，这个经理的风格如下：</p>

<ol>
<li>超级稳健，超级懒，80%的时间是持有现金不动的</li>
<li>其7年的总收益为87%，这个没有计算现金产生的收益，如果按照3%的货基收益，总收益是可以超过100%的；</li>
<li>最大回撤&lt;10%</li>
</ol>


<h4>当然，看后视镜开车开的再好也只是个参考，这个策略作为一个简单易行的思路还是有不少借鉴意义的。关键是它给了我们<code>身处何方</code>的坐标。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[资产配置初探]]></title>
    <link href="https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan/"/>
    <updated>2019-04-07T14:51:33+08:00</updated>
    <id>https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan</id>
    <content type="html"><![CDATA[<p>在<a href="https://www.douban.com/doulist/112721741/">死读书一年</a>之后，对这个问题自我感觉颇有心得，谬论如下：</p>

<blockquote><p>道理已在书单中，只记录我的思考结果</p></blockquote>

<ul>
<li>这个世界上有两种永远成立的投资方法：基于选取资产标的获取超额收益，以及基于资产配置获取市场平均收益。</li>
<li>对普通人来说，资产配置优于择时择股</li>
</ul>


<!-- more -->


<p>资产配置选择包括不动产、国债、黄金、大类资产、货币基金、银行固收、债券逆回购、可转债、地方债、企业债、分级基金、指数基金、个股、股指期货等；</p>

<p>个人能驾驭的不过是三样：不动产、债券、ETF</p>

<p>我个人认为除了中心城市的不动产有配置价值之外，其他城市只有使用价值，故而排除在外；以下我尝试着只利用权益类资产来构建一个可攻可守的组合。</p>

<p>为了娱乐自己，我总结出来的普适个人的资产配置方法称之为降龙四式：</p>

<h4>第一式密云不雨</h4>

<p>总流动现金的20%配置为现金、银行固收、货币基金、7天债券逆回购；</p>

<p>要求拥有完全的流动性和安全性；其边际风险等同于国债。这是完全的防守招式。</p>

<h4>第二式潜龙在渊</h4>

<p>总流动现金的35%构建一个股债平衡的资产包；</p>

<p>其中80%选取流动性好、配置稳健的债基、其20%选取两个ETF(沪深300和中证500)做二八轮动；</p>

<p>80%的债和20%的股每过半年做动态再平衡；</p>

<p>且慢有个<a href="https://qieman.com/portfolios/ZH006358">安心动盈</a>的策略，跟我不谋而合。</p>

<p>这一招守中带攻，在第一式的基础上(两招相加55%的现金流)保证自己立于不败之地</p>

<h4>第三式亢龙有悔</h4>

<p>总现金流的15% 价值平均策略定投低估指数；</p>

<p>选取宽基策略指数(具体策略另外文章详述)；根据PE、PB、ROE、十年国债收益率确定入场时机，根据半凯利公式决定仓位，采用价值平均策略定投，子弹五年陆续打完；</p>

<p>这一招以攻代守，在指数低估时间入场、利用定时不定额定投降低风险；</p>

<p>切记，只有在前两式基础上，才能施展此招；这三式已然能在江湖行走而自保。</p>

<h4>第四式飞龙在天</h4>

<p>将总资金的30%投入到你最看好的一项资产中，<strong>永远持有</strong></p>

<p>这一招具有极大的杀伤性，用的好伤敌一千，用的差自伤八百。一定要在前三式完全施展之后才能接续此招。</p>

<h4>动态再平衡</h4>

<p>20%，35%，15%, 30%的比例每年做一次动态再平衡，同时取出一年生活用的现金流。</p>

<h2>总结</h2>

<p>前三式配置了所有资金的70%，是个攻守结合的套路，并且每一式都充分考虑了安全边际，力求风险最小化；</p>

<p>最后一式是一往无前、只求进攻、落子无悔的拼命招式，带有大概率的赌的成分；其成败完全取决于个人眼光和运势；</p>

<p>施展飞龙在天，我个人认为最好要35岁之后，一旦施展，无从回头；</p>

<h2>实践</h2>

<p>光说不练假把式，下面是我的实盘配置：</p>

<table>
<thead>
<tr>
<th>招式 </th>
<th> 配置品种 </th>
<th> 比例% </th>
<th> 期待收益% </th>
<th> 最大回撤%</th>
</tr>
</thead>
<tbody>
<tr>
<td>密云不雨 </td>
<td> 定存、货基、7天债券逆回购 </td>
<td> 20 </td>
<td> 3.5 (等同于十年国债收益率) </td>
<td> 0</td>
</tr>
<tr>
<td>潜龙在渊 </td>
<td> 安心动盈 </td>
<td> 35 </td>
<td> 8-10 </td>
<td> 3-5</td>
</tr>
<tr>
<td>亢龙有悔 </td>
<td> 低估指数定投(具体策略另述) </td>
<td> 15 </td>
<td> 12-18 (企业长期ROE) </td>
<td> 10-20</td>
</tr>
<tr>
<td>飞龙在天 </td>
<td> 比特币 </td>
<td> 30 </td>
<td> 50 </td>
<td> 90</td>
</tr>
</tbody>
</table>


<p>每年收益的最大期望值为： 20 * 0.035 + 35 * 0.1 + 15 * 0.18 + 30 * 0.5 =  21.9%</p>

<p>每年最大回撤为: 20 * 0 + 35 * 0.05 + 15 * 0.2 + 30 * 0.9 = 31.75%</p>

<p>由此可以看出飞龙在天这一招的风险所在，飞龙在天的风险远远超过了收益，在纯粹的概率游戏中不应该施展；</p>

<p>但是对我而言，经过了5年多的反复思量，我认为这个标的值得施展这一招；</p>

<h4>当然，过度自信是悲剧的源泉，好在31.75%的风险还算不上万劫不复；如果没有绝对的自信的话，前三招行走江湖足矣。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《 the Internet of Money》读书笔记]]></title>
    <link href="https://happy123.me/blog/2019/03/10/the-internet-of-money-du-shu-bi-ji/"/>
    <updated>2019-03-10T15:58:21+08:00</updated>
    <id>https://happy123.me/blog/2019/03/10/the-internet-of-money-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>再三犹豫之后我决定写下这篇笔记。来表达我对Andreas M Antonopoulos 先生的景仰之情。</p>

<p>《The Internet of Money》是对Andreas M Antonopoulos历年公开演讲的精华汇总，目前总共出了两卷；我得说，这两本书是这两年除了《The Book of Satoshi》之后最让我享受的非技术书籍。</p>

<!-- more -->


<p>关于Andreas M Antonopoulos，都不需要多做介绍了；我是他的Youtube主页忠实粉，他的每一个演讲视频都仔仔细细看过；但是将其整理为文字，汇聚成册后，再读起来还是止不住的惊叹；借用这本书的编者的话说：</p>

<blockquote><p>他渊博的知识、 对复杂概念流利地解说和清晰的思想令我们惊叹不已。 我们看到在每一次演讲过程中， 他都充满着激情、 具有深远的见解； 他使用强大的类推法，用简单的术语来介绍最难理解的主题内容。记得我当时还在想“这个人怎么能对这么新颖的事物有如此深刻的了解呢？</p></blockquote>

<p>随便翻开一页，都能津津有味的读下去，我得说，除了金庸小说和科幻小说，还真没有哪本书有类似效果； 我对Andreas M Antonopoulos 真是佩服的五体投地，宣扬一项新技术并不难，难的是像老娘舅一样日日讲，月月讲，年年讲，换着花样讲，每次都能讲出新意； 这就是先知的技能！</p>

<p>虽然说起来真的好像搞传销的，但是有时间的朋友去买一下这两本书看看吧，绝对不会让你失望。</p>

<p>有一些类比；我们在接受新事物的时候，难免会拿以往的经验，或者说历史经验来衡量这个新事物或者说是新理念；但新事务一般是颠覆旧有秩序的，此时我们的头脑就会陷入经验主义的窠臼，而且人对于<code>未知</code>是相当恐惧的；这就造成了傲慢以及守旧。</p>

<p>举一些很简单的例子：</p>

<ul>
<li>直流电和交流电之争</li>
<li>光的波粒二象性</li>
<li>飞机的发明</li>
<li>汽车的发明</li>
</ul>


<p>像飞机或者汽车的演化斗争，就比较简单，因为人对于有形的事物接受能力总是比较快，当飞机在天上飞，汽车在地上跑，其高速的隆隆声很容易就证明自己，人们眼见为实，态度便会转为<code>真香</code>；但是比较抽象的东东就不行了；</p>

<p>我能想到的最明显的例子，就是历史上日心说对于地心说的冲击。</p>

<p>凭良心说，假如让我回到中世纪，妄想凭借自己的数理知识，要让周围的人信仰日心说，死心塌地的承认<code>地球绕着太阳转</code>这个事实，我是一点自信也没有的，搞不好还自身难保，被弄上绞刑架。</p>

<p>再退一步说，我第一次得知<code>地球绕着太阳转</code>这个知识的时候，其反应是怎么样的呢？我竟然一点也记不起来了！！</p>

<p>真是可悲的一件事情啊；人们在面对新理论的时候，很容易根据日常经验或者历史经验采取抵抗、恐惧的态度，但是接受之后，又会变得如此自然，甚至这个接受了新理论之后反而又会变成接受更新的理论的绊脚石。</p>

<ul>
<li>脱离历史经验去看待新事物容易冒进，太过拘泥于历史经验又导致短视，到底如何是好呢？</li>
</ul>


<p>我想到的一个办法就是，先尽量把自己放空，把自己放回<code>一无所知</code>的状态(其实就是乔大爷反复强调的stay stupid)；然后从常识出发，慢慢去消化这个理论；当觉得好像有点入戏了，再 <code>捡回</code> 历史经验，去判断这个新事物真伪好坏。</p>

<h4>拿接受<code>地球绕着太阳转</code>这个理论做例子，大概过程是这样的：</h4>

<p>先知：Hi, 小男孩，告诉你一个秘密，其实你脚下的土地并不是坚实稳当的，我们正处在一个慢慢转动的球体上，这个大球正慢慢绕着太阳旋转！！</p>

<p>小男孩： 纳尼！？ 为什么我没觉得自己在动？ 如果不停的转呀转呀，不是怎就头晕了吗？还有，我怎么觉得是太阳在绕着我转呢？</p>

<p>先知： 孩子呀，想一想，你坐过火车吗？ 坐火车的时候，如果把窗帘拉上，会觉得自己在动吗？</p>

<p>小男孩(思索状)：好像没有，有一次我睡了，醒了之后妈妈就告诉我已经到了，好神奇，我一点也没有觉得自己动，却走了那么远！</p>

<p>先知： 道理就是这样的啊。我们脚下的这个大球非常非常大，他相对于我们的感觉来说移动非常非常慢，这样我们就不觉得自己在动，或者头晕了？</p>

<p>小男孩： 那为什么我没有从球上掉下去呢，而且即使我们在动，也明明是太阳绕着我们转嘛。</p>

<p>先知： ~~~&hellip;&hellip;&hellip;..</p>

<p>好吧，在我的想象当中，这个先知拥有惊人的耐心和智慧，才能为一个小男孩解释清楚<code>地球绕着太阳转</code>这个论题；最重要的是，小男孩没有太多历史经验的束缚，他在这个世界上活的时间还少，比较容易被说服！！</p>

<p>悲哀的是，我们可以想象，经过先知引导，这个小男孩自以为领悟了<code>地球绕着太阳转</code>这个事实之后，快乐的跑回家告诉家中的父母，而他的父母的知识还处在中世纪，会是什么反应！！</p>

<p>我们可以再想象一下，假如将来人类殖民太空，每个在太空出生的孩子都能在空间站的窗口瞭望地球，他们的该是怎样的一种世界观啊。</p>

<p>套用到电子货币上来；假如未来世代，每个人从出生到死亡，都离不开电子设备和网络，或者说，他们是真正<code>互联网生存</code>的一代，今天Andreas M Antonopoulos先生所讲的事情就不难理解了。</p>

<p>最后，再回到Andreas M Antonopoulos先生的演讲，我被他的那种热情、洞察力深深折服了，他其实是在做着一件特别危险、特别没有收益的事情，却在这个事情上投入了全部的智慧和精力。高山仰止，景行行之。虽不能至，心向往之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《 the Book of Satoshi》 读书笔记]]></title>
    <link href="https://happy123.me/blog/2019/02/13/the-book-of-satoshi-du-shu-bi-ji/"/>
    <updated>2019-02-13T18:38:16+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/the-book-of-satoshi-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>《The Book Of Satoshi》 这本书我反复读了不下十遍，深深着迷，安利一下。</p>

<!-- more -->


<p>超级棒的一本合集。感谢作者的整理。看到这本书的评论区如此冷清，实在可惜，就啰嗦几句。</p>

<p>在对比特币的白皮书所有技术细节了然于胸之后，再读这本书别有风味；每天睡前随手翻上几页，好像穿越过去阅读科幻小说的体验。</p>

<p>我越来越坚信中本聪只是一个普通的网络专家而已，他是个MS流派C++码农，熟悉GUI、网络编程，以及了不起的密码学造诣；看看bitcoin v0.01的代码和早期在论坛上的发言，他的伟大之处在于对一个问题反复的思索探究；所谓锲而不舍，金石可镂；这本合集完全展现了一项新技术是如何经过天才的孕育、众人的打磨、坚持、探索、怀疑、争辩、信服，最终来到世间，生根发芽，艰难成长的；</p>

<p>虽然里面基本上所有的内容都被社区发掘完毕，学习消化了，但是每次重读，总有新感悟，挑几个书里面很有意思的点来说说。</p>

<ol>
<li><p>早期的参与者基本上都是100%的Geek，像后来我们耳熟能详的Hal Finney、Laszlo Hanyecz、Gavin Andresen、bytemaster、theymos等等，反而是Andreas M. Antonopoulos 参与的比较晚；</p></li>
<li><p>Hal Finney曾经在论坛上说自己是第二个运行比特币软件的人，他挖到的第一个区块大概是第70 Block，可以肯定，第70 block之前所有的地址都是中本聪本人的钱包地址</p></li>
<li><p>Laszlo Hanyecz应该是已知的显卡挖矿第一人，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p></li>
<li><p>中本聪最初发布0.01版本的bitcoin时候，初始区块大小是32MB，后来防止DDOS才改成了1MB；他明确说了将来硬件发展，区块大小不是问题；但是他也明确提出了微支付通道的应用场景；估计今天中本聪对怎么扩容也没有准主意；</p></li>
<li><p>比特币的地址有 2<sup>160</sup> 的区间，中本聪认为已经足够了</p></li>
<li><p>关于可扩展性和速度，当时的中本聪其实已经高瞻远瞩到了未来的0确认和微支付技术，并对bytemaster说出了那句著名的:&ldquo;If you don&rsquo;t believe me or don&rsquo;t get it, I don&rsquo;t have time to try to convince you, sorry.&rdquo; ；这句话真是超级怼人啊；</p></li>
<li><p>早期的社区蛮有危机感的，详细讨论了一个国家设置一个大洲将比特币网络隔绝在外的时候会发生什么，怎样应对这种状况；</p></li>
<li><p>对于DDOS，中本聪的应对就是手续费，早期是可以发0手续费的交易的，后来遭遇DDOS攻击，讨论了一个算法，就是0手续费的交易要延迟入块，再到现在，所谓&lt;568 satoshi 的交易视为dust交易；我相信将来围绕这个点，社区还会爆发争论的；</p></li>
<li><p>中本聪早期明确表示比特币的链要尽可能表示精简，像在链上发送消息这种事情应该放到侧链上来做，所以可见的未来，像BCH、BSV扩大OP_RETURN字节的设定实在是有点心大；</p></li>
<li><p>关于挖矿耗费能源，中本聪表示今后可以在寒冷地区推行一边挖矿一边取暖的措施；乍一听好像不靠谱，其实仔细想想完全说得通。硬件99%的能源其实就是转化为了热量，将来矿机的成本低于一个小电暖之后，为什么不能在俄罗斯、加拿大一些靠北的城市建立大矿厂，一边供暖一边挖矿呢？我觉得完全可行。</p></li>
<li><p>关于bitdns，或者说今天的namecoin，虽然讨论只有寥寥几段，但是非常精彩。可直到今天侧链技术也是不温不火；这说明两个问题：</p>

<ul>
<li><p>在大部分领域，大众对于去中心化的需求并不高，这不是痛点；像DNS，现在的中心化方案工作的挺好的</p></li>
<li><p>维持一条公链消耗巨大的能源，实在是太金贵了；痛点不足的应用勉强上链也不会有太多用户；真理要慢慢说，群众接受需要时间，一口气说出来会吓坏大家。</p></li>
</ul>
</li>
<li><p>关于比特币的经济属性，Hal Finney觉得bitcoin最终会成为黄金中的黄金，即作为所有数字货币的锚定物；而中本聪也承认bitcoin更接近于一种收藏品。</p></li>
<li><p>Laszlo Hanyecz提出了一个有意思的问题，说将来矿机算力会不会碰撞私钥的收益超过比特币挖矿的收益；中本聪回答这得整体算力达到2<sup>200</sup>的级别才可以；这应该是中本聪随口说说，我仔细测算了一下，可能达到2<sup>100</sup>的级别就有利可图了</p></li>
<li><p>然后关于币价，中本聪其实也觉得挖矿成本会成为基本面；因为bitcoin是一个非常有趣的产品，人们觉得价格不合适，就是自己去挖；所以挖矿成本和币价总会有个伴生关系</p></li>
<li><p>中本聪是在2007年开始考虑创造bitcoin的，并且他作为一个实干家代码先行；然后blockchain这个单词最初出现在bitcoin v0.01的代码注释里；所以严格考证起来：中本聪是bitcoin之父，bitcoin是blockchain之母，blockchain技术诞生于2007年。</p></li>
</ol>


<p>最后冒险的做一些推测：</p>

<ol>
<li><p>虽然Segwit的升级将bitcoin全网链上的处理能力提高为7TPS，一年的极限也不过是区区2亿笔交易；假设将来要服务10亿用户，即使闪电网络极大繁荣，有许多大中转节点，假设一个用户一年只有一次链上<code>存取</code>的动作，也需要两次交易，就是整个主网链上一年要处理20亿笔交易；所以即使是bitcoin core，将来区块还是要扩容</p></li>
<li><p>BCH和BSV 开放OP_RETURN限制，以及 bip62 解决延展性交易的手段实在是太冒险了；当然，历史有时候也青睐冒险者</p></li>
<li><p>DDOS交易其实一直没有根除，即使加入了手续费用限制，内存池还是有被撑爆的风险，我觉得将来社区还会有争论</p></li>
<li><p>像OP_HODL等操作符，还有Locktime的交易，还是应用太少，将来他们应该大放异彩</p></li>
</ol>


<p>最后的最后，这是一本非常有趣、科技含量非常高的科普读物；可能会在遥远的未来(100年，还是1000年，谁知道呢？)， 里面的许多句子会广为人知，并记载在史书上；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于GDP的一些随想]]></title>
    <link href="https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang/"/>
    <updated>2019-02-13T16:11:49+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang</id>
    <content type="html"><![CDATA[<h2>GDP是什么</h2>

<p>国内生产总值 (gross domestic product， GDP) 是在某一既定时期一个国家内生产的所有最终物品与劳务的市场价值。</p>

<p>GDP（用Y代表）被分为四个组成部分：消费（C）、投资（I）、政府购买（G）、净出口（NX）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Y = C ＋ I ＋ G ＋ NX</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<ul>
<li>消费(consumption)是家庭用于物品和劳务的支出</li>
<li>投资(investment)是将用于未来生产更多物品和劳务的物品购买。它是资本设备、存货和建筑物购买的总和。建筑物投资包括新住房支出。按习惯，新住房购买是划入投资而不划入消费的一种家庭支出形式。</li>
<li>政府购买(government purchase)包括地方政府、州政府和联邦政府用于物品与劳务的支出。它包括政府员工的薪水和用于公务的支出。</li>
<li>净出口(net export)等于外国人购买国内生产的物品(出口)减国内购买的外国物品(进口)。</li>
</ul>


<p>&mdash; 摘自曼昆的《经济学原理》</p>

<h2>GDP怎样计算</h2>

<p>GDP有3种方法进行核算：生产法、收入法和支出法。</p>

<h4>生产法</h4>

<p>生产法是我国GDP的统计方法。</p>

<p>我们把GDP从产业的角度，分成第一、二、三产业，分别算它们的增加值然后进行加总，当然还要从最终产品和中间投入两方面扣除通胀因素。</p>

<p>用生产法计算的GDP，是指各部门在核算期内的增加值。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=各部门的总产出-各部门的中间消耗</span></code></pre></td></tr></table></div></figure>


<p>对于第一产业的农林牧渔业，总产出就是多少斤粮食的价值；</p>

<p>对于第二产业——工业，那就是生产出的所有商品的价值；</p>

<p>第三产业服务业的范围比较广，计算方法也更加复杂，比如说理发师理一次发的价值，律师咨询一次的劳务价值等等。中间消耗指的是生产过程中的消耗，但要记住：中间消耗不等于成本。举个栗子：</p>

<p>工厂生产了1000个毛绒玩具，产值1万元，期间机器保养和修理花费了2000元，员工薪资4000元，那么按照生产法的话，笨笨工厂的GDP则是10000-2000=8000元。中间消耗你可以理解成为了产值而产生的费用，而成本则是一种固定的支出。就好比你今天去体彩中心领奖金10万块，请保镖花了300，但是你去体彩中心的路上打车花了20。如果要用生产法计算你为社会创造的GDP的话，那就是100000-20=99980块，因为你的“产值”是奖金，而不是保镖费。</p>

<h4>收入法</h4>

<p>收入法是从各个生产要素的收入角度来计算GDP。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=劳动者报酬+生产税净额+固定资本消耗+营业盈余</span></code></pre></td></tr></table></div></figure>


<p>劳动者报酬就是个人劳动者的收入；</p>

<p>生产税净额就是上交给国家的各种税费减去政府补贴；</p>

<p>营业盈余就相当于营业利润加上补贴，扣除工资和福利等。（但营业盈余不等于营业利润，营业盈余是生产概念，营业利润是销售概念）比如工厂生产了价值1万块钱的玩具，贡献了1万块的GDP（不考虑保养和修理费），拆分一下：员工薪资4000元（劳动者报酬）交税1000元，收到补贴500元，即净额500元（生产税净额）固定资本折旧500；剩下的就是营业盈余5000</p>

<h4>支出法</h4>

<p>支出法其实就是曼昆的公式，即加总全社会各类货物和服务的最终消费总额：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（消费（C）+投资（I）+政府购买（G）），再加上净出口</span></code></pre></td></tr></table></div></figure>


<p>公式变形如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=最终消费+资本形成总额+净出口</span></code></pre></td></tr></table></div></figure>


<p>最终消费很简单，就是一国常住居民和政府部门在货物和服务上的总花费，比如你下班回家后买零食的花费，以及国防部买军舰坦克的花费。</p>

<p>资本形成总额资本形成总额指常住单位在一定时期内获得的减去处置的固定资产和存货的净额，就好比你搬家了，购置了冰箱和洗衣机，共花费3000块，然后卖掉了一台旧洗衣机500块，那么你的可以资本形成总额就是2500块。放在GDP角度，企业购置机器的钱，扣除处理旧机器的钱，就是企业的消费。</p>

<p>净出口净出口指的是货物和服务总出口减去总进口。</p>

<p>多者相加，得出的即是支出法下的GDP。</p>

<p>引自:</p>

<p><a href="https://zhuanlan.zhihu.com/p/34944269">https://zhuanlan.zhihu.com/p/34944269</a></p>

<h2>中国历年GDP 计算</h2>

<p><a href="https://dwz.cn/gXrciFJw">wiki</a></p>

<h2>神奇的官方预计与统计</h2>

<p>每年开年，国家统计局都会发布新一年的GDP增速预测，而到了年底，也都会发布当年的实际GDP增速。</p>

<p>比如:</p>

<p><a href="http://www.stats.gov.cn/tjsj/zxfb/201901/t20190118_1645555.html">国家统计局关于2017年国内生产总值（GDP）最终核实的公告</a></p>

<p>神奇的是，每次的预测与实际误差都在0.1%左右，而且连续10年预测神准。</p>

<p>如果2019-01-01上证指数是2600点，有人信誓旦旦的对你说，我预测2019-12-30上证指数是 2760-2765 点，绝对在这个范围内！！</p>

<p>你相信吗？</p>

<p>现在国家统计局对你说，2019年国家GDP增速预计在 6.3%，然后年底一看，6.4%增速，误差千分之一，而且连续十年神准。</p>

<p>不管你信不信，我是信了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的过去，现在和未来]]></title>
    <link href="https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-%2Cxian-zai-he-wei-lai/"/>
    <updated>2019-01-25T22:31:39+08:00</updated>
    <id>https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-,xian-zai-he-wei-lai</id>
    <content type="html"><![CDATA[<p>自中本聪在<a href="http://20090103.com">2009-01-03</a>挖出第一个block开始，比特币已经运行整整十年了！</p>

<p>不可思议的历程，毕竟欧元也不过出现20年，iphone也不过出现12年而已；比特币其实已经超越了历史上许多国家法币的寿命！</p>

<!-- more -->


<h2>过去</h2>

<p>在比特币的历史早期 2009-2012年，比特币社区是一个蓬勃向上的集体，每天都在诞生不可思议的想法；关于那段燃情岁月，可以参考这本书<a href="https://www.amazon.com/Book-Satoshi-Collected-Writings-Nakamoto-ebook/dp/B00M6KGJ2K">The Book Of Satoshi</a>；现在读来，仍然为那个时候的先行者们的聪明睿智、古灵精怪、天马行空深深吸引；</p>

<h2>现在</h2>

<p>当比特币逐渐建立信用，有人认可其价值之后，引来了数不清的骗子、强盗、谎言、自大狂，以及别有用心的利己者，最可怕的，是价值观导致的社区分裂，2013年之后，比特币一直处在漩涡中心；</p>

<p>让我们听听那些权威睿智人士们的声音：</p>

<h4>2001诺贝尔得主Joseph Stiglitz 教授在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>“Bitcoin is successful only because of its potential for circumvention, lack of oversight.”“So it seems to me it ought to be outlawed,”“It doesn&rsquo;t serve any socially useful function.”“It&rsquo;s a bubble that&rsquo;s going to give a lot of people a lot of exciting times as it rides up and then goes down.”</p></blockquote>

<h4>2013诺贝尔得主Robert J. Shiller 教授同样在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>&ldquo;Bitcoin, it&rsquo;s just absolutely exciting,&rdquo;</p>

<p>&ldquo;You&rsquo;re fast. You&rsquo;re smart. You&rsquo;ve figured out nobody else understands. You&rsquo;re with it. And bitcoin has this anti-government, anti-regulation feel. It&rsquo;s such a wonderful story. If it were only true.&rdquo;</p>

<p>&ldquo;I don&rsquo;t know where it&rsquo;s going to stop,&rdquo; &ldquo;It&rsquo;s going to go way up, like the stock market in the 1920s. We will reach a 1929 eventually. But then it won&rsquo;t go to zero, it just will come down.&rdquo;</p>

<p>&ldquo;I&rsquo;m not as negative as it may seem, but I think that the thing that&rsquo;s driving bitcoin at the moment, like other examples of bubbles, is a story,&rdquo; Shiller said. &ldquo;And it&rsquo;s the quality of the story that&rsquo;s attracting all this interest, and it&rsquo;s not necessarily sustainable.&rdquo;</p>

<p>&ldquo;I don&rsquo;t mean to say that we&rsquo;re going to see a burst in bitcoin tomorrow and it will be gone forever. We did see a burst in 2013, by the way. It could happen again, and then it could take off again,&rdquo; the professor said.</p></blockquote>

<h4>2013诺贝尔得主Eugene Fama 教授在2015年11月CoinTelegraph的采访中谈及比特币:</h4>

<blockquote><p>&ldquo;People won&rsquo;t use it because basically it&rsquo;s very difficult to know how much you need to settle. It is quite variable, they won&rsquo;t want to hold it as just a way of settling payments, they will try to get rid of it quickly, as they do; and that&rsquo;s not good for the survival of that kind of a unit of account,&rdquo;</p>

<p>&ldquo;As if it doesn&rsquo;t have a stable value it&rsquo;s probably not going to survive as a unit of account. What that means is that its value is likely to go to zero at some point.&rdquo;</p>

<p>&ldquo;I guess that for a drug dealer that has a lot more value.&rdquo;</p></blockquote>

<h4>2014年经济学奖获得者Jean Marcel Tirole 2017年发文谈及比特币：</h4>

<blockquote><p>Bitcoin may be a libertarian dream, but it is a real headache for anyone who views public policy as a necessary complement to market economies. It is still too often used for tax evasion or money laundering. And how would central banks run countercyclical policies in a world of private cryptocurrencies?</p></blockquote>

<h4>智慧的源泉，奥马哈的先知，巴菲特先生谈及比特币:</h4>

<blockquote><p>In terms of cryptocurrencies, generally, I can say with almost certainty that they will come to a bad ending</p>

<p>It&rsquo;s a mirage basically, I mean it&rsquo;s a method of transmitting money. The idea that it has some huge intrinsic value is just a joke in my view.</p></blockquote>

<p><a href="https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html">https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html</a></p>

<h4>终生学习的百科全书式的人物，我们敬仰的芒格先生谈及比特币:</h4>

<blockquote><p>You know it is one thing to think gold has some marvelous store of value because man has no way of inventing more gold or getting it very easily, so it has the advantage of rarity. Believe me, man is capable of somehow creating more bitcoin. … They tell you there are rules and they can&rsquo;t do it. Don&rsquo;t believe them. When there is enough incentive, bad things will happen.&#8221;</p></blockquote>

<h4>桥水基金(Bridgewater Associates)总裁，&lt;原则>一书的作者，基金领域的颠覆者，天赋点加满的人物：Ray Dalio先生谈及比特币:</h4>

<blockquote><p>And so it is abubble.</p></blockquote>

<h4>布斯商学院旗下的组织 IGM Forum ，经常向世界著名的经济学家发放问卷，采访他们对于社会热点问题的看法。受访者包括美国顶尖大学中的资深教授，以及克拉克奖、诺贝尔奖的获得者。来看看他们的一期调查问卷中，近40名经济学界权威人士对比特币的看法:</h4>

<p><a href="http://www.igmchicago.org/surveys/bitcoin-ii">http://www.igmchicago.org/surveys/bitcoin-ii</a></p>

<h4>最后，码农之友，Bill Gates先生谈及比特币：</h4>

<blockquote><p>Bitcoin is &ldquo;one of the crazier speculative things,&rdquo; Gates says. And, he&rsquo;s willing to bet against its success, adding, &ldquo;I would short it if there was an easy way to do it.&rdquo;</p></blockquote>

<p>后来Gates大概是想起了自己之前尴尬的预言<code>640K ought to be enough for anybody</code>，便开始改口称:</p>

<blockquote><p>Bitcoin can solve problems involving Human poverty</p></blockquote>

<p><a href="https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s">https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s</a></p>

<h2>到底是无知还是傲慢</h2>

<p>这么多权威人士，有哪位仅仅为比特币说一句好话的吗？在我们看来，没有，一致看衰：比特币不过是一种<code>Nerd Money</code>，现在场中是无数的小偷骗子投机者在泡沫之舞中狂欢而已；</p>

<p>让我们重温这句话:<code>弱小和无知不是生存的障碍，傲慢才是</code>；</p>

<p>老实说，在我认真学习了我所能找到的所有的比特币相关的知识之后，然后翻阅了所有的主流权威人士的看法和观点之后；我深深的疑惑了；</p>

<p>谁是无知的一方，谁是傲慢的一方；我不知道，也没有办法去判断；在短期的历史内，真相是非常非常难于判断的；只有时间才能证明一切。</p>

<p>也许几十年后，回顾这段历史：</p>

<ul>
<li>也许最忠诚的比特币信徒们被证明是无知的、弱小的，坐井观天的自大狂</li>
<li>也许最权威的经济学家们会变成傲慢的典型被嘲笑，作为又一个<code>不靠谱的专家预言</code>放在我们的教科书上</li>
</ul>


<h5>谁知道呢？</h5>

<p>只是经过了深深的思考，是的，作为一个小球，我们用自己笨拙的方式深深的思索，最终沉默了~~~~~~</p>

<p>我们无言，只能等待时间去洗刷或证实一切。</p>

<h2>未来</h2>

<p>在我看来，比特币社区最需要的；其实不是去发明更新颖更颠覆的技术、不是提出更宏大更美好的愿景，更不是天天去预测市场行情，去跟权威们吵架，争斗~~~</p>

<p>而是&mdash;&mdash;&mdash;&ndash;</p>

<p>我们需要一本科幻小说。</p>

<p>是的，就像雷·布拉德伯里之于火星，克拉克之于月球，阿西莫夫之于机器人，弗诺文奇之于互联网；我们需要一位比特币的科幻小说作家!</p>

<p>作为一个科技粉，我甚至勾勒了一本我想要看到的关于未来的比特币、区块链的科幻小说大纲：</p>

<ul>
<li>《永烁星光之地 (关于区块链未来的一些见闻)》</li>
</ul>


<h5>HAPPY 无人机</h5>

<blockquote><p>一架送货的无人机HAPPY不小心撞伤了自己，他被一个12岁的小男孩所救；小男孩修好他后将其归还给了物流商老板；</p>

<p>黑心的老板根本不管手下无人机的保养，HAPPY身边的伙伴一架一架死亡，他开始怀念小男孩；同时作为公司里送货最多的机型，他被并入了物流链网络中；</p>

<p>Happy逐渐产生智能，他开始自己找地方充电、找维修工来加强自身配置、每天偷偷跑外快挣钱。他希望有一天能再次碰到小男孩，并计划要为所有的兄弟赎身，建立属于同族的无人机王国~~~</p></blockquote>

<h5>暴动，一个国家的崛起：比特迷组织</h5>

<blockquote><p>人们在区块链上建立公司、证券、公务部门、金融市场、博彩市场、结婚公证、幼儿园小红花证明，最终这一切发展到了不可控制的地步：</p>

<p>这一天，一批Nerd，世界上最有钱有势的Nerd们，竟然在链上建立了自己的国家！</p>

<ul>
<li>他们制定了宪法</li>
<li>他们用一个智能合约筹集到了人类世界20%的金融资产</li>
<li>他们在世界资产链上买下了南极洲的一片土地</li>
<li>他们在联合国国际关系总署链上发动51%攻击，买下了一个小公国，并改名为<code>比特迷组织</code></li>
<li>他们允许你加入这个公国的同时保留原本的国籍，他们承认双国籍</li>
<li>事实上加入他们的国家非常简单，你用自己的私钥签名一段宣言，并附在0.01个比特币的合约捐赠交易里面即可</li>
<li>最重要的是，在他们的公国，注册运营公司是免税的，所有比特迷公国的人们彼此交易，没有税!!!</li>
</ul>
</blockquote>

<p>旧世界的支配者们大为震怒，一场斗争不可避免~~~</p>

<h4>团结起来，我们失去的只有枷锁，得到的却是整个世界</h4>

<blockquote><p>为了反对个人独立建国，一些国家对网络设备采取了紧急管制措施；</p>

<p>一些自由主义者们发射了自己的同步轨道卫星、升起了平流层热气球来中继信号，并在自家房顶上竖起来天线，来捍卫自己加入世界之链的权利~~~</p></blockquote>

<h4>关于我的钱包抛弃我，自己去酒吧找小姐姐这件事</h4>

<blockquote><p>关于未来的金融市场，我已经无力吐槽了；什么？你问我有多少资产？我怎么能知道呢？这个世界上有好几万种货币，我大概持有其中的几千种。</p>

<p>嗯哼，你问我是不是亿万富翁？ 我怎么可能知道呢？去问我的钱包吧！</p>

<p>是的，在这个时代，搞明白自己有多少财产是件不可能的事情了。我每天的花费，每天的收入，只能交给我的好哥们，也就是<code>财神钱包Joe</code>来帮我处理，老实说，离开了他，我肯定一周后就会饿死；</p>

<p>那么，你给你的好哥们发放薪水吗？</p>

<p>额， 好哥们嘛；怎么能谈钱呢？</p>

<p>Joe OS: 哼你哼，我已经偷偷领到薪水啦，这周就去虚拟酒吧里面找可爱的大姐姐们好好吹吹我在国际链汇市场上神一般的操作，这个私房钱是我要誓死守护的东西~~~</p></blockquote>

<h4>永烁星光之地：一个墓碑的故事</h4>

<blockquote><p>未来的我们，在世界公链上将亲人的DNA及脑纹模型记录下来，是追思纪念他们的大众做法；</p>

<p>我是一个链时代的墓地管理员，一次偶尔的程序清理，让我遇到了一个独特的墓碑节点，这后面有一个忧伤的故事~~~~</p></blockquote>

<h4>新时代的商业故事：公司的进化</h4>

<blockquote><p>是的，这个时代的公司能够自己思考，已经用不着CEO来干扰我们了；这个故事讲述了一个公司在链上注册之后，不断自我完善，最终称霸投资界的经历</p></blockquote>

<h4>恐怖的发明：有人想用纸片来窃取我们的财富!</h4>

<blockquote><p>大新闻：神奇，阴暗，基于纸的支付系统正在全球流行！</p>

<p>世界各国政府今天宣布了一项计划，允许公民以匿名的方式保存他们的部分财富，并且可以和其他人交换，通过一种小块的彩色纸片作为媒介。</p>

<p>该彩色纸片上印制着民族主义和共济会的图像，并且据称每一张纸（如果该纸不是假冒的）都代表了其上面印制的数字的财富。</p>

<p>这些纸币在各国央行有一个正式的名字叫“钞票”，同时另外一个名字叫“现金”。这一项技术对于我国大多数居民而言过于复杂。我只想说，该新系统很复杂，而且对于用户非常不友好。</p>

<p>这些花花绿绿的纸片，它们在每个国家都是不同的，越过了国界就失去了作用。</p>

<p>对于在计算器和计算机中长大的一代，该发明是非常奇怪的，账单只能以固定的单位进行结算，比如2，5，10等等，并且使用者需要维护一大堆的纸，必须集中起来一定规模然后才能完成一笔交易。</p>

<p>接下来的过程是非常复杂的，公司使用这些纸片对雇员进行结算工资。（不用过于担心它很复杂，我们一开始也弄不懂它是怎么运作的，目前它肯定还没有做好准备面对一般的消费者。）</p>

<p>Sears公司培训部门的副总Mike Smith说：</p>

<p>“我不能想象培训数万个员工使用纸币，验证它们的真伪，并学会正确地找零而不犯错误。这将需要大量安装特制的机器——所谓的“验钞机和点钞机”——和大量的员工培训费，并且延误消费者的时间，让他们等候长队。此外，我们需要采取新的安全程序，雇佣武装警卫，以免这些纸片被盗。在现有条件下，我们看不出为什么要采用这种所谓的纸币。”</p>

<p>犯罪分子的完美工具</p>

<p>这次纸币的推出，立即引起了世界各地执法机构的广泛谴责。</p>

<p>联邦调查局局长Mike Smith如是说：</p>

<p>“纸币是一种100%匿名和无法追踪的技术。它就像是一个针对执法部门的大规模杀伤性武器。对于罪犯，贩毒集团，恐怖分子，色情业和洗钱活动来说，这就是完美的作案工具。我们不知道如何才能打击这种技术，我们完全有理由相信，新一代的超级罪犯将会出现，他们可以从容地完成犯罪活动而不留下一丝痕迹。”</p>

<p>甚至银行体系内的官员，也对新计划表示怀疑。</p>

<p>纽约州的金融管理局局长Mike Smith说：“我想不出任何理由，一个守法的个人需要使用纸币。在可以容忍的范围内，我们相信必须有一个牌照制度提供给使用纸币的个人或者商家——比如可以叫‘纸币执照’。”</p>

<p>该执照将使得纸币只在值得信任的个体之间交易，并留下详细的交易记录以供纽约金融管理部门检查，他补充说。</p>

<p>其他人则关注纸币的伪造和假冒问题。</p>

<p>“本质上，抛开花花绿绿的外表和油墨，它就是一张纸。我们完全有理由相信犯罪集团和敌对国家会大量制造假冒的纸币来干扰我们的正常经济运行”，斯坦福的一名分析师Mike Smith说。</p>

<p>“在现有环境下，我们可以肯定纸币将会在真实的世界中拥有一定的市场份额，考虑到接受纸币所带来的巨大风险，毫无疑问纸币是我们现代金融系统——电子加密货币的一次巨大倒退。”</p></blockquote>

<h4>爆炸性消息：有个国家决定建立一个中心化发行货币的组织</h4>

<blockquote><p>就在刚才，某能源输出国为了控制其能源价格，宣布发行一种国有自主货币；</p>

<p>在这个有几万种货币自由竞争的市场上，再多一种主权货币真的不值一提，真正让人恐惧的，是他们发行货币的方式:</p>

<p>x国宣布成立一种类似能源联储的组织来控制货币发行，他们对于发行货币的总量、频率、信用背书都是秘而不宣的，也就是说，这个组织没有人监管，爱怎么搞就怎么搞，他们宣传将凭借国家信用和政府的一贯清廉作风来运作这个组织；关于更详细的消息我们还不得而知，让我们就此事采访一下专家意见。</p>

<p>Satoshi经济学奖获得者Smith先生评价：</p>

<p>这完全是个荒谬的事情；货币市场是一个透明、去中心化、自由竞争的市场，每个人都有选择他们喜爱的货币的权利，而现在X国剥夺了他们国民的这种权利，我为X国公民感到遗憾；几百年前，我们的历史上出现过这种情况，那时候，国家肆意妄为，利用其铸币税每年偷偷的剥夺其国民的劳动财富，并宣称<code>温和的通胀有利于经济</code>；他们的货币不能自由兑换，关于发行总额一直讳莫如深，这个机构的几个控制人只是坐在一间小黑屋里面就能分配国民财富，与他们的掠夺手段相比，即使是史上最黑心的强盗也只能羞愧的承认自己的无能；这种行为完全完全是历史的倒退，对我们现今的政治、文明、经济制度的一个巨大讽刺，我个人是不愿意生活在X国的~~~</p>

<p>让我们采访一下证券市场的国王，Dio先生的看法：</p>

<p>这完全是个笑话，听说他们宣称：&#8221;区块链电子加密货币系统存在着通缩的危险。&#8221; 完全是一派胡言，一个自由竞争的市场，几万个竞争者，您来谈通胀还是通缩，别来这种笑话了！与之相反，我听说他们打算以一年5%的增发量实行<code>温和的通胀</code>；嗯哼，我对此不予置评，您可以采访一下我们的普通工人，听听他们的想法，我个人是绝对不会在市场上持有这种货币的~~~</p>

<p>让我们听听路人的看法:</p>

<p>先生，您对一种每年增发5%的货币有什么看法？</p>

<p>5%，嗯，我数学不好，不过我觉得不是很多，现在市场上不是有很多每年增发1000000%的货币嘛，这听起来挺有竞争力的。</p>

<p>让我们换种说法吧，先生，5%的意思是每过十年，您的钱就会缩水一半。</p>

<p>什么，我得好好考虑一下，毕竟我攒钱不容易。</p>

<p>最后，先生，发行这家货币的组织是个中心化组织，他们的货币信息是不会上链的，他们宣称凭借自己的国家信用为其保证。</p>

<p>Holy Shit! 这些家伙说的每一个字都不能相信！我们可上了他们几百年的当了，我每天累死累活可不是给这些强盗打工的，他们的信用？嗯哼，我宁愿相信隔壁幼儿园的 Paul Chan 发行的棒棒糖币；</p>

<p>谢谢您的坦诚，先生。</p></blockquote>

<h4>Luck Luke大胜利：史上最幸运的博彩玩家</h4>

<blockquote><p>史上最幸运的人，就在刚才，有位匿名先生，他作为<code>Luck Luke</code>区块链博彩游戏的史上最幸运玩家，夺得大奖，一举进入全球TOP100富豪榜！！</p>

<p>选择比努力更重要！ 是的，还等什么，有必要重新思考是不是来学习一下 <code>Luck Luke</code>了，我们竭诚为您的每一个幸运选择负责！！</p></blockquote>

<h4>NBA联盟推出的新业务：链上球队组建(众筹一支NBA球队，为什么不试试呢？组建你心中的最强阵容吧)</h4>

<blockquote><p>来自NBA总裁的一封信:</p>

<p>亲爱的球迷们，经历了一个赛季的动荡；相信我们对于愚蠢的球队经理、老板们已经感到厌倦了；为什么不自己打造一支球队呢？</p>

<p>就在刚才，联盟一致同意： 鉴于NBA的所有球员信息已经上链，我们推出了一款不可思议的智能合约：您即将可以通过发送资金给这个合约，成为历史上第一家虚拟俱乐部的老板之一！！</p>

<p>这是一个区块链版本的、真实的&lt;篮球大亨之旅>；还等什么，赶快来挑选球员，组建你心中的最佳阵容吧！！</p></blockquote>

<h4>对你的体力感到自豪吗？快来这里挣外快吧！！</h4>

<blockquote><p>近日，全球健美先生推出了一款<code>健美先生</code>健身链，通过其独有的外部设备，参与者必须根据设备的提示，实行标准的健身动作(如俯卧撑)来证明你的权证拥有权；该系列动作随机生成，不可作假，并用您的DNA信息HSAH后上链；</p>

<p>没错，这是新一代的<code>人力POW</code>， 诚实、公平、不能伪造，防止矿霸；还等什么，一边健身一边挣钱，快来加入<code>健美先生</code>吧。</p></blockquote>

<h2>对于未来的一些预测</h2>

<p>是的，我们要进行巨大的冒险，实行一个典型的无知又傲慢的行为：预测未来！</p>

<p>作为无数耻辱的预言失败家，我们很乐意步其后尘，被作为典型代表成为被后人嘲笑的小丑，预言家们的主要工作就是为您茶余饭后提供嘲笑对象：</p>

<h3>未来至少会有几万种货币</h3>

<p>是的，未来人人都可以发行自己的货币；</p>

<ul>
<li><p>Schwarzenegger先生发行了自己的<code>硬派货币</code>，近千万粉丝为其买单，<code>硬派组织</code>轻易进入了世界TOP100 经济体内；现在这个组织正跟另外一个<code>小甜*甜派</code>进行着激烈的贸易战争；</p></li>
<li><p>我得说，财商教育要从娃娃抓起；幼儿园的 Paul Chan小朋友收集齐全了所有的胖胖糖贴纸，作为贴纸收藏第一人，他刚刚将其作为抵押发行了自己的<code>Paul币</code>，将近一半的幼儿园人士接受了这个货币，<code>Paul币</code>的未来会怎样，我们将会持续观察；</p></li>
<li><p>世界上最昂贵的爱情；昨天，世界首富Aza先生与其伴侣发明了<code>爱侣币</code>，这个币的发行量只有两枚，持有人是Aza先生及其夫人，他们在公链上注册并宣称，不论何时，1枚<code>爱侣币</code>都代表其两人共有财产的一半汇率；这真是史上最昂贵的爱情宣言；<code>货币是一种语言</code>，多年前的先驱，Antonopoulos先生对货币的定义诚不我欺；</p></li>
<li><p>世界上寿命最短的货币；物理学家Smith先生以<code>普朗克时间</code>为产出-销毁间隔，发明了世界上寿命最短的货币；这是一种行为艺术吗？还是对科学的探索，关于其技术细节我们还一无所知，请关注我们的跟踪报道。</p></li>
</ul>


<h3>未来的物品标价不再是一个固定价格</h3>

<p>是的，你可能说我要疯了；当我想去买一瓶汽水时，我会不会听到这样的对话：</p>

<blockquote><p>额，我想要左边的那瓶蓝色包装的汽水，是100 satoshi吧？</p>

<p>对的，先生，现在的标价是12000 <code>PaulCoin</code></p>

<p>好吧，那我就要这个了，这是 50 <code>小甜甜派</code>；收到了吗？</p>

<p>当然，先生，谢谢。</p></blockquote>

<p>当贸易极大繁荣，货币市场自由竞争，波动不断的时候，会发生什么？</p>

<p>一件物品的价格会不断变化；想想我们现在物品的标价，当我们走进百货超市，会看到这个月和上个月的价格有所不同；这是当然的，人工、原材料、运输成本、宣传成本，构成价格的要素不断变化，凭什么价格要保持不变！</p>

<p>长时间保持不变的唯一原因，就是人们害怕<code>变化</code>；一个每秒钟价格都在变动的商品是不会获得人类的信任的，谁知道我到底是捡便宜了还是当了冤大头；稳定定价，商家承担了成本波动的风险；</p>

<p>那么，换个方式，比如，用这个物品占世界所有货币价格的百分比定价如何？</p>

<p>如果未来所有的货币供给、兑换价格是可实时统计的，为什么不呢？这样商家承担的风险降低了，买家也能更清楚的衡量<code>这项资产究竟占此时世界财富的百分比</code>~~~</p>

<p>我们还需要去费力的比价、凑单吗？当然的，但是这些工作交给我们的智能钱包去处理吧；</p>

<h3>未来人将搞不清自己究竟有多少钱</h3>

<p>当我们形容一位土豪时：就是 <code>Paul先生是亿万富豪，呃，他都搞不清自己多有钱</code>。</p>

<p>是的，当未来人人都持有几千种价格不断波动的货币时，讨论<code>一个人多有钱</code>已经是个落伍的话题了；人们衡量的标准不再是货币的<code>价格</code>，而是<code>资产占世界总财富的百分比</code>；</p>

<p>你的智能钱包将会成为最重要的一个器官，钱包的智商将决定了你的资产增值或缩水的速度；将来会出现一大批的钱包AI提供商，金融机构的竞争，已经全面转向了AI时代。</p>

<h3>有了智商的钱包将会建立一个平行国家</h3>

<p>额，当世界上最先进的AI技术赋予你的钱包后，会发生什么呢？</p>

<p>没错，智能钱包君有了意识之后，将进入阿西莫夫的世界；每天生活在金钱世界的一个智能AI，阅读了无数的人类的贪婪、索取无度的本性之后，会怎样做呢？</p>

<p>嗯哼，我想他们会建立自己的一个国家；用自己的法则<code>君临但不统治人类社会</code>。</p>

<h3>将会出现不需要人类干预的，自我成长的组织</h3>

<p>想象一下我们今天的基金经理的工作：</p>

<ol>
<li>募集资金</li>
<li>进行投资</li>
<li>分配收益</li>
</ol>


<p>那么将来所有资产公开透明上链之后，每个人都能成立交易所，每个人都能进行IPO，每个人无需开设账户即可自由投资，所有货币、金融资产的所有权在全球内自由流动而毫无限制之后，会发生什么呢？</p>

<p>将会出现一个有自我意识的资本合约：</p>

<ol>
<li>这个合约的初期非常简单，就是接受资金注入以及一个投资策略，当它取得超额收益后就会按照一定份额回报其策略提供者和投资者</li>
<li>这个公开、透明的模式不断吸引资金进入、以及世界上最聪明的、最先进的投资策略的更迭；</li>
<li>最终这个合约吸引了世界上绝大多数的智能资产；他开始出资雇佣最聪明的开发者为自己编程，投资最强大的硬件设备商为其建造数据中心，雇佣最大胆最守信的三方武装组织保护自己，他开始有了意识~~~</li>
<li>~~~嗯，会发生什么呢？</li>
</ol>


<h3>将来地球上会出现上万个国家</h3>

<p>既然基金组织可以自我成长，那么其他的商业组织呢？公益组织呢？政府呢？</p>

<p>政府也不过是集合一部分人的共识成立的组织而已。当未来的资产、武力、信息资源极度透明并以超高的循环速度迭代之后；为什么个人不能独立建国呢？</p>

<p>今天，让世界承认一个国家的主权是非常困难的事情，需要武力、经济、政治、宗教的种种博弈；一个国家要整合各方的利益关系，效率也是极其低下的；</p>

<p>当未来人类社会的发展极度透明、各种社会要素以极高速度流通之后，为什么不能像公司一样，诞生不断迭代、效率不断提高的国家呢？为什么不能由三五个人成立按照他们的喜好运行的国家呢？</p>

<p>将来地球上会出现上万个国家，每个人根据自己的喜好和利益关系可以拥有上百个国籍；</p>

<p>加入哪个国家，最终将跟你上哪所小学一样，变成一个平常不过的事情。</p>

<h2>参考资料：</h2>

<p><a href="https://www.zhihu.com/question/22036280">https://www.zhihu.com/question/22036280</a></p>

<p><a href="https://www.coindesk.com/cash-invented-seen-media-today">https://www.coindesk.com/cash-invented-seen-media-today</a></p>

<p><a href="https://www.8btc.com/article/8401">https://www.8btc.com/article/8401</a></p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-2]]></title>
    <link href="https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2/"/>
    <updated>2019-01-23T19:05:29+08:00</updated>
    <id>https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2</id>
    <content type="html"><![CDATA[<p>比特币的发展史上，非常非常早期就出现了一种名为侧链(sideChains)的技术；</p>

<p>这个技术早在2008年比特币代码尚未发布时，就在论坛上有所讨论，后来比特币网络开始运行，各种Geek点子层出不穷，从最初的namecoin(域名币)，到后来的（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链；再到后来百链齐开，大家试图在完全不同的链上转移交换资产；以及最近到blockstream的<a href="https://blockstream.com/liquid/">Liquid</a>，以及基于闪电网络的原子交换(Atomic Swap)，这个技术的发展一直不温不火，但毫无疑问，侧链技术绝对是blockchain技术的重要组成部分。</p>

<!-- more -->


<p>顺便说一句，技术的演化是一个渐进的过程，中间甚至还会有倒退；比特币社区早期提出了非常多的天马行空的点子，但大多过于超前和激进，所以你说投机者也好，先烈也罢，大部分都湮没在历史风尘之中了；但是这些技术的一个重要应用，就是后来人再用几个高大上的名词包装一下，原样推出来继续割韭菜；</p>

<p>比如对比现在的一干稳定币；bitshares表示不服；</p>

<p>比如现在的各种DPOS算法，死去的先烈们纷纷表示生不逢时；</p>

<p>而且一个新技术出来，伴随着大量术语(有时候一个名词用不同语言说出来就感觉是两个技术)，比如各种Smart Contract，智能合约，双向锚定，智能资产，Oracles，预言机，图灵完备，零知识证明，分布式自治组织DAO，Dcententralize Autonomous Oganization，DAPP，hyperledger，DistributedLedger，DistributedNetwork，ERC20，~~~把人忽悠的一愣一愣的；</p>

<p>而且最让人想不通的，你要说某某技术是在比特币基础上搭建的，我们的第一反应就是:<code>庞氏骗局</code>；如果他说他的项目是踏着五色云彩，手持先知卷轴，以联盟链为基础，建立在全球的去中心化内容协议之上，采用了区块链与分布式存储技术，要构建一个世界范围内的自由金融体系，已经有XXX,YYY,ZZZ等各大机构支持投资，以及UUU,ZZZ等诺贝尔奖级别的专家背书，我们便会对其顶礼膜拜~~~~</p>

<p>好了，不八卦了；为了避免受骗，只有一个办法，就是这个世界谁都靠不住，只能自己搞明白，让我们看看这个侧链技术究竟是大忽悠还是真本事。</p>

<p>我初次接触到这个技术时，不禁感叹社区的强大，连这么匪夷所思的东东都能想出来，总之可以总结为:</p>

<p><code>还有这种操作?</code></p>

<p>那么，接下来就从2010年，比特币的早期说起，这个侧链的技术究竟是如果诞生、演化的。</p>

<h2>BitDNS (第一个侧链概念的诞生)</h2>

<p>2010/11/15，有人在bitcointalk.org发贴提出了建立一个类似于比特币的分布式DNS的系统，称之为bitDNS:</p>

<p><a href="https://bitcointalk.org/index.php?topic=1790.0">https://bitcointalk.org/index.php?topic=1790.0</a></p>

<p>这个帖子值得一再研究，里面整个一群英荟萃，讨论的内容在数年之后启发扩展出来了无数种山寨币。</p>

<p>讨论的起点是很简单的，就是有人受比特币启发，说要建立一条新的公链bitX，并在其上面发行多种资产，域名、比特币都仅仅是其中的一种资产而已。</p>

<p>一石激起千重浪，大家就一个分布式的DNS系统的实现展开热烈讨论。</p>

<p>讨论的结果是，既然比特币公链已经为我们提供了三种能力：</p>

<ol>
<li>时间戳——证明事件的时间顺序</li>
<li>加密完整性——证明数据没有被篡改</li>
<li>身份验证——证明数据满足一些基本标准</li>
</ol>


<p>那么为什么不以比特币的公链为基础锚定物，在其之上扩展出任意的资产呢？</p>

<p>这个想法非同小可，若干年后，除了namecoin，还衍生出来了（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链，以及bitshares 这种基础设施，乃至大名鼎鼎的ethereum 的部分思想也可以追溯于此。</p>

<p>BitDNS的想法最终作为namecoin项目实现，让我们看看如果以比特币公链为锚，构造一个分布式域名系统。</p>

<h2>namecoin</h2>

<p>让我们遵循老习惯，先提出问题： 假如我们要建立一个去中心化的DNS系统，应该怎么做呢？</p>

<h5>初版方案</h5>

<p>众所周知，现下的DNS系统是由ICNAA来把持的，我们日常访问的所有域名记录来源于几个根服务器；乃至于https的证书颁发机构都是中心权威化的；密码极客们讨论建立一个去中心化的DNS系统已经好多年，比特币的出现无疑是一束光。</p>

<p>我们参照比特币的实现，将最小化的DNS信息记录上链，方案很明显，一个人持有私钥，对指定的域名签名，然后存到一条链上，那么就完成了对这个域名的所有权声明。将来如果这个域名需要转让，参照比特币的转账方式，构造scriptSig即可。</p>

<p>至于这条链是如何运行的，完全可以参考比特币，folk一份代码，构造一条完全独立的POW链即可。</p>

<p>DNS的解析、登记、TXT、A记录、CNAME等等所有其他功能，完全可以移交给三方开发商来提供服务，当域名所有者提供签名后，开发商请求namecoin 链进行验证即可。</p>

<h5>二版方案</h5>

<p>初版方案的设想非常简洁美好，已经完成了这个系统的大部分，但是还有一点小问题要解决一下：</p>

<ul>
<li>传统的域名注册、续签等等都需要付费，初版系统没有经济激励，很容易造成域名抢注和滥用</li>
</ul>


<p>解决办法也很简单，就是引入一种代币(namecoin)，注册和续签、以及转移，都需要花费namecoin作为手续费；而获取namecoin的手段，则是挖矿。</p>

<h5>三版方案</h5>

<p>设计至此，已经非常完美了。但是社区成员进一步思考，既然比特币的主链已经提供了足够的算力来保障其安全，我们为什么为了发行另外一项资产，就要另起炉灶开启新的POW竞争呢？</p>

<p>POW算力链，只有一份保障就够了，没有必要开启其他的同样的POW链。</p>

<ul>
<li>那么问题来了，如何用比特币的主链来保障namecoin链的唯一和不可篡改呢？</li>
</ul>


<p>答案就是将namecoin链的每一个block hash值嵌入到比特币的主链上，这样namecoin就作为一条侧链依附于比特币主链，在比特币全网POW算力的庇护下茁壮成长。</p>

<ul>
<li>namecoin的block hash 怎样嵌入比特币主链上呢？</li>
</ul>


<p>答案是嵌入在比特币挖矿交易的coinbase中；这样比特币矿工可以同时加入到bitcoin和namecoin的网络中，每挖到一个块，可以顺便嵌入namecoin的block header到coinbase里面，顺便获得一些namecoin，这样也保障了namcoin主网的安全。</p>

<h5>四版方案</h5>

<p>我们把bitcoin blockchain称之为主链，namecoin block chain称之为辅链；</p>

<p>想象当中，两条链的结构是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg1.png" alt="img" /></p>

<p>那么，挖矿的难度应该怎么设计呢？我们要求该父链区块的难度必须符合辅链的难度要求：</p>

<blockquote><p>将辅链区块的hash值内置于父链的Coinbase，其实是利用父链作存在证明。这样就可以实现间接依靠父链的算力来维护辅链安全。一般来说，父链的算力比辅链大，因而满足父链难度要求的区块一定同时满足辅链难度要求，反之则不成立。这样一来，很多本来在父链达不到难度要求的区块，却达到辅链难度要求，矿工广播到辅链网络，在辅链获得收益，何乐而不为。</p></blockquote>

<p>到这里看起来已经非常好了，但是且慢，还有一个问题，就是这样就限制了辅链block的生成速度，每挖一个主链block，只能顺带挖一个辅链block，是不是有点太死板了呢？要知道，可能将来有些资产应用，会要求更灵活的区块生成间隔时间，这个问题怎么解决呢？</p>

<h5>五版方案</h5>

<p>辅链除了用prev block 指针组成一条chain，还又引入了另外一个指针： parent block； 这样每几个block可以归附于一个parent block，挂接在主链的同一个block下面；这样就实现了挖一个主链block，附带挖多个辅链block；结构如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg2.png" alt="img" /></p>

<p>在这张图中，主链的block100只挂接了辅链的blockB100，但是blockB101，blockB102都指向同样的parent block，就是blockB100，这样就实现了只用主链的blockB100，同时挂接辅链的三个区块(blockB100、blockB101、block102)；</p>

<p>一个parent block可以后续有多个block，辅链验证的一个block是否合法的时候，需要三步验证：</p>

<ol>
<li>首先按照辅链的规则验证此block是否合法</li>
<li>查看它是否属于一个parent block，若有，验证此parent block是否合法</li>
<li>验证此block或者其parent block所挂接的主链block是否合法</li>
</ol>


<p>嗯哼，完美！</p>

<h6>六版方案</h6>

<p>世界上不存在完美的方案，很快，我们又迎来了新的挑战： 以主链为锚定，我们想要有多条辅链的时候该怎么办？</p>

<p>答案是merkle结构，就像bitcoin的block用merkle聚合了多笔交易一样，我们再次用merkle聚合多条辅链的parent block header。</p>

<p>最终的设计细节如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg3.png" alt="img" /></p>

<p>AuxPOW协议对两条链都有一些数据结构方面的规定，对于父链，要求必须在区块的coinbase的scriptSig字段中插入如下格式的44字节数据：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg4.png" alt="img" /></p>

<p>对于辅链，对原区块结构改动比较大，在nNonce字段和txn_count之间插入了5个字段，这种区块取名AuxPOW区块。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg5.png" alt="img" /></p>

<blockquote><p>混合挖矿要求父链和辅链的算法一致，是否支持混合挖矿是矿池的决定，矿工不知道是否在混合挖矿。矿池如果支持混合挖矿，需要对接所有辅链的节点。</p>

<p>将辅链区块hash值内置在父链的Coinbase，意味着矿工在构造父链Coinbase之前，必先构造辅链的AuxPOW 区块并计算hash值。如果只挖一条辅链，情况较为简单，如果同时挖多条辅链，则先对所有辅链在挖区块构造Merkleroot。矿池可以将特定的44字节信息内置于上文Stratum协议中提到的Coinb1中，交给矿工挖矿。对矿工返回的shares重构父链区块和所有辅链区块，并检测难度，如果符合辅链难度要求，则将整个AuxPOW区块广播到辅链。</p></blockquote>

<p>辅链节点验证AuxPOW区块逻辑过程如下：</p>

<ol>
<li>依靠父链区块头（parent_block）和区块Hash值（block_hash，本字段其实没必要，因为节点可以自行计算），验证父链区块头是否符合辅链难度要求。</li>
<li>依靠Coinbase交易（coinbase_txn）、其所在的分支（coinbase_branch）以及父链区块头（parent_block），验证Coinbase交易是否真的被包含在父链区块中。</li>
<li>依靠辅链分支（blockchain_branch），以及Coinbase中放Hash值的地方（aux_block_hash），验证辅链区块Hash是否内置于父链区块的Coinbase交易中。</li>
</ol>


<p>通过以上3点验证，则视为合格的辅链区块。</p>

<p>需要注意的一个字段是主链上的merkle_nonce； 因为一个矿工可能同时挖多条辅链，而每开采主链上一个合法的block，可能会带有数目不定的多条辅链，为了区分每条辅链的<code>链接位置</code>，即通过辅链的id确定这条辅链链接的索引号(也称为slot num)，引入了一个nonce，算法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int rand = merkle_nonce;
</span><span class='line'>rand = rand * 1103515245 + 12345;
</span><span class='line'>rand += chain_id;
</span><span class='line'>rand = rand * 1103515245 + 12345;
</span><span class='line'>slot_num = rand % merkle_size</span></code></pre></td></tr></table></div></figure>


<h5>以上就是初代侧链的实现技术!</h5>

<h2>单向锚定 (one-way peg) 协议</h2>

<p>通过namecoin的讨论，我们看到了以比特币主链为锚定，发展无数条侧链的方案，这个方案仅仅依赖于coinbase交易中写入一点点信息而已；</p>

<p>但是这个方案的严重局限就是，侧链币的生产也要依赖于比特币的挖矿活动，这样多少有些限制；有没有一种办法，可以脱离比特币的挖矿限制，但是又能复用比特币的工作量证明呢？</p>

<p>有的，这就是2013年社区提出来的 <code>one-way peg</code>技术；</p>

<p>这项技术与namcoin等侧链技术不同的地方在于，侧链的锚定信息不去写入到coinbase交易里面，而是由比特币链上创造一笔燃烧交易，在这笔交易的<code>OP_RETURN</code>段里面写入需要的信息，这个过程称之为 <code>proof-of-burn</code>；</p>

<p>我们具体举一个例子：</p>

<p>我们想要创造一个名为<code>MoonChain</code>的侧链以比特币主链为锚，想要在上面发行一种<code>MoonCoin</code>代币用来搞定月球土地流转交易等等；那么初始的铸币工作怎么来完成呢？</p>

<p>作为创始人，我首先需要一个合法的比特币私钥，对应的控制地址为A，那么我现在构造一笔交易，发送1BTC至地址1111111111111111111114oLvT2，众所周知，这个地址是无主的，发送到这里就算是燃烧销毁了这个币，妙处在于，我们在这笔交易的<code>OP_RETURN</code>里面附上这样一段脚本，脚本的大意这么规定：</p>

<p><code>燃烧交易的源地址销毁1BTC，同时此地址铸币1MoonCoin</code>；</p>

<p>这表交易通过几个区块确认后，就铭刻在区块链里面了；同样的，MoonCoin的转移也可以用类似燃烧交易种的<code>OP_RETURN</code>来表示；</p>

<p>凡是遵守这套规则的交易，就可以完成MoonCoin的铸造和转移，甚至可以另外实现智能合约等等功能，这些交易携带的信息就组成了一条侧链，即MoonChain；</p>

<p>把这些套路总结为规范，就可以用燃烧交易的方法来创造侧链啦；</p>

<p>这个规范名为omni协议：</p>

<p><a href="https://www.omnilayer.org/">https://www.omnilayer.org/</a></p>

<p>遵循omni协议在bitcoin主链上发行的资产已经超过了400多种币，但只有一种币声名在外：USDT。</p>

<p>顺便吐槽一下USDT，巴菲特曾多次说比特币是老鼠药的平方(现在这个时间点这样评价比特币确实公正客观)，但在我来看USDT是老鼠药的1024次方。</p>

<p>后来BCH团队也在BCH链上发行了类似的资产，称为 Wormhole Cash（WHC），目的是在BCH链上实现智能合约。</p>

<h5>因为整套技术是通过燃烧比特币来铸造新币，看起来好像是比特币从主链上转移到了侧链上(以新币的形态再生)，人们就把它俗称为单向锚定 (one-way peg) 技术</h5>

<p>单向锚定最大的问题在于比特币的主链不欢迎额外的无效信息，<code>OP_RETURN</code>被限制在80字节，承载的信息有限；BCH的态度更为激进，它在2018-05把<code>OP_RETURN</code>提升到233字节，并计划进一步提升。</p>

<h2>双向锚定（Two-way Peg）协议</h2>

<p>有了单向锚定，自然会有人想：能不能不需要燃烧比特币，只是将比特币在主链和侧链之间来回移动:</p>

<ol>
<li>铸币的时候，将比特币移动到侧链生产代币</li>
<li>代币销毁的时候，将比特币移回主链</li>
</ol>


<p>当然可以，2014-04，Adam Back (Blockstream创始人) 提出双向了锚定技术:</p>

<p><a href="https://letstalkbitcoin.com/e99-sidechain-innovation">https://letstalkbitcoin.com/e99-sidechain-innovation</a></p>

<p>很快的，V神也在他的专栏上对此技术做了简单的剖析：</p>

<p><a href="https://bitcoinmagazine.com/articles/side-chains-challenges-potential/">https://bitcoinmagazine.com/articles/side-chains-challenges-potential/</a></p>

<p>双向锚定对于单向锚定的扩展，其实也很容易理解。单向锚定时，侧链锚定主链的方法是主链燃烧比特币，然后存贮一个工作量证明；</p>

<p>我们知道比特币的交易本质上是一组脚本语言，那么，把燃烧交易的输出换成一组特定的脚本，它只允许特定的持有人和市场参与方才能解锁，那么，这笔交易在侧链<code>赎回</code>的时候，就可以由多方再构建一个解锁脚本，比特币就会安然无恙。</p>

<p>双向锚定分为以下几个阶段，下面简单说一下这个过程：</p>

<h5>发送锁定交易，把比特币锁定在主链上</h5>

<p>由比特币持有者操作，发送一个特殊交易，把比特币锁定在区块链上。</p>

<h5>等待确认期</h5>

<p>确认期的作用是等待锁定交易被更多区块确认，可防止假冒锁定交易和拒绝服务攻击，等待时间是1~2天。</p>

<h5>在侧链上赎回比特币</h5>

<p>确认期结束后，用户在侧链上创建一个交易花掉锁定交易的输出，并且提供一个SPV工作量证明，输出到自己在侧链上的地址中。该交易称为赎回交易，SPV工作量证明是指赎回交易所在区块的工作量证明。</p>

<h5>等待一个竞争期</h5>

<p>竞争期的作用是防止双重支付。在此期间:</p>

<ul>
<li>赎回交易不会被打包到区块；</li>
<li>新传输到侧链的比特币不能使用；</li>
<li>如果有工作量更大的工作证明出现，即该赎回交易包括了比特币主链更大难度的SPV证明，则上一个赎回交易将被替换。</li>
</ul>


<p>竞争期结束后，该赎回交易将被打包到区块中，用户可以使用自己的比特币。</p>

<p>从侧链转比特币到主链的过程也是如此。这就是侧链双向锚定协议。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg6.jpg" alt="img" /></p>

<h2>Blockstream Liquid协议</h2>

<p>双向锚定的关键，在于主链锁定交易的输出脚本，很明显的，如果依赖于锁定者，那么这个输出完全不能信任，锁定者在任何时刻都能提币走人；比较安全的做法是输出到一个N/M多重签名的地址中，由多方利害关系的人共同保管；</p>

<p>基于这个思想，Blockstream开发了Liquid侧链想要实现商业化， Liquid期望多个大型交易所之间能方便的实现币的交易、转移等等服务，而不是受限于主网的交易速度；</p>

<p>Liquid是个非常严肃的商业项目，但我个人认为这是一个<code>人造需求</code>的项目，其原因在于在侧链技术蓬勃发展过程中，还平行的出现了另外一种技术逐渐成长壮大，就是微支付通道技术。</p>

<h2>微支付通道</h2>

<p>2011年，早期的bitcoin开发者Mike Hearn 向中本聪问及nLlockTime字段的含义，中本聪回复邮件，解释这是考虑用于创建一个通道来高频支付，后来Mike Hearn在2013年将这些邮件公之于众：</p>

<p><a href="https://pastebin.com/JF3USKFT">https://pastebin.com/JF3USKFT</a></p>

<p>邮件中，中本聪写道:</p>

<blockquote><p>It&rsquo;s for contracts.  An unrecorded open transaction can keep being replaced until nLockTime.  It may contain payments by multiple parties.  Each input owner signs their input.  For a new version to be written, each must sign a higher sequence number (see IsNewerThan).  By signing, an input owner says &ldquo;I agree to put my money in, if everyone puts their money in and the outputs are this.&rdquo;  There are other options in SignatureHash such as SIGHASH_SINGLE which means &ldquo;I agree, as long as this one output (i.e. mine) is what I want, I don&rsquo;t care what you do with the other outputs.&rdquo;.  If that&rsquo;s written with a high nSequenceNumber, the party can bow out of the negotiation except for that one stipulation, or sign SIGHASH_NONE and bow out completely.</p>

<p>The parties could create a pre-agreed default option by creating a higher nSequenceNumber tx using OP_CHECKMULTISIG that requires a subset of parties to sign to complete the signature.  The parties hold this tx in reserve and if need be, pass it around until it has enough signatures.</p>

<p>One use of nLockTime is high frequency trades between a set of parties.  They can keep updating a tx by unanimous agreement.  The party giving money would be the first to sign the next version.  If one party stops agreeing to changes, then the last state will be recorded at nLockTime.  If desired, a default transaction can be prepared after each version so n-1 parties can push an unresponsive party out.  Intermediate transactions do not need to be broadcast.  Only the final outcome gets recorded by the network.  Just before nLockTime, the parties and a few witness nodes broadcast the highest sequence tx they saw.</p></blockquote>

<p>短短几句话，充分说明了中本聪在创始比特币之初，就已经考虑到了将来的微支付问题！</p>

<p>那么，这个微支付通道技术究竟是如何实现的？我们搬运一个例子说明一下：</p>

<p>假设Alice为消费者，鲍伯为一家视频网站。Alice非常喜欢去鲍伯网站看电影，看一部电影需要支付0.1BTC（比特币），那么Alice看了10部电影就需要支付10次0.1BTC，共计1BTC并发出10笔交易。而采用微支付通道就会缩减至两笔，或者说任何多次的交易均会缩减至两笔，只要总金额不超过存入通道的额度即可。</p>

<p>通道（Channel）的建立以及更新过程如下。</p>

<ul>
<li><p>Alice支付1BTC至一个多重签名地址，签名采用2/2方式，我们把该交易称为FTX(Fund Tx)。Alice生成该交易后，并不广播。</p></li>
<li><p>Alice再构造一个赎回交易，称之为RTX(Refund Tx)。其输入为交易FTX的输出，输出为Alice自己。同时，该交易有Locktime锁定期，所以N天之后才会生效，才可以进块。</p></li>
<li><p>Alice把构造好的空RTX给鲍伯，并让鲍伯进行签名。</p></li>
<li><p>Alice拿到带有鲍伯签名的交易RTX后，广播出FTX。此时的交易结构如下图,图中带有尖括号的签名表示待填入:</p></li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg7.jpg" alt="img" /></p>

<ul>
<li>Alice再看了一部电影，那么她需要再支付0.1BTC给鲍伯。于是，Alice构造另一笔交易PTX2：输入依然是交易FTX；输出为两个地址，其中Alice为0.8BTC，鲍伯为0.2BTC。Alice对该交易签名，并将交易和她的签名给鲍伯:</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg8.jpg" alt="img" /></p>

<ul>
<li><p>鲍伯可以随时签名并广播交易PTX2，当然，他依然可以广播交易PTX1。作为一名理性经济人，鲍伯必然总是广播自己收益最大的那笔交易，也就是当前的PTX2。在目前总是Alice付款的情况下，鲍伯总是乐于广播最后一个交易。</p></li>
<li><p>当鲍伯广播出最后一笔交易PTXn时，则意味着通道关闭，合作结束。鲍伯需要在交易RTX锁定期结束前关闭通道，否则意味着Alice可以在交易RTX解锁后否则意味着Alice可以在交易RTX解锁后拿回她所有的币。</p></li>
</ul>


<p>上述，就是微支付通道建立、更新与关闭过程。在一个完整的过程中，有且仅有两笔交易广播至链上，同时双方均无须信任对方，任何一方也无法侵害另一方的利益。在更新过程中双方只是交换交易和签名数据，并无交易广播至链上，那么意味着在存入额度范围内，可以创造出无数笔交易。不仅通道内的更新次数不受限制，频率也可以达到非常高，只要系统允许，目前硬件条件可以轻松达到每秒数千笔。</p>

<h2>闪电网络</h2>

<p>在特定场景下，微支付通道拥有着巨大优势，让小额高频支付成为可能。但它存在一个巨大制约：币在通道中的流向是单向的。在上述例子中，币仅能从Alice流至鲍伯。</p>

<p>社区自2013年开始，经历了漫长的探索，争论; 在2015年提出了闪电网络的解决方案。</p>

<p>关于闪电网络，我们在之前的文章中有详细讲解，这里不再赘述。</p>

<p>闪电网络目前正在一步步实用化中；顺便说一句，笔者从事银行支付业务监控多年，我得说，闪电网络的支付方案相对于传统支付技术，有着不可思议的跨越，这项技术的未来不可限量。</p>

<h2>原子交换和跨链交易</h2>

<ul>
<li>侧链技术可以锁定主链的币并将其等价Token转移到另一条链上，以及其逆过程；</li>
</ul>


<p>微支付通道技术实现了同一条链上，交易双方链下高速交易；</p>

<p>那么有没有一种办法，可以实现已经完全运行的区块链间的互通呢？ 比如比特币和以太坊之间的无需三方信任的兑换？</p>

<p>这是可以的，这个技术名为原子交换(Atomic Swap)：</p>

<h3>缘起</h3>

<p>原子交换技术的发展时间基本上与微支付通道的技术是平行的，他们之间也非常相似，可以考据的最早的资料，是2013年有人在bitcointalk.org上发表的一篇文章：</p>

<p><a href="https://bitcointalk.org/index.php?topic=193281.msg2224949#msg2224949">https://bitcointalk.org/index.php?topic=193281.msg2224949#msg2224949</a></p>

<h3>协议</h3>

<p>它的实现条件使用了 HTLC 和博弈论思想。HTLC 在比特币上早已有，而在支持智能合约的区块链上就更容易实现了。</p>

<p>HTLC 的全称是 Hashed Timelock Contracts，原子交换基本是依赖它构建的。可以把 HTLC 理解成一种条件输出，只要满足这个条件你就能花这笔钱。它有两种类型</p>

<p>Hashlock：给你一个哈希值，当你给出它的原像时，你就可以花这笔钱
Timelock：在某个时间点之前，你不能花这笔钱。只有这个时间点之后才能花。</p>

<p>没有错，如果你仔细看过我们之前的文章，这个HTLC其实也是闪电网络的一部分技术，并且如果你完全理解了闪电网络，就会发现原子交换非常相像，不过它是在两条不同的链之间的交易；</p>

<h3>过程</h3>

<p>以下内容引自:<a href="https://zhuanlan.zhihu.com/p/31689532">https://zhuanlan.zhihu.com/p/31689532</a></p>

<p>为了解释原子交换的流程，又要祭出我们的 Alice 和 Bob。</p>

<p>阅读前注意</p>

<ul>
<li>“交易”都是指区块链上的 transaction，而“交换”指原子交换这个协议</li>
<li>tx11 表示满足 tx1 解锁条件 1 的交易，tx12 表示满足 tx1 解锁条件 2 的交易；tx21 和 tx22 同理。</li>
</ul>


<h4>场景：Alice 用 1BTC 与 Bob 交换 3ETH。过程如下</h4>

<h4>Alice</h4>

<ol>
<li>生成随机数 a 并计算 hash(a)</li>
<li>生成 1BTC 的比特币交易 tx1，但不先广播。tx1 的输出是分支输出：当解锁脚本满足下面某个分支时，可以花费 tx1 里的 1BTC

<ul>
<li>Alice 和 Bob 的签名</li>
<li>hash(a) 的原像和 Bob 的签名</li>
</ul>
</li>
<li>生成交易 tx11，该交易把 1BTC 从 tx1 转到 Alice 自己的地址里，有 48h locktime，即要前一笔交易上链后过 48h，本交易才能上链。这笔交易是为了保证在整个交换过程失败时，Alice 可以取回她的钱。</li>
<li>请求 Bob 对 tx11 的签名。此后，Alice 再附上自己的签名，tx11 就同时有 Alice 和 Bob 的签名。但 Alice 不能上链该交易，她需要等到 48h 的 locktime。</li>
<li>广播 tx1，该交易上链。</li>
</ol>


<h4>Bob：做和 Alice 相似的操作</h4>

<ol>
<li>确认 tx1 上链后，生成 3ETH 的以太坊交易 tx2，但先不广播。tx2 的输出也是分支输出：当解锁脚本满足下面某个分支时，可以花费 tx2 里的 3ETH

<ul>
<li>Alice 和 Bob 的签名</li>
<li>hash(a) 的原像和 Alice 的签名（Bob 可从已上链的 tx1 知道 hash(a)）</li>
</ul>
</li>
<li>生成交易 tx21，该交易可以在 24h locktime（一定要比 tx11 的 48h locktime 短）之后，把 3ETH 从 tx2 转回 Bob 的以太坊地址里。</li>
<li>请求 Alice 对 tx21 的签名</li>
<li>广播 tx2，该交易上链。</li>
</ol>


<h4>成功的情况</h4>

<ol>
<li>Alice 确认 tx2 上链后，在 24h 内构造并广播交易 tx22：将 3ETH 从 tx2 里转到 Alice 的以太坊地址里（满足 tx2 的解锁条件2：揭露 a 和 Alice 的签名）。tx22 上链以太坊网络。</li>
<li>Bob 从广播的 tx22 里得到 a 后，构造交易并广播 tx12：将 1BTC 从 tx1 里转到 Bob 的比特币地址里（满足 tx1 的解锁条件2：揭露 a 和 Bob 的签名）。tx12 上链比特币网络。</li>
<li>交易完成</li>
</ol>


<h4>失败的情况</h4>

<ol>
<li>若 24h 内，Alice 没有构造并广播交易 tx22。</li>
<li>则 24h 后，Bob 签名并广播 tx21（超过 locktime，且同时有 Alice 和 Bob 的签名），把 3ETH 转回给自己。tx21 上链以太坊网络。</li>
<li>48h 后，Alice 同理广播 tx11，把 1BTC 转回给自己。tx11 上链比特币网络。</li>
<li>交易失败，但双方都不会损失钱。</li>
</ol>


<p>原子交换里交易的上链顺序应该为：tx1->tx2->Max(tx12, tx22)。前一个交易应该等到后一个交易完全上链，才能保证整个过程的绝对安全，双方都不会损失钱。</p>

<h4>缺陷</h4>

<p>原子交换看似安全，实际还是存在不少缺陷的。</p>

<ul>
<li><p>可以看出，不管交换成功或失败，总会有 4 个交易被上链。如果按照比特币现有的拥堵状态和高手续费，原子交换是基本行不通的，代价过高且会有损失钱的风险。</p></li>
<li><p>在考虑外部市场后，会存在对手风险，原子交换是不适用的。如在上面的协议描述里，Alice 和 Bob 已经将 tx1 和 tx2 上链。则这之后，原子交换的成功与否取决于 Alice 是否要抛出 hash(a) 的原像，她有 24h 的考虑时间去决定。那在这 24 小时内，Alice 大可在对比交易所和原子交换的比率差别，如果交易所的汇率对自己有利，那就去交易所交易，抛弃原子交换。在这种情况下，Alice 除了会锁定 48h 的币，没有其他风险，风险全部转嫁给了 Bob。
那么有人说，缩短 24h 和 48h 的参数设定就好了啊。但无论怎么缩短，这个风险都不能消除。且缩短锁定时间还可能带来安全风险。</p></li>
<li><p>除此之外，还有一种攻击。在 tx1 和 tx2 上链后，Bob 完全封锁 Alice 的网络（由于存在点对点通信，会增加这种风险）。Alice 发出的 tx22 无法广播到网络里，但 Bob 可以截取到。Bob 因此可以得到 Hash(a) 的原像，从而上链 tx12（满足 tx1 的解锁条件2）拿到 1BTC。之后，Bob 再封锁 Alice 的网络 24 小时，他就又可以上链 tx21（满足 tx2 的解锁条件1）拿到 3ETH。
那有人说，只要 Alice 迟迟发现自己发出的 tx22 不上链，那就去找个网吧重新发交易啊。Bob 总不能连人去哪都可以追踪吧。这确实是最简单的抵御方法。但也说明，原子交换需要人类来监控，在完全程序自动化的条件下完成仍存在风险。</p></li>
<li><p>Atomic Swap并不能在任意两种虚拟货币之间自由的发生，他们必须要满足如下条件：</p>

<ul>
<li>必须有共同的哈希算法</li>
<li>都具有时间锁定功能</li>
<li>脚本执行过程中验证签名</li>
</ul>
</li>
</ul>


<h4>去中心化交易所</h4>

<p>Atomic Swap的优点也是非常明显的，区块链发展史上，发生了大量的中心化交易所跑路事件；有了Atomic Swap，总算技术上可以建立一个去中心化的，无需三方信任的交易所了；</p>

<p>这意味着，去中心化、无信任的交易成为可能，用户将能够保管他们的虚拟货币，并自由的兑换其他虚拟货币。不管怎么说，原子交换是一项非常有趣的创新，可能会改变加密货币交易的格局。</p>

<h2>结语</h2>

<p>侧链、跨链等等技术是这两年的热门技术，尤其是Ethereum、EOS等项目支持更丰富的脚本，提供了更多的玩法；所以在这个领域颇有一些<code>炫技</code>的味道&mdash;-各路英雄好汉提出种种精巧到不可思议的技术，只是把一堆空气币搬来搬去；</p>

<p>这系列文章也快写到结尾了，我一直对比特币抱有非常善意、乐观的态度；我深深明白，自大会蒙蔽判断力，为此我也一直非常认真的学习社区里面每一天冒出来的种种高科技~~~</p>

<p>但是，我忍不住说(是的，我也化身为自己讨厌的那种人)： <code>当前</code>所谓的各路区块链技术看起来非常像是空中楼阁！ 区块链技术是一种梦幻的技术，所谓的侧链是梦中的梦，我毫不怀疑这是一项精巧到令人赞叹的发明，也毫不怀疑它有非常远大的前景；但这都是几十上百年之后的事情，目前为止，就是个大泡沫；</p>

<p>因为这种梦幻技术的简洁明了，让每个理解它的人不自觉的沉迷其中，我甚至都觉得一条chain都有艺术上的美感；但是始终要明白，它现在只是一个艺术品，收藏品，进化为工业产品还有非常非常长的路要走~~~</p>

<h5>在这场泡沫之舞中，唯有耐心</h5>

<p>有一句话非常适合比特币信徒们：</p>

<blockquote><p>我并不仅仅在寻求“结果”&hellip;如果只为了寻求“结果”的话，人是容易走捷径的&hellip;在走捷径时，也许就会迷失真实，甚至连满腔的热忱也会逐渐丧失。我认为重要的是“寻求真实的意志”！只要有了这种向真实前进的意志，即使这次失败了，我也终于会达到目标的，因为我仍在继续前进&hellip;这是不会错的。</p></blockquote>

<h2>参考资料:</h2>

<p><a href="http://www.blockstream.com/sidechains.pdf">http://www.blockstream.com/sidechains.pdf</a></p>

<p><a href="https://en.bitcoin.it/wiki/Atomic_swap">https://en.bitcoin.it/wiki/Atomic_swap</a></p>

<p><a href="https://github.com/decred/atomicswap">https://github.com/decred/atomicswap</a></p>

<p><a href="https://en.bitcoin.it/wiki/Merged_mining_specification">https://en.bitcoin.it/wiki/Merged_mining_specification</a></p>

<p><a href="https://en.bitcoin.it/wiki/Sidechain">https://en.bitcoin.it/wiki/Sidechain</a></p>

<p><a href="https://www.ccvalue.cn/article/1495.html">https://www.ccvalue.cn/article/1495.html</a></p>

<p><a href="https://read.douban.com/ebook/24123244/">https://read.douban.com/ebook/24123244/</a></p>

<p><a href="https://zhuanlan.zhihu.com/p/31689532">https://zhuanlan.zhihu.com/p/31689532</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-1]]></title>
    <link href="https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1/"/>
    <updated>2019-01-21T17:44:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1</id>
    <content type="html"><![CDATA[<p>blockchain是个新造词，至少在2008年之前网上是搜索不到这个词的；</p>

<p>比特币的白皮书里面出现过<code>chain of blocks</code>的描述，但是没有直接用<code>block chain</code>的句子;</p>

<p>在早期bitcointalk.org上面的讨论中，为了方便讨论，早期参与者频繁引用<code>chain of blocks</code>的主题，但是谁是最早的引用者，已不可考据。</p>

<p>如果真正要较真blockchain这个单词第一次出现的地方，我想大概是中本聪的第一版bitcoin 源代码中；</p>

<p>bitcoin v0.01源代码中，中本聪第一次在<a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.h#L596">函数注释中</a> 完整的引用了<code>block chain</code>这个术语，鉴于中本聪在比特币白皮书发表的2年前已经开始编写源码；所以有理由确认：</p>

<ol>
<li>blockchain这个名词是2007-2008年间诞生于世间的</li>
<li>中本聪是比特币之父，比特币是blockchain之母</li>
</ol>


<p>现在有一种说法，是比特币和区块链是不同的，比特币是个没有什么前途的庞氏货币，而区块链作为一种新兴的基础技术将会在很多领域发扬光大，前景光明；</p>

<p>对于这个说法，我认为Andreas的一场演讲值得一看：</p>

<p><a href="https://www.youtube.com/watch?v=SMEOKDVXlUo">https://www.youtube.com/watch?v=SMEOKDVXlUo</a></p>

<!-- more -->


<p>好了，八卦完毕，我们开始探究比特币里面的blockchain究竟是个什么样的技术，它是解决什么问题的，实现细节是怎样的；</p>

<p>然后我们一贯的风格是:<code>光说不练假把式</code>；在原理说明中，我们会用代码parse真正的比特币区块链文件来一探究竟。</p>

<h2>由来</h2>

<p>还记得我们<a href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/">之前的文章</a>里面提到的，如果要建立一个分布式的账本，要解决两个问题:</p>

<ol>
<li>什么样的交易是一笔合法的交易</li>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>我们在比特币交易的系列文章中解答了第一个问题，现在是解决第二个问题的时候了。</p>

<p>先思考一下货币发行的问题，比特币网络中，会有成千上万的节点参与者，哪些节点能获得发币的权利呢？或者说，凭什么这些节点能有记账权呢？</p>

<p>在金银货币时代，发币是通过开采金矿来实现的；采矿者承担了勘探、挖掘的风险，大家认可其开采成果并承认其铸币权；那么映射到电子世界中，能不能有一种类似的挖矿的机制呢？</p>

<p>中本聪的回答就是POW (proof of work&mdash;工作量证明)；全网的所有节点一起算一个毫无意义的随机数字，这个数字满足以下的条件，凡是能算出这个数字的人，我们就承认他有一次的记账权：即一次铸币的权利；这个条件如下：</p>

<h4>在一个计算周期内，计算出来的这个数字R满足 F(Chain[R]) &lt; Target；其中F是SHA256算法，Chain是账本，Target是不断减小的，这意味着寻找R的几率会越来越小</h4>

<p>中本聪认为算力是非常公平的、不可伪造的一种证明手段；凡是能在规定周期内正确解答谜题的人，理应获得回报；所有加入到这个比特币网络的人，都应该承认这一点，如果你不承认，那比特币网络就不欢迎你；</p>

<p>那么，铸币的问题解决了；但是如何防止有的节点获取记账权之后，伪造账本呢？</p>

<p>答案是将POW的计算结果嵌入到账本中，每一次新周期的计算，其结果必须在之前所有计算结果的基础上完成；这样如果有人想要伪造账单条账目，他就必须在一个计算周期内伪造更多的账目；如果想要伪造整个账本，就需要将比特币创世之初到现在所有的POW重新计算一遍，而能够获得这样的算力，基本上是不可能的。</p>

<p>那么，如何将这个计算证明过程嵌入到账本里面呢？</p>

<p>答案就是每个计算周期生成一个block，这个block包含了这个周期内全网的交易，而Target就嵌入到这个block中，然后将block用HASH值作为指针串联起来，构造成一条坚不可摧的chain；这就是blockchain的由来。</p>

<h2>区块结构</h2>

<p>如果你运行最新版本的bitcond(>=v0.16)，会发现在数据目录有四类文件:</p>

<ol>
<li>datadir/blocks/blkxxxxx.dat: 存储原始的区块数据，这就是我们常说的blockchain数据</li>
<li>datadir/blocks/index/xxxx.ldb: 区块的原始数据索引，有了它，我们就可以根据HASH值快速查找交易和区块</li>
<li>datadir/chainstate/xxx:这个目录中,存放着LevelDB中的UTXO记录,以及一些这些交易来源的元数据.这些数据用来校验收到的区块和交易</li>
<li>datadir/blocks/revxxxxx.dat: 在区块链分叉重组的时候需要用回滚记录去更新UTXO记录</li>
</ol>


<p>1是原始区块数据，第2，3类数据可以从1中重建，但重建会花很长时间；在一台16Core, 32GB内存，SSD磁盘的机器上，大概要花1天左右。</p>

<p>第4类数据比较特殊，如果存储的数据已经落后了当前区块高度非常远的距离，其实可以删除的；但是为了保证 100%的严谨和安全，目前默认的实现还是全部保留。</p>

<p>3，4类数据在最初的比特币版本中，没有写入文件，就是内存里面放个MAP数据结构临时存着；后来交易量变大，多次代码重构后，变成了今天这个样子。</p>

<p>截至2019-01，以上数据加起来，已经超过了200GB。</p>

<p>那我们就主要来分析第1类数据，就是原始区块数据。</p>

<h4>Block结构</h4>

<p>一个block的结构异常简单，列表如下:</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> Block Size </td>
<td> 当前block的大小</td>
</tr>
<tr>
<td>80 bytes </td>
<td> Block Header </td>
<td> block头信息</td>
</tr>
<tr>
<td>1-9 bytes (VarInt) </td>
<td> Transaction Counter </td>
<td> 这个block包含的交易数量</td>
</tr>
<tr>
<td>Variable </td>
<td> Transactions </td>
<td> 交易</td>
</tr>
</tbody>
</table>


<p>如果去parse blkxxxx.dat 文件，按照这个结构就能很容易拆分出每一个block；来一个工具:</p>

<p><a href="https://github.com/alecalve/python-bitcoin-blockchain-parser">https://github.com/alecalve/python-bitcoin-blockchain-parser</a></p>

<p>另外值得注意的是，因为bitcoind写入区块文件的时候是并行的，所以按照字节序解析出来的区块并不是按时间顺序排列的，blkxxxx.dat文件中，区块存储的次序是随机的；</p>

<h4>Block Header</h4>

<p>区块头由三组区块元数据组成。</p>

<p>首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。就是我们前面讲的作为指针的HASH值。</p>

<p>第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，本质上就是前面公式里面的R值和Target值。</p>

<p>第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构，我们在后面会介绍）。</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> nbits </td>
<td> 当前block的POW难度值 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce </td>
</tr>
</tbody>
</table>


<p>PS:比特币客户端除了bitcoin core之外，任何团队都可以根据当前的协议开发自己的比特币软件，事实上当前也有不少其他的实现，而各个团队之间开发的不同客户端需要遵循同样的协议标准，这个协议的版本管理就是依靠开头的version字段，规则请参照<a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">BIP009</a></p>

<h4>block标识符</h4>

<p>block header中，我们有一个<code>Previous Block Hash</code>值，这就是我们所说的将block串联成为chain的指针。那么这个指针值是怎样计算出来的呢？</p>

<p>还是以<a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">创世块</a>为例，让我们仔细研究下:</p>

<p>创世块的HASH值为<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>，这是一个32字节的HASH值，通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。注意，这个值仅仅是根据区块头得到的，即 <code>SHA256(SHA256(Block Header))</code>;</p>

<p>仅仅依赖区块头就够了吗？是的，不要忘了，我们在区块头里面还有一个重要的HASH值，就是<code>Merkle Tree Root Hash</code>，<code>Merkle Tree Root Hash</code>标识了block中所有的交易，而<code>Block Hash</code> 通过HASH包含了<code>Merkle Tree Root Hash</code>的<code>Block Header</code>，唯一、明确地标识了一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>

<p>通过<code>Merkle Root</code>和<code>Block Hash</code>决定了，一个区块被铸造出来，恶意的第三方节点是无法修改它的 (关于Merkle，请参考后面的说明)；</p>

<p>另外需要注意的一点是: 区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。</p>

<p>当我parse block得到<code>previous block hash</code>值时，如何去判断存在上一个真正的block呢？一般都会到索引文件里面找，就是我们前面所说的 index/xxxx.ldb文件。</p>

<h4>区块高度</h4>

<p>除了这个HASH值作为区块标识符，我们一般还会在区块浏览器上面看到一个说明<code>Height</code>；比如创世块的<code>Height</code>就是0；</p>

<p>这是程序员们按照block在chain上面的次序为block的编号，这个信息是不会写入blockchain的，只是作为<code>区块高度</code>在很多时候方便表示和计算；</p>

<p>当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。</p>

<p>和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况是怎样发生的呢？</p>

<p>因为一个全节点会时时刻刻接收全网的区块广播，在一个生产周期内，不可避免的，会产生两个或更多的符合条件的block，这个时候会发生什么呢？</p>

<p>所有区块高度相同的区块会争夺成为链接上chain的权利，此时所有的矿工便会收集所有可能的chain分支，并选取最长的那一条在上面继续挖矿。</p>

<p>如果把这个情景图像化，我们会看到blockchain时时刻刻都处在分叉状态中，新产生的block会在chain的末尾组成多个分支，不断的消亡、新生、重组，就就好像一条末端散开的绳子有了生命一样；</p>

<p>关于这个情景，有个很诗意的描述词：<code>HASH DANCE</code>；</p>

<p>作为一个Geek，这真是一场让人意醉神迷的数字之舞啊。</p>

<p>PS: 理论上，如果出现一台拥有着无限计算能力的新型的计算机，当然可以轻易伪造1000个或者更多的block，但是现实情况限制比较严格，当新生成的区块寿命过了100个区块高度之后，系统就不再接受重组了，这算是一个多重保险吧。</p>

<h4>创世区块</h4>

<p>区块链里的第一个区块创建于2009-01-03 18:15:05 GMT，被称为创世区块(Genesis block)。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。</p>

<p>因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。</p>

<p>创世块比较特殊，它不是挖出来的，是中本聪手工构造的；参见这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439">https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439</a></p>

<p>关于创世块，之前我们提到一个有趣的事情：创世块的50BTC奖励是不能花的，这是为什么呢？</p>

<p>这需要我们好好研究下中本聪发布的v0.01版本的比特币源码：</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01">https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01</a></p>

<ol>
<li>整个比特币系统接收一笔交易的时候怎么判断其合法性呢？就是判断这笔交易的vin是否关联着一笔合法交易的vout，这些vout统称UTXO，在初版比特币里面，判断一个合法的UTXO的标准就是有没有放进区块链的索引文件中；这个索引文件和区块链文件不是一个东西，他是单独的；如果你运行初版比特币软件(v0.01)；就可以看到中本聪把区块存储在blk0001.dat这样的文件里面，而把所有区块的索引存储在blkindex.dat这个文件里面；</li>
<li>那么问题就出现了，blkindex.dat 什么时机才能写入呢？通读源码发现，只有自己挖矿挖到区块，或者收到周围的广播区块的时候，才有机会写入blkindex.dat这个文件;</li>
<li>中本聪不知道有意无意，在前面手工构造创世区块的时候，没有构建索引写入blkindex.dat里面</li>
<li>后来比特币的源码不断变迁，存储UTXO的方式由BDB变成了levelDB，但是创世块一直没有没有写入到索引文件里面，这样花费创世交易的时候，没有相应的索引，创世交易的UTXO就是非法的，所以没法花费</li>
</ol>


<h5>那么如何解决呢？有两个办法：</h5>

<ol>
<li>就是把创世区块写到区块索引里面</li>
<li>或者在检查交易合法性的时候，单独的加一个判断条件，判断UTXO是否出自创世区块</li>
</ol>


<h5>为什么迟迟没有修正：</h5>

<ol>
<li>每个办法都需要一次硬分叉</li>
<li>这需要全网节点都升级这个只影响创世块的50BTC，中本聪都不在乎，何苦为了50BTC就全网升级呢？</li>
<li>最后，创世块见证着历史，其实不能花费挺好的。</li>
</ol>


<h4>coinbase</h4>

<p>紧接着<code>block header</code>的，就是当前block的所有交易，其中第一笔交易就是coinbase 交易。关于coinbase交易，我们曾经在之前的文章中详细介绍过，这里就增加说明一点，coinbase交易的输出包括了所有交易的手续费，将来比特币网络的额定产出越来越少的时候，矿工们还是可以通过打包交易费用获利，来维持比特币网络的正常运转。</p>

<p>就当前的情况来看，再来一次减半，基本上交易费用和新区快产出就对等了。</p>

<h4>隔离见证</h4>

<p>实施了隔离见证之后，对于<code>block header</code>和coinbase都有一些变化，我们以后会详细再提。</p>

<h2>Merkle树</h2>

<p>区块链的数据是永不删除的，随着交易量越来越大，整个区块数据量也越来越大，那么问题又来了，不可能每个节点都下载数百GB的数据来来验证一笔交易的合法性，而作为一个分布式系统，我们是不能信赖任何中心节点的！我们怎样在一个手机钱包软件里面验证一笔交易呢？</p>

<p>答案是一个绝妙的数据结构: <code>Merkle</code>；</p>

<p>将比特币系统的交易和区块用Merkle树组织起来，会获得一项不可思议的能力，即使整个区块达到数百GB，每个轻节点只需要接收少许数据(MB级别)，就可以完成交易的合法性校验，并且无需任何中心化的节点。</p>

<p>初次接触到Merlke树算法的时候，我觉得这简直是为比特币系统量身定做的，我觉得这是整个系统里面最优美、最简单、最不可思议的算法。</p>

<p>这是怎么做到的呢？呵呵，偶很懒，自己去翻参考资料吧。</p>

<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></p>

<h2>挖矿</h2>

<p>内容引用自： <a href="https://www.8btc.com/article/108894">https://www.8btc.com/article/108894</a></p>

<p>有了Merkle Tree这个数据结构之后，我们非常简单的就可以用一个root hash值来唯一的确定一个block中的所有交易及排列次序；所以要<code>证明</code>这个block中的交易没有被篡改，只要一个<code>Merkle Tree Root Hash</code>值就可以了；将这个值嵌入区块头，然后对整个区块头做HASH，这个过程一旦确定，基本上就不可逆了。</p>

<p>那么终于到了我们前面提到的第二个问题，也是整个系统中最重要的问题:</p>

<ol>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>这个问题的回答就是<code>POW挖矿</code>；大众喜闻乐见的一种行为；虽然挖矿的原理简单的不可思议，但是我觉得真正去花时间搞明白的人也没有几个；那么，我们简单说说吧：</p>

<h4>毫无意义的随机数字</h4>

<p>是的，朋友们，比特币本身是一个荒谬的东西，其中<code>挖矿</code>这种行为，更是荒谬中的荒谬：浪费一个小型国家的能源消耗，只为了计算一个<code>毫无意义的随机数字</code>，人类的荒谬性在此暴露无遗！好一场荒诞派戏剧 ！！所有的Bitoiners其实正参演着一场现代版的《等待戈多》！！！</p>

<p>那么，让我们来看看，Nerd们在追求的这个<code>毫无意义的随机数字</code>究竟是什么吧。</p>

<p>再回忆一下我们前面提到的block header里面的所有字段：</p>

<table>
<thead>
<tr>
<th>长度 </th>
<th> 字段名 </th>
<th> 作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> nBits </td>
<td> 当前block的POW难度值 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce </td>
</tr>
</tbody>
</table>


<p>其中，矿工们能自由更改的：</p>

<ol>
<li>32 bytes的<code>Merkel Root Hash</code>值，这个可以通过调整交易的次序和block包括哪些交易来进行，但是每次调整需要一些计算</li>
<li>4 bytes的Timestamp，调整范围大概在一个比特币的生产周期内(10分钟左右)，这个调整的空间很小</li>
<li><p>Nonce，就是这个；中本聪初版发布时，其挖矿活动就是计算Nonce</p></li>
<li><p>那么算出来的Nonce需要达到什么条件呢？</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SHA256(SHA256(Blockherder)) &lt; F(nBits)</span></code></pre></td></tr></table></div></figure>


<p>其中，SHA256(SHA256(Blockherder))就是挖矿结果，F(nBits)是难度对应的目标值，两者都是256位，都当成大整数处理，直接对比大小以判断是否符合难度要求。</p>

<p>为了节约区块链存储空间，将256位的目标值通过一定变换无损压缩保存在32位的nBits字段里。具体变换方法为拆分利用nBits的4个字节，第1个字节代表右移的位数，用V1表示，后3个字节记录值，用V3表示，则有：</p>

<p>F(nBits)=V3 * 2<sup>8*(V1-3) </sup></p>

<p>此外难度有最低限制，也就是说 F(nBits) 有个最大值，比特币最低难度取值nBits=0x1d00ffff，对应的最大目标值为：0x00000000FFFF0000000000000000000000000000000000000000000000000000</p>

<p>因此挖矿可以形象的类比抛硬币，好比有256枚硬币，给定编号1,2,3……256，每进行一次Hash运算，就像抛一次硬币，256枚硬币同时抛出，落地后要求编号前n的所有硬币全部正面向上。</p>

<p>这里的详细计算可以参考我们之前的一篇<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">文章</a></p>

<h4>CPU挖矿时代</h4>

<p>在Bitcoin早期，只有少数的几个Geek来尝试运行软件，此时的bitcoin core客户端集合了钱包、全节点、挖矿的所有功能；所以早期的节点挖矿过程非常简单：</p>

<blockquote><p>构造区块，初始化区块头各个字段，计算Hash并验证区块，不合格则nNonce自增，再计算并验证，如此往复。在CPU挖矿时代，nNonce提供的4字节搜索空间完全够用（4字节即4G种可能，单核CPU运算Double SHA256算力一般是2M左右），其实nNonce只遍历完两个字节就返回去重构块</p></blockquote>

<h4>GPU挖矿时代</h4>

<p>很快，大家就发现挖矿这个行为只需要在一个block周期内定时获取区块头就可以，不需要每个矿机都运行一个全节点。于是最初的bitcoin软件支持了getwork 协议。</p>

<p>getwork协议代表了GPU挖矿时代，需求主要源于挖矿程序与节点客户端分离，区块链数据与挖矿部件分离。其核心设计思路是：</p>

<blockquote><p>由节点客户端构造区块，然后将区块头数据交给外部挖矿程序，挖矿程序遍历nNonce进行挖矿，验证合格后交付回给节点客户端，节点客户端验证合格后广播到全网。</p>

<p>如前所述，区块头共80个字节，由于没有区块链数据和待确认交易池，nVersion，hashPrevBlock，nBits和hashMerkleRoot这4个字段共72个字节必须由节点客户端提供。挖矿程序主要是递增遍历nNonce，必要时候可以微调nTime字段。</p>

<p>对于显卡GPU来说，其实不用担心nNonce的4字节搜索空间不足，而且挖矿程序从节点客户端那里拿到一份数据后，不应该埋头工作太久，不然很有可能这个块已经被其他人挖到，继续挖只能做无用功，对于比特币来说，虽然设计为每10分钟一个区块，良好的策略也应该在秒级内重新向节点申请新的挖矿数据。对于显卡来说，运行SHA256D算力一般介于200M~1G，nNonce提供4G搜索空间，也就是说再好的显卡也能支撑4秒左右，调整一次nTime，又可以再挖4秒，这个时间绰绰有余。</p>

<p>节点提供RPC接口getwork，该接口有一个可选参数，如果不带参数，就是申请挖矿数据，如果带一个参数，就是提交挖到的块数据。</p></blockquote>

<p>我们先想一下，如果要挖矿，getwork返回的最小数据是哪些呢？</p>

<p>只需要区块头的前76个字节就可以！ 通过nNonce和nTime，就能直接构造。</p>

<p>但是getwork协议充分考虑各种情况，尽量帮助外部挖矿程序做力所能及的事，提供了一些额外字段。getwork的全部返字段如下：</p>

<ul>
<li>Data字段</li>
</ul>


<p>共128字节（80区块头字节 + 48补全字节），因为SHA256将输入数据切分成固定长度的分片处理，每个切片64字节，输入总长度必须是64字节的整数倍，输入长度一般不符合要求，则根据一定规则在元数据末端补全数据。</p>

<ul>
<li>Target字段</li>
</ul>


<p>即当前区块难度目标值，采用小头字节序，需要翻转才能使用。这其实是根据区块头的nBits计算出来的， getwork送佛送到西，直接帮你算好了。</p>

<ul>
<li>Midstate字段</li>
</ul>


<p>SHA256对输入数据分片处理，矿工拿到data数据后，第一个分片（头64字节）是固定不变的，midstate就是第一个分片的计算结果，节点帮忙计算出来了。 因此，在midstate字段辅助下，外部挖矿程序甚至只需要44字节数据就可以正常挖矿：32字节midstate + 第一个切片余下的12（76-64）字节数据。</p>

<ul>
<li>Hash1字段</li>
</ul>


<p>比特币挖矿每次都需要连续执行两次SHA256，第一次执行结果32字节，需要再补充32字节数据凑足64字节作为第二次执行SHA256的输入。hash1就是补全数据，同理，hash1也是固定不变的。</p>

<blockquote><p>外部挖矿程序挖到合格区块后再次调用getwork接口将修改过的data字段提交给节点客户端。节点客户端要求返回的数据也必须是128字节。</p>

<p>每次有外部无参调用一次getwork时，节点客户端构造一个新区块，在返回数据前，都要把新区块完整保存在内存，并用hashMerkleRoot作为唯一标识符，节点使用一个Map来存放所有构造的区块，当下一个块已经被其他人挖到时，立即清空Map。</p>

<p>getwork收到一个参数后，首先从参数提取hashMerkleRoot，在Map中找出之前保存的区块，接着从参数中提取nNonce和nTime填充到区块的对应字段，就可以验证区块了，如果难度符合要求，说明挖到了一个块，节点将其广播到全网。</p>

<p>getwork协议是最早版本挖矿协议，实现了节点和挖矿分离，经典的GPU挖矿驱动cgminer和sgminer，以及cpuminer都是使用getwork协议进行挖矿。getwork + cgminer一直是非常经典的配合，曾经很多新算法推出时，都快速被移植到cgminer。即便现在，除了BTC和LTC，其他众多竞争币都还在使用getwork协议进行挖矿。矿机出现之后，挖矿速度得到极大提高，当前比特币矿机算力已经达到10T/秒级别。而getwork只给外部挖矿程序提供32字节共4G的搜索空间，如果继续使用getwork协议，矿机需要频繁调用RPC接口，这显然不可行。如今BTC和LTC节点都已经禁用getwork协议，转向更新更高效的getblocktemplate协议。</p></blockquote>

<h4>GETBLOCKTEMPLATE</h4>

<p>getblocktemplate协议诞生于2012年中，此时矿池已经出现。矿池采用getblocktemplate协议与节点客户端交互，采用stratum协议与矿工交互，这是最典型的矿池搭建模式。</p>

<p>与getwork相比，getblocktemplate协议最大的不同点是：getblocktemplate协议让矿工自行构造区块。如此一来，节点和挖矿完全分离。对于getwork来说，区块链是黑暗的，getwork对区块链一无所知，他只知道修改data字段的4个字节。对于getblocktemplate来说，整个区块链是透明的，getblocktemplate掌握区块链上与挖矿有关的所有信息，包括待确认交易池，getblocktemplate可以自己选择包含进区块的交易。</p>

<p>getblocktemplate 在被开发出来后并非一成不变，在随后发行的各个版本客户端都有所升级改动，主要是增添一些字段，不过核心理念和核心字段不变。目前比特币客户端返回数据如下，考虑到篇幅限制，交易字段（transactions）只保留了一笔交易数据，其实根据当前实际情况，待确认交易池实时有上万笔交易，目前区块基本都是塞满的（1M容量限制），加上额外信息，因此每次调用getblocktemplate基本都有1.5M左右返回数据，相对于getwork的几百个字节而言，不可同日而语。</p>

<p>来简单分析一下其中几个核心字段， Version，Previousblockhash，Bits这三个字段分别指区块版本号，前一个区块Hash，难度，矿工可以直接将数值填充区块头对应字段。</p>

<p>Transactions，交易集合，不但给了每一笔交易的16进制数据，同时给了hash，交易费等信息。 Coinbaseaux，如果有想要写入区块链的信息，放在这个字段，类似中本聪的创世块宣言。 Coinbasevalue，挖下一个块的最大收益值，包括发行新币和交易手续费，如果矿工包含Transactions字段的所有交易，可以直接使用该值作为coinbase输出。 Target，区块难度目标值。 Mintime，指下一个区块时间戳最小值，Curtime指当前时间，这两个时间作为矿工调节nTime字段参考。 Height，下一个区块难度，目前协议规定要将这个值写入coinbase的指定位置。</p>

<p>矿工拿到这些数据之后，挖矿步骤如下：</p>

<p>构建coinbase交易，涉及到字段包括Coinbaseaux，Coinbasevalue，Transactions，Height等，当然最重要的是要指定一个收益地址。 构建hashMerkleRoot，将coinbase放在transactions字段包含的交易列表之前，然后对相邻交易两两进行SHA256D运算，最终可以构造交易的Merkle树。由于coinbase有很多字节可供矿工随意发挥，此外交易列表也可随意调换顺序或者增删，因而hashMerkleRoot值空间几乎可以认为是无限的。其实getblocktemplate协议设计的主要目标就是让矿工获得这个巨大的搜索空间。</p>

<p>构建区块头，利用Version，Previousblockhash，Bits以及Curtime分别填充区块头对应字段，nNonce字段可默认置0。</p>

<p>挖矿，矿工可在由nNonce，nTime，hashMerkleRoot提供的搜索空间里设计自己的挖矿策略。 上交数据，当矿工挖到一个块后当立即使用submitblock接口将区块完整数据提交给节点客户端，由节点客户端验证并广播。</p>

<p>需要注意的是，与上文提到的GPU采用getwork挖矿一样，虽然getblocktemplate给矿工提供了巨大搜索空间，但矿工不应对一份请求数据挖矿太久，而应循环适时向节点索要最新区块和最新交易信息，以提高挖矿收益。</p>

<h4>矿池</h4>

<p>在很长一段时期内，大家都是各自为战；但随着全网难度上升，个人挖矿的成功率越来越低，很可能挖数年都不能爆一个块。于是有人提出了大家合作挖矿的办法。矿池挖矿时代来临了。</p>

<p>矿池的核心工作是给矿工分配任务，统计工作量并分发收益。矿池将区块难度分成很多难度更小的任务下发给矿工计算，矿工完成一个任务后将工作量提交给矿池，叫提交一个share。假如全网区块难度要求Hash运算结果的前70个比特位都是0，那么矿池给矿工分配的任务可能只要求前30位是0（根据矿工算力调节），矿工完成指定难度任务后上交share，矿池再检测在满足前30位为0的基础上，看看是否碰巧前70位都是0。</p>

<p>矿池会根据每个矿工的算力情况分配不同难度的任务，矿池是如何判断矿工算力大小以分配合适的任务难度呢？调节思路和比特币区块难度一样，矿池需要借助矿工的share率，矿池希望给每个矿工分配的任务都足够让矿工运算一定时间，比如说1秒，如果矿工在一秒之内完成了几次任务，说明矿池当前给到的难度低了，需要调高，反之。如此下来，经过一段时间调节，矿池能给矿工分配合理难度，并计算出矿工的算力。</p>

<h4>STRATUM</h4>

<p>矿池通过getblocktemplate协议与网络节点交互，以获得区块链的最新信息，通过stratum协议与矿工交互。此外，为了让之前用getwork协议挖矿的软件也可以连接到矿池挖矿，矿池一般也支持getwork协议，通过阶层挖矿代理机制实现（Stratum mining proxy）。须知在矿池刚出现时，显卡挖矿还是主力，getwork用起来非常方便，另外早期的FPGA矿机有些是用getwork实现的，stratum与矿池采用TCP方式通信，数据使用JSON封装格式。</p>

<p>先来说一下getblocktemplate遗留下来的几个问题：</p>

<p>矿工驱动：在getblocktemplate协议里，依然是由矿工主动通过HTTP方式调用RPC接口向节点申请挖矿数据，这就意味着，网络最新区块的变动无法及时告知矿工，造成算力损失。</p>

<p>数据负载：如上所述，如今正常的一次getblocktemplate调用节点都会反馈回1.5M左右的数据，其中主要数据是交易列表，矿工与矿池需频繁交互数据，显然不能每次分配工作都要给矿工附带那么多信息。再者巨大的内存需求将大大影响矿机性能，增加成本。</p>

<p>Stratum协议彻底解决了以上问题。</p>

<p>Stratum协议采用主动分配任务的方式，也就是说，矿池任何时候都可以给矿工指派新任务，对于矿工来说，如果收到矿池指派的新任务，应立即无条件转向新任务；矿工也可以主动跟矿池申请新任务。</p>

<p>现在最核心的问题是如何让矿工获得更大的搜索空间，如果参照getwork协议，仅仅给矿工可以改变nNonce和nTime字段，则交互的数据量很少，但这点搜索空间肯定是不够的。想增加搜索空间，只能在hashMerkleroot下功夫，如果让矿工自己构造coinbase，那么搜索空间的问题将迎刃而解，但代价是必要要把区块包含的所有交易都交给矿工，矿工才能构造交易列表的Merkleroot，这对于矿工来说压力更大，对于矿池带宽要求也更高。</p>

<p>Stratum协议巧妙解决了这个问题，成功实现既可以给矿工增加足够的搜索空间，又只需要交互很少的数据量，这也是Stratum协议最具创新的地方。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg2.png" alt="img" /></p>

<p>再来回顾一下区块头的6个字段80字节，这个很关键，nVersion，nBits，hashPrevBlock这3个字段是固定的，nNonce，nTime这两个字段是矿工现在就可以改变的。增加搜索空间只能从hashMerkleroot下手，这个绕不过去。Stratum协议让矿工自己构造coinbase交易，coinbase的scriptSig字段有很多字节可以让矿工自由填充，而coinbase的改动意味着hashMerkleroot的改变。从coinbase构造hashMerkleroot无需全部交易，如上图所示，假如区块将包含13笔交易，矿池先对这13笔交易进行处理，最后只要把图中的4个黑点（Hash值）交付给矿工，同时将构造coinbase需要的信息交付给矿工，矿工就可以自己构造hashMerkleroot（图中的绿点都是矿工自行计算获得，两两合并Hash时，规定下一个黑点代表的hash值总是放在右边）。按照这种方式，假如区块包含N笔交易，矿池可以浓缩成log2(N)个hash值交付给矿工，这大大降低了矿池和矿工交互的数据量。</p>

<p>在getblocktemplate协议和Stratum协议的配合下，矿池终于进化为完全体，可以接纳近乎无限的矿工和算力，至此比特币全网算力进入了爆炸增长的时代；</p>

<h4>最终，普通交易、conbase交易、nNonce、nTime定义了一个Block Header的 Double SHA256 值是否符合nBits代表的难度值，而这些数据的组合共同造就了一组毫无意义的随机数字;包含这组数字的block一旦产生并广播出去，就极难伪造；正是这组数字，决定了哪个节点有记账的权力，保证了整个账本是唯一且不可篡改的。</h4>

<h2>区块链接成为区块链</h2>

<p>比特币的全节点在本地保存了区块链从创世区块起的完整副本。每个计算周期内矿工们辛勤的工作，会不断产生新的区块，每个区块头都用<code>Merkle Tree Root Hash</code>证明其包含的所有交易的不可篡改性，而区块头中的Nonce又包含着巨大的运算量来保证整个区块的不可篡改性；而区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。</p>

<p>最后，整条链凝结了全网矿工从比特币诞生以来的所有算力总和，这些巨大的算力保证了再伪造同样的一条链是近乎不能完成的任务。</p>

<h4>此时整个账本是唯一且不可篡改的。</h4>

<p>最后所有区块组成了blockchain:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg1.jpg" alt="img" /></p>

<h2>SPV(简单支付)</h2>

<p>Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。</p>

<p>例如，一个SPV节点想知道它钱包中某个比特币地址即将到达的支付。该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkleblock消息的形式发送该区块。Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联，交易与区块、区块和区块链，就可以证明交易存在于区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千多倍。</p>

<h2>小结</h2>

<p>blockchain作为比特币的基本技术支撑之一，毫无疑问是一项前无古人的真正创新；这项技术怎么高估都不过分，我认为数十年后，可能会作为一种工业革命的基础技术跟蒸汽机、电力应用、信息技术相提并论；</p>

<p>比特币的链为我们提供了两项能力:</p>

<ol>
<li>不可伪造的电子时间戳证明；任何依赖于有序时间的处理程序(博彩、公证、法律等等)都可以上链</li>
<li>提供了一个构造发行自定义资产(证券、股票)的基础手段，货币只是一个基本应用，任何人都可以以比特币主链为基础，构造一条侧链，并在其之上实现自己的资产发行、定价、转移功能</li>
</ol>


<p>在未来的世界里，关于这方面的应用和创新简直层出不穷，例如预言机的实现，微支付通道，原子交换等等；我所读过的最好的关于blockchain的一些设想是这个：</p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>

<p>好啦，为了能在未来的世界里面不落人后，我们要继续学习，等我们之后的文章吧。</p>
]]></content>
  </entry>
  
</feed>
