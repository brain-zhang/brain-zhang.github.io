<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2018-12-05T17:40:17+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-4]]></title>
    <link href="https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4/"/>
    <updated>2018-12-05T16:04:29+08:00</updated>
    <id>https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4</id>
    <content type="html"><![CDATA[<p>之前我们学习了比特币的HD钱包的技术部分，写着写着我都觉得太无聊了，其实我觉得比特币归根结底还是一个很Geek的东西，初期被它吸引的人估计心底里都有一个独立自由的梦，甚至很多人都想要独立建国；它的技术发展史上也出现过很多有意思的事情，于是增加一篇娱乐性文章；</p>

<p>我们知道比特币的交易是匿名的，但是有很多公共业务，比如交易所，以及公众人物&mdash;会公开他们的地址，那么让我们好好八卦一下比特币历史上那些有意思的地址</p>

<!-- more -->


<h4>satoshi的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a></p>

<p>该地址属于比特币创始人中本聪，是比特币的创世地址，地址内的比特币从未移动过，其中的50币因为技术上的设计原因也无法进行移动。(卖个关子，具体啥原因关注我们后续的文章哦)</p>

<p>具体请参考:<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a></p>

<p>直到今天，还有源源不断的小额转账给这个地址，纪念satoshi。</p>

<h4>Hal Finney的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3">1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3</a></p>

<p>比特币历史上第一笔交易发生在<a href="https://www.blockchain.com/btc/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16">f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16</a>；是中本聪发送给我们熟知的<a href="https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist">Hal Finney</a>)先生的。这笔交易发送了10个BTC，被收录在第<a href="https://www.blockchain.com/zh/btc/block-height/170">170 Block</a>中。</p>

<p>可以肯定，第170 block之前所有的地址都是中本聪本人的钱包地址，如果有人再跳出来说自己是中本聪的话，我们什么都不相信，只会问他两个问题：</p>

<ul>
<li>您能花费一笔第170 block之前的比特币吗？</li>
<li>或者您能出示 <code>I am xxx, happy bitcoiner guys, and today is 2xxx/xx/xx, i prove i am satoshi</code> 这句话的签名，并让我们用早期的公钥来验证一下吗？</li>
</ul>


<h4>Laszlo Hanyecz 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1XPTgDRhN8RFnzniWCddobD9iKZatrvH4">1XPTgDRhN8RFnzniWCddobD9iKZatrvH4</a></p>

<p>没错，这就是著名的<a href="http://link.zhihu.com/?target=https%3A//bitcointalk.org/index.php%3Ftopic%3D137.0">比特币披萨日</a>事件中的主人公。</p>

<p>当时<a href="https://www.blockchain.com/btc/tx/a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d">这笔2010-05-22的交易</a>中，Laszlo Hanyecz花费了10000个币买了两个pizza；造就了比特币历史上第二个节日：披萨日。撒花~~~ (PS:我把比特币的第一个节日归为比特币的生日，<a href="https://20090103.com">2009/01/03</a>)</p>

<p>后来比特币价格不断波动，人们就不断的调侃史上最贵的pizza，史上价格变化最快的pizza等等~~~</p>

<p>Laszlo Hanyecz是个真正的Geek，他应该是已知的显卡挖矿第一人，在这个地址上，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p>

<p>当年买了Laszlo一万个比特币的Jercos当然也是这次历史时刻的另一个主角。他在去年的时候接受了一家媒体的访问，并漏出了自己的真实身份。</p>

<p>原来Jercos非常的年轻，现在也只有25岁（买10000个比特币那年仅仅19岁）。他告诉记者说自己在bitcoin刚创世的2009年就关注了这项技术，并成为了出入各大极客论坛的一员。他与卖披萨的Laszlo并不认识，但是总是在同一个IRC（聊天室）出入，在当时算是对ID比较相熟。</p>

<p>谈到一万个比特币的去向时，他表示在第二年他把这一万枚比特币以400美金的价格出售了，回报率在十倍。（虽然十倍但是还是很可惜了。。）如今他对区块链的技术还是十分看好，对以太坊也十分看好。</p>

<p>Laszlo Hanyecz与Jercos的比特币经历可谓是大风大浪了，以后可以跟后来人好好说说<code>当年~~~</code>；</p>

<p>如果你这样想，那就Out了，真正的Geek永远是站在潮流前头的，同样的，2018-02-05，闪电网络运行后，Laszlo Hanyecz又花费了0.00649枚比特币通过闪电网络买了两块披萨，续写了比特币披萨的传奇；</p>

<p>少年，当你在为所谓<code>10000个比特币买披萨是不是很后悔</code>这种问题纠结时，人家早就又一次站在潮头浪尖了；所以~~~</p>

<h5>让我们努力学习吧。</h5>

<p>这个地址至今仍然非常活跃，Laszlo Hanyecz仍然是比特币世界中的Geek先锋，并且他用自己的乐观幽默为全世界的bitcoiner创造了一个节日，Hi, Laszlo Hanyecz，谢谢你！</p>

<h4>Bitcoin Faucet donation的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC?offset=0&amp;filter=6">15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC</a></p>

<p>这个地址属于比特币先驱<a href="https://en.bitcoinwiki.org/wiki/Gavin_Andresen">Gavin Andresen</a>在2010年建立的一个网站:</p>

<p><a href="https://freebitcoins.appspot.com/">https://freebitcoins.appspot.com/</a></p>

<p>当时Gavin Andresen作为中本聪之后的主力开发者，非常希望普及比特币，于是建立了<a href="https://bitcointalk.org/index.php?topic=183.0">Bitcoin Faucet donation</a>这个项目，免费发送比特币给人们，这个地址总共免费发放了超过10000个币；</p>

<p>Gavin Andresen为比特币的开发，普及做出了巨大的贡献，Hi, 了不起Gavin，向你致敬！</p>

<h4>Andreas M. Antonopoulos 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1andreas3batLhQa2FawWjeyjCqyBzypd">1andreas3batLhQa2FawWjeyjCqyBzypd</a></p>

<p>Andreas M. Antonopoulos是比特币社区里令人肃然起敬的人物，他从非常非常早期(2012)就开始比特币相关知识的布道；我得说，凡是有严肃的学习比特币、区块链知识愿望的人们，观看Andreas M. Antonopoulos的讲演视频是绝佳途径，他的Yotube主页：</p>

<p><a href="https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ">https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ</a></p>

<p>Andreas M. Antonopoulos对比特币布道激励了非常多的人，但是作为先驱，他却没有收到多少报酬，这完全是<a href="https://twitter.com/aantonop/status/938147200978374662?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E938147200978374662&amp;ref_url=https%3A%2F%2Fqz.com%2F1151233%2Fandreas-antonopoulos-got-1-5-million-in-bitcoin-donations-after-roger-ver-bitshamed-him%2F">公益的工作</a>。怎么能让真正输出价值的人受到冷落呢？为了感谢他，在2017-12，粉丝们为他的地址发送了近100个bitcoin的捐款。但是我们这里很高兴的引用一句俗语：<code>黄金有价，知识无价</code>；Hi, Antonopoulos，<code>比特有价，知识无价</code>，期待收到你更多的教诲。</p>

<h4>美国法警局的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55">1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55</a></p>

<p>所有者为美国法警局，该地址内的比特币来自被查获的丝绸之路，后在第一次拍卖会中将币转移给中标人<a href="https://www.blockchain.com/btc/tx/9e95c3c3c96f57527cdc649550bf8e92892f7651f718d846033798aee333b0c3">29,658BTC交易</a>。</p>

<p>2018年这个地址还有小额的零星收入，不知转入者是谁。</p>

<h4>Tim Draper的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi">1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi</a></p>

<p>这个哥们是bitcoin的铁杆粉丝；它是风险投资公司Draper Fisher Jurvetson的创始人，作为硅谷投资教父，投资了SpaceX、Tesla、Thumbtack，Baidu，Hotmail，Skype等耳熟能详的公司；</p>

<p>这个地址就是当时他购买美国法警局拍卖丝绸之路BTC的转移地址；</p>

<p>作为bitcoin铁粉，这个老哥早期投资了蝴蝶矿机，最著名的故事就是在Mt.Gox事件中损失惨重后仍然多次买买买，即使去年的大涨风潮中也一币不卖；他对于比特币的信心估计就是中本聪本人也不及，如果你去google <code>Tim Draper</code>，估计排在前面的就是$250K， 即他相信2022年一币250000$，让我们祝福这位老哥。</p>

<h4>Carl M. Force的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB">14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB</a></p>

<p>该地址属于“法国女仆”，又名Carl M. Force，是美国联邦缉毒局的一名探员，在参与调查丝绸之路时，Force化名“法国女仆”利用职务之便勒索罗斯乌布利希，并将赃款汇入该地址内，但Force最终被抓住并遭到起诉。</p>

<p>这应该是有据可查的第一起比特币偷盗破获案件。Hi, Carl M. Force，不要沮丧哦，你已经青史留名了。</p>

<p>不过悲伤的是，之后发生的偷盗事件数不胜数，却没有多少案件能被破获。</p>

<h4>真土豪的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv">1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv</a></p>

<p>该地址发生了一笔历史上最大额的交易，一次性转移了500,000 BTC，创历史之最，虽然是发生在2011年的事情，但是按币本位算，估计这个数额很难打破了。</p>

<p>这个地址2017年还被使用过，观看它的交易记录，我严重怀疑这是国内某一个大佬的地址，并且与Mt.Gox有牵连。</p>

<h4>wiki的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v">1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v</a></p>

<p>这是维基解密用来接受比特币捐赠的地址，维基解密的创始人，阿桑奇，也是比特币社区最早的支持者；我得说，这位阿桑奇，真是一条汉子；</p>

<p>希望能看到你收到更多的捐赠，wikileaks！</p>

<h4>烤猫的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW">15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW">1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey">1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey</a></p>

<p>由于比特币的匿名性，发生过很多看起来不可思议的事情。有时候看这些事情的时候好像是传奇小说。<a href="https://view.inews.qq.com/a/20170805G04OZI00?refer=share_recomnews">烤猫的故事</a>非常有意思，我都有点相信他现在在某个海岛上搞基建。这三个地址的交易也很有意思，有时间我们来细细探究一下。</p>

<h4>Bitstamp被盗地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf">1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf</a></p>

<p>Bitstamp遭窃的热钱包地址，黑客在2015年1月5日时陆续从该地址内盗取了大约19,000BTC 。</p>

<p>事件调查可以参考这里:</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/">https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/</a></p>

<p>这个地址非常奇怪，之后还陆陆续续有交易发生；并且在2017年，有人考证一币Tether的hack事件和Bitstamp被盗事件是同一个黑客：</p>

<p><a href="https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/">https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/</a></p>

<p>一个疑问重重的故事。</p>

<h4>Bitfinex被盗地址</h4>

<p><a href="https://gist.github.com/MrChrisJ/4a959a51a0d2be356cc2e89566fc1d87">地址列表</a></p>

<p>2016-08-03，<a href="https://www.reddit.com/r/Bitcoin/comments/5vr8xg/confirmed_120000_bitcoins_from_the_bitfinex_hack/">reddit</a>上面已经有人确认，Bitfinex被盗119756个btc.</p>

<p>查看黑客的接收地址，有些币至今未动。</p>

<p>bitfinex后来通过发行USDT起死回生，这种神操作说起来好像是天方夜谈，呵呵，比最诡异的侦探小说还诡异的故事。</p>

<h4>NiceHash被盗地址</h4>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>2017-12-06，Nicehash 被盗 4700+币</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>呵呵，说下去都不好意思了；黑客的黄金年代啊</p>

<h4>Mtgox</h4>

<p><a href="https://www.cryptoground.com/mtgox-cold-wallet-monitor/">https://www.cryptoground.com/mtgox-cold-wallet-monitor/</a></p>

<p>作为史上之最，Mtgox事件聚集了一切传奇侦探小说都有的元素，就等着将来一位福尔摩斯来为我们排疑解惑了；期待着那一天的到来</p>

<h4>官方土豪</h4>

<p><a href="https://www.blockchain.com/btc/address/1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX">1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX</a></p>

<p>之前我们说50w币转账的土豪毕竟是萌芽时期，只能说是个野生土豪。来来来，让我们活捉一位官方土豪。</p>

<p>就在前几天，2018-12-03，发生了<a href="https://www.blockchain.com/btc/tx/244c71c790eb327eb8bbf66aa2d0a75bac7c1fe7b55d1161c316c6f93292d376">一笔66233比特币的转账</a>。以当前的币价来算，可谓是天文数字了。这笔交易主要是将老地址的币逐步迁移到bech32地址上去。(什么是bech32地址？复习我们之前的文章哦)</p>

<p>这个地址的土豪还关联着9个地址，总币量加起来大概55w币。</p>

<p>有人推测这是coinbase.com的冷钱包。</p>

<p>嗯哼，应该是继中本聪之后最大的壕。</p>

<h4>伊朗恶意网络行动者</h4>

<p>前几天，美国财政部通过美国外国资产控制办公室(Office of Foreign Assets Control，简称OFAC)，在被制裁方名单上增加了两个比特币地址:</p>

<p><a href="https://www.blockchain.com/btc/address/149w62rY42aZBox8fGcmqNsXUzSStKeq8C">149w62rY42aZBox8fGcmqNsXUzSStKeq8C</a></p>

<p><a href="https://www.blockchain.com/btc/address/1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V">1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V</a></p>

<p>这些特殊的地址被挑选出来是因为其所有者被认为是伊朗人，而伊朗目前正面临来自美国的严厉经济制裁。可笑的是，美国政府将此地址列入黑名单的理由是这些地址跟勒索软件有关。</p>

<p>这两个地址自 2013 年以来已进行了 7,000 多笔交易，并收到近 6,000 枚 BTC。截至 2018年 11 月 28 日，任何与这些地址进行互动的人，在技术上都可能被美国政府追究责任并以某种方式受到惩罚。</p>

<p>但实际上，这些威胁不过只是空话。任何人，甚至包括美国政府及其执行官和执法人员，都无法阻止特定地址发送或接收比特币。</p>

<p>这不，美国财政部话音刚落，立即有人给这两个地址发币，并使用了嘲弄性质的地址 <code>3FUCKdZ89fxsk6KVKMTWvCWshsfL8xgmM4</code>发送交易并附言:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>The U.S. government cannot ban Bitcoin addresses
</span><span class='line'>
</span><span class='line'>Chancellor on brink of second bailout for banks</span></code></pre></td></tr></table></div></figure>


<p>赤裸裸的打脸一个国家政府的行为是Geek们的最爱，你可以把它理解为小孩子的淘气行为，我真的很好奇，美国政府该如何去寻找这些发币者并惩罚他们呢？</p>

<p>难道是去求助魔法师的水晶球吗23333?</p>

<p>&hellip;&hellip;</p>

<p>待续</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-2]]></title>
    <link href="https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2/"/>
    <updated>2018-12-03T18:06:46+08:00</updated>
    <id>https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2</id>
    <content type="html"><![CDATA[<p>之前的文章我们说过，比特币的所有交易抽象成了UTXO的转移。所谓转移，可以这么理解：</p>

<ul>
<li>有M个UTXO作为输入 (M >= 0)</li>
<li>有N个UTXO作为输出 (N > 0)</li>
<li>输入的UTXO总额==输出的UTXO总额</li>
<li>输入的UTXO来源于支付方控制的私钥账户</li>
<li>输出的UTXO流向收款方的公钥地址</li>
</ul>


<p>那么具体是怎么转移的？怎样手工的构造一笔交易呢？我们就在这篇文章里面详细的演示一遍。</p>

<p>首先科普一下常见的交易类型:</p>

<!-- more -->


<h4>Generation TX</h4>

<p>这种交易我们称之为是产量交易(Generation TX)，即矿工挖出一个新的Block时，系统允许这个矿工在块头构造一笔奖励自己的交易，这笔奖励金额被称之为Coinbase奖励，最初一个block挖出的奖励是50BTC，后来就是我们大家所熟知的四年减半原则啦。这样大家明白比特币整个账本里面的初始资金是怎么来的啦。就是系统通过Generation TX向矿工发放奖励产生的BTC。</p>

<p>矿工们计算随机数，竞争打包Generation TX的权力，就是挖矿。具体的细节我们会在以后的文章中介绍。</p>

<p>现在每笔Generation TX的奖励金额是12.5BTC，预计下个减半周期在2020年年中。</p>

<p>注意：Generation TX中的BTC是无中生有的，所以只有输出的UTXO，没有输入的UTXO。</p>

<p>PS:Coinbase作为一个很经典的技术名词，其<code>coinbase.com</code>域名被现在美国著名的交易所coinbase Pro 注册持有。</p>

<h4>Script Hash TX</h4>

<p>也被成为P2SH（Pay-to-Script-Hash）交易。</p>

<p>该类交易目前不是很常见，大部分人可能没有听说过，但是非常有意义。未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义的地址，而是一个合成地址，以<code>3</code>开头 (Segwit交易其实也可以看成是Script Hash TX)。比如三对公私钥，可以生成一个合成地址。在生成过程时指定n of 3中的n，n范围是[1, 3]，若n=1，则仅需一个私钥签名即可花费该地址的币，若n=3，则需要三把私钥依次签名才可以。 这种类型的交易适合比较复杂的保险、证券场景。</p>

<h4>Pubkey Hash TX</h4>

<p>也被称为P2PKH（Pay-to-Public-Key-Hash）交易。该类是最常见的交易类型，由N个输入、M个输出构成。交易地址都是以<code>1</code>开头。这种交易也是目前比特币网络中最典型的交易类型，也最简明，容易分析。下面我们就先拿它作为例子，开始探究一笔比特币交易的细节。</p>

<h2>数据结构</h2>

<h3>输入输出</h3>

<p>简单来看，一笔完整的P2PKH交易包含有两个部分:输入UTXO &ndash;> 输出UTXO，而每一个输入UTXO其实是上一笔交易的输出UTXO，这么说可能有点绕口，来张图解释一下：</p>

<p><img src="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/en-tx-overview.svg" alt="img" /></p>

<p>首先最前面的字段是版本号，每一个交易具有一个四字节的交易版本号，它告知比特币节点和矿工应使用哪一套规则来验证它。这使得开发者在为未来的交易创建新规则时可以不验证之前的交易。</p>

<p>接着就是输入的M个UTXO和输出的N个UTXO，代表着我要把一堆UTXO转移(支付)给谁。</p>

<p>最后是一个字段是锁定事件(Locktime)。Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。</p>

<p>如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>一笔交易中，构造的输出UTXO会完全花费掉输入的UTXO，注意：是完全花费掉。如果输出UTXO的总额小于输入UTXO的话，那么差值就会被系统作为矿工费奖励打包到Generation TX当中。所以所有的比特币钱包实现中，如果你有10BTC的UTXO集合，想要花掉9BTC，那么输出UTXO中，除了支付给收款方的UTXO，还一定要构造发送给自己的找零UTXO。曾经有人构造交易时忘记找零，发生了<a href="https://blockchain.info/tx/4ed20e0768124bc67dc684d57941be1482ccdaa45dadb64be12afba8c8554537">支付 200 BTC 的矿工费</a>的惨案，所幸的是收录该笔交易的Block由著名挖矿团队“烤猫（Friedcat）”挖得，该团队非常厚道的<a href="https://blockchain.info/tx/b18abce37b48a5f434f108ae7ce34f22aa2bfbd9eb9310314029e4b9e3c7cf95">退回了多余费用</a>。</p>

<p>早期Geek们比较作死，特别喜欢命令行构造发送交易，像是忘记构造找零而当了冤大头的人数不胜数，那么为什么是这么奇葩的设计呢？为什么一笔交易中，一定要花费所有的输入UTXO呢？</p>

<p>大家还记得我们的上一篇文章吧，一个分布式的账本，最容易的设计就是只支持<code>append</code>这个动作，诸如<code>update</code>、<code>delete</code>这种操作在区块链账本的设计中会引入额外的复杂性，尤其是后面我们讲述blockchain的组织的时候，你就会理解，这种设计的必要性。</p>

<h3>细节</h3>

<p>一笔完整的P2PKH 交易是这样的：</p>

<p><img src="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/en-tx-overview-spending.svg" alt="img" /></p>

<p>我们用之前文章中，利用<code>satoshi</code>生成的地址(<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>)做例子，来研究它花费的<a href="https://www.blockchain.com/btc/tx/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517">一笔交易</a>。</p>

<p>用<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">在线getrawtransaction工具</a> 解码一下这笔交易，得到输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>字段说明</h4>

<ul>
<li>txid (hash)</li>
</ul>


<p>Tx Hash (3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517)，俗称交易ID，由hex得出：Tx Hash = SHA256(SHA256(hex))。由于每个交易只能成为下一个的输入，有且仅有一次，那么不存在输入完全相同的交易。因为SHA256碰撞的概率极小，所以理论上存在相同的Tx Hash 的概率非常小。</p>

<p>即便如此，在系统里依然产生了相同的Tx Hash，是不知道哪位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<ul>
<li>vin (输入UTXO)</li>
</ul>


<p>vin是一个数组，里面即M个输入UTXO，每个UTXO都来自上一笔交易的一个UTXO输出，这笔交易的vin只有一个UTXO，它由以下几个字段组成</p>

<pre><code>- txid: 上一笔关联交易的hash值
- vout: 上一笔交易输出的N个UTXO里面的序号
- scriptSig: 对这笔UTXO的签名，还记得我们之前的文章吗？只有对一个UTXO签名才能证明其所有权，才能花费它
- sequence: 序列号。这个序列号来源比较复杂；还记得上面讲的locktime有所关联：
</code></pre>

<blockquote><p>Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。
如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>Bitcoin Core 的早期版本提供了一个可以防止签名者使用上述方法取消locktime 交易的功能。 后来为了防止大量的延时交易攻击网络，这个功能被禁用了。但是该系统还留下了这样的设置，每个输入会分配一个四字节的序列号。序列号的目的旨在允许多个签名者同意更新交易。</p>

<p>如果sequence number设置为0，就按照locktime执行入块操作，如果出现一笔新的交易，sequence大于原来的sequence，这笔新交易就会取代原来的交易；所以一般为了即刻入块，交易的sequence number一般设置为四字节的的无符号最大值(0xffffffff),使得交易的locktime 仍然有效的情况下，打包交易进块。</p>

<p>即使今天，如果所有的input 的sequence number都是最大值，locktime锁就会失效。所以如果想使用locktime，至少一个input的sequence number要小于最大值。由于sequence number不用于其他目的，任何sequence number 为零的交易都会启动locktime 功能。后面我们会看到，sequence number会在闪电网络中发挥作用</p></blockquote>

<p>vin的所有UTXO 余额相加，就是这笔交易的转账总额。</p>

<ul>
<li><p>vout (输出UTXO)</p>

<ul>
<li>value: 转账金额</li>
<li>n: 作为第N个UTXO输出</li>
<li>scriptPubKey: 这是设置的谜题，后来人想要花费这笔UTXO，必须提供scriptSig来解答这个谜题才可以</li>
</ul>
</li>
<li><p>vin 的总额 &ndash; vout的总额 == 打包费用 &ndash;> 奖励给打包矿工</p></li>
</ul>


<h4>交易十六进制解析</h4>

<p>spec规范在<a href="https://en.bitcoin.it/wiki/Protocol_documentation#tx">这里</a></p>

<p>这笔交易的vin及vout中各有一个UTXO，我们解析下它的十六进制原始数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>version (4字节): 刚开始的4个字节是version，小端排序(Little Endian)，因此version为<code>0x00000001</code></li>
</ul>


<blockquote><p>ps:关于小端排序的设计，社区里面还有过小争论，见<a href="https://bitcointalk.org/index.php?topic=4278.0">这里</a></p></blockquote>

<ul>
<li><p>flag (2字节，可选): 如果是<code>0001</code>，代表是witness交易；如果不是，就代表没有这个flag字段；这是一笔普通的交易，因此没有flag字段</p></li>
<li><p>vin count (>=1字节): vin数目，此交易为<code>01</code>，采用的是<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer">var_int</a>表示法，这样我们能方便的测算它的长度</p></li>
<li><p>vin (>=41字节): 所有的输入tx，是一个数组；这里只有一个tx，数据是:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff</span></code></pre></td></tr></table></div></figure>


<p>简单说下vin中一笔tx内部结构:</p>

<pre><code>- previous_output (32字节): 上一笔交易的HASH值，即这个花费的输入交易ID: 

3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0
-&gt; 转为大端排序  
b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b

- previous output index: 表示花费的是 previous_output 交易的第n个vout输出，这里是`00000000`

- script length (var_int变长，代表script的长度): 这里是`0x8a`，表示script长度为138字节

- criptSig (整个解密脚本)： 这个结构我们之后会具体分析
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<pre><code>- sequence no (4个字节): `ffffffff`
</code></pre>

<ul>
<li><p>vout count (>=1字节): vout数目，此处为<code>01</code></p></li>
<li><p>vout (>=9字节): 所有的输出tx，是一个数组；这里只有一个tx，数据是:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>581b0000000000002103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</span></code></pre></td></tr></table></div></figure>


<p>简单说下vout中一笔tx内部结构:</p>

<pre><code>- value (8字节): 转账到这个地址上的金额， 这里是`581b000000000000`小端排序，十六进制为`00000000000000581b`，即转账7000 satoshis
- scriptPubKey length (&gt;=1, var_int类型): 输出脚本的长度，这里是`0x21`，代表33字节长度
- scriptPubKey: 输出脚本，其实就是包含转账地址的脚本，这里是`03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac`
</code></pre>

<ul>
<li>locktime: 最后4个字节是locktime，这笔交易设置为0；就是立即打包</li>
</ul>


<h3>总览</h3>

<p>最后一张表格说明问题：</p>

<p><img src="https://ws1.sinaimg.cn/large/893d6e9dly1fxtq1vq3b1j20pc0e3gma.jpg" alt="img" /></p>

<h3>scriptSig与scriptPubKey</h3>

<p>目前为止，我们还没有解析vin中的scriptSig，以及vout中的scriptPubKey；这两个东东才是交易的核心，他们有什么作用呢？</p>

<p>~~ 待续</p>

<h2>参考资料:</h2>

<p><a href="https://en.bitcoin.it/wiki/Protocol_documentation">https://en.bitcoin.it/wiki/Protocol_documentation</a></p>

<p><a href="http://learnmeabitcoin.com/">http://learnmeabitcoin.com/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>

<p><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html">https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html</a></p>

<p><a href="https://www.8btc.com/article/24637">https://www.8btc.com/article/24637</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-stream,一次可怕的社工]]></title>
    <link href="https://happy123.me/blog/2018/11/27/event-stream/"/>
    <updated>2018-11-27T16:06:38+08:00</updated>
    <id>https://happy123.me/blog/2018/11/27/event-stream</id>
    <content type="html"><![CDATA[<p>几天前有人在github创建了一个issue:</p>

<p><a href="https://github.com/dominictarr/event-stream/issues/116">https://github.com/dominictarr/event-stream/issues/116</a></p>

<p>标题为：&#8221;I don&rsquo;t know what to say.&ldquo;，翻译过来大概就是“我无语了”。因为 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p>

<!-- more -->


<p>event-stream 被很多的前端流行框架和库使用，每月有几千万的下载量。作为最流行的前端框架之一，在 Vue 的官方脚手架 vue-cli 中也使用了这个依赖，作为最流行的前端框架之一，这个影响还是挺大的，这个影响还是挺大的。而 React 则躲过了。</p>

<p>flatmap-stream 中的恶意代码会扫描用户的 nodemodules 目录，因为所有从 npm 下载的模块都会放在此目录。如果发现了在 nodemodules 存在特定的模块，则将恶意代码注入进去，从而盗取用户的数字货币。</p>

<p>COPAY钱包因为引用了event-stream库，它在今年9、10、以及11月27日之前发布的所有版本都受到了感染，COPAY是bitpay旗下的开源钱包，市场占有率不可小觑；下面这个链接进行了分析，使用被感染钱包的用户很有可能被窃取私钥:</p>

<p><a href="https://github.com/bitpay/copay/issues/9346">https://github.com/bitpay/copay/issues/9346</a></p>

<p>COPAY紧急发布了5.2.2修正版本：</p>

<p><a href="https://github.com/bitpay/copay/pull/9348">https://github.com/bitpay/copay/pull/9348</a></p>

<h2>使用COPAY钱包的人，请立即升级新版本，并且生成新的钱包，把老钱包里面的币转走。</h2>

<p>这个恶意模块更可怕之处，在于背后的骇客是个深谋远虑、精于社工的人。</p>

<p>这个人的github账号叫做<a href="https://github.com/right9ctrl">right9ctrl</a>，他应该是精心分析了COPAY引用的所有模块，发现event-stream有机可乘。于是给event-stream的创始人-<code>dominictarr</code>发去了邮件，承诺会自愿维护这个项目。</p>

<p><code>dominictarr</code>是一个高产的开发者，他维护着多个NPM包，有人能自愿分担他的工作，他自然是高兴之至，于是将这个模块的仓库控制权移交给了<code>right9ctl</code>。</p>

<p>刚开始的时候，<code>right9ctl</code>非常小心的进行着常规的维护。一段时间后，即在 3 个月前，黑客在 GitHub 上新建了一个 flatmap-stream 仓库（内含恶意代码），并在这个项目中引用了自己的仓库。</p>

<p>直到几天前这个有漏洞的仓库才被发现，然后 npm 紧急将这个含有恶意代码的 flatmap-stream 模块删除了。</p>

<p>这个模块的攻击行为也很隐蔽，首先他只有引用了 event-stream 这个库，并且依赖引用了 flatmap-stream，用户在编译自己的项目时，才会感染恶意代码。</p>

<p>感染恶意代码的程序，也不会全部发作。只有COPAY钱包运行时，他才会悄悄的窃取用户信息，并发送到下面这几台服务器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>copayapi.host
</span><span class='line'>51.38.112.212
</span><span class='line'>145.249.104.239
</span><span class='line'>111.90.151.134</span></code></pre></td></tr></table></div></figure>


<p>我不知道截止到现在黑客获取了多少币，但整个事件非常惊悚。而且这个漏洞刚刚被发现，我认为还会持续有消息不灵通的受害者。</p>

<p>另外，如果想查看自己的项目是否受到影响，可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm ls event-stream flatmap-stream...flatmap-stream@0.1.1...</span></code></pre></td></tr></table></div></figure>


<p>如果在输出里面包含了 flatmap-stream 则说明你也可能被攻击。</p>

<p>如果使用 yarn 则可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yarn why flatmap-stream</span></code></pre></td></tr></table></div></figure>


<h2>区块链历史中的传奇HACK手段</h2>

<p>我在以前的文章中多次感叹所谓的区块链技术出来后，简直是黑客的黄金年代！大概从2011年开始，精彩的HACK事件层出不穷，如果要全部整理出来，可能会是一部让所谓的<code>区块链专家</code>和<code>区块链投资者</code>冷汗直流，后怕不已的手册。</p>

<p>撇开这几天的市场动荡，币价大跌不提，单单从技术上评估，能有多少人意识到他们所谓的投资的技术风险！</p>

<p>我随意的说几件印象非常深刻的HACK事件。</p>

<h4>整个国家DNS 流量劫持事件</h4>

<p>我记得大概是2015年，巴西的骨干网DNS整个被黑客劫持了，导致当时的blockchain.info 在线钱包有几个小时的流量完全被导向了钓鱼网站，这次事件导致的丢币数目不可统计。</p>

<p>但是给你一个启示，当利益足够大的时候，任何设施，包括国家设施都是不可信、不安全的。结合这两天发现的jd.com流量返利劫持，你就知道：网络世界里，有的组织或者个人，完全可以劫持一个国家的网络流量，这不是天方夜谭。</p>

<h4>官方域名劫持事件</h4>

<p>今年二月份的时候，有人花大价钱买了&#8221;electrumltc.org&#8221;这个域名，仿照&#8221;<a href="https://electrum-ltc.org/">https://electrum-ltc.org/</a>&ldquo;官网，精心炮制了一个以假乱真的网站，然后把下载链接改成了恶意钱包，并且做了Google SEO，把自己的骗子网站搜索结果推到了第一名；有人因此丢了2399个LTC，那个时候可是不少钱。</p>

<p>很讽刺的是，恰恰是因为真正的开发者买不起这个域名，才搞了一个山寨的域名发布自己的软件，让骇客有机可乘。</p>

<p>讽刺吧，原作者辛辛苦苦开发，却因为没钱买域名不得已搞个屌丝网站，骇客财大气粗，直接买下第一官方域名然后钓鱼，并且真的获取巨大收益。</p>

<p>这种钓鱼手法在多个钱包、多个网站上面一再重演，受害小白不计其数！</p>

<p><code>杀人放火金腰带，修桥补路无尸骸。</code>这个世界就是这样。</p>

<p>整个事件回顾：</p>

<p><a href="https://github.com/pooler/electrum-ltc/issues/176">https://github.com/pooler/electrum-ltc/issues/176</a></p>

<h4>~~~~</h4>

<p>这么罗列下去，我可以轻易列举出更多的涉及上亿美元的hack事件。每个事件说起来好像天方夜谭一样，不明技术的小白可能会惊叹：怎么可能有这种事情？！</p>

<p>但是事实就是这样，而且将来这样的悲剧会一再重复下去，说再多也没用，人的安全意识总敌不过懒惰、贪婪等等等等，可悲的人性啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoind Conf Template]]></title>
    <link href="https://happy123.me/blog/2018/11/26/bitcoind-conf-template/"/>
    <updated>2018-11-26T14:51:43+08:00</updated>
    <id>https://happy123.me/blog/2018/11/26/bitcoind-conf-template</id>
    <content type="html"><![CDATA[<p>bitcoin core 0.17版本开始废弃了不少RPC调用，另外RPC配置增加了test.rpcport参数，存一份模板:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=127.0.0.1
</span><span class='line'>rpcport=18332
</span><span class='line'>test.rpcport=8332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>walletnotify=/usr/bin/python3 /xxx.py</span></code></pre></td></tr></table></div></figure>


<p>另外<code>getaddressesbyaccount</code>即将废弃，可以使用<code>getaddressesbylabel</code>代替</p>

<p><code>signrawtransaction</code>即将废弃，实在要用的话只能在启动命令行中加deprecatedrpc指定。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/bitcoind --conf=/xxx/bitcoin.conf --datadir=/xxx/blockdata/mainnet --deprecatedrpc=signrawtransaction</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-1]]></title>
    <link href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/"/>
    <updated>2018-11-23T18:48:39+08:00</updated>
    <id>https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1</id>
    <content type="html"><![CDATA[<p>在我们前面的文章中，我们提到，从建设银行转账到工商银行10w元，过程其实是这样的:</p>

<ol>
<li>建设银行发送报文到人行CNAPS系统</li>
<li>人行CNAPS发送转账报文到工商银行</li>
<li>工商银行发送响应报文给人行CNAPS</li>
<li>人行发送响应报文给建设银行</li>
<li>转账成功，建设银行、人行、工商银行各自更新账本</li>
</ol>


<p>整个过程中，有几个很有趣的事实：</p>

<!-- more -->


<ol>
<li>所谓的转账交易，不过是账本上数字的加加减减</li>
<li>我们的账户，除了各自在工行、建行开设的户头之外，在人行还有一个总账；人行是所有银行的妈，你在任何银行开设的账户，人行都有一个总账；所以打印征信的时候我们要到人行打印</li>
<li>建设银行和工商银行间的转账需要人行做清算，人行提供了信用；建行和工行相信人行不会造假</li>
<li>我们需要信任三个机构：人行、工行、建行，我们相信他们不会造假</li>
<li>人行是所有账目的中心节点，人行的账本对不上了，中国的金融系统就乱套了</li>
</ol>


<p>然后作为对比，我们来看看比特币是怎样设计的。</p>

<p>中本聪创造比特币之初，在<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis Block</a>里面付了一句有名的话:&ldquo;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&#8221;。在白皮书中他很自豪的宣称:&#8221;We have proposed a system for electronic transactions without relying on trust. &rdquo; 去中心化一直是比特币的指导纲领，那么问题来了，如果让我们来设计一个去中心化的账本，将会面临哪些技术问题，又该如何解决呢？</p>

<p>很自然的，我们设想的是一个类似于分布式数据库的系统，整个系统维护着唯一的账本，每个节点（node）都是一个副本（Replica Set），每个副本保有完全的账本数据，并且节点间相互同步数据，如果部分节点挂掉，不影响整个系统的运行。</p>

<p>用户转账的行为，其实就是这个分布式账本的增删查改。当然，为了简化设计，我们这个账本可以只支持账目写入，不支持删改。</p>

<p>我们开始思考这个分布式账本要解决的两个核心问题：</p>

<h4>什么样的交易是一笔合法的交易</h4>

<ul>
<li>一笔交易中，如何保证交易账户的完全所有权；如果保证用户A的资金不会被用户B盗用</li>
<li>用户A本来有1000元，如何保证他不会转出2000元？</li>
</ul>


<h4>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</h4>

<ul>
<li>如果有部分节点是不诚实的，它就会有动机去伪造不存在的交易来获取利益，如何识别并排除不诚实的节点？(拜占庭将军问题)</li>
<li>如果A的账户有1000元，发送了1000元给B，由于是分布式系统，部分节点收到了这笔交易，这时候A又发送了1000元给C，另一部分收到了这笔交易，这时候该如何处理？如何保证一笔钱不会被花两次？ (双重支付问题)</li>
</ul>


<p>为了解决这两个问题，比特币引入了三个核心技术：UTXO交易模型、POW工作量证明、blockchain数据结构组织。且让我们一一道来。</p>

<h2>初版交易设计</h2>

<p>如果读了之前我们的&lt;比特币HD钱包>系列文章；天然的，我们意识到非对称加密方法是在分布式账本中建立账户的天选之术；</p>

<h4>存款</h4>

<p>用户A想要建立一个账户，只要在帐目中增加一笔 <code>公钥+金额</code> 的记录就可以了。我们用一个表格表示整个账本，用户A以及用户B各存入50个币的动作可以记作:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50)</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50)</td>
</tr>
</tbody>
</table>


<p>这个原始存入的资金我们先不去纠结怎么来的，总之此时账本中有两笔交易，代表着A以及B各自有50个币</p>

<h4>验证</h4>

<p>在账目1中，如何验证A确实是这笔资金的拥有者呢？非常简单，就是账户资金增加的时候，A对这笔交易数据的摘要用私钥做一个签名，然后再把公钥附在后面就可以了，这样账目就变成了这样:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
</tbody>
</table>


<p>任何一个要验证账户A的节点或第三方，对其所有权证明用公钥解密，然后对照摘要(digest)即可。</p>

<h4>转账</h4>

<p>如果A要向B转账20个币呢，我们最简单的设计，就是构造Trans1 &ndash; 20，然后同样的方法构造签名即可，这样账本如下:</p>

<table>
<thead>
<tr>
<th>账目ID </th>
<th> 原始交易细节 </th>
<th> 所有权证明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> Trans1:存入(A公钥+50) </td>
<td> signature(digest(Trans1))+A公钥</td>
</tr>
<tr>
<td>2 </td>
<td> Trans2:存入(B公钥+50) </td>
<td> signature(digest(Trans2))+B公钥</td>
</tr>
<tr>
<td>3 </td>
<td> Trans3:Trans1-20 &ndash;> B</td>
<td> signature(digest(Trans1 &ndash; 20 &ndash;> B))+A公钥</td>
</tr>
<tr>
<td>4 </td>
<td> Trans4:存入(B公钥+20) </td>
<td> signature(digest(Trans4))+B公钥</td>
</tr>
</tbody>
</table>


<p>看起来一切还好，但是这个时候我们发现了一些缺点</p>

<ol>
<li>收到汇款的时候因为要添加所有权证明，账户拥有者得一直在线监控自己的账户地址</li>
<li>收款人还得验证汇款人的合法性，感觉都点怪；我收钱就好了，还得去管这个钱合不合法？</li>
<li>如果多重转账，或者一对多，或多对一，这个记录格式就复杂了</li>
<li>用户B要验证一笔交易合法性的时候，可能要回溯到账本非常深的位置，因为上一笔交易可能发生在很久之前，这种交易记录的存储设计很难高效查询</li>
<li>最后，这个账目设计中，所有账户的公钥是暴漏在外的；虽然椭圆曲线算法目前看来牢不可破，但是整个安全体系只依赖一个非对称加密算法，比较脆弱</li>
</ol>


<p>解决方法其实也简单，换个思路，就是A转账给B，B是不需要验证的，只要A提供账户所有权的证明就好了，想想我们平时转账，不也是这样的吗？</p>

<p>那么最简洁的设计，就是借鉴现实世界。每一笔交易都看作是硬币的流转，硬币其实没有特征，它只是从A的保险箱转移到了B的保险箱而已，那么，采用什么办法来表示：<code>这是A的保险箱中的一笔资金币</code>这个譬喻呢？</p>

<h2>进阶交易设计</h2>

<h4>UTXO 模型</h4>

<p>比特币的账本世界，构筑在UTXO (Unspent Transaction Output)之上；其实每个UTXO代表着未花费的一笔硬币(数额可大可小，没有限制)；一个账户的资金，其实就是一堆UTXO的集合；转账交易，就是一个或多个UTXO的输入再输出为另外的UTXO而已。你可以想象成现实世界中金银铸币的流通。</p>

<p>那么一个UTXO中包含什么呢？如何作为输入呢？如何构造输出呢？这就是比特币交易的核心技术。</p>

<ul>
<li>我们用下面一张图来表示<code>A保险箱里面的50个硬币</code> 这件事：</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg1.jpg" alt="img" /></p>

<p>把它想象成一个邮筒构造的保险箱，在不打开的前提下，投币是只进不出的。可以注意到，我们并没有直接将Public Key明晃晃暴露在外面，而是先HASH一下，然后贴到保险箱子上面，想要存币的人，只要知道这个HASH值，作为保险箱的ID，就可以直接投币进去啦。</p>

<p>但是保险箱的锁在哪里呢？</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg2.jpg" alt="img" /></p>

<ul>
<li>这张图中，我们引入了一个脚本，称之为 <code>Pubkey Script</code>；具体内容是:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>呵呵，像天书吧，不要怕；这是我们特有的保险锁构造。细节会在后面讲到。这里你可以这样简单理解：</p>

<p>为了锁住这个保险箱里的资金，比特币系统设置了一个谜题作为锁。解开这个谜题，才能转移里面的资金。</p>

<p>这个谜题是这样构造的:</p>

<ol>
<li>记录了A的公开的<code>Public key hash</code>值，开锁的人，需要提供A的<code>full public key</code>，同时验证 <code>hash160(public key) == Public key hash</code></li>
<li>需要提供A的私钥基于这笔交易的签名Signature, 这样系统可以用<code>full public key</code>来验证公私钥是否匹配</li>
</ol>


<p>这个过程是通过上面的脚本指令通过入栈出栈执行的，这也为比特币系统验证更复杂的交易逻辑提供了基础，甚至能作为一个简单的虚拟机执行更复杂的组合指令。</p>

<p>整个过程组织如下图：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg3.jpg" alt="img" /></p>

<p>当我提供一个signature以及full public key的时候，就可以开锁了，开锁下一步自然就是转移资金啦。我们给B汇款50个币，而B的保险箱又是怎么表示的呢？和A保险箱是一样的。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181123/bg4.jpg" alt="img" /></p>

<ul>
<li><p>带有<code>public key hash</code> ID的保险箱是一个UTXO，这个保险箱用<code>public key hash</code>上锁，而提供<code>signature</code>和<code>full public key</code>开锁，转移资金的过程，就是花费UTXO的过程，其实就是把A的UTXO转移到B的UTXO的过程，这就是比特币最简单的一笔交易</p></li>
<li><p>我们可以继续拓展下去，可以1对多支付，多对1支付，多对多支付，更复杂的多签名支付，延迟支付等等，今后我们会详细介绍</p></li>
</ul>


<p>这个系统有如下优点:</p>

<ol>
<li>所有的交易都抽象为了UTXO的转移，你可以想象一下，一堆硬币在几个保险箱之间转移的样子</li>
<li>用户其实可以不检查交易的合法性，只要运行分布式账本的所有节点检查通过合法后，确保写入账本就保证资金的安全转移了</li>
<li>每个账户的拥有者在真正花费UTXO之前，是不用暴露公钥的</li>
<li>验证UTXO交易合法行的函数，抽象为几个指令的集合，这个验证行为指令通用化，为智能合约编写创造了条件</li>
<li>这样的交易记录非常容易组织，我们以后可以看到；把这些交易批量打包，组织成名为blockchain的精巧数据结构，有许多优点</li>
<li>一个用户A可以用一个私钥加密多个保险箱，或者多个私钥加密多个保险箱，非常灵活</li>
</ol>


<h2>小结</h2>

<p>好啦，看到这里，我们对比特币的最简单的交易构造已经有感性认识了。但是俗话说得好: <code>光说不练假把式</code>，下篇文章我们就会手工构造一笔完整的交易，让你搞明白其中细节。</p>

<p>另外，我们前面提出了好几个问题:</p>

<ul>
<li>原始资金从何处来？</li>
<li>节点如何解决拜占庭将军问题？</li>
<li>节点如何解决双重支付问题？</li>
</ul>


<p>后面我们会一一解答，那么，下次再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币、支付、清算漫谈]]></title>
    <link href="https://happy123.me/blog/2018/11/19/huo-bi-%2C-zhi-fu-%2C-qing-suan-man-tan/"/>
    <updated>2018-11-19T16:55:29+08:00</updated>
    <id>https://happy123.me/blog/2018/11/19/huo-bi-,-zhi-fu-,-qing-suan-man-tan</id>
    <content type="html"><![CDATA[<p>又看了一遍 <a href="https://book.douban.com/subject/26802686/">The book of Satoshi</a> 这本书，果然常读常新啊；又有很多想法冒出来，结合最近的BCH分叉事件，我不禁又开始思考金融系统的两大环节：清算和支付，究竟会如何发展？</p>

<p>我从事银行业务系统监控很长时间，结合咱的职业生涯所学，再重新梳理一遍支付和清算的发展史吧。</p>

<!-- more -->


<p>除了支付和清算，还有一个拓展概念，即结算。看一下权威机构的定义:</p>

<p>按照国际清算银行支付结算委员会的定义，所有涉及到资金转移的行为，都可视作支付行为，支付的概念最大，清算和结算属于支付过程中的特定环节，其中，清算是发生在结算前的支付环节，该环节的功能主要是为了提高结算的标准化水平和结算的效率。</p>

<ul>
<li><p>支付：完成付款人向收款人转移可以接受的货币债权的过程，包括交易过程、清算过程和结算过程等三个过程。</p></li>
<li><p>清算：包含了在收付款人金融机构之间交换支付工具以及计算金融机构之间待结算的债权，支付工具的交换也包括交易撮合、交易清分、数据收集等。</p></li>
<li><p>结算：该过程是完成债权最终转移的过程，包括收集待结算的债权并进行完整性检验、保证结算资金具有可用性、结清金融机构之间的债券债务以及记录和通知各方。</p></li>
</ul>


<h2>史前阶段</h2>

<p>支付清算的历史其实要比货币历史久远的多，但货币的演变是支付清算体系发展的原动力。</p>

<p>在货币产生前，物物交换其实就是一种支付行为，比如原始人甲有桃子，但喜欢苹果，而此时刚好碰到原始人乙，乙有苹果，但喜欢桃子，这样两个人就刚好满足双方的需求，甲向乙支付桃子，得到苹果，乙向甲支付苹果，得到桃子。这就是最原始的“支付”。随着持有香蕉的原始人丙也加入上述交易，那么必须形成需求的闭环，而且随着交易的物品数量、种类逐渐增多，就需要再找一个不参与交易的原始人丁专门做交易的分类、计数和记录，并且甲乙丙在丁面前都作出承诺：一是手里的桃子、苹果、香蕉都是真实存在的。二是交易的意愿都是真实的，不会拿了人家的东西却不给出自己的东西。那么丁做的事情就是最原始的“清算”。之后，桃子、苹果、香蕉交割到了新的主人手中，此时丁宣布交易成功结束，甲乙丙三方各不相欠&mdash;最原始的“结算”。</p>

<p>此时丁付出信用，承担了清算的网关。当然，这种清算是非常粗糙的，作为一个支付行为的环节不明显。</p>

<p>后来随着商品交换规模的扩大，统一的支付媒介就出现了。从最原始的贝壳，到铁铜铸币，再到金银物品，形成了人们统一承认的货币媒介。实物货币如金银货币的出现极大地提升了商品交易的成功率，形成了以货币为核心和交易媒介的支付清算体系雏形，极大地推动了贸易和经济社会发展。</p>

<p>此时的清算其实和支付行为频率差不多的，因为当时的贸易市场并不繁荣，货币媒介还很粗笨，可以说每一笔支付就伴随着一笔清算，清算如此重要，以至于此时的货币市场上最重要的并不是货币本身，而是记账的权力，最经典的例子就是我们前面文章中提到的雅浦岛的石币故事。</p>

<h2>纸币阶段</h2>

<p>但随着商品交易规模和范围的不断扩大，金银货币越来越不能更好地满足贸易经济大规模发展的需要，人们就开始尝试以收兑金银之后的收据代替金银实物进行流通，随着这种收据广为人们接受，纸币就此诞生了&mdash;这是货币发展史上的一个重要突破。当然，纸币是要与其背后的金银货币的成色、数量挂钩的，也就是金银本位制，而且发行纸币的单位是多样的，可以是国家，也可以是有实力有信誉的金银铸造商等等。这时的纸币仅仅只是一种“表征货币”。纸币的出现极大地提升了支付的便利性，但由于纸币的伪造难度和成本比金银货币低太多，如何避免收到假冒伪劣的纸币甚至防止纸币超发成为突出的难题。自此，支付的便利性与安全性因为支付工具（如纸币）从交易媒介（如金银货币）分离独立而始终成为一对矛盾。</p>

<p>纸币阶段其实和金银实体是并存的，这个时候的清算行为其实更好分辨；拿我们熟悉的晋商作为例子：</p>

<blockquote><p>早在清道光（1823年）年间，山西平遥商人就创立了“日升昌”等专门办理汇款业务的票号（古代的票号、钱庄就是现代银行的雏形）。
著名的红顶商人胡雪岩就是做票号生意起家的。
当时的票号支持异地汇款业务：客户来日升昌汇款，交了银子之后，票号就开出汇票给客户。
跟银行一样，票号也有总号和分号，客户可以携带汇票或者把票寄给亲人，只要凭票就可以到日升昌全国各地的分号兑出银子，分号给客户兑换之后先记内部账，日后再和总号清算债务。
从此之后，商人在城市之间贸易可以不用携带大量的银子。而汇票在不同城市的各个分号之间流转也形成了很多债务，有大量的银子需要周转，镖局就专为票号来运送银子以及为商人运送票据，有点类似于现在为银行押钞的威豹，不过镖局的手续费可是高达5%！</p></blockquote>

<p>整个过程中，每个月或年底各个分号之间周转银子，轧平账目的过程就是清算。虽然清算是整个支付环节的一部分，但是清算的频率比较低，平均下来多笔支付可能才发生一笔清算，所以此时表面上看货币是非常活跃的，清算作为一种记账行为默默引申到了后台。</p>

<h2>信用阶段</h2>

<p>牛顿爵士开创了金本位，其实在整个货币史上不过短短一段时间，然后我们现在就飞速的跳跃到了信用货币阶段，信用货币发展的技术基础，就是越来越完善普及的电子设备。可以想象，将来即使在非洲，持有一个智能电子钱包(不一定是手机)的成本也会小于持有纸币的成本，所以货币电子化的趋势不可逆转。</p>

<p>铸币信用化，表现形式电子化之后，最明显的一个改变，就是<code>清算</code>这个行为，夹杂在整个支付过程中越来越频繁了；</p>

<ul>
<li>原来钱庄分号之间轧账，周期可能半年一年记</li>
<li>金银铸币时代，两国之间的轧账，也可能持续几周</li>
<li>纸币化之后，可能国际汇兑、债券市场之间的清算，通过电报以及联行信件，就缩短到几天了</li>
<li>到了今天，跨行汇款，已经缩短到分钟级别了；移动支付，都可以到秒级了</li>
</ul>


<p>此时清算的次数又大致跟支付行为一个量级了，记账的技术又开始一轮飞跃；</p>

<p>放到我国来，伴随着改革开放，我们的金融市场30年走完了欧美100年的历史，其中支付清算系统的发展就是经典的代表，这段历史我比较熟悉，下面就我国的支付清算系统建设流水账一番;</p>

<h3>全国手工联行系统 (1949-1990)</h3>

<p>建国初期的银行是比较LOW的，那个时候的银行是沿袭历史发展过来的。因此银行之间的资金往来(通存通兑)，其实跟晋商时代的票号差不多，每个银行都和其它大行之间签订协议，开设备付金账户，实现互兑。</p>

<p>比如三家银行： 工行、建行、招行，他们每家银行都要在另外两家银行开设账户，存入准备金，不同银行间的业务往来像票号一样定期轧账。</p>

<p>此时，每家银行都是一个清算机构，为银行间的资金往来做清算。</p>

<p>这种清算方式无疑是低效的，每成立一家银行，要开启业务，都得一家家的在同行那里开设账户，费时费力。所幸那个时候的银行少，而且计划经济金融业务少，这么多年就凑合过来了。</p>

<p>一直到1984年中国人民银行专门行使中央银行职能之后，我们国家确立了法定存款准备金制度。央行的备付金系统正式确立。此时，银行跨行的资金清算有两种选择：</p>

<ul>
<li>用老办法，在所有有往来的银行开立清算账户清算</li>
<li>所有金融机构都在央行开立清算账户，由央行为商业银行统一清算</li>
</ul>


<p>显然大家都想用第二个方案。然而在那个时代，央行能承担的职责是很有限的，各银行内部数据还没有集中，没有电子化的记账系统，国内甚至都还没有银行卡，客户要转账也没有满大街的ATM。总之一句话，国内的金融环境还没有达到让央行推行全国统一结算制度的客观条件。</p>

<p>为了满足跨行结算的需求，央行当时提出商业银行要“自成联行系统，跨行直接通汇，相互发报移卡，及时清算资金”。也就是说同一家银行的总行及分支机构称为“联行系统”。同一联行内的资金结算，由联行总行自己做。这样，建行深圳分行和建行北京分行之间的资金清算由建行自己内部解决。跨银行之间要能支持直接汇款。跨行业务可以由央行清算，也可以由商业银行自己清算。</p>

<p>这是个各家银行系统很不智能，体验很差的时期，我们称为“全国手工联行”时期。于是，每家银行都可以接受跨行的汇款，银行每天自行轧差，各种交易汇总计算后，需要告知其他行的交易信息写成一张张特定的公文，加盖印鉴后在银行间送来送去。这种公文叫做联行信件，而收发联行信件就是当时邮电局的重要业务。</p>

<h3>全国电子联行系统EIS (1989-2005)</h3>

<p>随着银行业的不断发展，银行每天处理各类跨行业务的数量增多，各家银行之间的债权债务关系变得非常复杂，由各家银行自行轧差进行清算变得非常困难。这种状况要求央行必须承担起一个全国清算中心的角色。于是，央行在1989年12月6日，发布了“关于改革联行清算制度的通知”。</p>

<p>随后在1990年，中国人民银行清算中心建成，专门为金融机构提供支付清算服务。这个清算中心包括NPC和CCPC：</p>

<ul>
<li>NPC（National Process Center，国家金融清算总中心）</li>
<li>CCPC（City Clearing Processing Center，城市处理中心）</li>
</ul>


<p>1991年4月1日，基于金融卫星通讯网的应用系统——全国电子联行系统（EIS）开始试运行。EIS是人民银行专门用于处理异地（包括跨行和行内）资金清算和资金划拨的系统。它连接了商业银行、央行、NPC和CCPC。</p>

<p>假设客户在深圳建行汇款给北京工行，通过EIS处理一次跨行汇款的流程如下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg1.png" alt="img" /></p>

<p>可以看到，清算中心在各地建立了一个个分站，分站和总中心通过卫星网络互联，总站和分站共同构成了清算网络，为其它接入EIS的各家商业银行提供清算服务。</p>

<p>从此之后，各个银行之间的跨行汇款，以及同一银行的异地分行，就可以直接通过这样的电子化操作来完成了，客户的资金在途时间缩短到了一两天，这也算是中国金融系统的一大里程碑了。</p>

<p>PS: 直到2015年，我都在一些银行的老系统中见过EIS，这个东东真的很经典，生命力很顽强啊。</p>

<h3>现代支付系统CNAPS (1991-现在)</h3>

<p>1991年EIS试运行后，又发生了两件大事：</p>

<ul>
<li><p>各大银行核心系统投产，各家商业银行的内部联网系统纷纷建成投产</p>

<p>  银行内部资金划转都可以通过自己的核心系统解决了。这意味着各大行都可以做电子化的行内清算了，行内异地转账就不用再依赖EIS。笔者跑过许多银行，见识了许多核心系统的投产，几乎所有的核心系统设计都是一个套路，将来有时间可以再有一篇文章细说一下。</p></li>
<li><p>中国现代化支付系统（CNAPS）开始设计</p>

<p>  1991年10月，中国开始着手建设中国国家金融通信网（CNFN）和中国现代化支付系统（CNAPS，China National Automatic Payment System）。从此，全国电子联行（EIS）系统逐步向CNAPS过渡。到了二十一世纪，IT技术飞速发展，央行的CNAPS一代系统（大小额支付系统）也开始走上历史舞台。中国的支付清算步入了现代化支付系统CNAPS的时代。</p></li>
</ul>


<p>CNAPS值得我们大说特说，今天银行的主力业务都跑在它的基础上，它的发展历史上有几件大事:</p>

<ol>
<li>2002年，央行大额实时支付系统（HVPS）投产，用于处理同城和异地的商业银行跨行之间（也包括行内一定金额以上的）大额贷记业务。</li>
<li>2005年，央行小额批量支付系统（BEPS）投产，用来处理同城和异地纸凭证截留的借记支付业务以及每笔金额在5万以下的小额贷记支付业务。</li>
</ol>


<p>这两个业务统称为大小额系统，我们平时的跨行转账，走的就是这两个系统，他们之间有如下区别:</p>

<ul>
<li>首先，大小额的开放时间不同</li>
</ul>


<p>大额系统是工作日的 8:30 ~ 17:00，所以在节假日经常会收到银行通知说某些业务暂停了经常就是因为央行在节假日对大额系统做维护。小额系统全年无休，7*24小时工作。</p>

<ul>
<li>业务处理上不同</li>
</ul>


<p>大额是每笔交易都实时发送，实时清算的，所以基本上能实时到账，跨行资金零在途。小额系统是在收集若干笔交易后打一个包统一处理，定时清算。所以，用小额系统转账经常要几分钟甚至半个小时才能到账，银行间头寸交割也是非实时的。尽管理论上跨行转账业务不管用大额还是小额，一般在几分钟内都能到账，但是因为要经过央行，所以在这一时期基本没有银行敢向客户承诺资金多久能到账。比如我们早期银行卡转账，一半会发现一个<code>两小时内到账</code>的提醒，这就说明他走的是小额支付系统。</p>

<ul>
<li>金额不同</li>
</ul>


<p>大额系统没有金额限制，小额系统支持的单笔金额上限是5万元。从用途上讲，大额系统侧重于资金转移的时效性，主要用于资本市场、货币市场交易和大额贸易资金结算。小额系统对数据吞吐量要求较高，主要用于小额贸易支付和个人消费服务。</p>

<p>下面一张图就说明了CNAPS大小额的业务实现:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg3.png" alt="img" /></p>

<p>目前大部分手机网银跨行转账都没有手续费。所以如果你在晚上10点想跨行转账10万元，此时大额转账系统已经关闭了，建议你分成两个5万并且用加急方式来转账。</p>

<p>不管怎么说，现在我们的跨行汇款速度总算提高到小时级别了。</p>

<p>PS: 大小额支付的协议细节非常复杂，协议规范有上千页文档，是我去现场部署监控系统时永远的痛啊~~~</p>

<h3>第二代现代支付系统CNAPS2 (2013-现在)</h3>

<p>大小额系统已经很好用了，但是随着金融市场发展，业务需求是无穷无尽的；2013年10月6日，央行的第二代支付系统(CNAPS2)正式投产运行，其中包括2010年就推出的网上支付跨行清算系统（俗称“超级网银”）。超级网银是对大小额支付系统的一个补充，有两大亮点：</p>

<ul>
<li><p>接入机构不再限于银行</p>

<p>  支付宝、财付通等第三方支付也可以接入，所以有的第三方支付给商户提供的提现代发功能就是基于超级网银做的。</p></li>
<li><p>7*24小时实时到账，单笔上限5万元</p>

<p>  这就相当于在非工作日非营业时间增加了一种大额支付系统特性的渠道了。只不过金额限制是跟小额系统一致的。</p></li>
</ul>


<p>最后来一张总体架构图:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181120/bg2.jpg" alt="img" /></p>

<p>PS: 现场协议监控部署，<code>人行二代支付</code>是我听了上万遍的词汇啊，睡觉都无法摆脱~~~</p>

<h3>三方支付渠道</h3>

<p>人行的CNAPS2为不同银行间提供了清算服务，银行内部的核心系统为自己不同的分行间提供了清算服务。这两块已经覆盖了大多数的银行业务场景，包括:</p>

<ul>
<li>银行柜台&mdash;直接大小额转账</li>
<li>手机网银&mdash;大小额转账+超级网银</li>
</ul>


<p>但是还有一部分商业市场没有涉及到，就是我们常说的三方支付。我把它又分为两个场景:</p>

<ol>
<li>ATM 刷卡取款和POS机刷卡</li>
<li>网银支付</li>
</ol>


<p>在支付宝普及之前，POS机刷卡以及ATM取款都是我们日常生活中比较常见的资金流转渠道。相信大家都有不少储蓄卡及信用卡有着<code>银联</code>标识。这个银联又是何方神圣？</p>

<p>银联全称<code>中国银联银行卡跨行支付系统</code>，英文缩写为CUPS；我们说支付市场是很大而且油水很足的，人行作为银行的妈，建设清算系统主要是政治考量，而商业银行进军支付领域是要挣钱，所以2002年3月26日，经中国人民银行批准,各大发卡行的商业银行参股，成立了银联。</p>

<p>银联的目的就是提供人行二代支付之外的资金清算渠道，在支付场景捞油水。我们看一下ATM刷卡和POS机业务中，银联发挥的作用。</p>

<h4>POS机刷卡</h4>

<p>POS机刷卡的参与方比较多。以你在星巴克刷卡为例：</p>

<ul>
<li>持卡人——你</li>
<li>发卡行——你办这张卡的银行，我们假设是工行</li>
<li>商户——星巴克，我们假设星巴克的账户开在建行</li>
<li>收单行——星巴克的刷卡机的归属银行，假设也是建行</li>
<li>转接机构——银联</li>
<li>清算机构——银联和人行</li>
</ul>


<p>于是，当你用工行卡在星巴克消费的时候，资金流和现金流是这样发生的：</p>

<ol>
<li>你在收单行（建行）的POS机上刷卡消费</li>
<li>建行将消费报文发送给银联</li>
<li>银联交易系统记录交易数据，将消费报文给你的发卡行（工行）</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行的POS机</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
<li>银联通过小额支付系统或当地票据交换系统，完成建行和星巴克结算账户的资金划拨（收单清算）</li>
</ol>


<p>在这个过程中，银联提供两种清算：</p>

<p>1.建行和工行的清算叫“跨行清算”；
2.建行和星巴克的建行账户之间的清算叫“收单清算”；</p>

<p>无论是跨行清算还是收单清算，银联都是作为CNAPS的一个特许参与者，使用大小额支付清算系统，完成银行卡业务的资金划拨。本质上，银联提供交易转接、清分和对账，人行提供结算。</p>

<h4>ATM跨行取款</h4>

<p>你拿着一张工行卡去建行的ATM取了100元，这个跨行业务在CNAPS体系中的过程如下：</p>

<ol>
<li>你在建行ATM上输入100元按下取款按钮</li>
<li>建行将报文信息发送给银联</li>
<li>银联交易系统记录交易数据，将报文给你的发卡行(工行)</li>
<li>工行从你的卡中实时扣费，完成实时结算，并回复报文给银联</li>
<li>银联更新交易数据，回复报文给建行ATM</li>
<li>银联在其清算系统完成清分</li>
<li>银联通过大额支付系统，完成工行与建行清算账户的资金划拨（跨行清算）</li>
</ol>


<p>我们看到，ATM和POS渠道，是由银联的CUPS来对接各大商业银行做支付转接，解决信息流问题；银联同时提供清分和对账服务，对完账之后再调用央行大小额系统解决资金流问题；</p>

<p>当央行系统升级的时候，通过银行柜台和手机银行是不能做跨行转账的，但是通过ATM和POS却可以跨行取款和跨行支付，这是因为银联暂且处理了清分和对账，等到央行系统升级完毕后，他们才进行清算；</p>

<p>所以一般央行挑放假的日子升级系统，这个时候一般没有对公业务，但是我们平常的刷卡消费可以正常进行。</p>

<p>另外，我们说，资金跨行清算的发展中，出现了一位豪杰，就是三方支付的大佬：支付宝</p>

<h4>支付宝等势力的发展</h4>

<p>支付宝早期为了服务淘宝客户和商家，不可避免的要跟银联抢生意，对接各大银行的支付接口。</p>

<p>银联作为既得利益者，绝不会开放接口给支付宝的。所以当时支付宝拿到支付牌照之后，苦逼的一家一家跟跟银行洽谈对接，值得注意的是，支付宝对接的各机构间跨行转账，没有走人行的大小额系统，而是走的支付宝内部资金池。</p>

<p>支付宝积硅步以至千里，慢慢的接入的银行多了，服务竟然能叫板银联了。</p>

<p>印象特别深刻的是，有一年国庆节人行系统升级，当时的小额转账竟然有大多数交易走的支付宝渠道，这时候支付宝已经有能力作为第三大清算网关服务大众了;</p>

<p>另外举一个有趣的例子，因为支付宝早期转账有免费的短信留言服务，所以有人用每笔1分钱的转账服务聊天！而发条短信都1毛钱呢，这跟如今的bitmessage、memocash记录信息何其相似。</p>

<p>我后来工作走了不少地方性的小银行，因为供应商不一样，他们每家的对接方案都不同，支付宝竟然有耐心一家一家的啃下来了，不得不佩服他们下的苦功夫。</p>

<p>当然，后来微信支付也异军突起，三方支付平台各路神仙纷纷跳出来分蛋糕，银联节节败退之后，祭出杀手锏；找央妈诉苦。于是为了平衡各方利益，一纸文件下来，决定建立网联平台，大家之前的自留地接入废除，各方统一接入网联，利益均沾。支付宝之前的平台建设就完成历史使命了。</p>

<p>网联平台的建设由于有阿里和腾讯的研发力量加入，开发异常顺利。2017年开始逐步上线，2018年双十一，就在前几天，官方号称TPS超过了9万笔。实在了得。不得不承认，我国的交易金融系统处理能力在世界上已经是单独一档了。</p>

<h4>小结</h4>

<p>上面长篇大论了我国支付清算系统的建设和发展，无非说明几个问题:</p>

<ol>
<li>金融越发达，支付行为越多，清算所占的比例也水涨船高</li>
<li>清算的速度越来越快，处理效率越来越高</li>
<li>虽然清算接入的机构越来越多，但是清算网关呈现大一统的趋势</li>
<li>清算的交易笔数指数级增长，中国支付清算协会发布《中国支付清算行业运行报告（2018）》称，2017年，国内商业银行共处理移动支付业务375多亿笔，非银行支付机构共处理移动支付业务2390多亿笔，这之中大部分都包含有清算行为</li>
</ol>


<h2>区块链时代</h2>

<p>我认为区块链技术诞生后，清算技术又是一个进化。但是这个进化过程初期表现十分笨拙，以至于看起来像是退化。</p>

<p>在比特币诞生之前，Ripple网络其实已经在传统清算网关的基础上，基于中心化的共识，提出了新的清算网关方案。他们的技术其实很有意思，也非常创新。我们打算放到其它篇章来介绍。目前我们单独谈谈比特币的技术方案。</p>

<h4>容量</h4>

<p>首先比特币由于是去中心化的网络，处理能力是非常低的；即使引入了Segwit附带一点扩容效果，目前也不过是3~4 TPS，和中心化的清算网关相比，简直可怜。</p>

<p>但是比特币系统的特殊之处就在于，他没有集中的账户管理节点，这意味着网络中的每个全节点都承担清算网关的职能，每一笔支付必然带有一笔清算，清算率100%。</p>

<p>这实在是像极了早期雅浦岛上的石头货币系统，我们一再强调这个寓言故事，因为它和比特币如此相像；比特币系统简直是雅浦岛的石币系统的电子版！连处理能力也是如此相似的性能低下！</p>

<p>值得庆幸的是，雅浦岛上的居民限于物理条件，系统性能提升有极限；而现代的电子设备性能提升，横向扩展的话，几乎是无穷尽的。</p>

<p>当前比特币的扩容方案主要是两大流派，经济利益夹杂着技术讨论，是是非非就不评说了，我们撇开矿霸、专利、以及阴谋论，只是整理一下他们目前的发展状况</p>

<h5>闪电网络链下扩容</h5>

<p>主要路线是Segwit 解决交易延展性问题，然后在此基础上实现二层闪电网络。目前来看，Segwit已经占了主网交易的半壁江山，估计最终能扩容到4-8 TPS，这当然不够用。所以二层网络的闪电网络至关重要。</p>

<p>闪电网络目前还是处于试验阶段，虽然推出了一些应用，但总体还是和比特币早期发展一样，只是部分Geek在使用。</p>

<p>优点:</p>

<ol>
<li>中转节点越多，处理能力越强</li>
<li>如果两个节点间能形成比较短的支付路径，理论上它的处理能力会很惊人的，至少是比现在几个数量级的提升</li>
<li>微支付通道里面的交易记录不上主网，这样跑全节点的开销只会线性增长，有利于比特币的去中心化</li>
</ol>


<p>缺点:</p>

<ol>
<li>收款需要保持在线</li>
<li>形成微支付通道需要双方缴纳保证金</li>
<li>建立和销毁微支付通道都需要主网广播，如果支付笔数少，建立通道的得不偿失；因为这个原因，目前来看闪电网络的实际应用不多</li>
<li>闪电网络的中转节点需要大量的保证金，会天然的会向大公司、集权化发展，这也是区块扩容党最诟病的一点</li>
</ol>


<h5>大区快链上扩容</h5>

<p>优点:</p>

<ol>
<li>代码简单，即刻扩容</li>
<li>技术方面来讲，扩容到32M-128M其实开销也不大；根据硬件设备的发展，长远来看，1GB的大区快可能也行得通</li>
<li>有人认为Segwit引入了复杂度，原本的交易格式更改了，技术上有洁癖的人接受不了，大区快扩容没有技术债</li>
</ol>


<p>缺点：</p>

<ol>
<li>有人认为今天32MB，明天更多，扩容起来无穷无尽，早晚只有矿场才会运行全节点，这样去中心化吃枣药丸</li>
<li>交易延展性问题早晚得解决，目前来看Segwit解决方案还是比较成功的，扩容党只是嘴硬，早晚得上</li>
<li>扩容再多，性能也比上闪电网络</li>
</ol>


<h4>总结</h4>

<p>近日BCH社区又经历了一场硬分叉斗争，有利益相争的地方就有恩怨，有恩怨就有江湖；很有可能大家搞来搞去，Bitcoin就搞死了，很正常。</p>

<p>其实看到最后，最核心的分歧其实就是Bitcoin 主网是否每个节点该继续承担清算的工作，这其实和现实中的货币发展十分相似：</p>

<ol>
<li>市场初期不是那么繁荣，即使交易一次清算一次，货币的物理特性也能顶住，这和bitcoin初期很相似，每个全节点都是清算网关，每笔交易都有一笔清算，安安稳稳跑了十年</li>
<li>市场爆发，原有的清算体系扛不住了，这个时候需要升级技术方案解决；有分歧了，需要把全部交易都上主网吗？买杯咖啡需要记录到主链上吗？毕竟今天区块链还是非常金贵的资源，这个系统每天消耗的电力资金数以亿计了，在上面画画写诗实在是有点浪费；从历史来看，引入闪电网络，小笔交易不再并入主网，变成两个特殊清算节点之间的轧账比较合适</li>
<li>分歧就在这里，有人觉得硬件性能增长完全可以让主网记录人类所有的交易；有人说扯犊子，买咖啡不应该上主网</li>
</ol>


<p>目前的情况来看：</p>

<ol>
<li>闪电网络还是处于实验阶段，有力使不上，主网一直满负荷</li>
<li>扩容派各种斗争，要上位还很远</li>
</ol>


<p>看不清未来方向；其实历史是波浪式前进的，如果顶层设计，我可能倾向于:</p>

<p>先区块扩容一点(提高清算能力)&ndash;>Segwit+闪电网络(集中清算)&ndash;>硬件性能跟上了，继续扩容(再分布式清算)</p>

<p>但是现实斗争就是这么残酷哦，技术最优不代表市场最优，技术市场最优不代表拳头最大~~~所以说历史发展是随机的；像基督教分为犹太教、新教、天主教等等，佛教搞成藏传、南派北派等等，人类就是折腾中前进，比特币出来以后，一度把清算技术搞成了教派斗争，这挺有意思的</p>

<h4>更丰富的商业场景</h4>

<p>不管怎么说，我对于技术的前进还是乐观的，不管是传统的清算中心，还是区块链，如果将来我们的清算能力再有一个指数级飞升，我觉得又会有新的商业模式出现</p>

<ul>
<li>现在的保险行业，比如车险，保险的时段只能一整块时段，同样买了一辆车，有的几个司机合伙24*365天天在外跑，有的上下班每周就几个小时的使用时间，交一样的钱其实不公平；未来可能只有你的引擎发动之后，真正在路上跑了，按照分钟收费，你的钱要一点一点打到保险公司账户上，这样比较合理</li>
<li>娱乐消费行业，目前也是整段时间收费，未来你听一首歌，可能按照 0.0000001元/秒的速度慢慢付款给音乐公司</li>
<li>公益行业: 真正的贫困人口可以开设经过认证的账号，这样土豪捐款的时候可以绕过红十字会，平均账户发放救济金之类，而且可以有各种算法监控，比如每个月固定发个100元，这个账户之后走的是哪个清算单元，进行了什么消费，杜绝骗子的不正当用途</li>
<li>资金审计: 将来的所有公益和对公账户，审计不再是一个问题了，因为你可以追踪所有的清算单元，用智能算法来判断资金最终的流向和目的，财务造假的难度大大增加</li>
</ul>


<h4>引用：</h4>

<p><a href="http://www.gongxiangcj.com/posts/1478">http://www.gongxiangcj.com/posts/1478</a></p>

<p><a href="https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf">https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/about-deloitte/dttp/deloitte-cn-dttp-v2ch1-zh-150127.pdf</a></p>

<p><a href="https://www.zhihu.com/question/22148261">https://www.zhihu.com/question/22148261</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BCH分叉承担的风险--51%攻击者概率问题]]></title>
    <link href="https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti/"/>
    <updated>2018-11-17T18:42:09+08:00</updated>
    <id>https://happy123.me/blog/2018/11/17/bchfen-cha-cheng-dan-de-feng-xian-51-percent-gong-ji-zhe-gai-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>2018-11-16 01:40(UTC+8)发生的BCH分叉实在好看，转载一下进程说明:</p>

<!-- more -->


<blockquote><p>  “分叉前夕：
  BCH硬分叉过程中：第一个区块由澳本聪阵营svpool爆出，区块大小为51.385KB，区块高度为556761。BCH硬分叉连续爆出6个区块才会正式开始分叉。</p>

<p>  BCH硬分叉过程中：第二个区块由澳本聪阵营coingeek爆出，区块大小为8.24kB，区块高度为556762。</p>

<p>  BCH硬分叉过程中：第三个区块由澳本聪阵营SVPool爆出，区块大小为29.44kB，区块高度为556763。</p>

<p>  在BCH硬分叉过程中，ABC阵营开始反击，比特大陆旗下第一大矿池BTC.com已经获得部分客户同意，切换算力支援BCH ABC。ABC阵营Bitcoin.com矿池的BCH算力在分叉前24小时大增1593.09%，超过澳本聪阵营的Coingeek矿池，排名第一。</p>

<p>  BCH硬分叉过程中：第四个区块由吴忌寒阵营Bitcoin.com挖出。区块大小为57.11 kB，区块高度为556764。</p>

<p>  BCH硬分叉过程中：第五个区块由吴忌寒阵营ViaBTC爆出，区块大小为315.40 kB，区块高度为556765。</p>

<p>  BCH硬分叉过程中：第六个区块由澳本聪阵营SVPool爆出，区块大小为2597.76 kB，区块高度为556766。</p>

<p>  区块高度556766：正式分叉。算力大战正式开始。随后比特大陆阵营率先出两个块，并保持持续领先。”</p></blockquote>

<p>Bitcoin.com矿池临时集了4000P的算力，巅峰时Bitcoin ABC的算力达到了8500P，而Bitcoin SV始终没有超过5000P。分叉当晚，实力差距明显。</p>

<p><a href="https://cash.coin.dance/blocks/hashrate">https://cash.coin.dance/blocks/hashrate</a></p>

<p>但是Bitcoin SV目前没有放弃的意思，而且Bitcoin.com抽调的算力会慢慢撤回去，因为SV链没有重放保护，如果一直烧钱维护下去，现在还不能称胜负已分。</p>

<p>Bitcoin SV作为进攻方，按照现在1T算力0.1元/小时的价格计算，每天SV要烧掉$200W 维持这场战争。而且目前在BCH链上挖矿收益绝对小于BTC链，如此烧钱确实是土豪行径。如果CSW始终不加重放保护跟Bitcoin ABC死磕，确实是下决心了。但是如果怂了开始炒作Bitcoin SV，那就说明他也不过是个出来割韭菜的。</p>

<p>但是群众其实也不关心鹿死谁手，反正分叉明朗之前不动就可以了。看戏之余，不妨回顾一下中本聪白皮书中关于51%攻击的计算:</p>

<p>(参考第十一章:计算)</p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p>这个计算过程还是很有意思的，我们天天听各种媒体讲<code>51%攻击</code>，那么现实世界中，现在确实发生了两方争霸的情况，我们定义几个变量:</p>

<ul>
<li>P = 诚实节点制造下一个节点的概率</li>
<li>Q = 攻击者制造下一个节点的概率</li>
<li>Qz = 攻击者追上诚实节点z个区块的差距</li>
</ul>


<p>目前(2018-11-17 17:00 UTC+8)Bitcoin SV链算力4278PH，Bitcoin ABC链算力5677PH，Bitcoin SV落后7个Block。Bitcoin ABC为防守方，Bitcoin SV为进攻方，假如Bitcoin SV就这么死磕到底的话，算力保持不变的情况下，有多大机率能51%攻击呢？如果要提高攻击成功的概率，Bitcoin SV又需要多大的算力呢？</p>

<p>我们又要复习一下概率论里面的ABC了，搬来小方凳，数学课开始~~~~</p>

<h2>酒鬼漫步问题</h2>

<p>当一个喝大了的酒鬼在路上摇摇晃晃时，你是否会担心他还有能力避开一切障碍，成功找到家门而不是掉到某个下水沟里吗？</p>

<p>实际上，这正是非常有趣的酒鬼漫步问题，不妨让这个酒鬼的处境更夸张一些，设想他站在悬崖边，面前就是万丈深渊。如果他往后退一步远离悬崖的概率是 2/3 , 向前一步靠近悬崖的概率则是 1/3。那他摔下悬崖的概率是多少?</p>

<p>答案肯定不会是简单的 1/3。那不如先来看看酒鬼最初的几步会发生什么。下图是对这个酒鬼最初几步所有可能的轨迹的枚举。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg1.png" alt="img" /></p>

<p>从图中可以看到，达到<code>0</code> 即意味着跌落悬崖。所以在 <code>0</code> 的那些概率的和便是酒鬼前六步掉下悬崖的概率。这个图可以无限推演下去。</p>

<p>所以让我们把这个场景放到数轴上，换一种方式来看。如此一来醉鬼悬崖边漫步就相当于质点沿轴心运动这类问题了。酒鬼在这个数轴上随意地左右走动， 走到 x = 0 的位置意味着被吸收 ，也就是摔下了悬崖。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg2.png" alt="img" /></p>

<p>假设他向右一步的概率为 <code>p</code>，向左的概率为 <code>1－p</code>。当他在 <code>x = n（n&gt;0）</code> 的位置的时候，不是向右就是向左。记 <code>P（n）</code>为从 <code>x = n</code> 的位置出发，最后到达 <code>x = 0</code> 被吸收的概率。酒鬼一开始在 <code>x = 1</code> 的位置，我们要求的就是他到 0 的概率。</p>

<p>当酒鬼走完第一步后，他要么到了 <code>x = 0</code>（此事件发生的概率是 1－p），要么到了 <code>x = 2</code> 的位置（此事件发生的概率是 p），他再从 <code>x = 2</code> 出发最终走到 <code>x = 0</code> 被吸收的概率就是 <code>P（2）</code>。这时我们可以得到方程1:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>P(1) = 1 - p + p * P(2)</span></code></pre></td></tr></table></div></figure>


<p>而自 <code>x =2</code> 走出并最终到达 <code>x = 0</code> 的情况可以分解为两个阶段：先从 <code>x = 2</code> 到 <code>x = 1</code>（可以走任意步）, 然后从 <code>x = 1</code>到 <code>x = 0</code>（同样可以走任意步）。我们知道后一个的概率是 P（1）,那么前一个呢？其实是一样的，也是 P（1），它可以看作后一种情况的平移。又因为这两个事件相互独立，所以得到方程2:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>P(2) = P(1)²</span></code></pre></td></tr></table></div></figure>


<p>将方程2代入方程1，得到一个简单的一元二次方程:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>P(1) = 1 - p + p* P(1)²</span></code></pre></td></tr></table></div></figure>


<p>解得  <code>P(1) = 1</code>  或者   <code>P(1) = (1-p)／p</code></p>

<p>注意到这里 p 表示的是酒鬼每次向x轴正方向前进一步的概率，也就是他站在悬崖边上向后退的概率。我们不妨根据这个概率的取值情况来对酒鬼悬崖漫步这个问题做个总结。</p>

<p>当 p 等于 0 或 1 时，这显然就成了必然事件，酒鬼一定掉下悬崖或者一定能安全地离开。</p>

<p>但有趣的是，即便当 p 不是 0，在它小于等于 &frac12; 时，这个酒鬼一样难逃失足的厄运。</p>

<p>当 <code>p = 1/2</code>时， P(1) = 1</p>

<p>众所周知，一个事件发生的概率不会超过 1。所以从上面可以看出，当 <code>p ≤  1/2</code>时，也就是这个酒鬼每步选择向后退的概率不足一半时，不管他能离开悬崖有多远，最终都必将粉身碎骨。</p>

<p>而如果 p 在 （1/2 , 1） 这个区间里，这时候酒鬼摔落悬崖的概率实际上是一个关于 p 的连续函数。我们可以做出 P(1) 的图像如下</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg3.png" alt="img" /></p>

<p>现在让我们回答最初的问题，当酒鬼向后走的概率为2/3时，他摔下悬崖的概率为 &frac12; 。 很违背直觉的结果，保持一半清醒是不够的，最少要2/3的清醒。</p>

<h2>从酒鬼漫步到赌徒破产</h2>

<p>把酒鬼徘徊应用到赌博中会得到一个不可思议的结论。假设一个赌徒的赌金是 n，每次的下注金额是 1，而每盘赌局输赢概率各是 1／2。如果一直赌下去的话，赌徒输光的概率是多少呢？</p>

<p>由前面的分析可知，他破产的概率就是前面定义的 <code>P（n）</code>。 <code>P（n）</code>是 <code>P（1）</code> 的 n 次方，而 <code>P（1）</code> 在酒鬼等概率地向两个方向迈步的时候等于 1,所以 <code>P（n）＝1</code> ！这告诉我们，即使是公平赌局，你跟赌场玩，最后也一定会输光的！</p>

<p>这就是著名的赌徒破产问题（Gambler’s ruin）。</p>

<p>显然，赌徒的钱越多，输光需要的局数也越多。当赌徒的赌金是 n 时，我们记输光的概率为 p(n)。因为每次赌局有一半的可能赢，一半的可能输，赢的时候赌金变成 <code>n + 1</code>，输的时候变成 <code>n - 1</code>，所以 <code>p(n) = (p(n + 1) + p(n - 1))／2</code>。当 <code>n = 0</code> 的时候，即使不用赌，所有东西也都输光了，所以 <code>p(0) = 1</code>。</p>

<p>由此，p 可以看作一个满足下列递推关系的数列</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>p(0) = 1
</span><span class='line'>
</span><span class='line'>p(n+1) = 2 * p(n) - p(n-1)，
</span></code></pre></td></tr></table></div></figure>


<p>也就是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>p(n+1) - p(n) = p(n) - p(n-1)</span></code></pre></td></tr></table></div></figure>


<p>容易验证 <code>p(n) = n * p(1) - (n-1)</code> 正好符合上面的递推关系。</p>

<p>又因为<code>p(n) ≥ 0</code>，所以对于任意的 n，必定有 <code>p(1) ≥ 1 - 1／n</code>。因此 <code>p(1) = 1</code>。那么对于所有的 n，则有 <code>p(n) = 1</code>。这意味着，在无限次的赌博中，赌徒在某一次赌博中输光的概率是 1。</p>

<p>这个发现其实和经典的赌徒谬误异曲同工。上帝创造这个世界的一些规则真是意味深长啊，当你要赌的时候，50%的胜率是不够的，一定要有>50%的把握!</p>

<h2>从赌徒破产到算力攻击</h2>

<p>将上面两个例子映射到区块链算力争霸的过程中，发现有惊人的相似点。</p>

<h4>情况1</h4>

<p>当两条分叉从同一起点开始竞争时，就是一个酒鬼漫步问题；攻击者一方相当于不断的要逼近诚实者一方挖出的区块高度；</p>

<ul>
<li>诚实节点：block1&mdash;&mdash;&mdash;block2&mdash;&mdash;&mdash;block3&mdash;&mdash;&mdash;block4&mdash;&mdash;&mdash;</li>
<li>攻击节点：block1&mdash;&mdash;&mdash;block2A&mdash;&mdash;-block3A&mdash;&mdash;&ndash;</li>
</ul>


<p>攻击节点从block2开始攻击，尝试双花其中的交易，并挖出区块block2A。攻击节点挖出的链要比诚实节点挖出的链长——在本例中，它至少要挖到block5——才算攻击成功。我们把诚实节点的链长度减去攻击节点的链长度，得到的差记为n。诚实节点每挖出一个块则n+1；攻击节点每挖出一个块则n-1。我们把n放到数轴上<code>n-1  ←  n  → n+1</code>；攻击节点挖出一个块，相当于酒鬼向左移一步；诚实节点挖出一个块，相当于酒鬼向右移一步。设诚实节点领先n个块，如果攻击节点的算力达到或超过了全网的50%，那么它一定能把n减到0。而如果攻击者算力小于50%，则n越大，也就是确认数越多越安全。从这里你们也可以看出来，我们通常所说的51%攻击，是一个没看懂白皮书的人定下的名词。其实应该定名为50%攻击，攻击者不需要大于50%的算力就能成功。</p>

<p>在BCH的分叉战中，如果有一条链的算力一开始能达到算力的50%并保持下去，就可以杀死另外一条链；</p>

<h4>情况2</h4>

<p>但是随着链的延长，两边的算力便会拉开差距，挖出的快总是有多有少；算力战预测的初始条件变成了这样:</p>

<p>从交易被收录进区块的时候开始，诚实矿工出了z个块。攻击矿工在此期间出块数记为k，只要攻击者不广播别人就不知道，k可能等于0、1、2……直到无穷大。</p>

<ul>
<li>若k>z，攻击直接成功；若k&lt;=z，攻击者仍有可能追上，其成功的可能性即赌徒破产问题。因为攻击失败的情况有限，所以计算成功概率改为计算等价的<code>1-攻击失败的概率</code>。</li>
</ul>


<p>首先研究k，假定诚实矿工以均匀的速度出块，则k近似服从泊松分布：<code>P(k, λ)</code>；</p>

<p>就是“在一个指定长度的固定区间内有k个点（事件）”的概率。诚实矿工出z块的时间即“指定长度的固定区间”，攻击矿工出块次数k即“事件”，每种k出现的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg4.png" alt="img" /></p>

<p>其中λ是攻击矿工出块的期望，假设比特币的算力简化计算为:</p>

<p>速度 * 时间 = 工作量。</p>

<p>z是防御者的工作量，p是防御者的速度，z/p是防御者消耗的时间。防御者的时间=攻击者的时间。攻击者的速度=q；</p>

<p><code>攻击者的工作量期望 = 攻击者的速度 * 攻击者的时间 = q * z / p</code>。 即 <code>λ = z*q/p</code>。</p>

<p>根据赌徒破产问题，在落后了z-k个块之后仍旧能追上的概率是:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg5.png" alt="img" /></p>

<p>追不上的概率为:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg6.png" alt="img" /></p>

<p>每种k (k&lt;=z)出现的概率，乘以它追不上的概率，就是这个k的失败率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg7.png" alt="img" /></p>

<p>1-所有攻击失败情况的概率之和，就是攻击成功的概率:
<img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181117/bg8.png" alt="img" /></p>

<h2>总结</h2>

<p>当前Bitcoin SV算力占总算力的43%，落后7个block，取q=0.43, p=0.57, 计算成功率已然小于10%了。</p>

<p>那么，Bitcoin SV要把算力提高到多少，才能有50%的希望追上Bitcoin ABC呢？ 这是个复杂的问题啊，首先从分叉一晚的算力战来看，目前BitcoinABC可以调动的算力总量为8500P，所以Bitcoin SV目前一定要调动>8500P的算力，才能有翻盘的机会，至于需要多大才能把翻盘机会搞到50%，课后作业计算吧。</p>

<blockquote><p>PS:有个小漏洞，因为BCH的难度计算和BTC是不一样的，我不是很确定情况2的计算是否可以假设为泊松分布。</p></blockquote>

<p>当然，这是一个模拟，真实情况是，发生危机时，bitmain会不断的从BTC那边调集算力过来；这其实是BCH在吸血BTC的算力；</p>

<p>目前来看，BTC的算力有46EH，目前市场上所有的SHA256算力可能总共>60EH；如果算力占再升级，都可以看成是BCH链对BTC链的攻击了。而且只要Bitcoin SV一天不加重放保护，那么交易所就不太可能开放冲提币，这样BCH 链上的交易就会继续停滞，表面上来看是Bitcoin SV一方在烧钱，其实是BCH整条链都在烧钱。现在真正是考验信仰的时候，短期来看，输家会一无所有。赢家也未必能赚到什么。非常残酷的算力战。这真是难得一见，再过10年，真的像中本聪预测的那样，比特币广泛应用后，这种算力战出现的概率极小。某种意义上来说，这个热闹真好看啊:</p>

<p>每天投入$200W的豪赌!</p>

<p>这也进一步验证了，同一个POW算法，最多只能存在一条链，因为即使加了重放保护分叉，还是无法逃脱算力威胁；BCH是一条非常非常特殊的链，它是由bitmain大算力保证的小算力链；这么说可能有点绕口，可以看成BTC和BCH的战争会持续下去，我认为一定会有一方死亡！至于持续多长时间就不好说了，但是我认为这种平衡不可能无限保持下去，必然会发生黑天鹅事件。</p>

<p>另外，像PPC等SHA256 POW币，或者ETC之于ETH，也是同样的情况；我抱持一种观点：</p>

<blockquote><p>同样的POW算法，如果有大算力存在的情况下，一定归于一条链；
中间可能会多链并存很长时间，但总会发生黑天鹅事件将其它链清零</p></blockquote>

<h4>引用:</h4>

<p><a href="https://www.guokr.com/article/59575/?page=3">https://www.guokr.com/article/59575/?page=3</a></p>

<p><a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system/</a></p>

<p><a href="https://www.zhihu.com/question/263764571">https://www.zhihu.com/question/263764571</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bicoin Cash分叉在即]]></title>
    <link href="https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji/"/>
    <updated>2018-11-15T15:08:32+08:00</updated>
    <id>https://happy123.me/blog/2018/11/15/bicoin-cashfen-cha-zai-ji</id>
    <content type="html"><![CDATA[<p>Bitcoin Cash 将于UNIX时间1542300000 (即北京时间2018年11月16日00：40)发生硬分叉;</p>

<p>分叉两派是比特大陆为首支持的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc">Bitcoin ABC</a>实现，以及Craig Steven Wright为首的<a href="https://github.com/bitcoin-sv/bitcoin-sv">BItcoin SV</a>实现。</p>

<p>两派的恩恩怨怨政治斗争无心吐槽，咱也没有明确的倾向；但是作为码农咱要黑一黑；</p>

<!-- more -->


<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/2ab7775797a5a37ab311ab9a067771e5c1bfe22a">这里</a>是bitcoin SV 从Bitcoin ABC项目里面开始folk出来的修改；截至他们发布Bitcoin SV Beta1.0；最后提交的代码是<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/d9b12a23dbf0d2afc5f488fa077d762b302ba873">d9b12a23dbf0d2afc5f488fa077d762b302ba873</a></p>

<p>执行 <code>git diff 802629f d9b12a --stat</code> 瞄一眼:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>699 files changed, 11634 insertions(+), 197401 deletions(-)</span></code></pre></td></tr></table></div></figure>


<p>看起来改了不少，但是从头review一遍，他们从2018-08-22搞到现在，啥实质改动都没有，就开了几个操作码，改了几个测试；原本MAXBLOCKSIZE就变成可配置的了，他们不过是稍稍改了一下判断条件而已，改动最大的反而是README和release notes文件，最值得吐槽的就是这个提交：</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d">https://github.com/bitcoin-sv/bitcoin-sv/commit/db8190ab5fb5262a6d3701017d733f106308fd0d</a></p>

<p>好吧，也不能无脑黑你，你还是修掉了一个比较重要的BUG的:</p>

<p><a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86</a></p>

<p>凭良心说，Bitcoin ABC的开发比不上Bitcoin Core的活跃，但起码Bitcoin Core有什么更新，人家能及时Merge过来啊！</p>

<p>曾经，像Bitcoin Gold之流，改个POW算法就出来割韭菜了，大家还愤愤不平；</p>

<p>Litecoin和Dogcoin还是改了改币数上限和出块时间的，这是在早期，咱们也忍了~~</p>

<p>如今Bitcoin SV的代码库让我见识了什么叫任性！</p>

<p>如果不赞成升级，原版代码运行就是；现在哥们，你们倒是放开了操作码！但是操作码执行实现的部分好好测试过了吗，对应的测试在哪里？就两天时间开放出来不怕出BUG吗？</p>

<p>同样的一个<a href="https://bitcoincore.org/en/2018/09/20/notice/">重要BUG处理</a>:</p>

<p>Bitcoin ABC的<a href="https://github.com/Bitcoin-ABC/bitcoin-abc/commit/7e20479893089b2b80f81cc2e7e5712a2d4158ba">重构+修正</a>，BitcoinSV的<a href="https://github.com/bitcoin-sv/bitcoin-sv/commit/a8ab90a375db85b192057aa11f56bfa0612d7e86">修正</a>; 态度啊~~</p>

<p>我觉得数字货币这个场子没啥正义公理权威可言，就是中本聪重现人间，相信说话也没多大分量了；但是代码质量是没办法靠嘴炮提升的；长久来看，占据市场还是要靠产品质量啊。</p>

<p>但是不管怎么样，接下来的战争是一场明刀明枪的较量，没有重放保护，双方都是投入真金白银维护自己的立场，这比空气币收割韭菜实诚多了；</p>

<p>比特币这个社会实验已然十年，终于出现了白皮书所描写的第一场大规模算力战争，值得期待啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-3]]></title>
    <link href="https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3/"/>
    <updated>2018-11-07T19:59:04+08:00</updated>
    <id>https://happy123.me/blog/2018/11/07/bi-te-bi-de-hdqian-bao-yan-hua-3</id>
    <content type="html"><![CDATA[<p>通过前面两篇文章，我们认识到比特币的所有权是通过私钥来确定的。</p>

<p>那么我们就在此基础上研究比特币钱包的构成。广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，比特币钱包的核心就是对私钥的管理。</p>

<p>在比特币的历史发展中，钱包大致经过了三次进化:</p>

<ol>
<li><p>非确定性（随机）钱包</p></li>
<li><p>确定性（种子）钱包</p></li>
<li><p>分层确定性钱包（HD Wallets (BIP-32/BIP-44)）</p></li>
</ol>


<p>下面我们就好好说说钱包的历史发展轨迹</p>

<!-- more -->


<h2>非确定性（随机）钱包</h2>

<p>在比特币刚诞生时，Bitcoin Core客户端实现了第一个钱包功能，当时因为早期的用户并不多且都是专业人士，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。具体的实现细节就是:
比特币核心客户端预先生成100个随机私钥，每个密钥只使用一次；用完之后再生成100个；</p>

<p>这样做的缺点十分明显：</p>

<p>如果你生成很多私钥，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址重复使用将多个交易和地址关联在一起，这会减少隐私。</p>

<p>当比特币用户群逐渐扩大时，不少人因为随机生成的100个私钥用完后，没有备份老钱包，生成新的私钥后原先的钱包弃用，造成了未花费币的丢失。现在看看是个不可思议的幼稚的BUG，但是在比特币蛮荒时代，这种漫不经心的错误导致的丢币比比皆是。</p>

<h2>确定性（种子）钱包</h2>

<p>比特币私钥可以用任意方法生成，自然也可以通过一个随机短语进行多次hash得到不同的私钥。这种思路下，社区提出了确定性（种子）钱包的方案。</p>

<p>确定性，或者“种子”钱包包含通过使用HASH函数而可从公共的种子生成的私钥。种子是随机生成的数字。在确定性钱包中，种子足够恢复所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包导入或者导出。这就很容易允许使用者的私钥在钱包之间轻松转移。</p>

<p>比如，我们上一篇文章中用<code>satoshi</code>作为种子，得到SHA256(&lsquo;satoshi&rsquo;)作为私钥，完全可以继续用SHA256(SHA256(&lsquo;satoshi&rsquo;))&hellip;这样推导下去得出更多的私钥，同时，只需要记住<code>satoshi</code>这个种子，就可以方便的导入导出私钥。更进一步，可以加入password和更多的混淆短语，提高私钥生成的健壮性。</p>

<p>这种方案提出后，因为简单易行，多个轻钱包都做了自己的实现；虽然原理相似，但是他们之间并不通用，所以不同的钱包私钥导入导出还有一些不方便。社区就在此基础上继续探索，最终整理形成了BIP32、BIP39、BIP43，BIP44等规范，创造了我们今天通用的HD钱包。</p>

<h2>分层确定性钱包（Hierarchical Deterministic wallet&mdash;HD Wallet）</h2>

<p>首先用一张经典的图来描述HD钱包的私钥生成:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg1.jpg" alt="img" /></p>

<p>分层钱包说白了，就是将<code>seed-&gt;私钥</code>的过程变成了，<code>助记词-&gt;seed-&gt;一级私钥-&gt;二级私钥-&gt;三级私钥....</code>，即多层树状私钥生成的方案。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。HD钱包有两个主要的优势。</p>

<ol>
<li><p>树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。</p></li>
<li><p>它可以允许使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要存储私钥。</p></li>
</ol>


<p>再来一个在线工具用于验证:</p>

<p><a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a></p>

<p>最初的私钥seed来源于一个助记词（又称为Mnemonic Code），为了便于在不同的钱包中转移、导出和导入，社区对助记词的长度，范围，变换标准等等做了详尽的描述，最终形成了<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>规范。这个规范由Trezor硬件钱包背后的公司提出，已经成为事实上的行业标准。</p>

<p>BIP-39定义了助记符码和种子的创建， 为了清楚起见，该过程分为两部分：</p>

<p>先是创建助记词，然后是从助记词到种子。下面我们从一个<code>ffffffffffffffffffffffffffffffff</code> 的128bits 熵开始，演示HD钱包是如何生成、管理私钥的。让我们一步一步解释。</p>

<h3>先看看创建助记词的部分</h3>

<h4>生成步骤</h4>

<ul>
<li><p>1、创建一个128到256位的随机序列（熵）。我们取<code>ffffffffffffffffffffffffffffffff</code>，称之为原始熵。</p></li>
<li><p>2、用SHA256 HASH原始熵，就可以创造一个随机序列的校验和。代码如下</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from binascii import unhexlify
</span><span class='line'>from hashlib import sha256
</span><span class='line'>data = 'f' * 32
</span><span class='line'>data_unhexlify = unhexlify(data)
</span><span class='line'>h = hashlib.sha256(data_unhexlify)
</span><span class='line'>checksum = bin(int(h, 16))[2:].zfill(256)[:len(data) * 8 // 32]</span></code></pre></td></tr></table></div></figure>


<p>得到checksum为<code>0101</code></p>

<ul>
<li>3、首先求得原始熵的二进制表示，然后将校验和添加到随机序列的末尾。代码如下:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from binascii import unhexlify, hexlify
</span><span class='line'>data = 'f' * 32
</span><span class='line'>data_unhexlify = unhexlify(data)
</span><span class='line'>body = bin(int(hexlify(data), 16))[2:].zfill(len(data) * 8)
</span><span class='line'>final_result = body + checksum</span></code></pre></td></tr></table></div></figure>


<p>得出的结果为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4、将序列划分为包含11位的不同部分。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111110101</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5、将每个包含11位部分的值作为下标索引，与一个已经预先定义2048个单词的字典做对应。BIP39中对应的字典文件可以参考这里:</li>
</ul>


<p><a href="https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist">https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist</a></p>

<p>以上二进制表示的下标值为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2037</span></code></pre></td></tr></table></div></figure>


<p>为什么单词数目是2048呢？ 其实seed可以有12-24个单词，所有的组合可能性为 2048<sup>12</sup> &mdash; 2048<sup>24</sup>；</p>

<p>还记得我们之前的文章吗？比特币公钥->地址的倒数第二步是RIPEMD160，他一共有2<sup>160</sup>可能性，上面seed的生成空间覆盖了RIPEMD160的生成空间。</p>

<ul>
<li>6、生成的有顺序的单词组，就是助记码(Mnemonic Code)。在咱们的例子中如果采用英文字典，对应的结果为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</span></code></pre></td></tr></table></div></figure>


<p>一张图展示熵如何生成助记词:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg2.jpg" alt="img" /></p>

<p>在上面这个例子中，我们选取了128Bits 原始熵，BIP39规范中，用户有128bits, 160bits, 192bits, 224bits, 256bits多个选择;下面的表格说明了熵数据的大小和助记词的长度之间的关系:</p>

<table>
<thead>
<tr>
<th>Entropy(bits) </th>
<th> Checksum(bits)</th>
<th> Entropy + checksum(bits) </th>
<th> Mnemonic length(words)</th>
</tr>
</thead>
<tbody>
<tr>
<td>128</td>
<td>4</td>
<td>132</td>
<td>12</td>
</tr>
<tr>
<td>160</td>
<td>5</td>
<td>165</td>
<td>15</td>
</tr>
<tr>
<td>192</td>
<td>6</td>
<td>198</td>
<td>18</td>
</tr>
<tr>
<td>224</td>
<td>7</td>
<td>231</td>
<td>21</td>
</tr>
<tr>
<td>256</td>
<td>8</td>
<td>264</td>
<td>24</td>
</tr>
</tbody>
</table>


<p>目前最流行的实现还是跟我们上面的例子一样，选取128bits->12words 的Mnemonic code生成。</p>

<h3>从助记词生成种子</h3>

<p>现在我们已经从<code>ffffffffffffffffffffffffffffffff</code>随机熵得到了助记码<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>，现在需要从助记码再生成种子。</p>

<h4>PBKDF2函数</h4>

<p>这里我们需要先介绍一个函数:PBKDF2(Password-Based Key Derivation Function)，它是一个用来导出密钥的函数，常用于生成加密的密码。</p>

<p>它的基本原理是通过一个伪随机函数（例如HMAC函数），把明文和一个salt值作为输入参数，然后重复进行运算，并最终产生密钥。</p>

<p>如果重复的次数足够大，破解的成本就会变得很高。而salt值的添加也会增加“彩虹表”攻击的难度。</p>

<p>嗯，我们还要稍微解释一下HMAC的意义:</p>

<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>

<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p>

<p>采用不同的hash算法时如何混入salt，可能大家八仙过海各显神通；后来为了统一化，有人提出了Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把salt混入计算过程中。</p>

<p>简而言之，HMAC提供了标准的在HASH过程中混入salt的方法。 HMAC方法适用于任意HASH函数。</p>

<p>而比特币私钥生成过程中采用的PBKDF2算法，大量使用HMAC-SHA512算法，使用2048次 HASH来延伸助记符和salt参数，产生一个512位的值作为其最终输出。</p>

<p>这个512位的值就是种子。</p>

<h4>利用PBKDF2从助记词得到种子步骤</h4>

<p>1、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符(<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code>)。</p>

<p>2、PBKDF2密钥延伸函数的第二个参数是salt。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成 (<code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code> + <code>test</code>)。</p>

<p>3、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和salt参数，产生一个512位的值作为其最终输出。 这个512bits的值就是种子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; import hashlib
</span><span class='line'>&gt; import hmac
</span><span class='line'>&gt; from pbkdf2 import PBKDF2
</span><span class='line'>&gt; from binascii import hexlify
</span><span class='line'>&gt; PBKDF2_ROUNDS = 2048
</span><span class='line'>&gt; mnemonic = "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
</span><span class='line'>&gt; passphrase = "test"
</span><span class='line'>&gt; seed = PBKDF2(mnemonic, 'mnemonic' + passphrase, iterations=PBKDF2_ROUNDS, macmodule=hmac, digestmodule=hashlib.sha512).read(64)
</span><span class='line'>&gt; print(hexlify(seed))
</span><span class='line'>
</span><span class='line'>b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'</span></code></pre></td></tr></table></div></figure>


<h3>从种子中创造HD钱包</h3>

<p>我们已经得到了一个512bits的种子，我们把这个种子称之为<code>根种子</code>(root seed)。这个根种子是下面一切私钥产生的源泉。</p>

<p>让我们再回忆一下最开始的一张示意图：所有的私钥是成树状结构的。树的每一层都有无限分支，然后每一个分支都可以派生出下一层，这个结构该如何从根种子来构建呢？</p>

<p>这是一个精妙的设计。下面我们还是采用步步为营的方法来演示一遍:</p>

<h4>私有子密钥的衍生</h4>

<ul>
<li>1、 首先我们需要安装一个BIP32 Python解析库<code>pip install bip32utils</code>:</li>
</ul>


<p><a href="https://pypi.org/project/bip32utils/">https://pypi.org/project/bip32utils/</a></p>

<ul>
<li>2、 根种子输入到HMAC-SHA512中，得到一个512bits的输出:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; import binascii
</span><span class='line'>&gt; import hmac
</span><span class='line'>&gt; seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870de86587b2663c462dd9425d3d3ef04'
</span><span class='line'>&gt; entropy = binascii.hexlify(seed)
</span><span class='line'>&gt; I = hmac.new(b"Bitcoin seed", entropy, hashlib.sha512).digest()</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3、 这个512bits的<code>I</code>可以分为两个部分，左边的256bits用作Master Private Key，右边的256bits用作Master Chain Code。Master Private Key又可以推导出Master Public Key。整个表示如下:</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg3.jpg" alt="img" /></p>

<ul>
<li><p>4、 这样我们从一个512bits的输出里面分成了两个变量: Master Pirvate Key以及Master  Chain Code；下面分别说说他们的作用</p>

<ul>
<li><p>Master Private Key: 又被称作母私钥，很明显的，它可以衍生出公钥以及地址；但是我们的需求是生成多个公私钥对，所以我们又引入了一个索引号(32 bits)的概念，这样，一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，因为另一半是为特定类型的推导而保留的，我们将在稍后讨论。</p></li>
<li><p>Master Chain Code: 有了Master Private Key，可以在这一层生成2<sup>31</sup>个子私钥，但是这样无法得到我们想要的分层结构；于是就需要Master Chain Code的帮忙。这样上面的步骤我们需要三个输入：将Master Chain Code和Master Private Key以及索引号作为HMAC-SHA512的输入，又可以得到一个512bits的输出，左边的256bts就是我们需要的子私钥；重复这个过程，我们就得到了一个分层的私钥结构</p></li>
</ul>
</li>
<li><p>5、让我们总结一下这个过程:</p>

<ul>
<li>每次HMAC-SHA512，都得到一对Master Private Key以及Master Chain Code，再加上引入一个索引号，我们就能在这一层生成2<sup>31</sup>个私钥</li>
<li>用这一层的Master Chain Code和Master Chain Code以及选取一个固定的索引号作为HMAC-SHA512的输入，又可以得到下一层的Master Private Key以及Master Chain Code，</li>
<li>重复这个递归的过程就可以构造一棵私钥树状结构</li>
<li>这个递归构造的函数我们称之为CKD（child key derivation)函数</li>
</ul>
</li>
<li><p>6、 CKD (子密钥衍生函数): 这个函数有三个输入</p>

<ul>
<li>一个母私钥(Master Private Key 256bits)</li>
<li>一个链码(Master Chain code 256 bits)</li>
<li>一个索引号 (32 bits)</li>
</ul>
</li>
</ul>


<p>这三个输入可以得到一个512bits的输出，在得到一个私钥的同时，也可以作为一棵树的根节点，从而衍生出无数个子密钥。</p>

<p>叶子节点衍生出的子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。</p>

<h4>扩展密钥</h4>

<p>正如我们之前看到的，CKD函数可以被用来创造密钥树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key）。术语“extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p>

<p>引入我们之前的例子，这里我们第一层的扩展密钥为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; from bip32utils import BIP32Key
</span><span class='line'>&gt; from binascii import hexlify
</span><span class='line'>&gt; seed = b'0d756ad408b442341ec4895e854fe5ee55d2a93c6544d3e77b073100e9739e35b897b3fc81ef622babd3f6d7347af2e870d
</span><span class='line'>&gt; root = BIP32Key.fromEntropy(hexlify(seed))
</span><span class='line'>&gt; print(root.ExtendedKey())
</span><span class='line'>
</span><span class='line'>xprv9s21ZrQH143K35KaAEjp6RjB4LoeCR3prWBv6vmX7HuGnPFygragV39uDC24D3UZvMnWbhame5nykoXCcfy1Rbgg8uqSzmwoQgFEqt2bUNy</span></code></pre></td></tr></table></div></figure>


<p>第一层的扩展私钥也被称之为<code>BIP32 Root Key</code>；</p>

<p>得到了一个扩展私钥，就代表得到了树状结构中某个层级的完全控制权，这个扩展密钥可以创造出子密钥并且作为根节点能创造出密钥树结构中的整个分支。分享扩展密钥就可以访问整个分支。</p>

<h4>公共子密钥推导</h4>

<p>再审视一下前面的CKD函数，第一个输入是<code>一个母私钥(Master Private Key 256bits)</code>，这让我们思考，如果不是输入私钥，而是输入公钥会发生什么呢？</p>

<p>通过母公钥衍生子私钥为分层确定性钱包带来的一个很有用的特点，就是可以不通过私钥而直接从公共母密钥派生出公共子密钥的能力。</p>

<p>因此，扩展密钥可以在HD钱包结构的分支中，被用来衍生所有的公钥（且只有公钥）。</p>

<p>这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。</p>

<p>这种方案的常见应用是安装扩展公钥电商的网络服务器上。网络服务器可以使用这个公钥衍生函数去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公钥。</p>

<p>这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包），与此同时扩展公钥可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如 Trezor）签署交易。下图阐述了扩展母公钥来衍生子公钥的传递机制。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg4.jpg" alt="img" /></p>

<h4>硬化子密钥的衍生</h4>

<p>从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。</p>

<p>为了应对这种风险，HD钱包使用一种叫做硬化衍生(hardened derivation）的替代衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥，如图所示。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181113/bg5.jpg" alt="img" /></p>

<p>当强化私钥衍生函数被使用时，得到的子私钥以及链码与使用一般衍生函数所得到的结果完全不同。得到的密钥“分支”可以被用来生产不易被攻击的扩展公钥，因为它所含的链码不能被用来开发或者暴露任何私钥。强化衍生也因此被用在上一层级，使用扩展公钥的密钥树中创造“间隙”。</p>

<p>简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层级的子密钥最好使用强化衍生。</p>

<h4>正常衍生和强化衍生的索引号码</h4>

<p>还记得我们前面说:一个母私钥+索引号，就可以生成2<sup>31</sup>个子私钥，2<sup>31</sup>是整个2<sup>32</sup>范围可用的一半，另一半是做什么的呢？</p>

<p>用在衍生函数中的索引号码是32位的整数。为了区分密钥是从正常衍生函数中衍生出来还是从强化衍生函数中产出，这个索引号被分为两个范围。索引号在0和2<sup>31</sup>–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2<sup>31</sup>和2<sup>32</sup>– 1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生。因此，索引号小于2<sup>31</sup>就意味着子密钥是常规的，而大于或者等于2<sup>31</sup>的子密钥就是强化型的。</p>

<p>为了让索引号码更容易被阅读和展示，强化子密钥的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0&#8217;。第二个强化密钥依序有了索 引号0x80000001，且被显示为1&#8217;，以此类推。当你看到HD钱包索引号i&#8217;，这就意味着 2<sup>31</sup>+i。</p>

<h3>HD钱包密钥识别符</h3>

<p>我们看到，一个树状的私钥组织，命名就成了一个问题，如何快速的表示<code>这是一个由第三层的第n个扩展子私钥衍生的主密钥</code>呢？</p>

<p>答案是类似于文件路径的命名规则。</p>

<p>每个级别之间用斜杠（/）字符来表示。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。</p>

<p>密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。</p>

<h4>HD钱包树状结构的导航</h4>

<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及子分支的可能性是无穷的。</p>

<p>两个比特币改进建议（BIPs）提供了这个复杂问题的解决办法——通过创建几个HD钱包树的提议标准。BIP-43提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP-43，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i&#8217;/是 为了表明那个被索引号“i”定义的特殊为目地。</p>

<p>在BIP-43标准下，为了延长的那个特殊规范，BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m/44&#8217;/。 BIP-44指定了包含5个预定义树状层级的结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>m / purpose' / coin_type' / account' / change / address_index</span></code></pre></td></tr></table></div></figure>


<p>第一层的purpose总是被设定为44&#8217;。</p>

<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44&#8217;/0&#8217;、Bitcoin Testnet is m/44&#8217;/1&#8217;，以及 Litecoin is m/44&#8217;/2&#8217;, Ethereum 是 60&#8217;。</p>

<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性子账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m/44&#8217;/0&#8217;/0&#8217; 和 m/44&#8217;/0&#8217;/1&#8217;。每个账户都是它自己子树的根。</p>

<p>第四层级就是“change”。每一个HD钱包有两个子树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>

<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44&#8217;/0&#8217;/0&#8217;/0/2。</p>

<h2>几个BIP规范</h2>

<p>到这里为止，我们已经了解到了比特币HD钱包的绝大部分构造知识。如果能完全理解了上述内容，我们已经是<code>专家</code>了。让我们再简要回顾一下过程:</p>

<ol>
<li>生成一个随机序列作为原始熵</li>
<li>通过一系列变换操作得到了一个Mnemonic Code，这些操作需要大量的HASH过程，抵御了暴力碰撞。同时，生成的Mnemonic Code作为人类易读的助记词，可以轻易的抄写备份，导入导出，这个Mnemonic  Code代表着钱包的完全控制权</li>
<li>从Mnemonic得到了一个root seed，进而转化为 BIP32 Root Key，这可以构造一棵私钥树的根节点</li>
<li>从BIP32 Root Key开始，可以构造更多的公共子密钥，或者公共密钥；根据使用场景的不同，可以构造出完全控制的HD钱包，或者离线签署的只读钱包。</li>
</ol>


<p>这上面一系列的操作细节，被社区总结到了几个BIP规范当中。</p>

<h4>BIP32</h4>

<p>定义 Hierarchical Deterministic wallet (简称 &ldquo;HD Wallet&rdquo;)，是一个系统可以从单一个 seed 产生一树状结构储存多组 keypairs（私钥和公钥）。好处是可以方便的备份、转移到其他相容装置（因为都只需要 seed），以及分层的权限控制等。</p>

<h4>BIP39</h4>

<p>将 seed 用方便记忆和书写的单字表示。一般由 12 个单字组成，称为 mnemonic code(phrase)，中文称为助记词或助记码。例如：</p>

<p><code>zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong</code></p>

<h4>BIP43</h4>

<p>提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”</p>

<h4>BIP44</h4>

<p>基于 BIP32和BIP43 的定义，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支持多币种、多帐户等。各层定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>m / purpose' / coin_type' / account' / change / address_index</span></code></pre></td></tr></table></div></figure>


<p>其中的 purporse&#8217; 固定是 44&#8217;，代表使用 BIP44。而 coin_type&#8217; 用来表示不同币种，例如 Bitcoin 就是 0&#8217;，Ethereum 是 60&#8217;。</p>

<h4>BIP49，BIP84, BIP141</h4>

<p>加入隔离验证后的账户方案</p>

<h2>安全性</h2>

<p>关于安全性，reddit上面的<a href="https://www.reddit.com/r/Bitcoin/comments/6twuj1/are_12word_seeds_for_bitcoin_private_keys_secure/">一个帖子</a>做了比较全面的计算，可以参考。</p>

<h2>总结</h2>

<p>呼，漫长的一顿操作之后；我们终于拥有了一个完整的HD钱包，它有下面几个特性:</p>

<ol>
<li>只要记住seed，即12-24个单词，就可以在不同得系统中导入/导出这个钱包，并掌有完全的控制权，除了知道seed的人，世界上没有任何一个组织能操作这个账户</li>
<li>这个钱包拥有衍生无数个账户的能力，并通过树状层次组织</li>
<li>这棵树的任意一个节点都可以衍生出一棵子树，适用于大型组织的财务处理；比如国王拥有根seed的绝对掌控权，他分配了几个一级扩展私钥给总理大臣，而这几个一级扩展私钥又可以作为根节点衍生出二级扩展私钥分配给更多的人&hellip;..依次衍生下去无穷无尽，每一级的扩展私钥掌控者都拥有下级的资金调度权力，而同级别的私钥掌控者互不可见；</li>
<li>通过一个类似于文件系统命名的路径方式，扩展私钥的拥有者可以掌管任意一个子节点的账户，比如将来全家共享一个钱包，父母对子女的零花钱流水账有完全的掌控</li>
<li>可以构造出一个完全离线的只用来收款而不能付款的钱包账户，用于海量用户的电子商户系统</li>
<li>可以汇聚多个公私钥体系的电子货币；可以想象，未来所有的电子货币系统都聚集在一个钱包之中</li>
</ol>


<p>是不是非常神奇的感觉；呼呼，写到这里，我们已经将电子货币系统的钱包设计完全探究了一番；</p>

<p>其实这么长篇大论下来，我想要探讨的真正题目是比特币的交易构成，而不是什么钱包构造。</p>

<p>这个文章3年前就想写了，但是无穷尽的前置知识实在是让人望而却步；目前我们总算是对于比特币的账户系统有所了解了，反正我搞明白之后只能发出感叹：<code>设计的实在是太精巧了</code>；</p>

<p>但是比特币的交易构造之精巧，又胜过钱包十倍。走了这么远的路，还是那句话，还早得很呢。</p>

<p>那么，比特币的交易构造又是怎样的呢？我们下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-2]]></title>
    <link href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/"/>
    <updated>2018-11-02T13:31:50+08:00</updated>
    <id>https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2</id>
    <content type="html"><![CDATA[<p>好了，有了上一篇文章的基础，我们可以从零开始完全探究数字货币的地址生成、管理方法；下面的代码均使用Linux Bash shell和Python3来处理；另外需要安装<a href="https://github.com/richardkiss/pycoin">pycoin</a>这个库。</p>

<!-- more -->


<h2>生成私钥</h2>

<p>一般来说，私钥是个256bit的随机字符。为了演示方便，我们用一个人民大众喜闻乐见的地址生成为例子，私钥选取为 sha256(&ldquo;satoshi&rdquo;)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; printf "satoshi"|sha256sum
</span><span class='line'>da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f  -</span></code></pre></td></tr></table></div></figure>


<p>得到私钥为<code>da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</code></p>

<h2>用WIF (Wallet Import Format)表示私钥</h2>

<p>我们看到私钥本质上是256bit的数字，他可以用二进制表示，也可以用16进制字符串表示，也可以用Base58Check来表示；为了在不同的钱包中方便的导入导出私钥，也为了方便二维码的生成，比特币采用了名为<code>WIF</code>的表示方法，下面列一个表格来说明:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Prefix </th>
<th> Description </th>
<th> Private key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raw </td>
<td> None </td>
<td> 32 bytes binary </td>
<td>  11011010001010000&hellip;&hellip;&hellip;..</td>
</tr>
<tr>
<td>HEX </td>
<td> None </td>
<td> 64 hexadecimal digits </td>
<td> da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f</td>
</tr>
<tr>
<td>WIF </td>
<td> 5 </td>
<td> Base58Check encoding </td>
<td> 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</td>
</tr>
<tr>
<td>WIF-compressed </td>
<td> K or L </td>
<td> Base58Check encoding </td>
<td> L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6</td>
</tr>
</tbody>
</table>


<p>得到WIF 代码示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def gen_pubk_from_privk(private_key, compressed=True):
</span><span class='line'>    # private_key = codecs.encode(os.urandom(32), 'hex').decode()
</span><span class='line'>    secret_exponent = int('0x' + private_key, 0)
</span><span class='line'>    print('WIF: ' + encoding.secret_exponent_to_wif(secret_exponent, compressed=compressed))
</span><span class='line'>    public_pair = ecdsa.public_pair_for_secret_exponent(ecdsa.secp256k1.generator_secp256k1, secret_exponent)
</span><span class='line'>    print('public pair:', public_pair)
</span><span class='line'>    return public_pair
</span></code></pre></td></tr></table></div></figure>


<p>WIF格式分为非压缩和压缩格式，压缩私钥其实是对非压缩私钥后缀追加了01之后的Base58Check编码，具体生成过程为:</p>

<ul>
<li>压缩私钥: 私钥前缀80+私钥本体+压缩私钥后缀01 + 校验</li>
<li>非压缩私钥: 私钥前缀80+私钥本体+校验</li>
</ul>


<p>和字面意思相相反的是，压缩私钥比非压缩私钥还长。为啥这么折腾呢？这个我们在公钥生成的部分说明。</p>

<h2>生成公钥</h2>

<p>我们之前的文章介绍了，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头。</p>

<p>下面是由前文中的私钥所生成的公钥，其坐标x和y如下:</p>

<ul>
<li><p>public pair:</p>

<ul>
<li>x = 89077434373547985693783396961781741114890330080946587550950125758215996319671</li>
<li>y = 114001858762817543140175961139571810325965930451644331549950109688554928624341</li>
</ul>
</li>
</ul>


<p>加上前缀04，完整的公钥为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>K = 0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341</span></code></pre></td></tr></table></div></figure>


<h4>为什么要区分压缩格式和非压缩格式</h4>

<p>这是一个历史问题，初版比特币运行时，中本聪没有考虑到一个问题:</p>

<p>一个公钥是一个椭圆曲线上的点(x,y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程 <code>y^2 % p = (x^3 + 7) % p</code>得到y坐 标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256 bits。如果每笔交易所 需要的字节数减少了近一半，随着时间推移，节省的数据传输和存储空间还是很客观的。</p>

<p>所以后来开发团队推出了压缩公钥，为了跟之前老版本的非压缩公钥相区分，就加上了02和03作为前缀。</p>

<p>那么为什么要加两个前缀(02,03)呢？</p>

<p>因为椭圆曲线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在 x坐标轴的上面或者下面。椭圆曲线图中曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</p>

<p>总结出来，一个公钥的表现形式可以又两种:</p>

<ol>
<li>04开头的非压缩公钥: (130位十六进制 2+64+64)</li>
<li>02或03开头的压缩公钥:（66位十六进制 2+64）</li>
</ol>


<p>这样继续推导，两种表现形式可以推导出两个地址，也就是手握一个私钥，可以推导出两个合法的比特币地址。</p>

<p>这样又间接解释了为什么会有压缩私钥和非压缩私钥两种表现：</p>

<ul>
<li>当中本聪实现第一版比特币客户端钱包的时候，没有考虑到公钥可以压缩，所以采用了最原始直接的办法存储公钥和私钥</li>
<li>后来人们发现公钥可以简化存储来节省一部分空间，于是加入了压缩公钥格式，为了跟之前的非压缩公钥区分，引入了前缀</li>
<li>同样，使用压缩公钥格式的钱包导入导出私钥时，为了区分，也必须为私钥标明它对应的公钥是否压缩格式，所以也为私钥的表示引入了后缀</li>
<li>压缩私钥的意思是，由这个私钥导出的公钥表示方法是压缩的，私钥本身还需要引入一个01作为后缀，长度反而多了一个字节</li>
</ul>


<h2>从公钥到比特币地址</h2>

<p>得出公钥之后，地址的生成还要经过三重变换， 公钥为K，变换过程如下:</p>

<ol>
<li>首先计算 A = SHA256(K)</li>
<li>计算 B = RIPEMD160(A)</li>
<li>Addr = Base58Check（prefix + B）</li>
</ol>


<h4>为什么要有RIPEMD160(SHA256(K)) 的过程</h4>

<p>因为中本聪设计之初充分考虑到了安全性方面的问题，一笔交易广播后，并不是直接把公钥K暴漏在外，如果你不花费这个UTXO，暴漏的只有<code>RIPEMD160(SHA256(K))</code>这个值。假如将来有一种计算机的计算能力得到指数级别的提升，有一定可能暴力破解椭圆曲线算法。解决方案就是引入<code>RIPEMD160(SHA256(K))</code>的过程，这样要破解一个未花费的UTXO，需要逆向RIPEMD160，SHA256，secp256k1三种不同的算法，即使将来量子计算发展到实用阶段，也很难做到吧。</p>

<p>但是根据比特币交易的设计，一个地址重复使用就会暴露公钥K，所以我们推荐的安全做法就是一笔UTXO花费后就更换地址。这也是所有安全钱包的默认实现方法。</p>

<p>这个设计的唯一的瑕疵，在我看来，就是RIPEMD160将公钥的碰撞空间减小了，由 2<sup>256</sup> 减小到了 2<sup>160</sup>，当然 2<sup>160</sup> 的碰撞空间对于现有计算能力也是个天文数字，我想中本聪没有选择SHA3等算法的原因，应该是充分考虑了散列算法的复杂度和差异度，最后选择的RIPEMD160吧。</p>

<h4>Base58Check编码</h4>

<p>WIF格式和比特币地址都是用Base58Check编码表示的，Base58是Base64基础上发展来的，它具有以下功能:</p>

<ul>
<li>一个任意大小的payload。</li>
<li>一组58个字母数字符号，由易于区分的大小写字母组成(不使用0OIl)</li>
<li>一个字节的版本/应用程序信息。比特币地址为这个字节使用0x00</li>
<li>四个字节（32位）基于SHA256的错误检查代码。此代码可用于自动检测并可能纠正排版错误。</li>
<li>保留数据中零开头的额外步骤</li>
</ul>


<p>创建过程:</p>

<ol>
<li><p>获取版本字节和payload字节，并将它们连接在一起（按字节顺序）。</p></li>
<li><p>取SHA256(SHA256(步骤1的结果))的前四个字节</p></li>
<li><p>将步骤1的结果和步骤2的结果连在一起（按字节顺序）。</p></li>
<li><p>处理步骤3的结果 &ndash; 一系列字节 &ndash; 作为单个大端序号，使用正常的数学步骤（bignumber division）和下面描述的base-58字母表转换为base-58。结果应该被标准化为没有任何前导零（字符&#8217;1&#8217;）的base-58。</p></li>
<li><p>在base58中，值为零的前导字符&#8217;1&#8217;被保留用于表示整个前导零字节，就像它处于前导位置时一样，没有值作为base-58符号。必要时可以有一个或多个前导&#8217;1&#8217;来表示一个或多个前导零字节。计算步骤3结果中的前导零字节数（对于旧的比特币地址，至少有一个用于版本/应用程序字节;对于新地址，将永远不会有）。每个前导零字节在最终结果中应由其自己的字符&#8217;1&#8217;表示。</p></li>
<li><p>将步骤5中的1与步骤4 的结果连接起来。这是Base58Check的结果。</p></li>
</ol>


<p>最后综合起来，从公钥K到比特币地址完整的示意图如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181102/bg1.jpg" alt="img" /></p>

<p><code>satoshi</code>作为seed计算出私钥，进而计算出公钥K之后，最终进一步生成地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def genaddress_from_pubk(compressed=True)
</span><span class='line'>    # 首先计算 RIPEMD160(SHA256(K))
</span><span class='line'>    ripemd160 = encoding.public_pair_to_hash160_sec(public_pair, compressed=compressed)
</span><span class='line'>    # 再用Base58Check计算最终地址
</span><span class='line'>    addr = encoding.hash160_sec_to_bitcoin_address(ripemd160)
</span><span class='line'>    return addr</span></code></pre></td></tr></table></div></figure>


<p>因为公钥存在压缩形式和非压缩两种形式，所以完整的结果是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>seed: satoshi
</span><span class='line'>sha256 private key: da2876b3eb31edb4436fa4650673fc6f01f90de2f1793c4ec332b2387b09726f
</span><span class='line'>
</span><span class='line'>compress address
</span><span class='line'>WIF: L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
</span><span class='line'>hash160: 0a8ba9e453383d4561cbcdda36e5789c2870dd41
</span><span class='line'>Bitcoin address:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V
</span><span class='line'>
</span><span class='line'>uncompress address
</span><span class='line'>WIF: 5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
</span><span class='line'>hash160: 650d0497e014e60d4680fce6997d405de264f042
</span><span class='line'>Bitcoin address:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</span></code></pre></td></tr></table></div></figure>


<p><code>satoshi</code>作为seed生成了两个地址:</p>

<p><code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>，这都是两个正在使用的地址哦，到今天为止还有热心人源源不断的为<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>转账一些零钱作为中本聪的纪念。你可以将WIF导入钱包，然后运行一个全节点，在bitcoin.conf文件中加入<code>walletnotify</code>这个选项，关联一个脚本，当收到比特币时就自动转账到自己的地址，参与这两个地址的抽奖哦。</p>

<h2>一些Base58Check版本前缀和编码后的结果</h2>

<p>看到这里，我们发现Base58Check 编码的过程中，最后一步会引入一个前缀。而在比特币中，除了WIF私钥和地址，大多数需要向用户展示的数据都使用Base58Check编码，理所当然的，引入了不同的前缀来区分不同的信息，下面展示了一些版本前缀和他们对应的Base58格式:</p>

<table>
<thead>
<tr>
<th>Type </th>
<th> Version prefix </th>
<th> Base58 result prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Address </td>
<td> 0x00 </td>
<td> 1</td>
</tr>
<tr>
<td>Pay to Script Hash Address </td>
<td> 0x05 </td>
<td> 3</td>
</tr>
<tr>
<td>Bitcoin Testnet Address </td>
<td> 0x5F </td>
<td> m or n</td>
</tr>
<tr>
<td>Private Key WIF </td>
<td> 0x80 </td>
<td> 5, K or L</td>
</tr>
<tr>
<td>BIP-38 Encrypted Private Key </td>
<td> 0x0142 </td>
<td> 6P</td>
</tr>
<tr>
<td>BIP-32 Encrypted public Key </td>
<td> 0x0488B21E </td>
<td> xpub</td>
</tr>
</tbody>
</table>


<p>我们最常见的一些地址格式:</p>

<ul>
<li>一个是以<code>1</code>打头，这是用途最广泛的交易，用作Pay to public key hash，简称P2PKH交易；它表示的是最简单的、用一对私钥和公钥控制的钱包。例如上面的<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code></li>
<li>还有一种是<code>3</code>打头，用作Pay to Script Hash，简称P2SH。多重签名、SegWit以及一些智能合约（没错，比特币也支持简单的智能合约）通常都采用这种“3”型地址.例如<code>331jjM5a3HgiDqMuSxeiwTUQFCkM71c5VW</code></li>
<li>以<code>2</code>、<code>m</code>或<code>n</code>开头的地址非常罕见，仅仅被用于比特币的测试网络。</li>
<li>首字符是<code>5</code>、<code>K</code>或<code>L</code>的不是地址，而是WIF（Wallet Import Format）格式的私钥，务必要妥善保管，不可泄漏。</li>
</ul>


<p>除了我们已经提到的WIF和Bitcoin Address，我们还发现了奇怪的BIP-38和BIP-32，这个需要到解释比特币原始交易编码的时候来讲解。</p>

<h2>Segwit</h2>

<p>比特币的地址规范定义之后，平稳运行了很长时间；直到2017-08-24，<a href="https://www.reddit.com/r/Bitcoin/comments/6vnqi2/btccom_mines_the_481823rd_block_segwit_is_on_stage/">第一个Segwit block</a>被挖出；事情有了新变化。</p>

<p>比特币进行Segwit升级之后，地址需要做区分，因为Segwit也可以归类为简单的合约交易，所以在早期钱包还没有足够兼容的时候，Segwit地址都用<code>3</code>打头的合约地址。</p>

<p>但是Segwit交易其实是很特殊的，另外后来有了BCH分叉，越来越多的人闹不清其分叉地址搞丢过一些BCH币；后面为了解决Segwit交易的标识，大部分钱包逐渐实现了<a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173规范</a>；即我们今天可以见到的称之为<code>bech32</code>格式的地址。</p>

<p>这类地址统一以<code>bc</code>开头，后面接着一个版本号，目前只用了<code>1</code>，所以我们可以简单认为这类地址统一以<code>bc1</code>开头；比如:<code>bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj</code>；</p>

<p>bech32地址使用的字符比当前的地址格式要少， 由42个符号组成，小写字母和大写字母之间不再有区别。</p>

<p>这类地址在Bitcoin Core 0.16版本之后的钱包才支持，Bech32地址本身就与SegWit兼容。这意味着交易不需要额外的空间就能将SegWit放入P2SH地址，所以交易费用比较低，Segwit交易目前也逐渐占到了主网交易量的一半；但直到现在，还有很多交易所的BTC提现不支持这类地址；</p>

<p>详细的计算过程其实和base58大同小异，我们就不啰嗦了，可以自己看规范，或示例代码：</p>

<p><a href="https://github.com/sipa/bech32/blob/master/ref/python/segwit_addr.py">https://github.com/sipa/bech32/blob/master/ref/python/segwit_addr.py</a></p>

<p>再小小总结一下，目前为止，我们最常见的有三类地址:</p>

<ol>
<li><code>1</code>开头，最常见</li>
<li><code>3</code>开头，合约、多重签名、Segwit交易</li>
<li><code>bc1</code>开头，segwit交易</li>
</ol>


<h2>Brain Wallet</h2>

<p>好啦，我们上面已经完整的再现了由一个 seed单词 <code>satoshi</code>，导出两个比特币地址的过程；你只要记好<code>satoshi</code>这个单词，就可以在世界上的任何地方，任何时间，掌管发送给<code>1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V</code>和<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>这两个地址的比特币了。</p>

<p>你不需要银行账号，不需要密保卡，只需要有个可以联网的地方，就能秘密发送交易啦。将来有了免费的卫星网络的话，我想你都不用登陆互联网，可能在家里屋顶上架个锅，淘宝买些零件天线DIY一个设备，要转帐的时候，只要输入<code>satoshi</code>就可以秘密完成数亿美元的汇款，而且丝毫不用担心这个账户被政府查封，世界上也只有你一个人能动用这个账户，真是完美的洗钱逃汇工具！也难怪有人说，比特币是人类历史上第一次用技术手段保证了财产的完全私有权。</p>

<p>这个<code>satoshi</code>的seed，就是所谓脑钱包的口令，相对于天书一般的256 bits私钥无疑更好记忆，早期这样的工具非常受欢迎，到现在为止你也可以到这个<a href="https://brainwalletx.github.io/">在线工具</a> 去重复我们以上推导的所有过程。</p>

<p>但是这个方法有个致命的弱点，他的安全性完全取决于seed这个单词的复杂度，像<code>satoshi</code>这样的seed，就像<code>123456</code>的密码一样，不用说大家都知道安全度为0啊。</p>

<p>而且你自以为选取生日啊、姓名缩写啊、恋人海誓山盟的话语啊，这些东西作为seed，其实也是非常脆弱的。总有人孜孜不倦的遍历所有可能的seed。这在后期导致了非常多的hack事件。</p>

<p>截至2018-10，我检索区块链，统计公开的比特币地址已经超过了3亿个，如果有万分之一的地址是由脑钱包生成的话，不安全的地址也超过了3w个，所以后来脑钱包这种方式就不被推荐了。</p>

<p>下面可以列举一些已经公开的seed，这都是我用一些公开语料库随意碰撞出来的，你就知道这种方法的危险性啦：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FINAL_CRACK_ADDRESS: hash160:sha256:seed:address:wif-priv
</span><span class='line'>FINAL_CRACK_ADDRESS:0a8ba9e453383d4561cbcdda36e5789c2870dd41:c:sha256:satoshi:1xm4vFerV3pSgvBFkyzLgT1Ew3HQYrS1V:L4XnHhvLC1b4ag9L2PM9kRicQxUoYT1Q36PQ21YtLNkrAdWZNos6
</span><span class='line'>FINAL_CRACK_ADDRESS:650d0497e014e60d4680fce6997d405de264f042:u:sha256:satoshi:1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE:5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk
</span><span class='line'>FINAL_CRACK_ADDRESS:c71e3a0989754d4ffae45a1c6ef8e348539cd83c:u:sha256:satoshinakamoto:1K9qgN3H2wB2v3LwJEBDbRRJ3znHXEQP4Y:5HqE1vZMMLc7jZRF5wZb79QexyCguNeNdaHLdKTGndvLBrCHD31
</span><span class='line'>FINAL_CRACK_ADDRESS:ec42ad7fd54f931274b83f6137379206e458b106:u:sha256:1satoshi:1NYEM85RpgkSofLqDfwjb21o3MD4ibSo49:5JSGPQ2Jw1P5cVi2L8LeuWnMF5H8rLGrPPgVM2XE1cahG1BQDzY
</span><span class='line'>FINAL_CRACK_ADDRESS:fd8d22e02b3a41bc38f69516c43f7ebd6268e16b:u:sha256:satoshi nakamoto:1Q7f2rL2irjpvsKVys5W2cmKJYss82rNCy:5K7EWwEuJu9wPi4q7HmWQ7xgv8GxZ2KqkFbjYMGvTCXmY22oCbr
</span><span class='line'>FINAL_CRACK_ADDRESS:0000d85a71f305a1c907cdc7437c43b2eecc35e5:u:sha256:CHARINA143:11121ioKu4MCB1LLzPF98AVtzFsEg7UYKm:5JhayTrDhzDHqCg2v16Y2gZWi4kWF6BFoZR3MyaaxWtyKHzKJ8d
</span><span class='line'>FINAL_CRACK_ADDRESS:0002439f087ffefb973c5b9bbd52f509984d3cbe:c:sha256:purple99:113iKJcZeRxEYRVcWNgVxmjodPAisDZ45:KxFLoyseSyVtKGXQNkYBajT8EqviQSuH64Y6GE1g6KXuvcFaSrqc
</span><span class='line'>FINAL_CRACK_ADDRESS:00027a0ef2b9295011b10b089c8caf2e69f6b6f7:u:sha256:bridesmaid:113y6FCRm2WHh5Aru2R7ot37wkNDtxqf3:5JsYc8oXiHBJm9rzRPJHaCSYBBx7KCTx5L81rqRMZBArsdZTsan
</span><span class='line'>FINAL_CRACK_ADDRESS:00030fa763130b5310afe68b12204009e60e935c:u:sha256:masturbating:114fh9qiRhubJJDV5rCthFxmGyYeLQ2B6:5J8TgeF9jU3BPRrsCD75Ks4a6aWxgzLKENDSbsLufDTWq7evCQa
</span><span class='line'>FINAL_CRACK_ADDRESS:0005736b486f87e5823909a89eb48dda185d3956:u:sha256:nitro:117XjTn3UdBNjVo3KsB17WRFDDmcW2pPa:5JkUWsPzNEZEvMFwWQjoXCeem5LL6LDcC7K6H1LWiwXFAA9LFo1
</span><span class='line'>FINAL_CRACK_ADDRESS:00080beae5c3a433fbae8ff0b69e705ac3ce5464:u:sha256:resultantly:11Ae5tbiSZ7QJWh4okWJhDKuPfAvk3a13:5KftjbtsSmhy5Y42AYpfEAm4U4vQKP9VhjbS6xtFqBDhUfAGaFj
</span><span class='line'>FINAL_CRACK_ADDRESS:00083c18c738e883ebc1b5ca270569ee8f9f790e:u:sha256:suggestively:11AsAKWdMZj5ScSYRoAQ8xG4J7Y6s7cW9:5JvrusiSgSmCTV7x7f5vgdWUMLjwk153j9UXmNHvRAJ8m7rtsJD
</span><span class='line'>FINAL_CRACK_ADDRESS:000e4d1774a3fc0251e9e6caf0a8617639e80093:u:sha256:dezoxiribonukleinsav:11J8fK9qhgxdQ96ZvvXExkfFvQSPQiPKN:5KSkRxaAbk94wzzzynDNj2bzRFmJZXCrhtYj3iGU9JjUxnRXTYM
</span><span class='line'>FINAL_CRACK_ADDRESS:00135d1c8f99cc657ad1f246bc5051ad03f95d32:u:sha256:Mussolini:11QCR3sk9r4jeyMqCKGEYabGTfjzhgGdZ:5K2x6UanMSevNX7f19oB4to46C3zXoGTUBGVqv8WNtCRwJNGBGC
</span><span class='line'>FINAL_CRACK_ADDRESS:001ed6fae0af0b37126004029defcc4521b300dd:u:sha256:meagerness:11dwnVzCyGoMZcGDndQteWgR9b7FKsJMu:5JKVJhbZWXmHxj2MuttZCDaFk7TC9KBVYjbPRjztP63mmAUV6Vm
</span><span class='line'>FINAL_CRACK_ADDRESS:002607c11a2311825a087f37c95d7816e0491a9d:u:sha256:vertebrate:11nZPfxYPeDm4d4fd93BaFa1BezFRTP6F:5HsBbgzEXZEaeLRCZHs66ho2ekpFEqeAJyyBPe8YyMkCqCHWv6j
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>不过我们现在已经掌握到了比特币地址的生成原理，所以如何提高安全性就不用我再啰嗦了，相信你心中已有答案。</p>

<h2>那些山寨币们</h2>

<p>比特币项目是2009-01-03正式开始运行的，之后简单的复制一下比特币的代码，稍作修改就推出的山寨币们数不胜数；这些山寨币第一个要修改的，就是地址格式，以免和比特币地址混淆；</p>

<p>怎么修改呢？注意到前面Base58Check Encode的最后一步了吗？那个时候我们需要引入一个前缀作为地址的区分；得益于比特币这种前瞻性的设计，山寨币们只要改动一下这个前缀就可以了，下面列举一下我所知道的山寨币的实现：</p>

<p>引用自:
<a href="https://github.com/walletgeneratornet/WalletGenerator.net">https://github.com/walletgeneratornet/WalletGenerator.net</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>name, networkVersion, privateKeyPrefix, WIF_Start, CWIF_Start
</span><span class='line'>"2GIVE",               0x27, 0xa7, "6",    "R"
</span><span class='line'>"42coin",              0x08, 0x88, "5",    "M"
</span><span class='line'>"Acoin",               0x17, 0xe6, "8",    "b"
</span><span class='line'>"AGAcoin",             0x53, 0xd3, "8",    "Y"
</span><span class='line'>"Alphacoin",           0x52, 0xd2, "8",    "Y"
</span><span class='line'>"Alqo",                0x17, 0xc1, "7",    "V"
</span><span class='line'>"Animecoin",           0x17, 0x97, "6",    "P"
</span><span class='line'>"Anoncoin",            0x17, 0x97, "6",    "P"
</span><span class='line'>"Apexcoin",            0x17, 0x97, "6",    "P"
</span><span class='line'>"Auroracoin",          0x17, 0x97, "6",    "T"
</span><span class='line'>"Aquariuscoin",        0x17, 0x97, "6",    "P"
</span><span class='line'>"Axe",                 0x4B, 0xCB, "7",    "X"
</span><span class='line'>"BBQcoin",             0x55, 0xd5, "6",    "T"
</span><span class='line'>"Biblepay",            0x19, 0xb6, "7",    "[TU]"
</span><span class='line'>"Bitcoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"BitcoinCash",         0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"BitcoinDark",         0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Bitcore",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"BitcoinGold",         0x26, 0x80, "5",    "[LK]"
</span><span class='line'>"Bitconnect",          0x12, 0x92, "5",    "N"
</span><span class='line'>"Birdcoin",            0x2f, 0xaf, "6",    "[ST]"
</span><span class='line'>"BitSynq",             0x3f, 0xbf, "7",    "V"
</span><span class='line'>"BitZeny",             0x51, 0x80, "5",    "[LK]"
</span><span class='line'>"Blackcoin",           0x19, 0x99, "6",    "P"
</span><span class='line'>"BlackJack",           0x15, 0x95, "[56]", "P"
</span><span class='line'>"BlockNet",            0x1a, 0x9a, "6",    "P"
</span><span class='line'>"BolivarCoin",         0x55, 0xd5, "8",    "Y"
</span><span class='line'>"BoxyCoin",            0x4b, 0xcb, "7",    "X"
</span><span class='line'>"BunnyCoin",           0x1a, 0x9a, "6",    "P"
</span><span class='line'>"Cagecoin",            0x1f, 0x9f, "6",    "Q"
</span><span class='line'>"CampusCoin",          0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CanadaeCoin",         0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CannabisCoin",        0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Capricoin",           0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CassubianDetk",       0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"CashCoin",            0x22, 0xa2, "6",    "[QR]"
</span><span class='line'>"Catcoin",             0x15, 0x95, "[56]", "P"
</span><span class='line'>"ChainCoin",           0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"ColossusCoinXT",      0x1e, 0xd4, "5",    "[LK]"
</span><span class='line'>"Condensate",          0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Copico",              0x1c, 0x90, "5",    "N"
</span><span class='line'>"CopperCoin",          0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Corgicoin",           0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"CryptoBullion",       0x0b, 0x8b, "5",    "M"
</span><span class='line'>"CryptoClub",          0x23, 0xa3, "6",    "R"
</span><span class='line'>"Cryptoescudo",        0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Cryptonite",          0x1c, 0x80, "5",    "[LK]"
</span><span class='line'>"CryptoWisdomCoin",    0x49, 0x87, "5",    "[LM]"
</span><span class='line'>"C2coin",              0x1c, 0x9c, "6",    "Q"
</span><span class='line'>"Dash",                0x4c, 0xcc, "7",    "X"
</span><span class='line'>"DeafDollars",         0x30, 0xb0, "6",    "T"
</span><span class='line'>"DeepOnion",           0x1f, 0x9f, "6",    "Q"
</span><span class='line'>"Deutsche eMark",      0x35, 0xb5, "7",    "T"
</span><span class='line'>"Devcoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"DigiByte",            0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"Digitalcoin",         0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"Dimecoin",            0x0f, 0x8f, "5",    "N"
</span><span class='line'>"DNotes",              0x1f, 0x9f, "6",    "Q"
</span><span class='line'>"Dogecoin",            0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"DogecoinDark",        0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"eGulden",             0x30, 0xb0, "6",    "T"
</span><span class='line'>"eKrona",              0x2d, 0xad, "6",    "S"
</span><span class='line'>"ELECTRA",             0x21, 0xa1, "6",    "Q"
</span><span class='line'>"Ember",               0x5c, 0x32, "2",    "8"
</span><span class='line'>"Emerald",             0x22, 0xa2, "6",    "[QR]"
</span><span class='line'>"Emercoin",            0x21, 0x80, "5",    "[LK]"
</span><span class='line'>"EnergyCoin",          0x5c, 0xdc, "8",    "Z"
</span><span class='line'>"Espers",              0x21, 0x90, "5",    "N"
</span><span class='line'>"Fastcoin",            0x60, 0xe0, "8",    "a"
</span><span class='line'>"Feathercoin",         0x0e, 0x8e, "5",    "N"
</span><span class='line'>"Fedoracoin",          0x21, 0x80, "5",    "[KL]"
</span><span class='line'>"Fibre",               0x23, 0xa3, "6",    "R"
</span><span class='line'>"Florincoin",          0x23, 0xb0, "6",    "T"
</span><span class='line'>"Flurbo",              0x23, 0x30, "6",    "8"
</span><span class='line'>"Fluttercoin",         0x23, 0xa3, "6",    "R"
</span><span class='line'>"FrazCoin",            0x23, 0xA3, "6",    "R"
</span><span class='line'>"Freicoin",            0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"FUDcoin",             0x23, 0xa3, "6",    "R"
</span><span class='line'>"Fuelcoin",            0x24, 0x80, "5",    "[KL]"
</span><span class='line'>"Fujicoin",            0x24, 0xa4, "6",    "R"
</span><span class='line'>"GabenCoin",           0x10, 0x90, "5",    "N"
</span><span class='line'>"Garlicoin",           0x26, 0xb0, "6",    "T"
</span><span class='line'>"GlobalBoost",         0x26, 0xa6, "6",    "R"
</span><span class='line'>"Goodcoin",            0x26, 0xa6, "6",    "R"
</span><span class='line'>"GridcoinResearch",    0x3e, 0xbe, "7",    "V"
</span><span class='line'>"Gulden",              0x26, 0xa6, "6",    "R"
</span><span class='line'>"Guncoin",             0x27, 0xa7, "6",    "R"
</span><span class='line'>"HamRadioCoin",        0x00, 0x80, "5",    "LK"
</span><span class='line'>"HFRcoin",             0x10, 0x90, "5",    "N"
</span><span class='line'>"HOdlcoin",            0x28, 0xa8, "5",    "[LK]"
</span><span class='line'>"HTMLCoin",            0x29, 0xa9, "6",    "S"
</span><span class='line'>"HyperStake",          0x75, 0xf5, "9",    "d"
</span><span class='line'>"ImperiumCoin",        0x30, 0xb0, "6",    "T"
</span><span class='line'>"IncaKoin",            0x35, 0xb5, "7",    "T"
</span><span class='line'>"IncognitoCoin",       0x00, 0x80, "5",    "LK"
</span><span class='line'>"Influxcoin",          0x66, 0xe6, "8",    "b"
</span><span class='line'>"Innox",               0x4b, 0xcb, "7",    "X"
</span><span class='line'>"IridiumCoin",         0x30, 0xb0, "6",    "T"
</span><span class='line'>"iCash",               0x66, 0xcc, "7",    "X"
</span><span class='line'>"iXcoin",              0x8a, 0x80, "5",    "[LK]"
</span><span class='line'>"Judgecoin",           0x2b, 0xab, "6",    "S"
</span><span class='line'>"Jumbucks",            0x2b, 0xab, "6",    "S"
</span><span class='line'>"KHcoin",              0x30, 0xb0, "6",    "T"
</span><span class='line'>"KittehCoin",          0x2d, 0xad, "6",    "S"
</span><span class='line'>"Lanacoin",            0x30, 0xb0, "6",    "T"
</span><span class='line'>"Latium",              0x17, 0x80, "5",    "[LK]"
</span><span class='line'>"LBRY Credits",        0x55, 0x80, "5",    "[LK]"
</span><span class='line'>"Litecoin",            0x30, 0xb0, "6",    "T"
</span><span class='line'>"LiteDoge",            0x5a, 0xab, "6",    "S"
</span><span class='line'>"LoMoCoin",            0x30, 0xb0, "6",    "T"
</span><span class='line'>"MadbyteCoin",         0x32, 0x6e, "4",    "H"
</span><span class='line'>"MagicInternetMoney",  0x30, 0xb0, "6",    "T"
</span><span class='line'>"Magicoin",            0x14, 0x94, "5",    "[NP]"
</span><span class='line'>"Marscoin",            0x32, 0xb2, "6",    "T"
</span><span class='line'>"MarteXcoin",          0x32, 0xb2, "6",    "T"
</span><span class='line'>"MasterDoge",          0x33, 0x8b, "5",    "M"
</span><span class='line'>"Mazacoin",            0x32, 0xe0, "8",    "a"
</span><span class='line'>"Megacoin",            0x32, 0xb2, "6",    "T"
</span><span class='line'>"MintCoin",            0x33, 0xb3, "[67]", "T"
</span><span class='line'>"MobiusCoin",          0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"MonetaryUnit",        0x10, 0x7e, "5",    "K"
</span><span class='line'>"Monocle",             0x32, 0xb2, "6",    "T"
</span><span class='line'>"MoonCoin",            0x03, 0x83, "5",    "L"
</span><span class='line'>"Myriadcoin",          0x32, 0xb2, "6",    "T"
</span><span class='line'>"NameCoin",            0x34, 0x80, "5",    "[LK]"
</span><span class='line'>"Navcoin",             0x35, 0x96, "6",    "P"
</span><span class='line'>"NeedleCoin",          0x35, 0xb5, "7",    "T"
</span><span class='line'>"NEETCOIN",            0x35, 0xb5, "7",    "T"
</span><span class='line'>"NYC",                 0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Neoscoin",            0x35, 0xb1, "6",    "T"
</span><span class='line'>"Nevacoin",            0x35, 0xb1, "6",    "T"
</span><span class='line'>"Novacoin",            0x08, 0x88, "5",    "M"
</span><span class='line'>"Nubits",              0x19, 0xbf, "7",    "V"
</span><span class='line'>"Nyancoin",            0x2d, 0xad, "6",    "S"
</span><span class='line'>"Ocupy",               0x73, 0xf3, "9",    "[cd]"
</span><span class='line'>"Omnicoin",            0x73, 0xf3, "9",    "[cd]"
</span><span class='line'>"Onyxcoin",            0x73, 0xf3, "9",    "[cd]"
</span><span class='line'>"PacCoin",             0x18, 0x98, "6",    "P"
</span><span class='line'>"Particl",             0x38, 0x6c, "4",    "[HG]"
</span><span class='line'>"Paycoin",             0x37, 0xb7, "7",    "U"
</span><span class='line'>"Pandacoin",           0x37, 0xb7, "7",    "U"
</span><span class='line'>"ParkByte",            0x37, 0xb7, "7",    "U"
</span><span class='line'>"Peercoin",            0x37, 0xb7, "7",    "U"
</span><span class='line'>"Pesetacoin",          0x2f, 0xaf, "6",    "[ST]"
</span><span class='line'>"PHCoin",              0x37, 0xb7, "7",    "U"
</span><span class='line'>"PhoenixCoin",         0x38, 0xb8, "7",    "U"
</span><span class='line'>"PiggyCoin",           0x76, 0xf6, "9",    "d"
</span><span class='line'>"Pinkcoin",            0x3,  0x83, "[RQP]","L"
</span><span class='line'>"PIVX",                0x1e, 0xd4, "8",    "Y"
</span><span class='line'>"Peercoin",            0x37, 0xb7, "7",    "U"
</span><span class='line'>"Potcoin",             0x37, 0xb7, "7",    "U"
</span><span class='line'>"Primecoin",           0x17, 0x97, "6",    "P"
</span><span class='line'>"ProsperCoinClassic",  0x3a, 0xba, "7",    "Q"
</span><span class='line'>"Quark",               0x3a, 0xba, "7",    "U"
</span><span class='line'>"Qubitcoin",           0x26, 0xe0, "8",    "a"
</span><span class='line'>"Reddcoin",            0x3d, 0xbd, "7",    "[UV]"
</span><span class='line'>"Riecoin",             0x3c, 0x80, "5",    "[LK]"
</span><span class='line'>"Rimbit",              0x3c, 0xbc, "7",    "U"
</span><span class='line'>"ROIcoin",             0x3c, 0x80, "5",    "[LK]"
</span><span class='line'>"Rubycoin",            0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Rupaya",              0x3c, 0xbc, "7",    "U"
</span><span class='line'>"Sambacoin",           0x3e, 0xbe, "7",    "V"
</span><span class='line'>"SecKCoin",            0x3f, 0xbf, "7",    "V"
</span><span class='line'>"SibCoin",             0x3f, 0x80, "5",    "[LK]"
</span><span class='line'>"SixEleven",           0x34, 0x80, "5",    "[LK]"
</span><span class='line'>"SmileyCoin",          0x19, 0x99, "6",    "P"
</span><span class='line'>"SongCoin",            0x3f, 0xbf, "7",    "V"
</span><span class='line'>"SpreadCoin",          0x3f, 0xbf, "7",    "V"
</span><span class='line'>"StealthCoin",         0x3e, 0xbe, "7",    "V"
</span><span class='line'>"Stratis",             0x3f, 0xbf, "7",    "V"
</span><span class='line'>"SwagBucks",           0x3f, 0x99, "6",    "P"
</span><span class='line'>"Syscoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"Tajcoin",             0x41, 0x6f, "6",    "H"
</span><span class='line'>"Terracoin",           0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"Titcoin",             0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"TittieCoin",          0x41, 0xc1, "7",    "V"
</span><span class='line'>"Topcoin",             0x42, 0xc2, "7",    "V"
</span><span class='line'>"TransferCoin",        0x42, 0x99, "6",    "P"
</span><span class='line'>"TreasureHuntCoin",    0x32, 0xb2, "6",    "T"
</span><span class='line'>"TrezarCoin",          0x42, 0xC2, "7",    "V"
</span><span class='line'>"Unobtanium",          0x82, 0xe0, "8",    "a"
</span><span class='line'>"USDe",                0x26, 0xa6, "6",    "R"
</span><span class='line'>"Vcash",               0x47, 0xc7, "7",    "W"
</span><span class='line'>"Versioncoin",         0x46, 0xc6, "7",    "W"
</span><span class='line'>"VergeCoin",           0x1e, 0x9e, "6",    "Q"
</span><span class='line'>"Vertcoin",            0x47, 0x80, "5",    "[LK]"
</span><span class='line'>"Viacoin",             0x47, 0xc7, "7",    "W"
</span><span class='line'>"VikingCoin",          0x46, 0x56, "3",    "D"
</span><span class='line'>"W2Coin",              0x49, 0xc9, "7",    "W"
</span><span class='line'>"WACoins",             0x49, 0xc9, "7",    "W"
</span><span class='line'>"WankCoin",            0x00, 0x80, "5",    "[LK]"
</span><span class='line'>"WeAreSatoshiCoin",    0x87, 0x97, "6",    "P"
</span><span class='line'>"WorldCoin",           0x49, 0xc9, "7",    "W"
</span><span class='line'>"XP",                  0x4b, 0xcb, "7",    "X"
</span><span class='line'>"Yenten",              0x4e, 0x7b, "5",    "K"
</span><span class='line'>"Zcash",        [0x1c,0xb8], 0x80, "5",    "[LK]"
</span><span class='line'>"Zetacoin",            0x50, 0xE0, "8",    "a"
</span><span class='line'>"Testnet Bitcoin",     0x6f, 0xef, "9",    "c"
</span><span class='line'>"Testnet Dogecoin",    0x71, 0xf1, "9",    "c"
</span><span class='line'>"Testnet MonetaryUnit",0x26, 0x40, "3",    "A"
</span><span class='line'>"Testnet PIVX",        0x8b, 0xef, "9",    "c"
</span><span class='line'>"Testnet WACoins",     0x51, 0xd1, "8",    "[XY]"
</span></code></pre></td></tr></table></div></figure>


<p>哈哈，洋洋大观啊。这也说明了folk一个山寨币的成本是如何的低；然后有了以太坊的ERC20之后，发一个新币的成本简直低到令人发指，也无怪乎场子里面骗子横行了。</p>

<h2>以太坊的地址生成</h2>

<p>Ethereum项目是不走寻常路的，他作为比特币之后最具创新性的后辈，地址设计反而简单的多。</p>

<p>直到生成公钥这一步，以太坊和比特币都是一致的，采用了secp256k1算法，只是最后的地址生成以太坊很简洁，直接Keccak256 hash，然后取最后的40位16进制字符得到的。</p>

<p>为什么比特币实现复杂呢？这是因为比特币的交易是以UTXO为核心的，每个UTXO包含其所有者及价值信息，系统中的每一笔的交易由若干UTXO输入和若干UTXO输出组成。UTXO无法只提取部分，每次必须完整的使用，这有点像我们生活现实中的现金。比特币系统中，一个用户的“余额”是该用户的私钥能够有效签名的所有UTXO的总和。要深刻的理解这一点，还需要我们了解了比特币的交易数据构成之后才能探讨。我们后面会写文章解释这一点啦。</p>

<p>而以太坊采用了与比特币不同的实现方式——账户，类似我们生活中的银行卡。以账户为核心的设计比较节省空间,而且以太坊的block组织更为精巧。另外，以太坊的设计目标和比特币是不同的：</p>

<ul>
<li>首先以太坊的账户除了普通的收发币的账户(俗称外部账户EOA)，还有合约账户，合约账户需要一个固定的地址，不然每次调用合约都会很麻烦；这样就要求以太坊的合约账户不像比特币交易那样频繁的更换地址；</li>
<li>他并不执着于强迫用户去注意隐私问题，以太坊的态度是，如果用户注重隐私问题，你就自己搞定；你需要通过合约中的签名数据包协议来建立一个加密“混合器”进行加密。</li>
<li>总之以太坊因为要实现的目标更为宏大，他的设计理念是根据最初的用户都是一群Geek们来建立的；Geek们最喜欢啥？就是不要过度设计，让我来自己搞定</li>
</ul>


<p>所以在以太坊系统中，账户是一个20字节的地址，他关联的信息包含四个部分：</p>

<ol>
<li><p>随机数，用于确定每笔交易只能被处理一次的计数器</p></li>
<li><p>账户目前的以太币余额</p></li>
<li><p>账户的合约代码，如果有的话</p></li>
<li><p>账户的存储（默认为空）</p></li>
</ol>


<p>可以采用<a href="https://github.com/ethereum/pyethereum">pyethereum</a>这个库，用以下代码模拟以太坊地址的生成:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># -*- coding: utf-8 -*-
</span><span class='line'>
</span><span class='line'>"""doctopt ethereum address generate tools
</span><span class='line'>
</span><span class='line'>Usage:
</span><span class='line'>  genaddr.py p2addr         &lt;private&gt;
</span><span class='line'>  genaddr.py word2addr      &lt;word&gt;
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -h --help                                             Show this screen.
</span><span class='line'>  --version                                             Show version.
</span><span class='line'>
</span><span class='line'>Example:
</span><span class='line'>
</span><span class='line'>    genaddr.py p2addr 6bd3b27c591                                         # gen address from private 0x6bd3b27c591=&gt;1PiFuqGpG8yGM5v6rNHWS3TjsG6awgEGA1
</span><span class='line'>    genaddr.py word2addr 'Money is the root of all evil.'                 # gen address from private wordlist
</span><span class='line'>
</span><span class='line'>"""
</span><span class='line'>
</span><span class='line'>from docopt import docopt
</span><span class='line'>
</span><span class='line'>import os
</span><span class='line'>import sys
</span><span class='line'>from ethereum import utils
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    arguments = docopt(__doc__, version='1.0')
</span><span class='line'>
</span><span class='line'>    if arguments['p2addr']:
</span><span class='line'>        private_key = bytes.fromhex(arguments['&lt;private&gt;'])
</span><span class='line'>        passpharse = b'unknown'
</span><span class='line'>
</span><span class='line'>    elif arguments['word2addr']:
</span><span class='line'>        passpharse = arguments['&lt;word&gt;'].encode('utf-8')
</span><span class='line'>        private_key = utils.sha3(passpharse)
</span><span class='line'>
</span><span class='line'>    raw_address = utils.privtoaddr(private_key)
</span><span class='line'>    account_address = utils.checksum_encode(raw_address)
</span><span class='line'>    print("word:{}:private:{}:address:{}".format(passpharse.decode('utf-8'), private_key.hex(), account_address))
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; python genaddr.py word2addr 'hello'
</span><span class='line'>
</span><span class='line'>word:hello:private:1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8:address:0x5ccfa55C29F0522f062E3C15004E35a69dD45F6B</span></code></pre></td></tr></table></div></figure>


<p>以太坊账户方式的一个弱点是：为了阻止重放攻击，每笔交易必须有nonce。这就使得账户需要跟踪nonce的使用情况。而且，不再使用的账户，无法从账户状态中移除。</p>

<p>关于重放攻击，我们会在后面说明。</p>

<h2>重放攻击</h2>

<p>在网络中重放攻击是一种很常见的hack方式，关于相关攻防有足够丰富的案例；但是在区块链历史上却是一个悲伤的故事；在此我们用一点点篇幅回忆一下区块链上第一次大规模的重放攻击(replay Attack)。</p>

<h4>缘起</h4>

<p>众所周知，以太坊作为<code>智能合约</code>的首创者，在区块链技术史上是继比特币之后最大的创新。在V神于2015-07-30正式推出运行后，立即吸引了众多Geek来探究如何实现白皮书中所说的去中心化程序。其中最受关注的就是2016-04-30日开始募资的<a href="https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413">The DAO</a>项目。</p>

<p>关于这个项目的始末，实在是槽点满满。即使已经两年后的今天，估计你去搜索这起著名的事件，非码农人士也很难搞明白。简而言之，就是<code>The DAO</code>作为一个去中心化的项目基金会开始募资，令人觉得神奇的是，这个项目背后没有一个控制人！即使这个项目筹到一大笔钱，也没有一个人有权利单独动用它，只能所有投资人投票才能决定资金的使用，这是写在区块链代码上的铁律，这就是去中心化的魅力！</p>

<p>但是一个没有控制人，没有开发目标，拿到了钱也不知道今后要干啥的项目组织，说要募资了，然后人们纷纷掏钱买股权，是不是很神奇！</p>

<p>咱们说传销还得有个愿景呢！但是当时<code>去中心化程序</code>的概念横空出世，官网页面美轮美奂，诸多<code>专家</code>纷纷发表晦涩难懂的高大上文章齐赞<code>The DAO</code>的历史意义，就在那种巨大的泡沫环境中，人们害怕的是错过发财的上车机会，于是根本搞不明白这是个什么东西，就慷慨解囊。</p>

<p>你可能觉得好笑，可是看看今天，那些所谓的高大上的区块链项目，所谓的伟大愿景，那些山寨币，那些要颠覆这颠覆那的各路神仙，和当时何其相似！熙熙攘攘的投资人群中，有几人能花时间去搞明白比特币和以太坊的白皮书？</p>

<p>所谓的区块链技术的发展，充斥着贪婪和诈骗。就和人性一样。</p>

<h4>崩溃</h4>

<p>同样，人类的愚蠢也是不变的，贪婪之下，BUG是无法避免的。</p>

<p>截至2016-05-15，<code>The DAO</code>项目的合约募集了大约当时价值约1.5亿美元Ether，占当时Ether发行总量的15%。讽刺的是，这个项目募集了巨大的金额，却没有一个像样的专家去做一个合约代码安全审计！</p>

<p>终于，THE DAO创始人之一Stephan Tual发现其合约代码有部分缺陷，他于6月12日宣布，他们发现了软件中存在的“递归调用漏洞”问题，不过对DAO资金来说则不会出现风险。讽刺的是还是没有多少人注意到这个问题。</p>

<p>2016-06-17，一名黑客在编码上发现了真正的漏洞，使得他可以从<code>The Dao</code>上抽走资金。在攻击的头几个小时，360万的Ether被转出，在当时价值相当于七千万美元。当时引起的混乱可想而知，社区采用紧急措施冻结了所有的币，但是只要以太坊的根基代码不变，就无法阻止黑客取现这些财富。</p>

<p>你可以想象当时那些投资人的反应，有人气急败坏要求以太坊开发团队立即采取措施，作废黑客的攻击行为，回退区块链并退回所有投资人的Ether。</p>

<p>而真正的区块链信徒认为<code>代码即正义、代码即法律</code>，传统世界中的法律不能应用到cyberpunk世界中，即使是黑客的盗窃行为，也理应收到这种正义保护！回退作废Block的行为其实就是否认区块链的技术意义，它会毁灭以太坊项目。</p>

<p>你可以想象，当你损失了几十万美元，对面的一群码农却做出这种<code>奇谈怪论</code>，肯定是想砍人的心都有了。当时的各路利益纠葛者吵了一个翻天覆地。甚至黑客本人也跳出来发表了一通公开信，先为自己的盗窃行为辩护一番，然后承诺只要社区不回退，就会返还一部分金额。整个事件好一场精彩大戏。</p>

<h4>分裂</h4>

<p>经历了无休止的利益、法律、技术等等辩论后，以太坊社区分裂了。争论的结果就是诞生了ETH Classic (即ETC)项目；一批坚持<code>代码即正义</code>者分裂出来创造了ETH Classic 网络，这个项目称自己才是真正的以太坊，并承认黑客的攻击行为且继续将这条链运行下去。而现在仍旧运行的Ethereum网络保护了投资者的利益，做出了妥协；</p>

<p>这个分叉开启于Ethereum网络Block编号为<a href="https://gastracker.io/block/0x94365e3a8c0b35089c1d1195081fe7489b528a84b22199c916180db8b28ade7f">1920000</a>区块。</p>

<p>这是世界上第一次公开的人为的区块链分叉事件。但是好戏才刚刚开始。</p>

<h4>重放攻击</h4>

<p>以太坊硬分叉出现了ETH和ETC两条链，两条链上的交易数据结构是完全一样的，因此一笔交易在ETH上是有效的， 那它在ETC上同样会被接受，反之亦然。 因为当时所有人都认为ETC将不会再存在，所以分叉前没人意识到两条链会产生相互重放问题。 后来还有许多矿工继续在维持ETC链时， 大家发现在ETH链上的交易拿到ETC链继续重放（广播）仍然是有效的。</p>

<p>因为没经验，以太坊分叉时几乎所有交易所也都没意识到这个问题，更没有提前做ETH和ETC分离， 这时候只要有人从交易所提取ETH币，就有可能得到同等数量的ETC币。许多人利用这个漏洞，不断在交易所充币和提币（ETH）， 从而获取额外的ETC。 当时云币、BTC-E等交易所发布说自己被重放攻击了，被骗取了几乎所有ETC。“重放攻击”也就此闻名于币圈。</p>

<p>解决这个问题也很简单，或者就是两边的原始交易数据要有所区别:</p>

<ul>
<li>或者地址前缀做一下改动</li>
<li>或者交易数据签名增加一个标志</li>
</ul>


<p>因为以太坊地址没有像比特币一样的前缀，ETC和ETH社区经过讨论，简单的提出了<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">EIP-155</a> 作为解决方案。简而言之，就是判断分叉的区块编号，引入一个CHAIN ID新值来解决这个问题。</p>

<p>耐人寻味的是，Ethereum团队此时对于ETC分叉的态度是支持的。就像中本聪早期提到的那样，没有一个人可以集权控制一条链，算力说话。因此ETC活了下来。也因为以太坊的创始人Vitalik Buterin是个非常年轻的天才，整个开发团队洋溢着一种骑士精神;他们对于自由竞争出生的ETC非常包容，不管将来结果如何，我认为这种态度是非常了不起的。</p>

<p>当然，个人感情的说一下。此事说明了投资所谓的区块链项目，究竟有多大的风险！以太坊基础代码有许多人审核，有一定的安全保证，但是形形色色的智能合约就不好说了。后来像DAO一样的hack事件数不胜数！</p>

<p>我得说，当你想要投资一个所谓<code>未来项目</code>时，除了你自己的知识和判断，没有任何一个人是可信的！我是说，只能靠自己，其他任何人，甚至创始者的意见也不可信。</p>

<h2>Bitcoin Cash地址生成</h2>

<p>关于Bitcoin Cash的诞生，其过程之离奇曲折，胜过ETH分叉百倍。这是一个比最精彩的侦探小说还要反转反转再反转的故事。</p>

<p>不过我们就不要讲故事了，总之Bitcoin Cash分叉诞生后，为了和传统的Bitcoin地址相区别，自己又做了一下改动。</p>

<p>快速看看BCH新老地址的对比：</p>

<ol>
<li><p>新地址是和老地址一一对应的，它们对应了同一个私钥，只是换了种写法</p></li>
<li><p>新地址可以发送余额给老地址，老地址可以发送余额到新地址</p></li>
<li><p>新地址是大小写不敏感的，可以全部转成大写，也可以全部转成小写，优先小写格式，同一地址不能大小写混用</p></li>
<li><p>新地址的前缀可写可不写，老地址没有前缀，通过首字符来标识类型</p></li>
<li><p>新地址用base32编码，老地址用base58编码</p></li>
</ol>


<p>官方文档描述参见<a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md">这里</a>，让我们从seed <code>satoshi</code> 生成一个bitcoin cash 地址演示一遍。</p>

<h4>规范</h4>

<p>新的bitcoin cash地址是由：</p>

<ul>
<li>能够表示该地址有效的网络的前缀，一般为主网(bitcoincash)、测试网(bchtest)、回归测试网(bchreg)三种。</li>
<li>一个分隔符：<code>:</code></li>
<li>一个base32编码的payload，表示这个地址的目的地和包含的checksum（校验和）。</li>
</ul>


<h4>Payload</h4>

<p>payload是base32编码的数据流，由三个元素组成:</p>

<ul>
<li>指示地址字节的版本类型</li>
</ul>


<p>共8bits, 1bit(0) + 4bits (地址类型：Type bits) + 3bits (hash长度：Size bits)</p>

<table>
<thead>
<tr>
<th>Type bits (二进制) </th>
<th> 地址类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 </td>
<td> P2PKH</td>
</tr>
<tr>
<td>1000 </td>
<td> P2SH</td>
</tr>
<tr>
<td>0000 </td>
<td> P2PKH-TESTNET</td>
</tr>
<tr>
<td>1000 </td>
<td> P2SH-TESTNET</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th>Size bits (二进制) </th>
<th> 代表hash长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>000 </td>
<td> 160</td>
</tr>
<tr>
<td>001 </td>
<td> 192</td>
</tr>
<tr>
<td>010 </td>
<td> 224</td>
</tr>
<tr>
<td>011 </td>
<td> 256</td>
</tr>
<tr>
<td>100 </td>
<td> 320</td>
</tr>
<tr>
<td>101 </td>
<td> 384</td>
</tr>
<tr>
<td>110 </td>
<td> 448</td>
</tr>
<tr>
<td>111 </td>
<td> 512</td>
</tr>
</tbody>
</table>


<ul>
<li>一个hash值</li>
</ul>


<p>hash含义取决于版本字段。它是表示数据的hash，即P2KH的pubkey hash和P2SH的reedemScript哈希。这个可以直接从BTC地址里面推出，这个hash值导出后需要用40Bits的BCH码来表示，这样做之后，地址大小写不敏感。</p>

<ul>
<li>一个40字节的校验和</li>
</ul>


<p>这个校验和的计算比较繁琐，它是在GF（2 ^ 5）上定义的40bits的BCH码，校验和根据以下代码计算：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>uint64_t PolyMod(const data &v) {
</span><span class='line'>    uint64_t c = 1;
</span><span class='line'>    for (uint8_t d : v) {
</span><span class='line'>        uint8_t c0 = c &gt;&gt; 35;
</span><span class='line'>        c = ((c & 0x07ffffffff) &lt;&lt; 5) ^ d;
</span><span class='line'>        
</span><span class='line'>        if (c0 & 0x01) c ^= 0x98f2bc8e61;
</span><span class='line'>        if (c0 & 0x02) c ^= 0x79b76d99e2;
</span><span class='line'>        if (c0 & 0x04) c ^= 0xf33e5fb3c4;
</span><span class='line'>        if (c0 & 0x08) c ^= 0xae2eabe2a8;
</span><span class='line'>        if (c0 & 0x10) c ^= 0x1e4f43e470;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return c ^ 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>具体的规则可以详细参考<a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md">这里</a>。</p>

<h4>地址转换生成</h4>

<ul>
<li>1.取<code>satoshi</code> 生成的非压缩地址<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code></li>
<li>2.这个地址是一个主网地址，前缀为<code>bitcoincash:xxxxx</code></li>
<li>3.这个地址类型为<code>P2PKH</code>，version_bits为0000</li>
<li>4.<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>进行base58 Decode，去掉末尾的4字节checksum，得到的hash值用list表示</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>payload = [101, 13, 4, 151, 224, 20, 230, 13, 70, 128, 252, 230, 153, 125, 64, 93, 226, 100, 240, 66]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5.加入version前缀</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>payload = [0, 101, 13, 4, 151, 224, 20, 230, 13, 70, 128, 252, 230, 153, 125, 64, 93, 226, 100, 240, 66]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>6.将hash进行8bits->5bits BCH码的转换</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>payload = [0, 1, 18, 16, 26, 1, 4, 23, 28, 0, 10, 14, 12, 3, 10, 6, 16, 3, 30, 14, 13, 6, 11, 29, 8, 1, 14, 30, 4, 25, 7, 16, 8, 8]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>7.计算校验和</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checksum=[24, 25, 19, 1, 12, 3, 18, 8]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>8.对payload + checksum进行base32编码，得到<code>qpjs6pyhuq2wvr2xsr7wdxtagpw7ye8sggcenpvrjg</code></li>
<li>9.加入前缀<code>bitcoincash:</code>，组合得到最后地址<code>bitcoincash:qpjs6pyhuq2wvr2xsr7wdxtagpw7ye8sggcenpvrjg</code></li>
</ul>


<p>有许多在线转换工具可以验证，比如:</p>

<p><a href="https://bch.btc.com/tools/address-converter">https://bch.btc.com/tools/address-converter</a></p>

<h2>总结</h2>

<p>以上长篇大论了比特币系统的地址是如何生成的，当然我们也略过了许多细节，比如钱包如何加salt，如何加passphrase等等，这些直接去读BIP 规范更为精确；但是一个完整的钱包，可不仅仅是要解决地址生成这个问题，还要能方便的管理私钥。</p>

<p>在比特币早期，私钥的管理是非常粗暴的，就是每次创建新钱包时，系统自动随机生成100个私钥，然后随着用户交易增多用光之后，再生成100个私钥；钱包文件就是一个二进制文件，即使加了密码保护，也很容易暴力破解泄密；</p>

<p>这导致了无穷多的hack事件；不管你信不信，初期很多从事比特币交易的网站，其wallet.dat文件就明晃晃的放在服务器上，管理员粗心大意，完全可以形容为 <code>没头脑+不高兴</code>，很多人连个最基本的密码保护也不设置；另外也发生过很多悲剧的<code>rm -rf</code>事件，我认为由于这样的失误导致的比特币丢失至少在100w+ 币的级别；换算今天的汇率，你能相信有个银行将数亿美元现金的保险柜不加锁，明晃晃的摆在大堂上摆阔吗？</p>

<p>在一连串的悲剧事件中(具体是哪些悲剧可以写一本书哦)，作为登峰造极者，mtgox当之无愧！ 80多万个比特币的丢失，史上独一份。这个交易所的老板也是心大，80w+币的钱包密码也不设置一个，就在那里任由黑客予取予求；还不是一天两天哦，是持续好几周的hack事件！</p>

<p>mtgox是比特币历史上巨大的迷雾，他不光牵扯到许多比特币的早期玩家，还有BTC-E, FBI牵涉其中，我认为这是仅次于<code>中本聪到底何方神圣</code>的谜题。所幸法胖还活着，我希望有生之年能读到这个事件的完整披露。</p>

<p>好了，假如你是一个交易所的老板，你会很快发现自己面临着以下问题：</p>

<ul>
<li>不需要给每个用户的账户都建立一个钱包文件，我希望能有一个总的账户管理方案</li>
<li>可能交易所有1000个大户，你希望他们的钱包是冷存储的，提币的时候他们可以耐心等一段时间，但是剩下的100000个普通用户的账户就要存放到一个热钱包上，只留有部分资产来应付流动性</li>
<li>有很多部门需要批准获取一些资金，比如研发要用来做测试，市场部门要用来搞活动等等</li>
<li>最后，私钥最好只能由少数人，最好只有我本人来掌握，不然私钥的传播过程中，随便一个人就能让你万劫不复</li>
<li>我如果有一些合伙人的话，肯定也希望能掌管一部分资金</li>
<li>如果有突发情况，我能迅速把公司账上所有的币都转移到另外一个安全的账户上，这有可能是要迅速完成上万笔的交易转移</li>
<li>最后，我希望所有的交易，签署和广播是在不同的机器上进行的，存有私钥的机器不能联网，这台机器签名完毕后，调用远端的服务端广播交易，这样完全实现钱包的冷隔离</li>
</ul>


<p>好啦，假如我们现在只有前面那种一个wallet.dat钱包的管理方案，要怎么做呢？</p>

<p>很明显的，这种管理太粗糙了。社区们经过不断的探索，提出了BIP-32，BIP-39，BIP-44等规范，以绝妙的办法解决了这些问题。这就是比特币HD钱包的由来。同时这些规范不仅仅适用于比特币系统，还适用于所有的电子货币方案，也许今后，你可以同时在一个钱包里管理你的ETH, BTC, 支付宝余额等等~~~</p>

<p>那到底要怎么做呢？</p>

<p>我们已经探索了这么远，估计你也不耐烦了，但是我们还要说，这还早的很呢！那么下次文章再见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoin-cli Cheat]]></title>
    <link href="https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat/"/>
    <updated>2018-10-26T16:28:23+08:00</updated>
    <id>https://happy123.me/blog/2018/10/26/bitcoin-cli-cheat</id>
    <content type="html"><![CDATA[<p>今天踩了一个巨坑。</p>

<p>我一直以为<code>bitcoin-cli sendfrom</code>命令是可以花费uncomfirmed UTXO的。</p>

<!-- more -->


<p>然后今天发现bitcoin-core 0.17版本已经开始废弃这个命令和<code>bitcoin account</code>的支持了。于是去修改万年之前的一个脚本。</p>

<p>然后我切换到TESTNET里面发了几笔交易，惊奇的发现sendfrom并不能花费uncomfirmed UTXO。执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; bitcoin-cli sendfrom "" "1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd" 0.01 0</span></code></pre></td></tr></table></div></figure>


<p>明明我已经发给测试账户0.1BTC过去了，getwalletinfo可以看到这个币了，我也把minconf设为0了，却在执行sendfrom的时候总是提示我<code>Account has insufficient funds</code>；</p>

<p>我一路代码追下去，在这里:</p>

<p><a href="https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915">https://github.com/bitcoin/bitcoin/blob/e44150feed53317677b1e2073f3cb0cfc67b691c/src/wallet/rpcwallet.cpp#L915</a></p>

<p>惊奇的发现只有自己的找零才会在uncomfirmed的情况下被计入credit fund，震惊了。我这个脚本运行了半年了，才发现这个坑。</p>

<p>没办法，自己又封装了一遍<code>createrawtransaction</code>，<code>signrawtransaction</code>, <code>sendrawtransaction</code>，来代替sendfrom的功能。</p>

<p>找这个问题我在TESTNET里面发了不下一百笔交易，wallet部分的代码已经翻遍了，我深深为之感叹bitcoin core实现wallet这部分的精巧，好多地方的细节已经不是人类能理解的了；太可怕了。</p>

<p>另外记一下远程调用bitcoind rpc接口的套路:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;bitcoin_cli --rpcconnect=192.168.2.7 --rpcpassword="xxxxx" --rpcuser=test getwalletinfo</span></code></pre></td></tr></table></div></figure>


<p>相应的，bitcoin.conf也要允许远端调用rpc接口的权限:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=test
</span><span class='line'>rpcpassword=xxxxx
</span><span class='line'>rpcallowip=192.168.2.0/255.255.255.0
</span><span class='line'>rpcport=8332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span></code></pre></td></tr></table></div></figure>


<p>ps: bitcoin.conf 可以直接放到blockchain的数据目录，反正我看0.15的代码，已经把这个路径默认加到path搜索里面了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-1]]></title>
    <link href="https://happy123.me/blog/2018/10/23/bi-te-bi-de-hdqian-bao-yan-hua-1/"/>
    <updated>2018-10-23T18:49:26+08:00</updated>
    <id>https://happy123.me/blog/2018/10/23/bi-te-bi-de-hdqian-bao-yan-hua-1</id>
    <content type="html"><![CDATA[<h2>密钥分发的问题</h2>

<p>在之前我们的一篇文章<a href="https://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/">加密技术发展</a> 中提到了一个经典的问题:</p>

<!-- more -->


<ul>
<li><p>Alice和Bob是朋友，他们的住处离得比较远，Alice想要发送一则隐私消息给Bob</p></li>
<li><p>Eve想要窃听Alice和Bob的通信，Alice和Bob无法防止Eve的偷看</p></li>
<li><p>Alice把信放在一个盒子里，她上了锁，让邮差发给Bob，Eve没有钥匙，无法打开盒子，但是Bob也无法打开</p></li>
</ul>


<p>那么问题来了，Alice如何把钥匙发给Bob呢？</p>

<p>Alice如何发送钥匙给Bob的问题，就是现代密码学中<code>密钥分发</code>的问题;现代密码学的大部分研究，就是围绕这个问题展开的。</p>

<p>我们在思想实验中虚拟了两个解决方案:</p>

<h4>方案A</h4>

<ul>
<li><p>Alice把信息放到铁盒子里，上锁，发给Bob</p></li>
<li><p>Bob收到盒子，没有去想办法打开它，而是又加上了自己的一把锁，发回给Alice</p></li>
<li><p>Alice打开自己加的锁，发回给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
</ul>


<h4>方案B</h4>

<ul>
<li><p>Bob满世界散播自己的锁，随便一个人都能捡到Bob的锁并且能分辨是否被别人伪造</p></li>
<li><p>Alice捡了一把Bob的锁，把消息放进铁盒子里，锁上，发给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
</ul>


<p>这两个虚拟的解决方案意义非同寻常，它证明了两个人可以互相交换秘密的信息而不怕密钥泄露；但是在真实世界中，对一则文本信息加密，并不完全像给一个铁盒子上锁那样方便，我们如何把这两个故事的寓意融入到真正的密码术当中去呢？</p>

<h2>单向/双向函数</h2>

<p>在密码学中，很常用的一个数学特性叫做<code>单向函数</code>。</p>

<p>同样与之相对的，还有一个概念叫做<code>双向函数</code>。</p>

<p>让我们来看看他们是什么东东。</p>

<h4>双向函数</h4>

<p>大部分函数都是双向函数，<code>双向</code>意味着可逆。比如加倍函数就是一个双向函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y = 2x</span></code></pre></td></tr></table></div></figure>


<p>知道了x，很容易能求得y；同理，知道了y，很容易逆向求得x。</p>

<h4>单向函数</h4>

<p>与上面相对的，知道x，很容易能求得y；但是知道了y，逆向很难推出x。这就是单向函数。举一个最常见的例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y = 453^x % 21997</span></code></pre></td></tr></table></div></figure>


<p>一个很大的数的x次方来模除另一个很大的数，取模得到y，知道x，y是很容易计算的，但是反向从y推导x却十分困难。这就是一个单向函数。</p>

<p>码农童鞋们非常熟悉的一种算法:HASH(散列)，其原理就是建立在单向函数之上的；但是现在我们先把这个应用放到一边，单单探讨单向函数在密钥交换中的作用</p>

<h4>单向函数在密码学中的应用</h4>

<p>Alice和Bob在不懈的努力之后，发现采用上述 M<sup>x</sup> % P = y 的单向函数可以帮助他们交换密钥，而且
不怕遭到Eve的窃听，让我们看看他们怎么做到的：</p>

<table>
<thead>
<tr>
<th>选择 7<sup>x</sup> % 11 = y 这个单向函数作为约定函数 </th>
<th>Alice </th>
<th> Bob</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一步 </td>
<td> Alice随机选择了一个数字代入x，比如3 </td>
<td> Bob 随机选择了一个数字代入x，比如6</td>
</tr>
<tr>
<td>第二步 </td>
<td> Alice运算得到 7<sup>3</sup> % 11 = 2  </td>
<td> Bob 运算得到 7<sup>6</sup> % 11 = 4</td>
</tr>
<tr>
<td>第三步 </td>
<td> Alice把2发给Bob  </td>
<td> Bob 把4发给Alice</td>
</tr>
<tr>
<td>第四步 </td>
<td> Alice得到Bob发送的结果4，代入单向函数再一次运算得到 4<sup>3</sup> % 11 = 9  </td>
<td> Bob 得到Alice的2后进行同样的运算 2<sup>6</sup> % 11 = 9</td>
</tr>
</tbody>
</table>


<p>神奇的事情发生了，第四步中Alice和Bob得出了相同的数字9，这个数字就是他们需要传递的密钥。</p>

<p>让我们再重新审视一遍，Alice和Bob在这次交换密钥的过程中都传递了什么呢？</p>

<ol>
<li>他们约定了单向函数的 M, P值</li>
<li>他们各自选定了一个x值，然后计算结果y值并互相传递</li>
<li>通过前面两组信息，他们各自独立计算出了密钥值</li>
<li>Eve如果监听到了M,P,以及两个人传递的y，是很难逆向计算出x，并得出密钥值的；这是单向函数的数学特性决定的</li>
</ol>


<p>通过仔细的选定一个稳妥的单向函数，就可以通过公开的讨论来建立一个密钥。这是密码学史上一个伟大发现。它是如此的简单和违反直觉，简直让人觉得不可思议。</p>

<p>如果仔细看看，两个人交换模除结果y的过程，是不是和我们之前提到过的<code>方案A</code>有点像呢，这就是思想实验在理论世界中的映射。</p>

<p>这个发现是由我们前面那篇<a href="https://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/">加密技术发展</a>中帅帅的大叔们在1972年的工作成果，向他们致敬！</p>

<h2>非对称加密算法的建立</h2>

<p>虽然我们上面所建立的交换密钥的方案已经取得了巨大的进步，但是这个方案并不完美，因为它有一个不方便的地方:</p>

<p>Alice 想要给Bob发信，必须拿到Bob的y值，除非是热恋的情人，谁能一直在线回复你的消息呢？所以Alice要发信，一定要Bob配合达成一个密钥才可以；如果Bob恰巧睡觉了，这封信就只能延迟发了</p>

<p>这个不方便之处促使密码学家们寻求更完美的解决之道，这促成了非对称加密算法的建立。</p>

<p>我们至今为止的所有探讨都是建立在对称加密算法之上的。所谓<code>对称加密</code>，就是你有一个密钥，使用这个密钥加密一段信息，同样可以使用这个密钥解密这段信息。正是之前所有的加密算法都是建立在这个基础上的，所以密钥的传递才是如此重要。</p>

<h4>现在让我们思考另外一种看似违反直觉的方案</h4>

<p>如果有一种加密解密函数，它的加密密钥和解密密钥是不同的。在这个系统中，如果Alice只知道加密密钥，她只能加密，加密之后自己却无法解密&mdash;除非她知道另外一个解密密钥。</p>

<p>听起来好像有点绕口。用现代密码学的定义来解释，就是Alice需要同时拥有两把密钥：私钥和公钥。私钥用来解密，公钥用来加密。这样Alice只要好好藏好自己的私钥，然后把公钥广播天下，谁想要给Alice写情书，就用Alice广播出来的公钥加密寄给她就好啦，只有持有私钥的Alice才能解密这封情书。</p>

<p>这个系统的巨大优点就是两人通信不需要同时在线来来回回折腾了，只要两人把各自把自己的公钥广而告之，任何一个人就可以毫不顾忌的用公钥加密，写一些只能给Alice和Bob才能解密的隐私信息了。</p>

<p>这个方案是由帅帅的Whtfield Diffie想到的，在此我们要撒一把狗粮；这位老兄灵光一现想到这个方案之后，第一个想要与之分享的人是他的妻子玛丽，当时的情形是这样的:</p>

<blockquote><p>那是在下午发生的，维特不得不等几个小时，玛丽才会回来。
&ldquo;维特等在门口，&#8221;玛丽回忆说，&#8221;他说有事要告诉我，他脸上的表情很奇怪。我进了门，他说:&lsquo;请坐下来，我想和你说话。我相信我有一个重大的发现&mdash;-我是第一个知道这问题答案的人。&#8217;那一刻我感觉时间突然停止了，我似乎生活在好莱坞的电影中。&rdquo;</p></blockquote>

<p>好，单身狗童鞋们从暴击伤害中回过神来没有，让我们继续艰难的人生~~~</p>

<p>虽然Whtfield Diffie早在1975年就提出了这个方案，但是他没有找到他所需要的函数。他公开发表了论文，号召同时代的数学家们一起来找；但是时间飞逝，年底还是没人能找到这样的函数，有些人灰心了；正在这时，远在5000公里之外的美国西海岸，有个小组找到了这样的函数~~~这就是今天大名鼎鼎的RSA算法的诞生。</p>

<h4>那些个帅帅的大叔们</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg1.jpg" alt="RSA加密发明人" /></p>

<p>额，关于RSA算法，阮一峰老师的文章写的更清晰，我就不多废话了；童鞋们可以移步<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">这里</a>来探讨细节，当然，懒得去理解数学原理对于我们下面的探讨也没啥影响~~~~</p>

<h4>让我们总结一下一个典型的非对称加密算法的特点，并看看它是如何应用到实际中的</h4>

<ol>
<li>Bob手里有两把钥匙，一把是公钥，另一把是私钥。有了私钥能推导出公钥，有了公钥不能推导出私钥</li>
<li>用私钥加密，可以使用公钥解密</li>
<li>用公钥加密，可以使用私钥解密</li>
<li>Bob把公钥送给他的朋友们&mdash;&mdash;Alice, Sam ~~每人一把；或者直接把公钥公示在自己的个人网页上，谁都能看；</li>
<li>Alice要给Bob写一封保密的信。她写完后用Bob的公钥加密，就可以达到保密的效果。</li>
<li>Bob收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要Bob的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</li>
<li>Bob给Alice回信，决定采用&#8221;数字签名&#8221;。他写完后先用Hash函数，生成信件的摘要（digest）。</li>
<li>然后，Bob使用私钥，对这个摘要加密，生成&#8221;数字签名&#8221;（signature）。Bob将这个签名，附在信件下面，一起发给Alice。</li>
<li>Alice收信后，取下数字签名，用Bob的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</li>
<li>Alice再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</li>
<li>复杂的情况出现了。Eve想欺骗Alice，他偷偷使用了Alice的电脑，用自己的公钥换走了鲍勃的公钥。此时，Alice实际拥有的是Eve的公钥，但是还以为这是Bob的公钥。因此，Eve就可以冒充Bob，用自己的私钥做成&#8221;数字签名&#8221;，写信给Alice，让Alice用假的Bob公钥进行解密。</li>
<li>后来，Alice感觉不对劲，发现自己无法确定公钥是否真的属于Bob。每次都去寻找Bob的个人网页去比对也很麻烦；她想到了一个办法，要求Bob去找&#8221;证书中心&#8221;（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对Bob的公钥和一些相关信息一起加密，生成&#8221;数字证书&#8221;（Digital Certificate）。</li>
<li>Bob拿到数字证书以后，就可以放心了。以后再给Alice写信，只要在签名的同时，再附上数字证书就行了。</li>
<li>Alice收到信后，用CA的公钥解开数字证书，就可以拿到Bob真实的公钥了，然后就能证明&#8221;数字签名&#8221;是否真的是Bob签的。</li>
<li>以上过程涉及了<code>非对称加密</code>，<code>HASH</code>，<code>签名</code>,<code>Digest</code>，<code>CA</code>等等名词，没错，我们说的就是HTTPS</li>
</ol>


<p>完整的资料参看这里：</p>

<p><a href="http://www.youdzone.com/signature.html">http://www.youdzone.com/signature.html</a></p>

<h2>椭圆曲线ECC加密算法（Elliptic Curve Cryptography）</h2>

<p>我们看到了，非对称加密的核心，依赖于一个非常健壮的单向函数。RSA采用的是大素数分解的单向函数。这基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难。大质数分解问题一直是数学里面的热门问题。</p>

<p>即便如此，因式分解在位对位基础里不是最难的问题。这些因式分解算法随着被因式分解的数字变得越大而变得越有效率。因式分解大批数字和乘以大批数字的难度的差距随着数字（即秘钥的字节长度）变大而缩小。随着有效解码数字的资源增加，秘钥的大小必须更快增长。对限制计算能力的手机和低功率设备来说，这不是一个可持续的情况。从长期来看，因式分解和乘法的差距是不可持续的。</p>

<p>所有这一切意味着RSA不是理想的系统对将来的密码学来说。在一个完美的trapdoor函数里，对于数字大小的问题，简单方法和困难方法都一同样的速率变难。所以我们需要一个基于更好的trapdoor的公钥系统。</p>

<p>以上RSA的这些不完美加速了另外一种算法的诞生：在1985年，加密算法被提议以一个叫椭圆曲线的数学密码分支为基础。这也是比特币地址采用的核心加密方法。</p>

<h4>什么是椭圆曲线</h4>

<p>对于我们小白来说，椭圆曲线可以暂时简单的理解为描述了特定点的集合的公式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y^2 = X^3 + ax + b</span></code></pre></td></tr></table></div></figure>


<p>取不同的a值和b值，这个函数在坐标轴上绘制出来的曲线大概是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg2.jpg" alt="椭圆曲线" /></p>

<p>a和b的取值变化决定了曲线在坐标系上的不同形状。从图中可以看到，椭圆曲线是相对X轴对称。</p>

<p>通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的。椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。</p>

<h4>secp256k1椭圆加密曲线</h4>

<p>a和b的不同取值可以画出多条不同的曲线，比特币使用了secp256k1标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y^2 % p = (X^3 + 7) % p</span></code></pre></td></tr></table></div></figure>


<p>看到了吧，这个函数结合了我们之前介绍的取模操作和椭圆曲线函数。</p>

<p>上述素数p取模表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2<sup>256</sup> – 2<sup>32</sup> – 2<sup>9</sup> – 2<sup>8</sup> – 2<sup>7</sup> – 2<sup>6</sup> – 2<sup>4</sup> – 1， 这是个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散落的点，因此很难可视化。不过，其中的数学原理与实数范围的椭圆曲线相似。</p>

<p>这条曲线画出来的样子大概是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg3.jpg" alt="椭圆曲线" /></p>

<p>在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。</p>

<p>还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3 = P1 + P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线相交于另外一个地方。此点记为 P3&#8217;= (x，y)。然后，在x轴做翻折获得 P3=(x，-y)。</p>

<p>下面是几个可以解释“穷远点”之存在需要的特殊情况。</p>

<p>若 P1和 P2是同一点，P1和P2间的连线则为点P1 的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微积分求得。即使限制曲线点为两个整数坐标也可求得斜率！</p>

<p>在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3 = “无穷远点”。</p>

<p>若P1就是“无穷远点”，那么其和 P1 + P2= P2。类似地，当P2是无穷远点，则P1+ P2 = P1。这就是把无穷远点类似于0的作用。 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)+C = A+(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。 因此，我们已经定义了椭圆加法，我们可以对乘法用拓展加法的标准方法进行定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，在这种情况下k有时被混淆而称为“指数”。</p>

<h4>生成公钥</h4>

<p>以一个随机生成的私钥k为起点，我们将其与曲线上预定的生成点G相乘以获得曲线上的另一点，也就是相应的公钥 K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p>

<p>{K = k * G}</p>

<p>其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将 得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生） 与任何人共享而不会泄露私钥（k）的原因。</p>

<p>提示 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。</p>

<p>为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：</p>

<p>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</p>

<p>公钥K 被定义为一个点 K = (x, y)：</p>

<p>K = (x, y)</p>

<p>其中，</p>

<p>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</p>

<p>y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</p>

<p>为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一 点，然后翻折到x轴。</p>

<p>下图显示了在曲线上得到 G、2G、4G 的几何操作。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181023/bg4.jpg" alt="椭圆曲线" /></p>

<h4>比特币账户</h4>

<p>呼呼，以上就是比特币的账户核心算法的一部分。</p>

<ol>
<li>选定了secp256k1算法，其实是通用的椭圆曲线的特化(a=0, b=7)，另外选定一个非常大的模除数字p</li>
<li>选定了一个G点;G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</li>
<li>随机生成了一个私钥k</li>
<li>求得公钥K = k * G，这里对G进行了k次翻转，一个不可逆的操作得到公钥K</li>
<li>对K再做后续变形，最终得到比特币账户的地址，这个变形又是一系列神操作，我们在后面的文章会讲</li>
</ol>


<h2>寻求更极限的安全</h2>

<p>到目前为止，密码学家们为了实现更安全的非对称加密算法，探索了模除、大素数分解、以及椭圆曲线；他们的共同特点就是逆向运算极难极难；但是极难并不代表着不可能，随着量子计算的发展，谁也不能保证今后逆向运算的复杂度会不会有大幅降低；所以寻求更安全的单向函数始终是密码学家们最重要的工作之一；</p>

<p>近年来，这个探索的边界又有了更大的突破，就是为人们所熟知的量子加密技术。</p>

<p>限于篇幅，我们就不做更多的科普了，可以参考这本书:</p>

<p><a href="https://book.douban.com/subject/1036413/">https://book.douban.com/subject/1036413/</a></p>

<p>PS:一个小科普，量子计算机和量子加密其实没有多大关系哦，他们之间其实是雷锋和雷峰塔的关系，就是名字相似而已，可不要被忽悠哦</p>

<h2>总结</h2>

<p>呼呼，老实说，我最初想要介绍的是比特币HD钱包的演化过程，BIP32,BIP44,BIP49，BIP84以及BIP141这些文档共同定义了比特币HD钱包的底层构造。</p>

<p>从BIP44开始，比特币账户的管理其实已经在中本聪最初定义的一个简单地址生成的路上又走了很远；我也觉得HD钱包是比特币社区为区块链技术贡献的一个非常重要、非常有用的部分；这个钱包生成的技术超出了比特币本身，在可见的未来，会在多个领域发挥巨大作用。</p>

<p>为了学习比特币HD钱包的基础理论支撑，我们从最原始的凯撒加密，到Alice和Bob的思想实验，到单向函数，再到安全的密钥分发方法，到非对称加密，椭圆曲线，甚至还隐约看到了量子加密，这一切的一切是近2000年来无数密码学家们日日夜夜的冥思苦想的成果；</p>

<p>然后站在所有这些成果的基础上，到了中本聪及比特币技术社区手中融合发扬光大；创造了独一无二的电子货币金融账户；这个账户设计的方法之精妙，值得我们再长篇大论一番；那么，下次文章再见。</p>

<p>参考资料:</p>

<p><a href="https://book.douban.com/subject/30280401/">https://book.douban.com/subject/30280401/</a></p>

<p><a href="https://book.douban.com/subject/1036413/">https://book.douban.com/subject/1036413/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们的货币超发了吗]]></title>
    <link href="https://happy123.me/blog/2018/10/16/wo-men-de-huo-bi-chao-fa-liao-ma/"/>
    <updated>2018-10-16T19:21:08+08:00</updated>
    <id>https://happy123.me/blog/2018/10/16/wo-men-de-huo-bi-chao-fa-liao-ma</id>
    <content type="html"><![CDATA[<p>这是一个没有公认答案的问题，但是从央行的角度来说说，真有点冤；</p>

<p>看看一些数据吧：</p>

<!-- more -->


<h4>美国 (单位：亿美元)</h4>

<table>
<thead>
<tr>
<th>Year</th>
<th> M0  </th>
<th> M2 </th>
<th> GDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>2008</td>
<td>8370 </td>
<td>74574  </td>
<td>144776</td>
</tr>
<tr>
<td>2018</td>
<td>38500</td>
<td>138344 </td>
<td>193906</td>
</tr>
</tbody>
</table>


<p>来源：<a href="https://stock-ai.com/eom-1-M2SL.php">https://stock-ai.com/eom-1-M2SL.php</a></p>

<h4>中国 (单位:亿元)</h4>

<table>
<thead>
<tr>
<th>Year</th>
<th> M0 </th>
<th> M2 </th>
<th>GDP</th>
<th> 外汇储备(亿美元)</th>
<th> 外汇占款(亿元) </th>
<th> 汇率</th>
</tr>
</thead>
<tbody>
<tr>
<td>2008 </td>
<td>  36673 </td>
<td> 403442.2 </td>
<td> 265810.30 </td>
<td> 15898.10 </td>
<td> 115168.71 </td>
<td> 7.4</td>
</tr>
<tr>
<td>2018 </td>
<td>  70645 </td>
<td> 1676800 </td>
<td> 827122.00 </td>
<td> 31399.49 </td>
<td> 214788 </td>
<td> 6.6</td>
</tr>
</tbody>
</table>


<p>来源：<a href="http://www.pbc.gov.cn/diaochatongjisi/116219/index.html">http://www.pbc.gov.cn/diaochatongjisi/116219/index.html</a></p>

<p>Tooltips:</p>

<h3>m2对应的只是存款，没有包含所有的可变现金融资产。另外中美M2统计口径不同</h3>

<h4>美国M2包含零售的货币市场基金份额，是指在售的部分，美国M1、M2的统计口径分别如下：</h4>

<ul>
<li><p>M1：包括：</p>

<p>  1）美国财政部、联邦储备银行以及存款货币机构之外的现金；
  2）旅行支票；
  3）商业银行活期存款；
  4）其他可支付存款；NOW；ATS以及储蓄贷款协会的定期存款。</p></li>
<li><p>M2：包括M1，以及
  1）储蓄存款（包括货币市场存款账户）；
  2）小额定期存款（即10万美元以下）；
  3）零售的货币市场基金份额。</p></li>
</ul>


<p>当前美国货币统计口径最大的M2并未包括机构的大额存款以及境外流入的资金，主要是个人的储蓄存款以及机构的小额定期存款。美国的M2仅大致相当于中国的M1加上储蓄存款，即小于中国M2的统计口径。</p>

<h4>中国的M2包括了货币和准货币，基本上代表了货币总量即广义货币。但是，国际上并不存在这样的约定俗成：M2即是广义货币。</h4>

<h3>中国M2是否超发</h3>

<h4>统计方法差异</h4>

<p>2016-06的统计数据，美国GDP总量17.87万亿美元，中国GDP总量10.42万亿美元，美国总量是中国的1.7倍。美国M2总量12万亿，中国M2总量22万亿，中国M2是1.83倍，看起来似乎人民币超发了。</p>

<p>但是美国基金行业总量17.8万亿美元，中国基金行业总量仅1.2万亿美元，美国国债规模12万亿美元，中国国债规模3万亿美元</p>

<p>美国的财富更多通过直接投资来体现，不体现在M2中，比如同样是购买债券，中国的模式是“个人存银行－》银行购买国债”，而美国的模式是“个人购买债券基金－》债券基金购买国债”或者“个人和机构直接购买国债”。</p>

<p>如果 <code>P＝M2+开放式基金余额＋国债余额</code></p>

<ul>
<li>P（美国）＝12+17.8+12=41.8</li>
<li>P（中国）＝22+3+1.2=26.2</li>
</ul>


<p>那么P（美国）／P（中国）＝1.6</p>

<p>这样看又是正常的</p>

<p>链接：<a href="https://xueqiu.com/5819606767/70273695">https://xueqiu.com/5819606767/70273695</a></p>

<h4>外汇占款理解</h4>

<ul>
<li><p>从<code>M0/外汇占款</code>来看，并没有超发；汇率也是正常的波动</p></li>
<li><p>从美国自己的M2膨胀来看，美元购买力其实下降了，我们的外汇占款发行方式其实吃了美国QE的亏，这是强势美元全世界割韭菜，怨不得央行</p></li>
</ul>


<h3>结论</h3>

<ul>
<li><p>央行对外通过购买美国国债对抗美元通胀，对内实行外汇占款为基础的本币发行，佐以发行国债冲销干预M2超发隐患，操作水平是非常高的，没有可黑的地方;</p></li>
<li><p>除去M2的统计差异，我们的M2/M0比值相对于美国过高；货币周转快，这是我们处于发展相对高速的周期决定的</p></li>
<li><p>美元的通胀和我们高速的货币周转共同造成了国内通胀压力，这不能全部甩锅货币政策</p></li>
<li><p>M2迅猛增长还是经济周期的大势决定，经济周期是逃不开的；</p></li>
<li><p>我们已经享受了很长时间的高增长繁荣，这是不可持续的，有繁荣就有衰落，平常心对待之</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Evolution of a Programmer]]></title>
    <link href="https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer/"/>
    <updated>2018-10-06T17:22:54+08:00</updated>
    <id>https://happy123.me/blog/2018/10/06/the-evolution-of-a-programmer</id>
    <content type="html"><![CDATA[<p>快有二十年的老段子了，最近又看到很多次，莫非是邪恶旧势力的崛起？存档一下。</p>

<!-- more -->


<h4>High School/Jr.High</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  10 PRINT "HELLO WORLD"
</span><span class='line'>  20 END</span></code></pre></td></tr></table></div></figure>


<h4>First year in College</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  program Hello(input, output)
</span><span class='line'>    begin
</span><span class='line'>      writeln('Hello World')
</span><span class='line'>    end.</span></code></pre></td></tr></table></div></figure>


<h4>Senior year in College</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  (defun hello
</span><span class='line'>    (print
</span><span class='line'>      (cons 'Hello (list 'World))))</span></code></pre></td></tr></table></div></figure>


<h4>New professional</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  void main(void)
</span><span class='line'>  {
</span><span class='line'>    char *message[] = {"Hello ", "World"};
</span><span class='line'>    int i;
</span><span class='line'> 
</span><span class='line'>    for(i = 0; i &lt; 2; ++i)
</span><span class='line'>      printf("%s", message[i]);
</span><span class='line'>    printf("\n");
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h4>Seasoned professional</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #include &lt;iostream.h&gt;
</span><span class='line'>  #include &lt;string.h&gt;
</span><span class='line'> 
</span><span class='line'>  class string
</span><span class='line'>  {
</span><span class='line'>  private:
</span><span class='line'>    int size;
</span><span class='line'>    char *ptr;
</span><span class='line'> 
</span><span class='line'>  string() : size(0), ptr(new char[1]) { ptr[0] = 0; }
</span><span class='line'> 
</span><span class='line'>    string(const string &s) : size(s.size)
</span><span class='line'>    {
</span><span class='line'>      ptr = new char[size + 1];
</span><span class='line'>      strcpy(ptr, s.ptr);
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    ~string()
</span><span class='line'>    {
</span><span class='line'>      delete [] ptr;
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    friend ostream &operator &lt;&lt;(ostream &, const string &);
</span><span class='line'>    string &operator=(const char *);
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  ostream &operator&lt;&lt;(ostream &stream, const string &s)
</span><span class='line'>  {
</span><span class='line'>    return(stream &lt;&lt; s.ptr);
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  string &string::operator=(const char *chrs)
</span><span class='line'>  {
</span><span class='line'>    if (this != &chrs)
</span><span class='line'>    {
</span><span class='line'>      delete [] ptr;
</span><span class='line'>     size = strlen(chrs);
</span><span class='line'>      ptr = new char[size + 1];
</span><span class='line'>      strcpy(ptr, chrs);
</span><span class='line'>    }
</span><span class='line'>    return(*this);
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  int main()
</span><span class='line'>  {
</span><span class='line'>    string str;
</span><span class='line'> 
</span><span class='line'>    str = "Hello World";
</span><span class='line'>    cout &lt;&lt; str &lt;&lt; endl;
</span><span class='line'> 
</span><span class='line'>    return(0);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h4>Master Programmer</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  [
</span><span class='line'>  uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
</span><span class='line'>  ]
</span><span class='line'>  library LHello
</span><span class='line'>  {
</span><span class='line'>      // bring in the master library
</span><span class='line'>      importlib("actimp.tlb");
</span><span class='line'>      importlib("actexp.tlb");
</span><span class='line'> 
</span><span class='line'>      // bring in my interfaces
</span><span class='line'>      #include "pshlo.idl"
</span><span class='line'> 
</span><span class='line'>      [
</span><span class='line'>      uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
</span><span class='line'>      ]
</span><span class='line'>      cotype THello
</span><span class='line'>   {
</span><span class='line'>   interface IHello;
</span><span class='line'>   interface IPersistFile;
</span><span class='line'>   };
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  [
</span><span class='line'>  exe,
</span><span class='line'>  uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
</span><span class='line'>  ]
</span><span class='line'>  module CHelloLib
</span><span class='line'>  {
</span><span class='line'> 
</span><span class='line'>      // some code related header files
</span><span class='line'>      importheader(&lt;windows.h&gt;);
</span><span class='line'>      importheader(&lt;ole2.h&gt;);
</span><span class='line'>      importheader(&lt;except.hxx&gt;);
</span><span class='line'>      importheader("pshlo.h");
</span><span class='line'>      importheader("shlo.hxx");
</span><span class='line'>      importheader("mycls.hxx");
</span><span class='line'> 
</span><span class='line'>      // needed typelibs
</span><span class='line'>      importlib("actimp.tlb");
</span><span class='line'>      importlib("actexp.tlb");
</span><span class='line'>      importlib("thlo.tlb");
</span><span class='line'> 
</span><span class='line'>      [
</span><span class='line'>      uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
</span><span class='line'>      aggregatable
</span><span class='line'>      ]
</span><span class='line'>      coclass CHello
</span><span class='line'>   {
</span><span class='line'>   cotype THello;
</span><span class='line'>   };
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>  #include "ipfix.hxx"
</span><span class='line'> 
</span><span class='line'>  extern HANDLE hEvent;
</span><span class='line'> 
</span><span class='line'>  class CHello : public CHelloBase
</span><span class='line'>  {
</span><span class='line'>  public:
</span><span class='line'>      IPFIX(CLSID_CHello);
</span><span class='line'> 
</span><span class='line'>      CHello(IUnknown *pUnk);
</span><span class='line'>      ~CHello();
</span><span class='line'> 
</span><span class='line'>      HRESULT  __stdcall PrintSz(LPWSTR pwszString);
</span><span class='line'> 
</span><span class='line'>  private:
</span><span class='line'>      static int cObjRef;
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>  #include &lt;windows.h&gt;
</span><span class='line'>  #include &lt;ole2.h&gt;
</span><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  #include &lt;stdlib.h&gt;
</span><span class='line'>  #include "thlo.h"
</span><span class='line'>  #include "pshlo.h"
</span><span class='line'>  #include "shlo.hxx"
</span><span class='line'>  #include "mycls.hxx"
</span><span class='line'> 
</span><span class='line'>  int CHello::cObjRef = 0;
</span><span class='line'> 
</span><span class='line'>  CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
</span><span class='line'>  {
</span><span class='line'>      cObjRef++;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
</span><span class='line'>  {
</span><span class='line'>      printf("%ws
</span><span class='line'>", pwszString);
</span><span class='line'>      return(ResultFromScode(S_OK));
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>  CHello::~CHello(void)
</span><span class='line'>  {
</span><span class='line'> 
</span><span class='line'>  // when the object count goes to zero, stop the server
</span><span class='line'>  cObjRef--;
</span><span class='line'>  if( cObjRef == 0 )
</span><span class='line'>      PulseEvent(hEvent);
</span><span class='line'> 
</span><span class='line'>  return;
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  #include &lt;windows.h&gt;
</span><span class='line'>  #include &lt;ole2.h&gt;
</span><span class='line'>  #include "pshlo.h"
</span><span class='line'>  #include "shlo.hxx"
</span><span class='line'>  #include "mycls.hxx"
</span><span class='line'> 
</span><span class='line'>  HANDLE hEvent;
</span><span class='line'> 
</span><span class='line'>   int _cdecl main(
</span><span class='line'>  int argc,
</span><span class='line'>  char * argv[]
</span><span class='line'>  ) {
</span><span class='line'>  ULONG ulRef;
</span><span class='line'>  DWORD dwRegistration;
</span><span class='line'>  CHelloCF *pCF = new CHelloCF();
</span><span class='line'> 
</span><span class='line'>  hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
</span><span class='line'> 
</span><span class='line'>  // Initialize the OLE libraries
</span><span class='line'>  CoInitializeEx(NULL, COINIT_MULTITHREADED);
</span><span class='line'> 
</span><span class='line'>  CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,
</span><span class='line'>      REGCLS_MULTIPLEUSE, &dwRegistration);
</span><span class='line'> 
</span><span class='line'>  // wait on an event to stop
</span><span class='line'>  WaitForSingleObject(hEvent, INFINITE);
</span><span class='line'> 
</span><span class='line'>  // revoke and release the class object
</span><span class='line'>  CoRevokeClassObject(dwRegistration);
</span><span class='line'>  ulRef = pCF-&gt;Release();
</span><span class='line'> 
</span><span class='line'>  // Tell OLE we are going away.
</span><span class='line'>  CoUninitialize();
</span><span class='line'> 
</span><span class='line'>  return(0); }
</span><span class='line'> 
</span><span class='line'>  extern CLSID CLSID_CHello;
</span><span class='line'>  extern UUID LIBID_CHelloLib;
</span><span class='line'> 
</span><span class='line'>  CLSID CLSID_CHello = { /* 2573F891-CFEE-101A-9A9F-00AA00342820 */
</span><span class='line'>      0x2573F891,
</span><span class='line'>      0xCFEE,
</span><span class='line'>      0x101A,
</span><span class='line'>      { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  UUID LIBID_CHelloLib = { /* 2573F890-CFEE-101A-9A9F-00AA00342820 */
</span><span class='line'>      0x2573F890,
</span><span class='line'>      0xCFEE,
</span><span class='line'>      0x101A,
</span><span class='line'>      { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
</span><span class='line'>  };
</span><span class='line'> 
</span><span class='line'>  #include &lt;windows.h&gt;
</span><span class='line'>  #include &lt;ole2.h&gt;
</span><span class='line'>  #include &lt;stdlib.h&gt;
</span><span class='line'>  #include &lt;string.h&gt;
</span><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  #include "pshlo.h"
</span><span class='line'>  #include "shlo.hxx"
</span><span class='line'>  #include "clsid.h"
</span><span class='line'> 
</span><span class='line'>  int _cdecl main(
</span><span class='line'>  int argc,
</span><span class='line'>  char * argv[]
</span><span class='line'>  ) {
</span><span class='line'>  HRESULT  hRslt;
</span><span class='line'>  IHello        *pHello;
</span><span class='line'>  ULONG  ulCnt;
</span><span class='line'>  IMoniker * pmk;
</span><span class='line'>  WCHAR  wcsT[_MAX_PATH];
</span><span class='line'>  WCHAR  wcsPath[2 * _MAX_PATH];
</span><span class='line'> 
</span><span class='line'>  // get object path
</span><span class='line'>  wcsPath[0] = '\0';
</span><span class='line'>  wcsT[0] = '\0';
</span><span class='line'>  if( argc &gt; 1) {
</span><span class='line'>      mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
</span><span class='line'>      wcsupr(wcsPath);
</span><span class='line'>      }
</span><span class='line'>  else {
</span><span class='line'>      fprintf(stderr, "Object path must be specified\n");
</span><span class='line'>      return(1);
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  // get print string
</span><span class='line'>  if(argc &gt; 2)
</span><span class='line'>      mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
</span><span class='line'>  else
</span><span class='line'>      wcscpy(wcsT, L"Hello World");
</span><span class='line'> 
</span><span class='line'>  printf("Linking to object %ws\n", wcsPath);
</span><span class='line'>  printf("Text String %ws\n", wcsT);
</span><span class='line'> 
</span><span class='line'>  // Initialize the OLE libraries
</span><span class='line'>  hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);
</span><span class='line'> 
</span><span class='line'>  if(SUCCEEDED(hRslt)) {
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>      hRslt = CreateFileMoniker(wcsPath, &pmk);
</span><span class='line'>      if(SUCCEEDED(hRslt))
</span><span class='line'>   hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&pHello);
</span><span class='line'> 
</span><span class='line'>      if(SUCCEEDED(hRslt)) {
</span><span class='line'> 
</span><span class='line'>   // print a string out
</span><span class='line'>   pHello-&gt;PrintSz(wcsT);
</span><span class='line'> 
</span><span class='line'>   Sleep(2000);
</span><span class='line'>   ulCnt = pHello-&gt;Release();
</span><span class='line'>   }
</span><span class='line'>      else
</span><span class='line'>   printf("Failure to connect, status: %lx", hRslt);
</span><span class='line'> 
</span><span class='line'>      // Tell OLE we are going away.
</span><span class='line'>      CoUninitialize();
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  return(0);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h4>Apprentice Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #!/usr/local/bin/perl
</span><span class='line'>  $msg="Hello, world.\n";
</span><span class='line'>  if ($#ARGV &gt;= 0) {
</span><span class='line'>    while(defined($arg=shift(@ARGV))) {
</span><span class='line'>      $outfilename = $arg;
</span><span class='line'>      open(FILE, "&gt;" . $outfilename) || die "Can't write $arg: $!\n";
</span><span class='line'>      print (FILE $msg);
</span><span class='line'>      close(FILE) || die "Can't close $arg: $!\n";
</span><span class='line'>    }
</span><span class='line'>  } else {
</span><span class='line'>    print ($msg);
</span><span class='line'>  }
</span><span class='line'>  1;</span></code></pre></td></tr></table></div></figure>


<h4>Experienced Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #include &lt;stdio.h&gt;
</span><span class='line'>  #define S "Hello, World\n"
</span><span class='line'>  main(){exit(printf(S) == strlen(S) ? 0 : 1);}</span></code></pre></td></tr></table></div></figure>


<h4>Seasoned Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % cc -o a.out ~/src/misc/hw/hw.c
</span><span class='line'>  % a.out</span></code></pre></td></tr></table></div></figure>


<h4>Guru Hacker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % echo "Hello, world."</span></code></pre></td></tr></table></div></figure>


<h4>New Manager</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  10 PRINT "HELLO WORLD"
</span><span class='line'>  20 END</span></code></pre></td></tr></table></div></figure>


<h4>Middle Manager</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  mail -s "Hello, world." bob@b12
</span><span class='line'>  Bob, could you please write me a program that prints "Hello, world."?
</span><span class='line'>  I need it by tomorrow.
</span><span class='line'>  ^D</span></code></pre></td></tr></table></div></figure>


<h4>Senior Manager</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % zmail jim
</span><span class='line'>  I need a "Hello, world." program by this afternoon.</span></code></pre></td></tr></table></div></figure>


<h4>Chief Executive</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % letter
</span><span class='line'>  letter: Command not found.
</span><span class='line'>  % mail
</span><span class='line'>  To: ^X ^F ^C
</span><span class='line'>  % help mail
</span><span class='line'>  help: Command not found.
</span><span class='line'>  % damn!
</span><span class='line'>  !: Event unrecognized
</span><span class='line'>  % logout</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个经典的排障故事]]></title>
    <link href="https://happy123.me/blog/2018/10/04/liang-ge-jing-dian-de-pai-zhang-gu-shi/"/>
    <updated>2018-10-04T21:48:57+08:00</updated>
    <id>https://happy123.me/blog/2018/10/04/liang-ge-jing-dian-de-pai-zhang-gu-shi</id>
    <content type="html"><![CDATA[<p>很久之前就在某杂志上看过，不久前在知乎<a href="https://www.zhihu.com/question/21747929">有哪些让你目瞪口呆的 bug</a>里面又见到了；我觉得这两个troubleshooting的case有很深的道理在里面，记一下。</p>

<h3>电子邮件无法发送到500英里以外</h3>

<!-- more -->


<p>这个故事最早出现于2002年11月24日，而且每过若干年，它就会在不同的系统管理技术社区中再次出现，并且引发人们的热议和关注。有人对这个故事给出了这样的评价：</p>

<blockquote><p>这个故事大约每过三年或四年就会在系统管理社区出现，每次我读到它，都觉得很值得一读。即便在正常环境下已经做过检查，甚或经过片刻思考之后，我还是高度怀疑这种事情是否会发生在自己身上。</p></blockquote>

<p>这是一个真实的故事。如果你想要进一步了解它的相关信息，可以访问这个 <a href="http://www.ibiblio.org/harris/500milemail-faq.html">FAQ</a> &ndash; 一个关于本故事的常见问题列表，由本故事作者 Trey Harris 编写。</p>

<p>这个故事听起来有点儿天方夜谭的感觉&hellip; 我已经有些后悔把这个故事分享给大家了，因为它很可能会沦为众人茶余饭后的谈资。:&ndash;) 为了保护自己的内疚感，我对故事做了稍许改动，省略了无关紧要以及无聊的细节，总之让故事变得更加生动有趣了。</p>

<p>几年以前，我在一家运营校园邮件系统的公司工作。有一天，我接到了来自统计部主任给我的电话。</p>

<p>“我们的邮件系统存在一个问题。”</p>

<p>“什么问题？” 我问道。</p>

<p>“我们不能发送超过500英里距离的邮件，” 主任解释说。</p>

<p>我被手中的拿铁咖啡呛着了。“再说一遍？”</p>

<p>“我们不能把邮件发送到超过500英里距离的地方，” 他重复道。“真的，哪怕再远一点点。只能到达520英里，不能再远了。”</p>

<p>“嗯&hellip;通常来说，邮件真的不是按照这种方式来发送的，” 我说道，并尽力让自己的声音平静下来。一个人与部门主任谈话时通常不会带有恐慌情绪，即使是一个相对无实权的部门如统计部。“是什么让你认为邮件不能发送超过500英里之外的？”</p>

<p>“并非我这么认为，” 主任不耐烦地回答道。“你瞧，几天之前我们就发现了这一现象&hellip;”</p>

<p>“你等了好几天了？” 我打断他的话，声音有些颤抖地问道，“这段时间你都不能发送邮件吗？”</p>

<p>“我们能发邮件，只要不超过&hellip;”</p>

<p>“500英里，是吧，” 我替他补充道，“我知道了。但是为什么你不早点给我电话呢？”</p>

<p>“好吧，问题是直到刚才，我们才收集到足够的证据确定这一现象的发生。” 也对，他是统计部主任。“总之，我让一名地理统计人员去调查了这件事情&hellip;”</p>

<p>“地理统计人员&hellip;”</p>

<p>“是的，她制作了一张地图，地图上显示我们能发送邮件的区域半径比500英里多那么一点点。即便如此，这个半径区域之内的有些地方也不能发送，或者偶发性地能发送，但是在半径区域之外从来没有发送成功过。”</p>

<p>“我明白了，” 我说道，“何时开始的？你说几天之前，那么这段时间内系统发生什么改变了吗？”</p>

<p>“是的，技术服务人员来过，给服务器打了补丁然后重启了系统。但是我给他去过电话，他说他没碰邮件系统。”</p>

<p>“好的，我先看看吧，然后再给你打过去，” 我说，几乎不相信我也会来虚与委蛇这一套。今天不是愚人节啊。我试着去回忆，是不是有人欠我一个恶作剧。</p>

<p>我登进他们部门的服务器，发了一封测试邮件。这是发送到北卡罗莱纳州的三角研究实验，测试邮件很顺利地到达我的邮箱。同前面一样，我又发送到里士满、亚特兰大、华盛顿，还有普林斯顿（400英里），都能顺利到达。</p>

<p>但是当我尝试发送邮件到孟菲斯（600英里）时，却失败了。发往波士顿，失败了。发往底特律，同样是失败。我拿出我的地址薄，开始试图缩小范围。纽约（420英里）可以发送，但是普罗维登斯（580英里）就失败了。</p>

<p>我开始困惑，是不是我失去了理智。我试着给我一位居住在北卡罗来纳州的朋友发送邮件，他的 ISP（网络服务提供商）在西雅图。谢天谢地，发送失败了。如果这个问题只和收件人的居住位置有关，而不是和他（她）的邮件服务器有关的话，我想我真该泪奔了。</p>

<p>问题得以确认，尽管令人难以置信，但问题确实存在而且可以重现。我查看了 sendmail.cf 文件，它看起来很正常，没有任何问题。事实上，它看起来很熟悉。</p>

<p>我将这个文件和我本机 home 目录下的 sendmail.cf 文件进行了比对。二者没有什么不同，这个文件就是我自己写的。我也确信没有启用 “FAIL_MAIL_OVER_500_MILES” 这一选项。带着满腹困惑，我远程登录到 SMTP 端口。服务器使用一个 SunOS sendmail 标识愉快地做出了响应。</p>

<p>等等&hellip; 一个 SunOS sendmail 标识？在那时，Sun 仍然随同操作系统捆绑发布 Sendmail 5 版本，尽管 Sendmail 8 已经相当成熟了。作为一名优秀的系统管理员，我已经把 Sendmail 8 作为一个标配了。同时，作为一名优秀系统管理员，我写了一个 sendmail.cf 配置文件，使用了 Sendmail 8 中优雅详细且自我描述的选项和变量名，而不是 Sendmail 5 中含义模糊的标点符号标记的代码。</p>

<p>一切都水落石出了，突然间，我被那杯现已冷的掉渣的拿铁咖啡再次被呛到了。当那名技服给服务器打补丁的时候，很显然他也升级了 SunOS 的版本，如此一来自然把 Sendmail 的版本“降级”了。升级程序将 sendmail.cf 配置文件单独保留了下来，即使它现在对应的是错误的版本。</p>

<p>碰巧的是 Sendmail 5（至少 Sun 发布的版本，或许做过一些调整）可以处理 Sendmail 8 的 sendmail.cf 配置文件，因为大多数的规则在那时并没有改变。但是对于那些在 Sendmail 8 中新增的长配置项，Sendmail 5 将之视为垃圾而忽略掉了。sendmail 的二进制安装包对大多数选项没有提供默认值，因此，如果在 sendmail.cf 中找不到合适的设置，它们就会被设为0。</p>

<p>这些被设为0的选项之一就是连接远程 SMTP 服务器的超时时间。一些试验已经证实，在一个具有典型负载的特定机器上，零超时意味着如果连接时间稍微超过3毫秒，服务器就会终止连接。</p>

<p>当时我们的校园网络有一个很奇怪的特点，它是百分之百交换型网络。发送出去的数据包，在遇到 POP 服务器和远端路由器之前，不会出现路由器延迟。因此，连接到临近网络上负载较轻的服务器所花的时间，很大程度上是由光速决定的，而不是偶发的路由器延迟。</p>

<p>这可真是让人有点儿眼花缭乱啊，我在 shell 里敲入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ units
</span><span class='line'>1311 units, 63 prefixes
</span><span class='line'>
</span><span class='line'>You have: 3 millilightseconds  
</span><span class='line'>You want: miles  
</span><span class='line'>        * 558.84719
</span><span class='line'>        / 0.0017893979
</span><span class='line'>
</span><span class='line'>"500 miles, or a little bit more."</span></code></pre></td></tr></table></div></figure>


<p>原文:</p>

<p><a href="http://www.ibiblio.org/harris/500milemail.html">http://www.ibiblio.org/harris/500milemail.html</a></p>

<h3>地板阻碍打印</h3>

<p>那还是80年代初期，我爸爸在一家存储设备公司工作，这个公司现在已经不存在了，它生产磁带机和驱动这些磁带高速运转的气动系统 —— 这是那个时代的产物。</p>

<p>他们技术改造了磁带驱动器，使得你可以只有一个中心驱动器 —— “A”盘 —— 由它连接着数个“B”盘，在跟A盘连接的内存里驻留这一个小型的操作系统，负责代理所有B盘的数据的读写操作。</p>

<p>每次当你启动A驱动器，你需要在外围驱动器里插入一张软盘，操作系统会把A盘加载到内存里。这个操作系统简单的出奇 —— 它的处理能力全部从一个8字节的微型控制器产生。</p>

<p>这种设备的目标用户是拥有大量数据的企业 —— 银行，杂志等等 —— 他们需要打印大量的地址簿或银行帐目。</p>

<p>有个客户出现了一个问题。在打印的过程中，有个别的驱动器会停止工作，导致整个打印过程终止。为了重载驱动器，值班人员必须重启所有驱动 —— 如果这种事情发生在一个6小时的打印任务中，大量宝贵的计算机使用时间都会浪费，整个任务将不能按时间完成。</p>

<p>公司派出了技术人员。技术人员尽了他最大的努力也不能在测试环境复制出这个问题：这个问题似乎只会出现在打印大量任务的过程中。尽管问题出在硬件上可能性微乎其微，他还是更换了所有的设备 —— 内存，微处理器，磁盘驱动，所有跟磁带机相关的部件 —— 但问题仍然出现。</p>

<p>于是技术人员打电话给总部叫来了一位专家。</p>

<p>专家要了一把椅子和一杯咖啡，坐在了计算机房 —— 那个时候他们已经专门为计算机提供了机房 —— 值班人员准备了一大堆的打印任务，他就在旁边看着。他等着，一直到机器崩溃。机器果真崩溃了，所有人都看着专家 —— 专家没有发现任何的线索。他命令把打印任务重新执行一次，所有的值班人员和技术人员都回各自岗位工作。</p>

<p>专家又在椅子上做下来，等着机器崩溃。这一等就是六小时，但真的又发生了。专家仍然没有弄清是什么导致了崩溃 —— 除了有一点他注意到，崩溃总是发生在屋内人比较多的时候。他命令再打印一次，重新坐下，等着。</p>

<p>当第三次崩溃时，他发现了一件事情。崩溃总是在值班人员更换其他没有关联的启动盘时发生的。进一步研究，他意识到当一个值班人员走过某块地板时崩溃就会发生。</p>

<p>地板是由铝制的板块拼成，下面有6 到 8 英寸高的隔空层，计算机所使用的大量的电缆都走地板下，这样可以避免值班人员无意间踢到它们。地板块间拼合的很紧密，这是为了保证垃圾不掉进电缆通过的空间。</p>

<p>专家说有一块地板变形了。当值班人员踩着这块变形的地板的一角时，地板块的边缘相互摩擦，这就会跟连接各地板的塑料之间产生静电，进而造成电磁干扰。</p>

<p>如今所有的RAM都有防电磁干扰功能。但当时并没有这种技术。专家指出，电磁干扰破坏的RAM的工作，操作系统也就崩溃了。</p>

<p>专家打电话给维护部门，拿来了一块新地板，他自己把它装上，问题就这样解决了。</p>

<p>原文:</p>

<p><a href="http://patrickthomson.tumblr.com/post/2499755681/the-best-debugging-story-ive-ever-heard">http://patrickthomson.tumblr.com/post/2499755681/the-best-debugging-story-ive-ever-heard</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用wireshark分析网络]]></title>
    <link href="https://happy123.me/blog/2018/10/02/yong-wiresharkfen-xi-wang-luo/"/>
    <updated>2018-10-02T21:36:37+08:00</updated>
    <id>https://happy123.me/blog/2018/10/02/yong-wiresharkfen-xi-wang-luo</id>
    <content type="html"><![CDATA[<p>这两天看了两本有意思的书，<a href="https://book.douban.com/subject/26268767/">《Wireshark网络分析就这么简单》</a>、<a href="https://book.douban.com/subject/26710788/">《wireshark网络分析的艺术》</a>。</p>

<p>之前工作中就常常用到这个软件，好多时候总是感叹<code>这个软件实在太NB了</code>，这本书作者也是个实战派，采用种种案例展示了如何用Wireshark探索网络现象，实在是很迷人。</p>

<p>开篇有一个很有意思的小问题，我思考了一下，觉得很容易作为网络理解的小case用在课堂ABC上，记录一下。</p>

<!-- more -->


<h3>问题：两台服务器A和B的网络配置如下</h3>

<ul>
<li><p>服务器A:</p>

<ul>
<li>IP:192.168.26.129</li>
<li>Mask: 255.255.255.0</li>
<li>Gateway: 192.160.26.2</li>
</ul>
</li>
<li><p>服务器B:</p>

<ul>
<li>IP:192.168.26.3</li>
<li>Mask: 255.255.255.224</li>
<li>Gateway: 192.160.26.2</li>
</ul>
</li>
</ul>


<p>B的子网掩码本应该是255.255.255.0，被不小心配成了255.255.255.224。它们还能正常通信吗？</p>

<p>哈哈，我就喜欢这样简单明快的问题。看似简单，其实想想还是有点陷阱的。而且这种问题有个共同点，就是如果你不懂原理，也没关系；喜欢瞎动手的童鞋一般都会去试试这种情况，所以能把答案<code>碰出来</code>。我就见到过这种·自学成才·的老师，他们从来没有在学校里系统学过什么TCP/IP或者老破旧的ISO 7层模型，照样能对网络和路由配置如数家珍，他们的能力完全建立在实战的基础上。</p>

<p>让我们好好分析一下这个问题。</p>

<p>首先B的子网掩码配置决定了它和A不在一个子网上，我们在书本上学到的知识，如果两台机器不在一个子网上，能够通信吗？</p>

<p>哈，如果死读书不实践的人肯定会说:不能通信，不在一个子网嘛。</p>

<p>那么我们照这个逻辑，公司里岂不是不同子网的机器老死不相往来了？</p>

<h4>看吧，这是第一个陷阱，两台机器跨子网能否通信，取决于网关。</h4>

<p>如果没有网关服务器，或者网关服务器限制的话，肯定是不能通信的，虽然A和B物理上处于同一个子网，但是这个时候可以看成有一道防火墙在两台机器之间。</p>

<h4>其实大部分网络管理员都会把网关设置为不同子网间相互转发的，不然一个公司各部门间的机器不能互访，岂不是很悲剧。</h4>

<p>那么在网关能正常转发的情况下，我们来脑补一下两个场景，B访问A，A访问B的具体过程。</p>

<h4>B Ping => A</h4>

<ol>
<li>B首先检查到A和它不在一个子网，这个时候它需要网关来转发数据包</li>
<li>B发一个网关IP的ARP请求</li>
<li>网关(192.168.26.2) 回复B的ARP请求，告诉它俺的MAC 地址是XXX</li>
<li>有了网关的MAC，B就可以直接发包给网关了，它告诉网关，我要你帮我转发包给A</li>
<li>如果网关没有限制的话，它就会把包转发给A</li>
<li>A收到B的请求，他就会问，这个B是谁呀？A检查一番，发现B和自己在一个子网</li>
<li>既然一个子网，那么A就不会走网关了，它直接发出ARP请求在以太网上广播，谁是B呀，MAC地址回我一个</li>
<li>B在物理上实际上是和A在一起的，所以直接响应A，俺的MAC地址是这个</li>
<li>A收到B的ARP响应，就很HAPPY的跳过网关，直接给B响应包啦</li>
<li>这样的结果就是B发给A的包需要走网关，A发给B的包直接广播到以太网上，由B直接接收</li>
<li>最终的效果就是B能和A正常通信，虽然B的通信绕了一点远路</li>
</ol>


<h4>A Ping => B</h4>

<p>这个过程其实跟上面一样，A发出ARP请求直接找到了B，所以A发包给B是不用走网关的，B的响应还要走网关。</p>

<p>怎么样，这么看看，是不是问题就很明晰了呢。大部分情况下(网关没有特殊配置)，A和B是能够正常通信的。</p>

<p>有点小得意的说，这个问题我很快就反应过来了；因为我和作者一样是野路子出家，实战瞎鼓捣过，所以这类小Case恰好是尝过的菜。</p>

<p>咳咳，真是有点自吹自擂了；其实绝大多数网络问题最后找到原因都很简单，但是当一个大型的网络里面发生诡异的情况时，能迅速定位问题点是很不容易的。我又回想起来之前工作时，在一个客户现场遇到的坑。</p>

<h4>很久很久以前~~~</h4>

<p>咳咳，其实也不是多久，但那个时候我已经工作挺长时间了，虽然没有经过什么系统理论培训，但是靠着大量野路子实践，我觉得也算是见过很多网络万年坑了，我去客户现场从来不怵头，但就是那一次，差点阴沟里翻船~~</p>

<p>我去国内的某家大型券商部署项目，那家券商真是壕啊，从服务器到网络设备都是定制的特别高端的一批货，然后我熟门熟路的安装好Centos7.1，他们的系统管理员按照内部规定，做了安全防护之后，我们从他们的顶层小机房转移到操作办公室，准备部署应用软件。</p>

<p>这家券商的网络大部分已经迁移到SDN上面，办公室的终端机器经过两层跳板，跳到一个云主机的shell上面，然后再远程ssh连接到我们刚刚装好的服务器上，准备大展拳脚~~~~</p>

<p>根据故事的发展，这个时候就出现了诡异的事情，随机过20~40分钟后，我们的ssh连接就会卡一段时间，然后有几率断掉，之前所有工作都是正常的，而且有时候能正常个1小时，但是最后总是会开始卡。</p>

<p>唉，网络卡死，网络时不时断掉，真的是现场网络工程师人生中的一大悲剧，这类问题感觉天天遇见，但是总是没有一个固定的套路去解决它。</p>

<p>我们的终端机经过了两重跳板，然后ssh客户端和服务器之间，还有一个庞大的网络拓扑，跋山涉水十万八千里才能相见，然后就被某个不知名的幽灵生生拆散了，想象他们艰难的会师路径，我不禁打个冷颤。</p>

<h4>肯定不能先去怀疑他们的会师历程，我们先去查找最简单的，也是最容易出错的部分，就是服务端的sshd配置</h4>

<p>因为安装完系统后，客户的管理员根据他们的安全管理条例，运行了自己开发一个脚本进行了系统加固，很自然的，我们怀疑这个脚本是不是有什么地方配置不对，导致问题</p>

<p>在对服务器配置文件和脚本代码详细检查之后，我失望的判定，人家的脚本没问题</p>

<h4>配置没有问题，那就看看是不是ssh终端软件有问题呢</h4>

<p>我反复使用ssh登陆不同的服务器，惊奇的发现，凡是登陆我们刚安装好的这批服务器，就会时不时断掉，其它服务器就没有问题；
但是悲剧的是我们的服务器所在的机房，没有其它测试机，所以只能证明ssh终端软件没问题</p>

<h4>不到万不得已，我是不想怀疑中间庞大的网络路径的，谁知道是不是什么抽风的防火墙规则呢</h4>

<h4>我抱着笔记本，跑到楼上服务器的小机房直联看看，发现直联好得很</h4>

<p>现在说起来简单，其实跑一趟机房需要审批、内部人员带路一堆手续，累的客户跟我上上下下，验证一次需要1个小时以上，而且重现时间是随机的，这就是一线人员苦逼的地方啊。</p>

<h4>看起来一切都导向那个我最不愿意看到的结果，好像是通信中间有个什么诡异的防火墙规则之类的~~，但是这么庞大的网络拓扑，怎么定位问题呢？</h4>

<h4>到了此时，客户不再纠结于安全管理条例，我们小心翼翼的祭出了·抓包·这个手段</h4>

<ul>
<li><p>不到万不得已，其实大家都不想抓包的；金融行业的客户群，重视安全问题甚于生命，所以能在生产环境中让你抓包，其实已经是皇恩浩荡了。</p></li>
<li><p>经过了几十分钟苦苦等待，终于问题又重现了，我们小心翼翼的把抓到的包存到本地，用wireshark打开，像欣赏小电影一样仔仔细细~~~</p></li>
<li><p>果然有问题，那台服务器的ARP响应包里面，MAC地址竟然会变！</p></li>
<li><p>奇哉怪哉，我们刚配好这台服务器，怎么就让人ARP欺骗了呢？而且如果是他们的网络里面有ARP病毒，为啥就只找我们的服务器呢？</p></li>
</ul>


<h4>当时已经从早上折腾到下午3点种左右，虽然有了重大发现，但是也有了更大的迷惑</h4>

<p>突然我灵光一闪，服务器接了两根网线，一根是管理口为了方便管理，这个一直没有动过，会不会是~~~</p>

<p>我立马报着笔记本和一台小交换机跑上楼去</p>

<h4>将服务器和笔记本通过一台小交换机联到一个小局域网络中，再抓包发现了真相</h4>

<p>这台定制的服务器是浪潮提供的，而浪潮的管理口有个奇怪的设定，它和服务器上的多个网卡被绑定成一个NIC Teaming，类型为Transmit Load Balancing（TLB）。TLB的特点就是收包工作只由一个网卡负责，发包工作则分摊给所有网卡，但是管理口的默认配置有问题，有时候莫名其妙会共享同一个IP，回应ARP请求的时候把自己的MAC地址发回去，但是系统中管理口是没有配置的，所以这台服务器莫名其妙就自己变成了一台ARP欺骗源。</p>

<p>问题定位了，我们打电话找浪潮的供应商；供应商也非常奇怪，表明是第一次碰到这种问题，可能是由于定制的机器，考虑不周导致的。</p>

<p>然后我们的解决方法就是，将笔记本直联服务器，在笔记本上运行一个DHCP 服务，这样管理口在开机的时候会被分配一个IP地址，我们再通过这个IP地址登陆服务器管理界面，配置一个静态IP，就OK了。</p>

<p>虽然最后是一个简单至极的ARP欺骗问题，但是发生在一个庞大的网络拓扑中，调试手段被限制，发生时间随机，楼上物理距离和安全条例导致你重现一次成本极为高昂，你还能·镇定自若，指挥谈笑间·吗，这是一次一波三折的排障经历啊。</p>

<p>我这么详细的回忆一次折腾的排障经历，是因为我在这本书里发现了作者和我一模一样的苦逼例子，在&lt;wireshark网络分析的艺术>这本书里，大家有兴趣可以自己去翻翻。</p>

<p>其实这两本书真可谓是作者的网络排障手记，因为我也有那么一段跑在一线的日子，读起来格外亲切。这就是一线工程师的日常啊。</p>

<p>曾经，我以为熟读&lt;TCP/IP详解>和&lt;Unix网络编程>就能成为无所不能的网络大拿；曾经，我以为独立实现一个网络协议栈就是开创天地的神邸；后来，我明白了，网络的海洋无穷无尽，虽然规则是死的，但是现实世界实在不可预测，也许下一分钟就会有一个匪夷所思的case来纠缠你，嘲笑你的妄自尊大。</p>

<p>在网络世界迈入SDN之际，我非常惶恐，因为我明白以我的智商，不可能成为什么·专家·了；我想，未来，可能只有在AWS或者Google Cloud浸淫数十年的人，才能小心翼翼的称自己为·真专家·；面对网络知识的变幻莫测，总有一种·生有涯，知无涯·的惶恐；我总是会感叹，网络这个东西实在是太神奇了，真不知道如何形容这份感觉，就是只有·神奇·来形容</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[黎曼猜想的证明会对加密货币产生影响吗?]]></title>
    <link href="https://happy123.me/blog/2018/09/26/li-man-cai-xiang-de-zheng-ming-hui-dui-jia-mi-huo-bi-chan-sheng-ying-xiang-ma/"/>
    <updated>2018-09-26T10:19:00+08:00</updated>
    <id>https://happy123.me/blog/2018/09/26/li-man-cai-xiang-de-zheng-ming-hui-dui-jia-mi-huo-bi-chan-sheng-ying-xiang-ma</id>
    <content type="html"><![CDATA[<p>当今资讯发达，娱乐界、学术界以及投机赌博界已然不分家了。</p>

<p>Michael Atiyah老爷子来一场数学报告，已然惊动众多娱乐媒体和赌徒大佬。老爷子的秀场视频在这里，快去瞻仰:</p>

<p><a href="https://www.youtube.com/watch?v=oe4Jo4i3w_w">https://www.youtube.com/watch?v=oe4Jo4i3w_w</a></p>

<p>为了跟上时代的步伐，民工也要求上进啊，只能又去填鸭科普了一下数学ABC。</p>

<!-- more -->


<h3>黎曼猜想是啥</h3>

<p>黎曼猜想起源于素数的研究。素数在自然数中是一种特别的数，它只能被1和自己整除。而且素数的个数是无限的。</p>

<p>素数如此特别，数学家们试图搞清楚如何判断一个数是素数。给你一个小的数，例如7，你很容易判断它是素数。但是当给你一个很大的数字时，判断一个数是否为素数，是需要方法的。由此产生了素数判定的算法。</p>

<p>为了更好地理解素数，数学家们在 19 世纪便不再尝试预测素数的精确位置，转而将素数的现象视为一个整体。这个预测素数分布规律的挑战吸引了众多大佬，包括我们的数学王子gauss，独行侠Selberg等等，最著名的还是Riemann hypothesis提出的黎曼猜想。这段历史可以参考卢昌海老师的<a href="https://www.changhai.org/articles/science/mathematics/riemann_hypothesis/index.php">科普文</a>。</p>

<p>黎曼1859年在他的论文《论小于已知数的素数个数》提出了这个著名的猜想，但它并非该论文的中心目的，他也没有试图给出证明。这个猜想描述如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20180926/bg1.jpg" alt="黎曼猜想" /></p>

<p>这个函数称之为黎曼 zeta 函数。黎曼给出了一个推测：黎曼 zeta 函数的所有非平凡零点可能都全部位于实部等于1/2的直线上。上述公式中的第二项，x 的 ρ 次幂的ρ就是黎曼 zeta 函数非平凡零点。</p>

<h4>简而言之，任意给定一个自然数x，通过这个公式能更精确的得出 x 以内素数的个数。</h4>

<p>那么这个公式是正确的吗，通过现在的计算机暴力计算，不能证伪，好像是正确的。但是也没有人能给出严格的证明，所以称之为是猜想。</p>

<h3>如果猜想被证明，对安全界有什么影响</h3>

<p>这又得从我们码农熟知的非对称加密算法开始说起了。众所周知，SSL/TLS(https)等一系列安全协议都是建立在RSA算法之上的，而RSA作为非对称加密算法的典型代表，又是建立在大素数分解的基础上的。这部分可以参考阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">科普文</a>。</p>

<p>那么黎曼猜想如果被证明，是不是意味着RSA算法就不再安全了呢？作为吃瓜群众，大可不必去跟风娱乐媒体，不需要多高深的数学知识就能自己来判断:</p>

<ol>
<li><p>黎曼猜想是在1859年提出的，虽然没人能证明，但是也没人能证伪，这说明这个方法作为一个判别素数个数分布的工具，已然被广泛运用多年了</p></li>
<li><p>非对称加密是在20世纪70年代末提出的，如果黎曼猜想能加速大素数分解的计算，那么其实1970s左右，RSA诞生之初，就已经面临重大威胁了</p></li>
<li><p>素数检测和整数分解是两回事，至今还没有人找到他们之间有何联系</p></li>
<li><p>如果素数的检测能加速分解计算的话，即使有某个人或某个组织掌握了这个技术，那么全世界的网络，包括各大银行、金融、政府组织，都会受到严重威胁；但是目前为止还没有啥迹象；</p></li>
</ol>


<h3>如果猜想被证明，对加密数字货币(如比特币)有什么影响</h3>

<p>我们知道，比特币的安全设计是远远领先于时代的，我们之前在<a href="https://happy123.me/blog/2018/04/24/cryptocurrency-security/">这篇文章</a>中，曾经谈到过比特币的地址安全问题。</p>

<ol>
<li><p>基本上所有加密货币的地址都是参考比特币，采用椭圆曲线非对称加密算法为基础生成的</p></li>
<li><p>椭圆曲线和RSA的套路完全不同，和素数分解也没啥关系，即使RSA被破解了，和比特币也是雷峰塔倒掉和学雷锋的关系&mdash;&mdash;就是没关系</p></li>
<li><p>大多数加密货币的挖矿采用了许多不同的单向散列(HASH)函数，目前理论来看，这基本上也和素数分布没啥关系</p></li>
</ol>


<h2>结论</h2>

<ol>
<li><p>黎曼猜想能不能成功证明、有没有人能理解这个证明还是两说</p></li>
<li><p>即使黎曼猜想不能被证明，它作为一个检测素数分布的工具使用已经好多年了，如果真的对基于素数分解的非对称加密算法有威胁，100多年了，早也应该暴雷了吧</p></li>
<li><p>即使RSA GAME OVER了，对于以椭圆曲线为基础的比特币等加密货币，没啥影响</p></li>
<li><p>估计娱乐媒体又要对中本聪一顿<code>先知</code>神吹了</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自由交易创造财富?]]></title>
    <link href="https://happy123.me/blog/2018/09/12/zi-you-jiao-yi-chuang-zao-cai-fu/"/>
    <updated>2018-09-12T15:44:14+08:00</updated>
    <id>https://happy123.me/blog/2018/09/12/zi-you-jiao-yi-chuang-zao-cai-fu</id>
    <content type="html"><![CDATA[<p>有人调侃说，这世上有些事人人都觉得自己懂：音乐，政治，和经济。</p>

<!-- more -->


<p>看看股市里面各种股评家就知道了，感觉人人都是斯密再生，什么不可能三角，反身性，蓄水池，M0 M1 M2，做空美国，汇率战争&hellip;&hellip;纵论世界经济大势，舍我其谁。</p>

<p>作为一个财经盲，听到人家谈论这些话题的时候完全是一脸懵逼，智商失联；为了提高一点点可怜的交际能力，近期恶补一番《国富论》。</p>

<p>于是，我由文盲晋级到小白，Level+1。这里记录一下小白的瞎想：</p>

<h2>斯密全书反复强调的一个观点: 分工和自由交易可以创造巨大的财富</h2>

<h4>分工创造财富</h4>

<p>书中开篇就举了一个例子:</p>

<blockquote><p>以前一个工匠一天最多做几十枚铁钉。但是在一个现代化工厂中，一天则可以生产几万枚。之所以有如此大的提升，原因就是进行了细致的分工：</p>

<p>有的人负责把铁熔成铁水，有的人负责把铁水抽成铁丝，有的人负责把铁丝斩断，再有的人负责把铁丝磨尖，另外有人把头给打出来，这个流程每一个人都特别熟悉自己的哪一个非常小的环节。这种分工协作，让每个人都对自己的这一个环节特别熟悉，生产效率得到了上百倍的提高。</p></blockquote>

<p>斯密观察到了这种现象，专业分工可以极大的提高生产力、创造财富——这个结论在今天已经成为常常识，在中学的课本上我们就对其耳熟能详。</p>

<h4>自由交易创造财富</h4>

<p>交易创造财富呢？</p>

<p>这一听好像是非常违背常识的事情。我们的吃穿用度，都是劳动人民辛辛苦苦用汗水换来的，是生产活动创造了财富；</p>

<p>而交易，无非是投机倒把，更甚者，那些金融掮客们，不事生产，不辨菽麦，怎么能说他们创造财富呢？一批金融人士和股民集体中枪中&hellip;.</p>

<p>斯密先生是如何解释的呢？他在<code>分工创造财富</code>的基础上继续追问，是什么促成了专业分工这种生产方式？</p>

<blockquote><p>他进一步分析，得出结论：专业分工是基于庞大的、自由的市场交易。</p>

<p>一是市场得庞大，二是交易得自由：</p>

<p>如果在某一个闭塞的小地方建立一个工厂，每日生产几万颗铁钉，铁钉是卖不出去的，因为一个人一年只需要五六根——市场不够大。市场不够大，高密度的分工就不会出现。这就是资本主义国家总是想打开封闭国家的大门的原因。</p>

<p>市场够大了，但是如果交易不自由，被各种限制，也不行。当时的欧洲，还存在封建割据。商人要把一个东西从英国卖到德国去，中间要穿过几十个封建小国，过一个关，收一道税，“通关文牒”上密密麻麻盖满了章。而且有些产品还不让过，严重阻碍了交易自由。这样，高密度的分工也不会出现。</p>

<p>当时的欧洲，还流行封建行会制度：不能说你有技术，能做鞋，你就开店去做鞋了！得经过行会批准，否则就是非法经营，就砸你的店。而且工人也不能自由跳槽，你跟了一个师傅，就像拜师学艺，不能说这个师傅对你不好，你就另找一个师傅！那不行，那是违背“道德”的。</p>

<p>这种“道德”和封建制度的枷锁，对生产力的束缚是非常之大。</p>

<p>不只是普通商品需要自由交易，土地、资本、劳动力等生产要素，也都应该可以自由交易才行——交易自由是基本的人权。</p></blockquote>

<h4>&ldquo;交易&#8221;在大部分人的直觉中，只是转移、交换，财富是不会增加的。其中的秘密是什么呢？</h4>

<p>斯密提出了一个非常著名的悖论：</p>

<blockquote><p>空气和水对于我们非常重要，却几乎是免费的，黄金钻石属于非必需品，没有它也能照样生活，却贵得要死。</p></blockquote>

<p>衣服比较需要，价格比较便宜，汽车不一定需要，价格相当昂贵。你会发现越是你不需要的东西，价格越贵。</p>

<p>为什么会这样？</p>

<p>斯密想：是什么决定了物品的价值？</p>

<p>他开创性地提出了使用价值（用值）和交换价值（换值）的概念：用值高的东西，换值可能很低，用值低的东西，换值可能很高。</p>

<p>后来有了&#8221;边际&#8221;概念之后，后人发现，换值其实就是边际用值。</p>

<p>水的用值非常高，但在喝了5杯水之后，再多喝一杯的用值则非常低了，喝到你不想再多喝一口！其边际用值非常低。</p>

<ul>
<li><p>一只画笔，在放羊娃的手里一钱不值，但到了齐白石手中，丹青妙笔下的画卷价值万金；</p></li>
<li><p>一亩鱼塘，游牧民族不屑一顾，江南农民眼里可能就千金不换；</p></li>
</ul>


<p>而这些资源，天分是老天爷随机配比的，每个人都不可能生下来物尽其用、才尽其用、各得其所；更何况一个人的境遇、天然的环境是时时变化的，齐白石也可能拿不动笔，骑马的汉子也可能会娶江南的姑娘，他也需要一亩鱼塘来养家糊口；于是便产生了交易；</p>

<p>财富的本质，源于&#8221;资源的有效配置&#8221;，就是有效的交易；资源可以是自然资源、天分、知识、美貌等等一切有人看重的东西；</p>

<p>当交易无时无刻不在发生，那么价值就无时无刻不在创造。</p>

<p>交易创造财富！</p>

<p>这种自由交易的机制，不需要有人去刻意安排，也不需要刻意维持和鼓励。只要你不去人为地打压，它就会如野草般自己生长。</p>

<p>原因何在呢？斯密先生的解释是：</p>

<blockquote><p>很多时候，一个人会需要兄弟朋友的帮助，但假如他真的要依靠他们的仁慈之心，他将会失望。倘若在需求中他能引起对方的利己之心，从而证明帮助他人是对自己有益的事，那么这个人的成功机会较大。任何人向他人提出任何形式的交易建议，都是这样想：给我所需要的，我就会给你所需要的——这是每一个交易建议的含义；而我们从这种互利的办法中，所获的会比我们所需的更多。我们的晚餐可不是得自屠夫、酿酒商人，或面包师傅的仁慈之心，而是因为他们对自己的利益特别关注。我们认为他们给我们供应，并非行善，而是为了他们的自利。</p>

<p>所以，每个人都会尽其所能，运用自己的资本来争取最大的利益。一般而言，他不会意图为公众服务，也不自知对社会有什么贡献。他关心的仅是自己的安全、自己的利益。但如此一来，他就好像被一只无形之手引领，在不自觉中对社会的改进尽力而为。在一般的情形下，一个人为求私利而无心对社会作出贡献，其对社会的贡献远比有意图作出的更大。</p></blockquote>

<p>这样看来，一个有意思的推论就产生了：</p>

<h4>某些财富可能不过是一种幻觉！！</h4>

<p>我们所看重的东西，所谓的财富，不管是我们的衣食住行实实在在的实物，还是音乐文学绘画等等精神产品，建立的基础是人们的需求。而人们的需求并不是万古不变的:</p>

<p>比如美学产品，很难说几千年后毕加索的作品会有何种评价；或者科幻一点，将来有了可飞行的汽车，市中心的房子能有多大市场&hellip;&hellip;</p>

<p>说的更唯心一点，劳动人民不过是在一种精神层面需求的驱动下生产的，财富的第一创造驱动力来自于交易。</p>

<p>D(t) > 0；交易创造财富；</p>

<p>简明版本的解释就是：</p>

<ul>
<li><p>人们喜欢吃梨子和苹果，于是培育了果树</p></li>
<li><p>我喜欢吃梨，但是家里只有苹果树；你喜欢吃苹果，家里只有梨树</p></li>
<li><p>我拿苹果换梨子，需求满足++，创造了财富</p></li>
</ul>


<h4>为什么会有人限制苹果换梨子</h4>

<p>既然自由的市场是最好的，为什么政府还会有种种管制行为呢？为什么还会有贸易战呢？再进一步，为什么需要政府插手经济呢？</p>

<ul>
<li>自由市场是会崩溃的。</li>
</ul>


<blockquote><p>16世纪后期的荷兰，出现了发达的商业贸易。但也是商业贸易，促成了“郁金香泡沫”的爆发，这是有史记载的第一次金融泡沫。</p>

<p>从16世纪中期到17世纪初期，人们逐渐对郁金香产生了狂热。一些郁金香珍品被卖到了不同寻常的高价，富人们竞相在他们的花园中展示稀有的品种。1635年，一种叫Childer的郁金香品种单株卖到了1615弗罗林（florins，荷兰货币）。一株这玩意，就能换3头公牛。第二年，一株稀有品种的郁金香（当时荷兰全境只有两株）卖到了4600弗罗林的价格，除此之外，购买者还需要支付一辆崭新的马车、两匹灰马和一套完整的马具。</p>

<p>但是，所有的金融泡沫，正如它们在现实世界中的名字所喻示的那样脆弱。这个因为自由交易而导致的泡沫，最终崩溃了。</p></blockquote>

<p>正常交易创造了财富值100，人的贪婪本性注定了有人想要攫取财富值1000；于是有了欺诈和恐惧，于是有了管制；国家也是一样的，总有一些国家更加贪婪，或者说每个国家都会更加贪婪，它们之间也会有恐惧和欺诈，于是诞生了贸易战。</p>

<ul>
<li>自由交易的市场能创造出一切东西，唯独不能创造市场本身</li>
</ul>


<p>一个公平的环境需要信用，目前为止，人类历史更迭，尝试了无数种办法，能维系信用的唯有<code>暴力</code>；这促成了国家的诞生。国家一定要用暴力来维护市场。</p>

<p>人类财富的创造源泉，最终由<code>交易</code>推导到了<code>信用</code></p>

<h2>让我们谈谈区块链(blockchain)吧</h2>

<p>我是非常不愿对这个东西夸夸其谈的，因为卷入这个场子的人，在我看来，就像美国大淘金时代一样，小偷、骗子、强盗实在太多。</p>

<p>好吧，我也一样，自以为悟到了一些东西就来夸夸其谈，大家当成笑料听听就好，不用当真。</p>

<h4>区块链是人类历史上第一次找到了这样一种工具：它维系市场，超乎暴力之上</h4>

<p>区块链是信用的承载。让我们这样想象：</p>

<p>来源于名为<code>Bitcoin</code>的信用之水，得益于早期信徒的开采维护，汇集成了一条小溪汩汩向东流去；</p>

<p>一路上有更多的信徒创造更多的信用，合力汇集为一条名为<code>blockchain</code>的大河，滚滚东流；</p>

<p>这条大河是最终到达信用之海，创造出一个超出暴力之上的信用汇集而成的新市场；还是因为没有更多的信用注入，逐渐干涸为沼泽，沦为一个庞氏骗局，没有人能预言。</p>

<p>不过可以这样推想，信用是个很神奇的东西：它无法定量计算，但是社会上产生的信用多寡又是如此明显；人人都知道一个正直的人创造的信用值肯定大于一个骗子；同理，同样的人口，一个民风淳朴的国家创造的信用肯定大于索马里人民的信用值；</p>

<p>最神奇的，一个人可以创造的信用没有明显的上限；信用也可以由一代代的人无限创造；相对的，信用也可能不断损耗，最终趋近于0。</p>

<p>我们所景仰的奥马哈先知曾多次强调：比特币是老鼠药的平方。</p>

<p>当区块链上承载的信用量不再增加的时候，就是一朵郁金香。奥马哈的先知此时是对的。</p>

<p>当区块链上承载的信用无限增加的时候，就是永不终结的市场。当然这个概率有多少，没人能预测。</p>

<h4>回到未来</h4>

<p>让我们掏出水晶球，冒险预言一下blockchain的未来：</p>

<ul>
<li>初期</li>
</ul>


<p>就像早期大淘金时代一样，这个市场会充斥骗子、小偷、强盗、投机家，以及一些英雄人物；但还是摆脱不了<code>庞氏骗局</code>的帽子</p>

<p>正如我们前面所强调了，区块链是一条信用之链，而且目前维护这样一条链的代价及其昂贵；</p>

<p>既然是如此金贵的资源，那么最初利用它做什么呢？有什么东西是信息量无限小，价格无限大呢？</p>

<p>我们把能想到的领域排排坐：</p>

<p>1.铸币权</p>

<p>2.投机博彩传销</p>

<p>3.洗钱</p>

<p>4.黑市</p>

<p>5.国际汇款</p>

<p>6.券商承兑，金融产品</p>

<p>7.法律公证等等一切需要用到公章的地方</p>

<p>8.版权、数字营销、保险、电子证据、物联网、供应链、积分共享、征信、公益、游戏道具等等PPT概念产品</p>

<p>9.工业能源政务医疗衣食住行阿猫阿狗等等忽悠</p>

<p>&hellip;&hellip;</p>

<p>目前占大头的应用是什么呢？上面的诸家应用能在什么阶段落地呢？</p>

<p>是不是看出来有些东西永远不能落地，为什么呢？</p>

<p>大家自有分辨。</p>

<ul>
<li>早期</li>
</ul>


<p>一个国家金融业完善发达，一个国家还处于一穷二白，谁更需要所谓的数字货币，所谓的区块链呢？</p>

<p>与直觉相反，我认为将来比特币会在中东这种政治动荡之地，拉美这种经济动荡之地，非洲这种一穷二白之地发挥巨大作用；</p>

<p>对于其它经济体，肯定会抵制、再抵制，直到无可奈何，开一道小口子，让其在外贸领域有点活命的机会；或者说，比特币是永远不能登上主流舞台的，它只能跟投机、黑市、国家破产等等联系在一起。</p>

<p>那是不是说，这个技术就没有前途呢？就等着各国纷纷禁止，然后戳破泡沫，价格归零呢？</p>

<ul>
<li>中期</li>
</ul>


<p>不是的，它是一项非常非常危险的创造，潘多拉魔盒一旦打开，无法关闭。数字货币的生命力可能会超过许多国家的寿命，成为新时代的黄金，但是是一种不能为国家所容忍的黄金。</p>

<p>所以，这个泡沫会 破灭->复兴->破灭，不断的循环下去，投身于其中的人会越来越多；</p>

<p>这是一个泡沫，但是可能会持续几十年甚至超过国家的寿命，也可能一夜归零后，等待几年甚至几十年才能有下次复兴；</p>

<p>blockchain本质上是一项跟国家抢夺铸币权、抢夺信用定价权的技术，它从根本上动摇了国家的根基，所以可能会出现绝大多数国家联起手来，共同封杀这项技术的一天。</p>

<ul>
<li><p>后期</p>

<ul>
<li><p>究竟是人类的贪婪占据上风，信用之河就此干涸成为沼泽，最终作为最大的郁金香泡沫永载史册呢?</p></li>
<li><p>还是一小撮信徒自诩为摩西，或者卫星上天，或者公海游弋，或者开疆裂土，建立一个信用自由港呢？</p></li>
<li><p>还是开天辟地，超脱国家和暴力，成立一个新的信用市场呢？</p></li>
</ul>
</li>
</ul>


<h4>唯有时间能给出答案。</h4>

<hr />

<p>PS: 神遭遭瞎扯了这么多，其实我是被Bitcoin Core的闪电网络的代码搞烦了，我怎么也理解不了；</p>

<p>理解不了的东西让我对他的安全性产生重大怀疑，我能创造的的信用值直线下降；</p>

<p>市场动荡之际，我投入BCH阵营了；好吧，这一次我是个投机者了，Maybe将来很悲惨，所以回到未来记下这一惨痛投机教训。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The History of X86]]></title>
    <link href="https://happy123.me/blog/2018/09/12/the-history-of-x86/"/>
    <updated>2018-09-12T10:22:01+08:00</updated>
    <id>https://happy123.me/blog/2018/09/12/the-history-of-x86</id>
    <content type="html"><![CDATA[<p>我们平时老看到<code>X86指令集</code>, <code>X86架构</code>等等词汇，很容易就猜到这个86来源于Intel那款名动天下的处理器&mdash;8086，那么8086的名字又是怎么来的呢？</p>

<!-- more -->


<p>这是一个遥远的传说，各种解释众说纷纭，挑两个有说服力的段子吧:</p>

<h4>说法1</h4>

<p>当intel发明第一颗4位的位处理器的时候，intel把他叫4004。在当时，intel也没有意识到这就是微处理器，（微处理器是后来人的说法），intel当时只是给做手持计算器的厂家来定制处理器。</p>

<p>因为4004的指令集很有限，所以又搞出来了一个升级版本4040。</p>

<p>8008是4004的8位版，8080是4040的8位版。</p>

<p>8085是8080的单5伏电压版。</p>

<p>8085升级到16位后，就叫8086了。</p>

<p>嗯，还是很有逻辑的。</p>

<h4>说法2</h4>

<p>微处理器是在70年代末发明的。 接近80年，所以，前两个数字就是这么来的;</p>

<p>当时微处理器是8位的，因此，第3个数字是8;</p>

<p>在8085和8086 cpu之前，8080处理器是需要+5-5和12v电压来工作。 随着技术的进步，只需要单一的5v供电了，因此，最后一个数字是5;</p>

<p>8085升级到16位后，就叫8086了;</p>

<p>好吧，也说得通。</p>

<h4>不管怎么说，反正Intel推出的8086在历史上的经典地位不容置疑；那我们来简单回顾一下Intel CPU发展的历史吧</h4>

<ul>
<li><p>20世纪70年代末，Intel生产了著名的16位8086处理器，之后又推出了80186与80286；</p></li>
<li><p>1985年，Intel继摩托罗拉之后，第二个研制出32位的微处理器80386；</p></li>
<li><p>8086、80286、80386等等，这一系列CPU就称作x86，正式一点称作IA-32（Intel Architecture 32-bit）。正是这个架构开启了Intel在个人PC CPU领域的无敌之路，后来的操作系统、编译器、应用软件无一不是把<code>适配X86指令</code>作为核心竞争力；</p></li>
<li><p>1989年，Intel推出80486处理器，具有浮点运算功能；</p></li>
<li><p>因为当初与Intel竞争微处理器的摩托罗拉公司是以86开头的，如68000，68010，68020，而且AMD也崭露头角，他们也搞出来AM386，AM486等等，令Intel不胜其烦；而当时的法律不允许将数字注册为商标，于是1993年，Intel推出奔腾(Pentium)处理器，不再以数字命名其产品；Pentium刚刚推出的时候，命名及其混乱，有人叫I586，有人叫P5，有人叫PI，还有人叫奔腾的芯，更别提什么梦幻神器，裸奔天下等等搞笑名词了~~不管怎么说，那时候伴随我们记忆的不只是Pentium这个名字，还有那个经典的&#8221;等等等你等&#8221;的广告音乐，Intel又凭借Pentium这个架构继续无敌并寂寞着</p></li>
<li><p>在Pentium时代，其实AMD也不是毫无作为，老一代DIY玩家们一定还对Athlon K7的传说记忆犹新，尤其是当时那些拉风的译名，什么&#8221;速龙&#8221;、&#8221;毒龙&#8221;、&#8221;钻龙&#8221;等等，我得说，这个时期的农企实在是很时髦，远远不像他们后来的市场部那么傻13</p></li>
<li><p>当然，当时最璀璨的舞者，我只献给活在DIYer心里那个最美好的名字&mdash;图拉丁赛扬；正是这款CPU成为了许多人的电脑时代的启蒙者</p></li>
<li><p>2001年开始，Intel将用于服务器以及工作站的Pentium 4 Xeon独立成全新的品牌“Xeon”（至强）)；正如这个名字所蕴含的霸气一样，这个品牌延续到了今天</p></li>
<li><p>2006年，Intel发布“Core”（酷睿）品牌，用作英特尔的旗舰级处理器系列的新品品牌； 然后，这个品牌经历了数代架构更迭，一直伴随我们到了今天</p></li>
<li><p>同样的，围绕指令集从32位跃迁到64位的过程中，AMD和Interl在这段时间还爆发了一场惊天缠斗；Intel作为CPU市场的领跑者，觉得自己理应主导32位到64位时代跃进的浪潮；早在Pentium时代，他们就制定了Intel 64计划；然而，由于一个大公司内部的种种政治斗争，市场斗争，人的本性里面悲剧的傲慢，这个过程种出现了种种败着昏棋，最终AMD64架构在IA-32上新增了64位寄存器，并兼容早期的16位和32位软件，可使现有以x86为对象的编译器容易转为AMD64版本，在2003年9月推出了AMD64；在64位时代由追随者变成领跑者</p></li>
<li><p>Intel此时如梦方醒，慌忙将AMD的指令集拿过来稍作加工推出自己的兼容产品；然后就是两个公司营销和市场人员、法律人员旷日持久的撕逼大战；中间诞生了许许多多匪夷所思的营销名词，比如A64, I64, IA32E，iAMD64，Intel64，X86-64等等等等；如果你是一个Linux爱好者，很容易看到各个软件包都会注明Amd64, X86_64等等，这是那场混乱大战的遗留物</p></li>
</ul>


<h4>总结一下现在的主流</h4>

<ul>
<li><p>32/64 位系统编译在32位系统上运行 => x86</p></li>
<li><p>32 系统上编译64位系统上运行 => x86_amd64</p></li>
<li><p>64 系统上编译在64位系统上运行 => amd64</p></li>
</ul>


<h4>看看MSDN的解释:</h4>

<blockquote><p>The following list describes the various versions of cl.exe (the Visual C++ compiler):</p>

<p>x86 on x86
Allows you to create output files for x86 machines. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.
Itanium on x86 (Itanium cross-compiler)
Allows you to create output files for Itanium. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.</p>

<p>x64 on x86 (x64 cross-compiler)
Allows you to create output files for x64. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.</p>

<p>Itanium on Itanium
Allows you to create output files for Itanium. This version of cl.exe runs as a native process on an Itanium machine.</p>

<p>x64 on x64
Allows you to create output files for x64. This version of cl.exe runs as a native process on an x64 machine.</p></blockquote>

<h4>总之CPU的历史生动说明了了计算机界的很多老梗是如何诞生的，比如很多人都疑惑为什么Windows的发布名称是Win95->W98->W98SE->Win2000(NT)&ndash;>WinXP->Vista->Win7->Win10，等等等等；这种现象是商业环境、市场营销、法律风险以及随意拍脑门的高管，放荡不羁的开发团队合力促成的~~~</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Minimum Fee of Bitcoin Transaction]]></title>
    <link href="https://happy123.me/blog/2018/09/11/the-minimum-fee-of-bitcoin-transaction/"/>
    <updated>2018-09-11T15:13:35+08:00</updated>
    <id>https://happy123.me/blog/2018/09/11/the-minimum-fee-of-bitcoin-transaction</id>
    <content type="html"><![CDATA[<p>昨天看到地球人都知道的1号地址转了<a href="https://btc.com/b9a6f0b287646c30bdafa08cc997d7af93ca20eb7b2d09084ddf7a7a075394b2">0.00000555个币进来</a>，也不知道是谁在做测试，恶作剧心起，遂想要转掉这点娱乐币。</p>

<p>默认Bitcoin Core 0.15之后的客户端貌似都不能调节transaction fee大小了，老实说，自从Segwit升级完毕之后，我很少用core钱包了。这次没办法，为了构造一笔最小手续费用的交易，采取如下动作:</p>

<!-- more -->


<p>1.先看一下vout和txid:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli listunspent 0 9999999 "[\"12AKRNHpFhDSBDD9rSn74VAzZSL3774PxQ\"]"</span></code></pre></td></tr></table></div></figure>


<p>输出里面找到 <code>12AKRNHpFhDSBDD9rSn74VAzZSL3774PxQ</code>的vout为0， txid是<code>b9a6f0b287646c30bdafa08cc997d7af93ca20eb7b2d09084ddf7a7a075394b2</code></p>

<p>2.创建转账交易</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli createrawtransaction "[{\"txid\":\"b9a6f0b287646c30bdafa08cc997d7af93ca20eb7b2d09084ddf7a7a075394b2\",\"vout\":0}]" "{\"1HB1Efu8RkEpxzTHYd1E7NgdimL1ddDhkR\":0.0000055}"</span></code></pre></td></tr></table></div></figure>


<p>得到十六进制输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0200000001b29453077a7adf4d08092d7beb20ca93afd797c98ca0afbd306c6487b2f0a6b90000000000ffffffff0126020000000000001976a914b1665e71006dbfbabb69cbcdc5717b11abdb89e888ac00000000</span></code></pre></td></tr></table></div></figure>


<p>3.签名之</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli signrawtransaction  "0200000001b29453077a7adf4d08092d7beb20ca93afd797c98ca0afbd306c6487b2f0a6b90000000000ffffffff0126020000000000001976a914b1665e71006dbfbabb69cbcdc5717b11abdb89e888ac00000000"</span></code></pre></td></tr></table></div></figure>


<p>得到十六进制输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "hex": "0200000001b29453077a7adf4d08092d7beb20ca93afd797c98ca0afbd306c6487b2f0a6b9000000008a47304402202a51aa8eb0593a4b48880712c3ee70b7d6ca74ed313ef93e9c92489616587a2c022048c87fde75761e2a9cc9fef7dc8d0d9961ef1df89e22f88e5e3902567ec956f8014104fdf4907810a9f5d9462a1ae09feee5ab205d32798b0ffcc379442021f84c5bbfc891eb16b0faef4bef99ba6d522fb85470a20df730808e583778aa35c7af98f5ffffffff0126020000000000001976a914b1665e71006dbfbabb69cbcdc5717b11abdb89e888ac00000000",
</span><span class='line'>  "complete": true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>4.激动人心的时刻来了，广播之:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli sendrawtransaction  "0200000001b29453077a7adf4d08092d7beb20ca93afd797c98ca0afbd306c6487b2f0a6b9000000008a47304402202a51aa8eb0593a4b48880712c3ee70b7d6ca74ed313ef93e9c92489616587a2c022048c87fde75761e2a9cc9fef7dc8d0d9961ef1df89e22f88e5e3902567ec956f8014104fdf4907810a9f5d9462a1ae09feee5ab205d32798b0ffcc379442021f84c5bbfc891eb16b0faef4bef99ba6d522fb85470a20df730808e583778aa35c7af98f5ffffffff0126020000000000001976a914b1665e71006dbfbabb69cbcdc5717b11abdb89e888ac00000000"</span></code></pre></td></tr></table></div></figure>


<p>然后得到报错:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>error message:
</span><span class='line'>66: min relay fee not met</span></code></pre></td></tr></table></div></figure>


<p>喵喵喵，怎么回事，我记得2016年的时候还是允许0.00000001的手续费的，比如下面这笔交易:</p>

<p><a href="https://blockchain.info/tx/d36a18d1fa4c6ccc4b90ab8a13dd3e55b396ac07bf7fbbee281c1025da2b86fc">https://blockchain.info/tx/d36a18d1fa4c6ccc4b90ab8a13dd3e55b396ac07bf7fbbee281c1025da2b86fc</a></p>

<p>5.没办法，我只能在createrawtransaction的时候手工指定手续费为0.000001，心痛啊，手续费是转账金额的20%~</p>

<p>然后又得到了这个错:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mempool min fee not met</span></code></pre></td></tr></table></div></figure>


<p>怒了，又去翻了一下代码，还是由mempoolminfee 决定的啊，执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoin-cli getmempoolinfo</span></code></pre></td></tr></table></div></figure>


<p>现在是够的啊，搞不明白了；不行，再等别人就转走了，得争分夺秒啊2333</p>

<p>6.只能去找几个大矿池在线广播了，我无奈的先后使用了:</p>

<p><a href="https://btc.com/tools/tx/publish">https://btc.com/tools/tx/publish</a></p>

<p><a href="https://www.blockchain.com/btc/pushtx">https://www.blockchain.com/btc/pushtx</a></p>

<p><a href="https://live.blockcypher.com/btc/pushtx/">https://live.blockcypher.com/btc/pushtx/</a></p>

<p>统统失败，悲剧了；还测试出blockcypher有个500，它的后台没处理好，直接就挂掉了；btc.com是个鬼精灵，把所有的异常一把抓，就不告诉你出了啥错；值得表扬的是blockchain.info，完美显示了bitcoin core抛出的错误，嗯嗯嗯，记住，以后可以用极小值的手续费广播来测试这几个网站的后台bitcoind 实现版本，不要干坏事哦~~</p>

<p>7.万般无奈之下我将手续费用继续提高为0.000002，然后得到下面的报错:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dust transaction</span></code></pre></td></tr></table></div></figure>


<p>一顿google之下发现0.15版本以后，bitcoin core的<a href="https://bitcoin.stackexchange.com/questions/10986/what-is-meant-by-bitcoin-dust">dust判定标准是546 satoshins</a>，这笔交易的金额正好处于这么一个微妙的位置。</p>

<p>8.一通操作之后，发现这笔钱是无论如何不能立即拿出来了；于是写个脚本暴力广播之，总有mempool size下来的时候吧，我幻想着，说不定能中奖呢23333</p>

<h4>结局</h4>

<p>昨晚有个土豪加上另外一个vout提走了，额，为了提0.00000555BTC，土豪动用了88BTC的vout作为陪练，并留下了0.00000400(高达90%) 的矿工费，交易记录在此:</p>

<p><a href="https://btc.com/d6d59802eb987fe96b9e827c07a1acff5e80ba5e9dae3f6f56f9ea427d98e585">https://btc.com/d6d59802eb987fe96b9e827c07a1acff5e80ba5e9dae3f6f56f9ea427d98e585</a></p>

<p>土豪，是在下输了。</p>

<p>这件事情挺有意思的，我相信还有很多自动机器人在hunter这几个大众抽奖地址，为了不到1分钱，真是<code>一通操作猛如虎，回头一看啥没有</code>。而且中间还有一笔流入，我放过了；作为傻逼的记录，我老老实实记一下。</p>

<p>现在minimum fee的行情是0.00001/KB，下次我得记好了，方便抽奖。</p>
]]></content>
  </entry>
  
</feed>
