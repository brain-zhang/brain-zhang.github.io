<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-05-06T10:11:27+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Improve Performance Your Cmd by Parallel]]></title>
    <link href="http://happy123.me/blog/2018/05/06/how-to-improve-performance-your-cmd-by-parallel/"/>
    <updated>2018-05-06T09:32:03+08:00</updated>
    <id>http://happy123.me/blog/2018/05/06/how-to-improve-performance-your-cmd-by-parallel</id>
    <content type="html"><![CDATA[<p>有很多时候，处理一个大文件，常规命令并不能很好的利用多核</p>

<!-- more -->


<p>例如，一个1T的文本，百亿条数据，我想要:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wc -l test.txt</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fgrep xxxx test.txt</span></code></pre></td></tr></table></div></figure>


<p>一般机器就会自觉进入<code>一核有难，其它核点赞</code>的看戏模式。</p>

<p>我花钱配了这么多核，加了这么多内存，不是让大家来看戏的。于是祭出<code>parallel</code>~</p>

<h2>原理</h2>

<p>parallel 是一个perl脚本，通过分割输入，并行处理的方式来加速执行命令。</p>

<p>例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wc -l test.txt</span></code></pre></td></tr></table></div></figure>


<p>简单想想就是用个for循环split文件，挨个wc，然后相加。parallel就是自动帮你把这类事情做掉而已。大道不过两三行，所谓外部排序，Map-Reduce莫不如是。</p>

<h2>安装 (ubuntu 16.04LTS)</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> apt-get install parallel</span></code></pre></td></tr></table></div></figure>


<h2>示例</h2>

<h4>最快的办法计算一个大文件的行数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --pipe wc -l | awk '{s+=$1} END {print s}'</span></code></pre></td></tr></table></div></figure>


<p>非常的巧妙，先使用parallel命令‘mapping’出大量的wc -l调用，形成子计算，最后通过管道发送给awk进行汇总</p>

<h4>SED, 想在一个巨大的文件里使用sed命令做大量的替换操作吗？</h4>

<p>常规做法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sed s^old^new^g bigfile.txt</span></code></pre></td></tr></table></div></figure>


<p>现在你可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --pipe sed s^old^new^g</span></code></pre></td></tr></table></div></figure>


<h4>GREP 一个非常大的文本文件</h4>

<p>以前你可能会这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep pattern bigfile.txt</span></code></pre></td></tr></table></div></figure>


<p>现在你可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --pipe grep 'pattern'</span></code></pre></td></tr></table></div></figure>


<p>或者这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --block 10M --pipe grep 'pattern'</span></code></pre></td></tr></table></div></figure>


<p>这第二种用法使用了 –block 10M参数，这是说每个内核处理1千万行——你可以用这个参数来调整每个CUP内核处理多少行数据。</p>

<h4>压缩一个非常大的文件</h4>

<p>bzip2是比gzip更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。</p>

<p>以前的做法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.bin | bzip2 --best &gt; compressedfile.bz2</span></code></pre></td></tr></table></div></figure>


<p>现在这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.bin | parallel --no-notice --pipe --recend '' -k bzip2 --best &gt; compressedfile.bz2</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>作为一个Python党，经常写一些<code>用过即弃</code>的边角料脚本</p>

<p>比如最近要把一个1T的文件汉字全部转换为拼音，初版当然是这样的:</p>

<h4>版本1</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>with io.open(sys.argv[1], encoding='utf-8') as fp:
</span><span class='line'>    for line in fp:
</span><span class='line'>        print(lazy_pinyin(line))</span></code></pre></td></tr></table></div></figure>


<p>lazy_pinyin的效率奇慢无比，这回陷入了一核有难，其它核+内存+磁盘全部看戏模式</p>

<p>作为一个初级合格的Python开发人员，你当然说要用process，于是我们有了第二版:</p>

<h4>版本2</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from multiprocessing import Pool
</span><span class='line'>pool = Pool(16)
</span><span class='line'>with io.open(sys.argv[1], encoding='utf-8') as fp:
</span><span class='line'>    pool.map(lazy_pinyin, fp, 16)
</span><span class='line'>    pool.close()
</span><span class='line'>    pool.join()</span></code></pre></td></tr></table></div></figure>


<p>嗯，很好，16个核都跑起来了；但是你有很快尴尬的发现，map把文件一把load进来，内存有难了</p>

<h4>~~~~</h4>

<p>作为一个初级合格的Python开发人员，你当然说不要一把读进来，要用chunk_read，一次读一块，或者更高级一点，直接用mmap映射进内存巴拉巴拉</p>

<h4>少年，这还是那个边角料脚本吗，你已经在它上面操心一个小时了，还能不能愉快的玩耍了</h4>

<p>让 parallel来拯救你</p>

<h4>版本3</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import fileinput
</span><span class='line'>
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    for line in fileinput.input():
</span><span class='line'>        lazy_pinyin(line)</span></code></pre></td></tr></table></div></figure>


<p>然后执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt| parallel --no-notice --pipe python pinyinconv.py &gt; pinyin.result</span></code></pre></td></tr></table></div></figure>


<p>享受所有CPU满负荷运载的工头压榨工人的快感吧</p>

<h2>一些扩展</h2>

<ul>
<li>为啥所有的parallel都带有一个奇怪的&mdash;no-notice?</li>
</ul>


<p>嗯，虽然这个作者非常非常好，但是他总是在命令前面输出一些慈善提示；当然我并不是讨厌这种做法，但看多了总有些疲劳，你懂的~~</p>

<ul>
<li>这些命令都是pipeline读取stdin，怎么直接从文件流里面读?</li>
</ul>


<p>看手册</p>

<ul>
<li>我有一些参数想传给程序，怎么办？</li>
</ul>


<p>看手册</p>

<ul>
<li>这个命令很好，但是语法好像啰嗦了一些，还有其它的替代命令吗？</li>
</ul>


<p>嗯~ o(<em>￣▽￣</em>)o，还是有的，xargs有个-P的参数，类似的效果，不过功能弱化很多，基本上是鸡肋</p>

<h2>参考:</h2>

<h4>手册:</h4>

<p><a href="https://www.gnu.org/software/parallel/parallel_tutorial.html">https://www.gnu.org/software/parallel/parallel_tutorial.html</a></p>

<h4>资料:</h4>

<p><a href="http://www.freeoa.net/osuport/sysadmin/use-gnu-parallel-multi-core-speed-up-cmd_2343.html">http://www.freeoa.net/osuport/sysadmin/use-gnu-parallel-multi-core-speed-up-cmd_2343.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Sort a Very Very Very Big File]]></title>
    <link href="http://happy123.me/blog/2018/05/03/how-to-sort-a-very-very-very-big-file/"/>
    <updated>2018-05-03T07:21:50+08:00</updated>
    <id>http://happy123.me/blog/2018/05/03/how-to-sort-a-very-very-very-big-file</id>
    <content type="html"><![CDATA[<p>sort -uo 一个1T的文件，让最高配的google cloud instance (48 core/512G)崩溃了<del>，可惜了我的$30，白白跑了那么长时间</del></p>

<p>网上搜索都是how to sort a big file，那我这个属于very very very big big big file了~~</p>

<p>不管是并行也好，管道也好，用了各种奇技淫巧就是敌不过人家 very very big~</p>

<p>不要跟我谈什么外排，归并，位图，bloom filter，redis hash去重，我就是不想折腾，最后只有分割手动外排搞定~~</p>

<h3>把大象装进冰箱分为几步？</h3>

<h3>三步:</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>split -l 1000000000 huge-file small-chunk
</span><span class='line'>
</span><span class='line'>for X in small-chunk*; do sort -u &lt; $X &gt; sorted-$X; done
</span><span class='line'>
</span><span class='line'>sort -u -m sorted-small-chunk* &gt; sorted-huge-file && rm -rf small-chunk* sorted-small-chunk*</span></code></pre></td></tr></table></div></figure>


<h3>小TIPS:</h3>

<p>如果只要去重不要排序的话，尽量不要用 sort -u或者sort | uniq，这个是nLog(n)的效率，让人捉急。</p>

<p>可以利用awk的数组是内存hash表的特性，直接awk来做，前提是你内存够大，瞎估估需要十倍于数据的内存吧:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat xxxxx zzz | awk '{ if (!seen[$0]++) { print $0; } }' &gt; xxx_zzz.uniq.txt</span></code></pre></td></tr></table></div></figure>


<h3>PS:</h3>

<p>我后来又看了一下GNU Sort的实现描述，它说已经用了外排了，但是实际使用还是不给力，暂时迷惑中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get Intersection of Two Big Files]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-get-intersection-of-two-big-files/"/>
    <updated>2018-05-01T22:18:33+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-get-intersection-of-two-big-files</id>
    <content type="html"><![CDATA[<p>两个大文件，a.txt和b.txt两个文件的数据都是逐行呈现的， 如何求他们的交集、并集和差集。</p>

<p>用sort+uniq直接搞定:</p>

<h2>交集</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sort a.txt | uniq &gt; aa.txt
</span><span class='line'>$ sort b.txt | uniq &gt; bb.txt
</span><span class='line'>$ cat aa.txt bb.txt | sort | uniq -d</span></code></pre></td></tr></table></div></figure>


<h2>并集</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat a.txt b.txt | sort | uniq</span></code></pre></td></tr></table></div></figure>


<h2>差集</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sort a.txt | uniq &gt; aa.txt
</span><span class='line'>$ sort b.txt | uniq &gt; bb.txt
</span><span class='line'>$ cat aa.txt bb.txt bb.txt | sort | uniq -u</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在开搞 bloom filter或者bitmap 或者grep -f之前可以先组合工具来一个</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Parallel All Cmds for Linux]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-parallel-all-cmds-for-linux/"/>
    <updated>2018-05-01T13:07:20+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-parallel-all-cmds-for-linux</id>
    <content type="html"><![CDATA[<p>grep 一个100GB的文件总是很有压力，怎么才能提速呢?</p>

<h3>瞎优化</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LC_ALL=C fgrep -A 5 -B 5 'xxxxx.password' allpassseed.txt</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p><code>LC_ALL=C</code>比<code>LC_ALL=UTF-8</code>要块</p></li>
<li><p>不需要正则的话，用fgrep可以提速</p></li>
</ul>


<h3>不过这样优化总是治标不治本，下面隆重推出linux 里面parallel all cmds的perl工具</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat allpassseed.txt |parallel  --pipe  --no-notice grep -f xxxxx.password</span></code></pre></td></tr></table></div></figure>


<p>使用parallel ，和不使用parallel直接grep。结果显而易见，相差 20 倍。这比用啥 ack，ag优化效果明显多了</p>

<h3>xargs也有一个-n的多核选项，可以作为备用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ time echo {1..5} |xargs -n 1  sleep
</span><span class='line'>
</span><span class='line'>real    0m15.005s
</span><span class='line'>user    0m0.000s
</span><span class='line'>sys 0m0.000s</span></code></pre></td></tr></table></div></figure>


<p>这一条xargs把每个echo的数作为参数传给sleep ，所以一共sleep了 1+2+3+4+5=15秒。</p>

<p>如果使用 -P 参数分给5个核，每个核各sleep 1,2,3,4,5秒，所以执行完之后总共sleep的5秒。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ time echo {1..5} |xargs -n 1 -P 5 sleep
</span><span class='line'>
</span><span class='line'>real    0m5.003s
</span><span class='line'>user    0m0.000s
</span><span class='line'>sys 0m0.000s</span></code></pre></td></tr></table></div></figure>


<ul>
<li>引自:</li>
</ul>


<p><a href="https://www.jianshu.com/p/c5a2369fa613">https://www.jianshu.com/p/c5a2369fa613</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Calling Multiple Commands Through Xargs]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-calling-multiple-commands-through-xargs/"/>
    <updated>2018-05-01T09:25:03+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-calling-multiple-commands-through-xargs</id>
    <content type="html"><![CDATA[<p>有时候想在xargs后面接多条命令，这个时候直接加<code>;</code>是不行的，要这样做:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat a.txt | xargs -I@  sh -c 'command1; command2; ...'</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Compress All Find Files to Single Line Argv]]></title>
    <link href="http://happy123.me/blog/2018/04/30/how-to-compress-all-find-files-to-single-line-argv/"/>
    <updated>2018-04-30T10:39:39+08:00</updated>
    <id>http://happy123.me/blog/2018/04/30/how-to-compress-all-find-files-to-single-line-argv</id>
    <content type="html"><![CDATA[<p>有时候find的所有文件要合并为一个argv管道到一个命令里面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>find /path/to/directory/ -name *.csv -print0 | xargs -0 -I file cat file &gt; merged.file</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Sort Big Files]]></title>
    <link href="http://happy123.me/blog/2018/04/27/how-to-sort-big-files/"/>
    <updated>2018-04-27T17:03:22+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/how-to-sort-big-files</id>
    <content type="html"><![CDATA[<p>在linux要排序一个100G的文件，压力比较大</p>

<p>并行解决之:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort -S 50% --parallel=2 -uo list-sorted.txt list.txt</span></code></pre></td></tr></table></div></figure>


<p>注意这一招在管道里面行不通，所以要用管道的话一定要先重定向到一个文件里面中转一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Strange Bitcoin Transaction]]></title>
    <link href="http://happy123.me/blog/2018/04/27/a-strange-bitcoin-transaction/"/>
    <updated>2018-04-27T14:24:30+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/a-strange-bitcoin-transaction</id>
    <content type="html"><![CDATA[<p>在之前的<a href="http://happy123.me/blog/2018/04/24/cryptocurrency-security/">谈谈比特币的地址安全问题</a>这篇文章中，我们谈到一个名为&#8221;LBC&#8221;的项目，这个项目通过暴力碰撞企图打捞到一些什么东西。</p>

<p>令人惊奇的是，他们真的碰到了几个地址。对他们最近发现的4个地址做了一下分析，发现了更让人惊奇的事情。</p>

<p>他们最近的四个发现是:</p>

<!-- more -->


<h4>2017-11-15 01:25:58 UTC</h4>

<ul>
<li><p>private key:0x236fb6d5ad1f43</p></li>
<li><p>hash160:cb66763cf7fde659869ae7f06884d9a0f879a092</p></li>
<li><p>address:1KYUv7nSvXx4642TKeuC2SNdTk326uUpFy</p></li>
<li><p>balance:0.054 BTC</p></li>
</ul>


<h4>2017-09-04 16:54:48 UTC</h4>

<ul>
<li><p>private key:0x180788e47e326c.</p></li>
<li><p>hash160:2f4870ef54fa4b048c1365d42594cc7d3d269551</p></li>
<li><p>address:15K1YKJMiJ4fpesTVUcByoz334rHmknxmT</p></li>
<li><p>balance: 0.053 BTC</p></li>
</ul>


<h4>2017-04-21 12:50:55 UTC</h4>

<ul>
<li><p>private key:0xefae164cb9e3c.</p></li>
<li><p>hash160: 36af659edbe94453f6344e920d143f1778653ae7</p></li>
<li><p>address:15z9c9sVpu6fwNiK7dMAFgMYSK4GqsGZim</p></li>
<li><p>balance:0.052 BTC</p></li>
</ul>


<h4>2017-04-05 02:23:00 UTC</h4>

<ul>
<li><p>private key:0x75070a1a009d4.</p></li>
<li><p>hash160:ef6419cffd7fad7027994354eb8efae223c2dbe7</p></li>
<li><p>address:1NpnQyZ7x24ud82b7WiRNvPm6N8bqGQnaS</p></li>
<li><p>balance:0.051 BTC</p></li>
</ul>


<h3>账户的余额依次递增，分别为0.051 &ndash;> 0.052 &ndash;> 0.053 &ndash;> 0.054</h3>

<h3>这也太凑巧了吧，为什么LBC的网站上没有小于0.051之前的数额呢</h3>

<p>一番追踪之后，我们发现了下面这笔交易:</p>

<p><a href="https://btc.com/08389f34c98c606322740c0be6a7125d9860bb8d5cb182c02f98461e5fa6cd15">https://btc.com/08389f34c98c606322740c0be6a7125d9860bb8d5cb182c02f98461e5fa6cd15</a></p>

<p>在2015年初的时候就有人对于比特币的安全模型提出过一个严肃的检验，他构造了以上这笔交易。</p>

<p>这笔交易的每个输出地址的私钥是这样构造的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>000...........................00001
</span><span class='line'>0000..........................000011
</span><span class='line'>0000.........................0000111
</span><span class='line'>0000........................00001000
</span><span class='line'>0000.......................000010101
</span><span class='line'>0000......................0000110001
</span><span class='line'>0000.....................00001001100
</span><span class='line'>0000....................000011100000
</span><span class='line'>0000...................0000111010011
</span><span class='line'>0000..................00001000000010
</span><span class='line'>0000.................000010010000011
</span><span class='line'>0000................0000101001111011
</span><span class='line'>0000...............00001010001100000
</span><span class='line'>0000..............000010100100110000
</span><span class='line'>0000.............0000110100011110011
</span><span class='line'>0000............00001100100100110110
</span><span class='line'>0000...........000010111011001001111
</span><span class='line'>0000..........0000110000100000001101
</span><span class='line'>0000.........00001010111010010011111
</span><span class='line'>0000........000011010010110001010101
</span><span class='line'>0000.......0000110111010010100110100
</span><span class='line'>0000......00001011011110010000001111
</span><span class='line'>0000.....000010101010110111001010010
</span><span class='line'>0000....0000110111000010101000000100</span></code></pre></td></tr></table></div></figure>


<p>第n个输出值为n mBTC，它的私匙(二进制)从右到第n位，也就是1，然后剩下的部分是随机的。</p>

<p>在我写这篇文章的时候，这批地址里面的余额已经被花费到了第54个地址，其实我猜就是LBC那帮人碰撞到的最大值(但是奇怪的是LBC的统计页面上没有包括这几个地址，我怀疑还有另外一个私下的类似LBC的组织在碰撞)</p>

<p>也许是币价飞涨，从第161个地址之后的币应该是被持有人花掉了。但是从55-160这个区间里面的币还安然无恙，这个价值加起来也不算小了。</p>

<p>这似乎是经过深思熟虑的~~也许是一个实验，看看在产出被拿走之前的时间。我认为这确实是个有趣的实验，比特币世界总不乏一些有趣的人。</p>

<p>少年，拿起你手中的显卡算力，2<sup>55</sup>级别的碰撞似乎不是那么遥不可及，让我们看看第55个幸运儿什么时候诞生。</p>

<ul>
<li>引用资料:</li>
</ul>


<p><a href="https://rya.nc/forensic-bitcoin-cracking.html">https://rya.nc/forensic-bitcoin-cracking.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Dump Csv From Sqlite3]]></title>
    <link href="http://happy123.me/blog/2018/04/27/how-to-dump-csv-from-sqlite3/"/>
    <updated>2018-04-27T08:57:22+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/how-to-dump-csv-from-sqlite3</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>/usr/bin/sqlite3 test.db &lt;&lt;!
</span><span class='line'>.headers on
</span><span class='line'>.mode csv
</span><span class='line'>.output out.csv
</span><span class='line'>select username,password,email from passhouse order by site;
</span><span class='line'>!</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[寻找并删除Git记录中的大文件]]></title>
    <link href="http://happy123.me/blog/2018/04/26/purge-large-files-in-gitrepo/"/>
    <updated>2018-04-26T13:36:16+08:00</updated>
    <id>http://happy123.me/blog/2018/04/26/purge-large-files-in-gitrepo</id>
    <content type="html"><![CDATA[<p>有时候gitignore没做好，一不小心就又进来一个二进制文件</p>

<p>在重复了N次Google之后，还是记一下吧</p>

<!-- more -->


<ol>
<li>首先通过rev-list来找到仓库记录中的大文件：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '{print$1}')"</span></code></pre></td></tr></table></div></figure>


<ol>
<li>然后通过filter-branch来重写这些大文件涉及到的所有提交（重写历史记录）：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git filter-branch -f --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch your-file-name' --tag-name-filter cat -- --all</span></code></pre></td></tr></table></div></figure>


<ol>
<li>再删除缓存的对象，顺便瘦身一下:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
</span><span class='line'>git reflog expire --expire=now --all
</span><span class='line'>git gc --prune=now</span></code></pre></td></tr></table></div></figure>


<p>打完收工</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈比特币的地址安全问题]]></title>
    <link href="http://happy123.me/blog/2018/04/24/cryptocurrency-security/"/>
    <updated>2018-04-24T21:38:13+08:00</updated>
    <id>http://happy123.me/blog/2018/04/24/cryptocurrency-security</id>
    <content type="html"><![CDATA[<h4>比特币的地址生成过程分为以下几个步骤:</h4>

<ol>
<li><p>随机生成一个32字节(256bits)的私钥k</p></li>
<li><p>采用椭圆曲线算法，以私钥k为起点，将其与曲线上预定的生成点G相乘以获得曲线上的另一点，也就是相应的公钥 K</p></li>
<li><p>进一步SHA256=>RIPEMD160 得到地址原始值A: A = RIPEMD160(SHA256(K))</p></li>
<li><p>对A进行Base58Check编码，添加前置版本号后Double SHA256取最后四个字节作为校验位，最后 Base58Check(前缀+Base58Check(A)+校验)得到最终地址</p></li>
</ol>


<p>整个过程中，私钥的生成空间有256bits，由私钥推出地址过程中，由于用到了RIPEMD160散列，所以生成空间共有160bits。</p>

<p>也就是说，去除版本号变化，某一类型的比特币地址最多有 2<sup>160</sup>个。</p>

<p>为什么有步骤3呢，不光增加了地址复杂度，还降低了HASH碰撞空间(从256bits降到160bits)。</p>

<p>所以中本聪的选择只是带来了不必要的复杂度和浪费吗？最后证明，答案是否定的。有另外一个非常好的理由去使用这个&#8221;公钥的哈希值&#8221;的地址结构：量子加密技术。量子计算机可以破解椭圆曲线数字签名算法（也就是说，给定一个公钥，量子计算机可以相当快速的找到对应的私钥），但它们不能相类似的逆转哈希算法（或者说他们可以，但是将需要花掉280个步骤来完成一个比特币地址的破解，这仍然是相当不可行的）。因此，如果你的比特币资金存放在一个你没有支出过的地址里（这意味着公钥是没有公开的），它们在量子计算机面前也就是安全的，至少在你把它们花掉之前。有理论上的途径可以让比特币完全免于量子计算机的威胁，但一个地址只是一个公钥的哈希值的事实，意味着一旦量子计算机真的出现了，在我们全面切换之前攻击者可以造成的损失要小得多。</p>

<p>请参考:</p>

<p><a href="http://www.8btc.com/satoshis-genius-unexpected-ways-in-which-bitcoin-dodged-some-cryptographic-bullet">http://www.8btc.com/satoshis-genius-unexpected-ways-in-which-bitcoin-dodged-some-cryptographic-bullet</a></p>

<!-- more -->


<h4>那么是不是我们就此可以高枕无忧了呢?</h4>

<p>2<sup>160</sup> 的散列空间，也足够对抗HASH碰撞了。现在计算机普遍的频率为GH/s的量级，假设我们有1EH/s的算力来碰撞，有效的比特币地址为10亿个，2<sup>160</sup>/2<sup>60</sup>/2<sup>30</sup>=2<sup>70</sup>，换算成年单位大概是10<sup>15</sup>年，假设宇宙年龄为100亿年，那么我们碰撞出一个私钥的时间为10<sup>15</sup>/10<sup>10</sup>=100000 个宇宙轮回，就是宇宙毁灭重生100,000次，我们有可能破解一个比特币私钥。</p>

<p>那么有人质疑比特币的安全性，我们大可以傲娇的说：&#8221;没错，比特币在数学上不是绝对安全的。但我可以保证，它比这个宇宙安全的多。你相信明天宇宙就会爆炸吗？不相信的话，就相信比特币，洗洗安心睡吧。^_^&#8221;</p>

<h4>事实果真如此吗?</h4>

<p>让我们看一下<a href="https://lbc.cryptoguru.org/">Large Bitcoin Collider</a>这个项目。</p>

<p>该项目被称为大型比特币对撞机（LBC）。大型比特币对撞机尝试进行加密碰撞，它本质上证明了一个据称独特且随机的数字字符串可以重复。一路上爱好者们都在利用该项目的强大计算能力来尝试和破灭比特币的算法规则，最后打开其他人所拥有的比特币钱包，并有可能在里面拿走这些比特币。</p>

<p>是的，他们就是简单粗暴，他们试图从1穷举碰撞到2<sup>160</sup>来&#8221;打捞&#8221;比特币私钥。</p>

<p>我猜你肯定会说：哇咔咔，这帮傻小子，打捞到宇宙末日也不会有啥的</p>

<p>这个项目已经被贴上了很多标签：不可能，违法，毫无意义等等。</p>

<h4>一些让人惊奇的事情</h4>

<p>这个项目从2016年4月份开始运作，算力逐渐壮大到1GH/s的碰撞强度，到目前(2018-04)为止，发现了什么？</p>

<p>事实上他们刚刚碰撞到2<sup>54</sup>级别，按照道理来说他们离发现第一个私钥还相隔了xxxxxxx个宇宙轮回，事实呢？</p>

<p>他们共发现了16个有效的私钥，其中有4个地址是真实有效并且有余额的，共打捞了不到1个BTC。当然，他们花费的成本可能已经远远超过了所得，但是毕竟这对人们信奉的&#8221;比特币安全牢不可破&#8221;产生重击。</p>

<h4>他们骗人，用事先生成的地址来发送交易，然后蒙蔽世人</h4>

<p>事实上只要在bitcointalk.org论坛上仔细追踪一下这个帖子，就会发现这个项目完全是可信的，发起人十分严谨，记录了每次碰撞成功的结果，并且时间点上并无伪造的可能</p>

<p><a href="https://bitcointalk.org/index.php?topic=1573035.0">https://bitcointalk.org/index.php?topic=1573035.0</a></p>

<h4>哇，比特币被攻破了，我要赶紧卖卖卖</h4>

<p>事实上我们还是要强调比特币的设计比起这个星球上所有的银行和金融机构要安全的多，比起担心你的币，还是多担心一下你在人行总账上的资产账户吧。</p>

<h4>那这种事情怎么解释呢？</h4>

<ol>
<li><p>不是所有人的私钥都是那么&#8221;随机&#8221;，有理由相信，早期的一些玩家或者说一些钱包生成私钥的机制并不是那么完善，他们采用的熵源不够随机，造成私钥的值太小，被碰撞机发现了</p></li>
<li><p>总有一些人们，对于随机字符有莫名的恐惧，他们采用&#8221;脑钱包&#8221;来让自己更有控制感，相信我，大部分&#8221;脑钱包&#8221;的生成密语并不是多好，可能你会拿到一个被碰撞概率大得多的私钥。那些手头有大量&#8221;社工库&#8221;的坏小子们，是无法抵挡去碰撞攻击你的私钥的诱惑的</p></li>
<li><p>也许，我是说也许。数字货币的安全性设计是如此的健壮，健壮到人们忽视了最基本的问题：历史上从来没有哪一个系统能把所有东西都暴露在外，让人们随意碰撞攻击。这种时候，安全性最薄弱的环节还是在于人们的意识</p></li>
</ol>


<h4>那我们要如何保护自己呢？</h4>

<ol>
<li><p>尽量采用最新的，社区公认的健壮的钱包</p></li>
<li><p>如果你要用脑钱包，确认你明白其中的风险，并且自己最好对生成的私钥做一个安全评估</p></li>
<li><p>一个地址发送一笔转账后就更换地址</p></li>
</ol>


<h4>一些后续</h4>

<p>LBC这个项目遭受了很多人的误解和攻击。有的人认为这是一种偷盗行为。我得说，现有的法律在这里的确是盲点。</p>

<p>我在街上捡了一个钱包，大家都知道送去警局。</p>

<p>我在数字世界里面碰到了宇宙洪荒岁月亿万年一次的大奖，尽管这个奖励可能是从别的一个什么倒霉蛋那里拿来的，不过也没其他人知道，为什么不能看作是无主物品呢？为什么不看成是上天的眷顾呢？</p>

<h4>数字货币世界还是处于蛮荒狂野时代，不是那么多事情都是理所当然的;乔帮主的训诫要时时温习:饥渴求知，虚怀若愚(Stay Hungry, Stay Foolish)</h4>

<h4>少年，祝你好运</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get Pubkey From a Transaction]]></title>
    <link href="http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction/"/>
    <updated>2018-04-22T20:42:49+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/how-to-get-pubkey-from-a-transaction</id>
    <content type="html"><![CDATA[<p>比如<code>1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD</code>，这个地址，有转出过，如何得到公钥</p>

<p>原理很简单，但是实践起来比较烦：</p>

<!-- more -->


<p>首先我们找一下这个地址的随便一笔花费，比如这个:</p>

<p><a href="https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33">https://btc.com/0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33</a></p>

<p>然后需要一个工具通过交易hash解析一下这笔交易</p>

<p>推荐用这个 <a href="https://github.com/libbitcoin/libbitcoin-explorer/wiki/Download-BX">libbitcoin/libbitcoin-explorer</a></p>

<p>执行</p>

<pre><code>bx-windows-x64-icu.exe fetch-tx 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
</code></pre>

<p>得到了这笔交易解析后的完整输出:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>transaction
</span><span class='line'>{
</span><span class='line'>    hash 0998ef06442994c147aec242e6973dfe3d512b05bde880793051a48bd021fc33
</span><span class='line'>    inputs
</span><span class='line'>    {
</span><span class='line'>        input
</span><span class='line'>        {
</span><span class='line'>            address_hash b4a5d3960471568c3883046eec3b41b4953d61a1
</span><span class='line'>            previous_output
</span><span class='line'>            {
</span><span class='line'>                hash 5fb9f0e7f520163e4afe0baa440fe93999273e95d9e345e0488a0802ed62674f
</span><span class='line'>                index 0
</span><span class='line'>            }
</span><span class='line'>            script "[3045022100e4a4695ecbe6f507ec7181a2f321f489c7a3bd7eea032c75e4e1eba89174183c022019555aa917be6191db14da72e5c234a4b628f321b917ea334bcf9c122296cd5901] [044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b]"
</span><span class='line'>            sequence 4294967295
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    lock_time 0
</span><span class='line'>    outputs
</span><span class='line'>    {
</span><span class='line'>        output
</span><span class='line'>        {
</span><span class='line'>            address_hash c621cbfd778e6109e26046d96738c7af75e7b78b
</span><span class='line'>            script "dup hash160 [c621cbfd778e6109e26046d96738c7af75e7b78b] equalverify checksig"
</span><span class='line'>            value 43103
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    version 1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意script那一段，就是分成了两部分，前面一个中括号里面是签名，后面是公钥。</p>

<p>然后仔细看看这还是个老钱包生成的地址，没有压缩;</p>

<p>写个小脚本parse一下这个公钥，就可以看看是不是和地址对应啦:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env python
</span><span class='line'>
</span><span class='line'>from hashlib import *
</span><span class='line'>from base58 import *
</span><span class='line'>
</span><span class='line'>def SHA256D(bstr):
</span><span class='line'>    return sha256(sha256(bstr).digest()).digest()
</span><span class='line'>
</span><span class='line'>def ConvertPKHToAddress(prefix, addr):
</span><span class='line'>    data = prefix + addr
</span><span class='line'>    return b58encode(data + SHA256D(data)[:4])
</span><span class='line'>
</span><span class='line'>def PubkeyToAddress(pubkey_hex):
</span><span class='line'>    pubkey = bytearray.fromhex(pubkey_hex)
</span><span class='line'>    round1 = sha256(pubkey).digest()
</span><span class='line'>    h = new('ripemd160')
</span><span class='line'>    h.update(round1)
</span><span class='line'>    pubkey_hash = h.digest()
</span><span class='line'>    return ConvertPKHToAddress(b'\x00', pubkey_hash)
</span><span class='line'>
</span><span class='line'>pubkey = "044da006f958beba78ec54443df4a3f52237253f7ae8cbdb17dccf3feaa57f3126da0a0909f11998130c2d0e86a485f4e79ee466a183a476c432c68758ab9e630b"
</span><span class='line'>print(len(pubkey))
</span><span class='line'>print("Address: %s" % PubkeyToAddress(pubkey))</span></code></pre></td></tr></table></div></figure>


<p>输出是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>130
</span><span class='line'>Address: 1HUBHMij46Hae75JPdWjeZ5Q7KaL7EFRSD</span></code></pre></td></tr></table></div></figure>


<p>OK，打完收工。</p>

<p>如果一个地址只收币，从来没消费币，公钥是不会广播到网上的，所以这种地址拿不到公钥。一定要有花费，才能得到公钥。</p>

<p>所以有人推荐每次花费币之后就不要再用老地址了，每次交易都用新地址，避免将来出现什么黑科技（比如量子计算机之类的）穷举破解。 其实我觉的无所谓，大不了有人喊ECDSA挂了我再转移一下就行了，人家富豪榜里面都有好几个大佬也不在乎这点事。</p>

<p>PS:更新自打脸一下，我还是觉得每次交易用新地址是一定要做的，理论上HASH碰撞的概率有2<sup>160</sup>，但是我现在觉得这个量级不能简单的推算为1/2<sup>160</sup>；毕竟不是所有的钱包实现熵值都足够大。尽可能每次交易用新地址会增加碰撞库更新的难度。</p>

<h4>再强调一遍，每次交易用新地址是一个必须养成的习惯。</h4>

<p>另外公钥有两种形式：压缩与非压缩。一把私钥其实可以搞出两个地址哈。早期比特币均使用非压缩公钥，现大部分客户端已默认使用压缩公钥。早期openssl库的文档写的比较糙，导致Satoshi以为必须使用非压缩的完整公钥，后来大家发现其实公钥的左右两个32字节是有关联的，左侧(X)可以推出右侧(Y)的平方值，有左侧(X)就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Satoshi Craig Wright Is Being Sued for $10 Billion]]></title>
    <link href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/"/>
    <updated>2018-04-22T19:31:24+08:00</updated>
    <id>http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion</id>
    <content type="html"><![CDATA[<p>啥也不说了，涉及百亿美元的案子，估计在人类历史上都能排前排了。</p>

<p>而且作为Bitcoin粉，我估计这个案子有可能在历史上空前绝后。涉及悬疑，天才，欺诈，巨额金钱，先知等等元素~~</p>

<p>留名之。</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>另外我对这篇<a href="http://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">文章</a>用press.one进行了<a href="https://press.one/file/v?s=60db2f3ea40a25d28781c900af248523eb3c17024ce3ca18a42433035aff55524e4b2df76cfcef1466d38c4e23e4ab770d42359835b66d159cd5dd5099e0be260&amp;h=a93f5a68189ff4a9b14d9e592c4dd0a8a1b649d0191b58740d93ce10c0d055ec&amp;a=7e32e3deba87efcd35bc6d1ab355d85c50aa60bd&amp;v=2&amp;f=P1">签名:</a></p>

<!-- more -->


<h4>PS:附一下之前的总结</h4>

<p>2016-05更新:</p>

<p>=========================</p>

<p>参考<a href="http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:">http://8btc.com%E7%9A%84%E6%96%87%E7%AB%A0:</a></p>

<p>为什么说这个中本聪是假的</p>

<p>Craig Wright 又在声明他是”中本聪”了.</p>

<p>“中本聪”给出的签名是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MEUCIQDBKn1Uly8m0UyzETObUSL4wYdBfd4ejvtoQfVcNCIK4AIgZmMsXNQWHvo6KDd2Tu6euEl13VTC3ihl6XUlhcU+fM4=</span></code></pre></td></tr></table></div></figure>


<p>我们先对信息串进行base64解码，再转换成hex是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3045022100c12a7d54972f26d14cb311339b5122f8c187417dde1e8efb6841f55c34220ae0022066632c5cd4161efa3a2837764eee9eb84975dd54c2de2865e9752585c53e7cce</span></code></pre></td></tr></table></div></figure>


<p>很遗憾，我们可以在交易ID：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe</span></code></pre></td></tr></table></div></figure>


<p>中找出这个签名。可通过：</p>

<p><a href="https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex">https://blockchain.info/tx/828ef3b079f9c23829c56fe86e85b4a69d9e06e5b54ea597eef5fb3ffef509fe?format=hex</a></p>

<p>找到十六进制串的交易内容</p>

<p>然后搜索一下hex样子的签名，遗憾地发现，能在这个交易中找到这个签名。</p>

<p>但是令人疑惑的是GAVIN ANDRESEN为这位”中本聪”背书:</p>

<p><a href="http://gavinandresen.ninja/satoshi">http://gavinandresen.ninja/satoshi</a></p>

<p>Gavin不是一个无的放矢的人,他肯定是见到了更多的证据.</p>

<p>但是Craig Wright 又不对其他给定的文本签名来证明自己是中本聪,反而老是用这种神神遭遭的签名来忽悠大家……</p>

<p>卫平布莱恩特老师说,这球有意思啊…….</p>

<p>最后, 如果Craig Wright这个人是为了某种目的假冒的话,只能说他真是煞费苦心啊. 我不认为一个签名造假如此low的家伙能有这种能力.</p>

<p>但是他的一些行为如果算恶作剧的话,又未免太高段了,参考这里:</p>

<p><a href="https://www.zhihu.com/question/22199390/answer/76083139">https://www.zhihu.com/question/22199390/answer/76083139</a></p>

<p>不负责任的YY一下, Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>

<p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>

<p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p>

<p>呵呵, 绝佳的侦探小说体裁啊.</p>

<p>2017-12-24更新</p>

<p>================</p>

<p>我在比特币开发论坛的早期帖子上发现了一个线索，在bitcoin release 0.1版本的时候，satoshi曾经自称自己:</p>

<pre><code>"The design supports a tremendous variety of possible transaction types that I designed years ago.  Escrow transactions, bonded contracts, third party arbitration, multi-party signature, etc.  If Bitcoin catches on in a big way, these are things we'll want to explore in the future, but they all had to be designed at the beginning to make sure they would be possible later."
</code></pre>

<p>这代表satoshi早期的职业生涯和金融、保险以及法务方面联系很紧密，同时看他的代码风格是老派C++的写法，有MS的味道 ：），然后看看 David Kleiman的个人主页，浮想联翩啊。</p>

<p>2018-04-22更新</p>

<p>==================</p>

<p>Craig Wright的案宗已经出来了:</p>

<p><a href="https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/">https://www.coindesk.com/satoshi-craig-wright-sued-10-billion/</a></p>

<p>我觉得基本上可以确定猜测是对的，但是除了Craig Wright本人，真相的细节可能永远不会有人知道了。</p>

<p>现在最大的疑问就是100w币的私钥是谁控制着？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Disable Performance_schema to Save Mysql's Memory]]></title>
    <link href="http://happy123.me/blog/2018/04/02/disable-performance-schema-to-save-mysqls-memory/"/>
    <updated>2018-04-02T09:14:01+08:00</updated>
    <id>http://happy123.me/blog/2018/04/02/disable-performance-schema-to-save-mysqls-memory</id>
    <content type="html"><![CDATA[<p>小VPS内存一般都不大，比如 1GB 什么的。估计总是发现装完 LAMP 就基本上内存全用光了。</p>

<p>访问量不大的话，可以在 my.conf 中加入以下配置，关掉性能优化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mysqld]
</span><span class='line'>performance_schema=off</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable Multiusers Support for Win10]]></title>
    <link href="http://happy123.me/blog/2018/02/28/enable-multiusers-support-for-win10/"/>
    <updated>2018-02-28T11:14:54+08:00</updated>
    <id>http://happy123.me/blog/2018/02/28/enable-multiusers-support-for-win10</id>
    <content type="html"><![CDATA[<p>自从买了套正版Win10，感觉又回归软粉行列。这就是所谓的屁股决定脑袋。</p>

<p>开了hyper-v，日常使用足够了，我感觉hyper-v的虚拟化可能真的是Vmware的有力竞争对手。</p>

<p>然后WSL的横空出世，让人调侃<code>win10将变成最好的Linux发行版</code>，此言不虚啊。</p>

<p>最后我寻寻觅觅，找到了一个RDP多用户支持的工具:</p>

<p><a href="https://github.com/stascorp/rdpwrap">https://github.com/stascorp/rdpwrap</a></p>

<p>妥妥的把Win10变成了Win2012 Server。</p>

<p>现在Win10日常使用组件好评度爆表依次为:</p>

<ul>
<li><p>多桌面</p></li>
<li><p>hyper-v</p></li>
<li><p>WSL</p></li>
<li><p>RDP</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Do Cryptic Github Comments Mean?]]></title>
    <link href="http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean/"/>
    <updated>2018-02-17T16:35:55+08:00</updated>
    <id>http://happy123.me/blog/2018/02/17/what-do-cryptic-github-comments-mean</id>
    <content type="html"><![CDATA[<p>在Github的Issue里面经常见到一堆<code>ACK</code>，原来知道肯定不是TCP的ACK，估计是acknowledge之类的缩写，但是一直不求甚解。</p>

<!-- more -->


<p>今天心血来潮搜了一下，嗯，猜的也差不多:</p>

<ul>
<li><p>LGTM—looks good to me</p></li>
<li><p>ACK—acknowledgement, i.e. agreed/accepted change</p></li>
<li><p>NACK/NAK —negative acknowledgement, i.e. disagree with change and/or concept</p></li>
<li><p>RFC—request for comments, i.e. I think this is a good idea, lets discuss</p></li>
<li><p>WIP—work in progress, do not merge yet</p></li>
<li><p>AFAIK/AFAICT—as far as I know / can tell</p></li>
<li><p>IIRC—if I recall correctly</p></li>
<li><p>IANAL—“I am not a lawyer”, but I smell licensing issues</p></li>
</ul>


<p>像比特币代码仓库里还经常见到:</p>

<ul>
<li><p>Concept ACK—agree with the concept, but haven’t reviewed the changes</p></li>
<li><p>utACK (aka. Untested ACK)—agree with the changes and reviewed them, but didn’t test</p></li>
<li><p>Tested ACK—agree with the changes, reviewed and tested</p></li>
</ul>


<p>资料来源:</p>

<p><a href="https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4">https://medium.freecodecamp.org/what-do-cryptic-github-comments-mean-9c1912bcc0a4</a></p>

<p><a href="https://github.com/dear-github/dear-github">https://github.com/dear-github/dear-github</a></p>

<p><a href="http://www.catb.org/jargon/html/index.html">http://www.catb.org/jargon/html/index.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币POW难度调节分析]]></title>
    <link href="http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/"/>
    <updated>2018-02-12T20:50:34+08:00</updated>
    <id>http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi</id>
    <content type="html"><![CDATA[<p>比特币白皮书在工作量证明章节中解释了工作量证明（PoW）的方式：</p>

<blockquote><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p></blockquote>

<p>那这个随机数难度值是怎么产生的呢？</p>

<!-- more -->


<p>原理是简单的，但是细节总是需要穷根究底。</p>

<h2>比特币难度值Difficulty</h2>

<p>难度值在区块中并不记录，仅仅是为了人类直观感受解题难度而演变出的一个浮点数。难度每2016个区块改变一次，公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diffculty = difficulty_1_target / currentTarget</span></code></pre></td></tr></table></div></figure>


<p>此处的 difficulty_1_target 为一个常数，非常大的一个数字。表示矿池挖矿最大难度。目标值越小，区块生成难度越大。区块中存储的是这个名为target的值。</p>

<h2>难度值如何存储在区块中的</h2>

<p>在区块中存储的是Target，但是将Target经类似于浮点数的一种压缩表示法，字段为nbits。例如，如果区块bits记录为0x1b0404cb，那么他表示的十六进制的Target值为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span></code></pre></td></tr></table></div></figure>


<h3>在计算时，后面3个字节0x0404cb作为底，前面1字节0x1b表示次方数。具体压缩过程如下：</h3>

<ul>
<li><p>将数字转换为256进制数</p></li>
<li><p>如果第一位数字大于127(0x7f),则前面添加0</p></li>
<li><p>压缩结果中的第一位存放该256进制数的位数</p></li>
<li><p>后面三个数存放该256进制数的前三位，如果不足三位，则后面补零</p></li>
</ul>


<h4>例如，将数字1000压缩，先转换为256进制数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1000 = 0x03 * 256 + 0xe8 * 1</span></code></pre></td></tr></table></div></figure>


<p>那么是由两个数字构成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>03   e8</span></code></pre></td></tr></table></div></figure>


<p>第一个数未超过0x7f,则不需填0，但长度两位低于三位，在后面补零，最终表示为：0x0203e800</p>

<h3>等等，我有点晕了，为什么要采取这种绕弯的存储方式呢?</h3>

<ul>
<li><p>比特币的工作量证明本质是计算一个256bits的hash值，并保证这个值小于target，表示为公式如下:</p>

<p>  <code>
  SHA256(SHA256(区块头)) &lt; Target
 </code></p></li>
<li><p>初始Target，即difficulty_1_target设置为<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>，此时难度为1</p></li>
<li><p>Target是一个256位的很大的数，对这个数进行乘除运算需要特殊的库来处理，所以中本聪考虑用一个32位的数来近似表示Target</p></li>
<li><p>256 / 32 = 8, 2<sup>8</sup> = 256，因此我们需要用256进制来表示Target，256进制的运算规则如上所述</p></li>
<li><p>那么初始Target其实可以表示为0x1D00FFFFFF，解压验证一下:</p>

<p>  <code>
      0x00ffff *256** (0x1d - 3)  = ff ff 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 </code></p></li>
<li><p>0x1D00FFFFFF 这个值可以称为nbits，就是存储在区块中的原始值，通过nbits可以推算当前Target，通过当前Target及初始Target可以推算当前难度</p></li>
</ul>


<h2>难度如何调节</h2>

<p>目标值计算公式如下，但在实际计算时有些特别处理，将目标值控制在一定范围内。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>新目标值= 当前目标值 * 实际2016个区块出块时间 / 理论2016个区块出块时间(2周)。</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>判断是否需要更新目标值(2016的整数倍)，如果不是则继续使用最后一个区块的目标值</p></li>
<li><p>计算前2016个区块出块用时</p></li>
<li><p>如果用时低于半周，则按半周计算。防止难度增加4倍以上。</p></li>
<li><p>如果用时高于8周，则按8周计算。防止难度降低到4倍以下。</p></li>
<li><p>用时乘以当前难度, 再除以2周</p></li>
<li><p>如果超过最大难度限制，则按最大难度处理</p></li>
</ol>


<p>代码参考这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857">https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857</a></p>

<h2>知道nbits，如何推算全网算力</h2>

<ul>
<li><p>nbits为0x1b0404cb时，难度为：</p>

<p>  <code>
  0x00000000FFFF0000000000000000000000000000000000000000000000000000 / 0x00000000000404CB000000000000000000000000000000000000000000000000 = 16307.420938523983
 </code></p></li>
<li><p>为了找到新区块，该区块的target值必须小于目标target值，实际上是一个在0到2<sup>256</sup>-1之间的随机数，难度1的偏移量是：</p>

<p> <code>
 0xffff * 2^208
</code></p></li>
<li><p>难度D的偏移量是</p>

<p> <code>
 (0xffff * 2^208)/D
</code></p></li>
<li><p>在难度D下，为了找到新区块，我们预期要计算的HASH数量是</p>

<p> <code>
 D * 2^256 / (0xffff * 2^208)
</code></p></li>
<li><p>难度的设定，是为了以每10分钟一个区块的产生速度产生2016个区块，因而我们在600秒内计算 (D * 2<sup>48</sup> / 0xffff) 个HASH，这就意味着产生2016个区块的网络HASH速率(算力)是</p>

<p> <code>
 D * 2^48 / 0xffff / 600
</code></p>

<p> 可以进一步简化为：</p>

<p> <code>
 D * 2^32 / 600
</code></p></li>
<li><p>2018-02-12 21:00:00(UTC+8), 难度值D为2,874,674,234,415; 此时全网算力为20.75EH/S</p></li>
<li><p>如果我有一台蚂蚁S9，算力13T/S，那么一个区块周期(10分钟)的期望BTC收益为12.5 * 13T / 20.75EH</p></li>
</ul>


<h2>一点小TIPS</h2>

<ul>
<li>难度为1时，目标target在比特币客户端中表示为</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFF0000000000000000000000000000000000000000000000000000</span></code></pre></td></tr></table></div></figure>


<p>但是在绝大部分矿池里面表示为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></code></pre></td></tr></table></div></figure>


<p>这样挖矿的时候，挖矿软件显示的难度和比特币客户端api调用算出来的难度有微小差别，可以忽略。这个其实时早期矿池实现的时候找方便造成的不统一，因为比特币客户端判断HASH合法性的时候用的是nbits来判断，所以不影响最终计算结果</p>

<ul>
<li>现有的算法中，难度值每2016个区块调整一次，但新的难度值不需要与难度“1”进行比较运算，而是根据前2015个块的出块时间来计算，所以严谨的计算公式为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>difficulty = [prev_target] * 【前2015个区块生成所用的时间】 / 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数）</span></code></pre></td></tr></table></div></figure>


<p>为啥？就是中本聪早期的代码比较糙，他在循环的时候因为还有一个genius block要处理，可能为了代码干净起见就不去特殊处理了，其实也没啥影响</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[央行抵押补充贷款PSL浅析]]></title>
    <link href="http://happy123.me/blog/2018/02/02/yang-xing-di-ya-bu-chong-dai-kuan-pslqian-xi/"/>
    <updated>2018-02-02T22:38:15+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/yang-xing-di-ya-bu-chong-dai-kuan-pslqian-xi</id>
    <content type="html"><![CDATA[<p>看到一则新闻，山东取消了货币化安置奖励，美其名曰控制房价，其实想想就明白是政府余粮不足了，房价飞涨，补贴不能。</p>

<p>老家这里的棚户改造轰轰烈烈搞了两年了，货币化安置的效果非常显著，周边的房价一个劲往上涨。我就有点纳闷了，这个货币化安置的钱是从哪儿来的呢？</p>

<!-- more -->


<p>央行在2014年推出的PSL（抵押补充贷款）创新性政策工具，部分解决了棚改货币化安置的资金问题。央行通过PSL向国开行发放贷款，国开行通过棚改专项贷款向地方政府发放贷款，地方政府通过货币化安置向棚户区居民发放补偿款，地方政府拆迁卖地后偿还国开行贷款，国开行偿还央行贷款，形成资金流的闭环。</p>

<p>我查了一下资料，问题来了:</p>

<ul>
<li><p>开行是把什么抵押给央行了？是只能抵押棚改专项贷款，还是国债、开行债、扶贫贷款、小微企业贷款之类的都可以?</p></li>
<li><p>PSL利率怎么设定？央行指定还是市场化？</p></li>
<li><p>如何监控PSL的投向，并防止利差套利。</p></li>
<li><p>开行用什么方式来偿还PSL贷款？</p></li>
</ul>


<h2>最重要的是，这是不是放水？</h2>

<p>又学习了一下基本金融知识，发现一个比较权威的解释:</p>

<p>国信证券宏观经济分析师钟正生认为，这一工具最大突破在于，将商业银行贷款纳入用于基础货币投放的合格抵押品框架，从而摆脱再贷款的信用风险问题，打造一个常规的基础货币投放渠道。央行投放基础货币需要同时扩张资产方和负债方，而为了保证央行资产的安全性，央行一般会要求交易对手提供抵押品并进行风险评估。而合格抵押品意味着受到央行认可的，可在货币政策工具中用于抵押给央行的资产，例如我国正逆回购以及SLO、SLF操作中，一般使用国债和政策性金融债作为合格抵押品。我们在之前报告中提及，外汇占款趋势下滑，央票自然到期萎缩背景下，央行需要重启再贷款作为弥补基础货币缺口的手段。其主要原因在于，央行缺乏合适的抵押品，用于大规模基础货币的投放。而再贷款是信用贷款，不需要抵押。但吊诡的是，无需抵押既是再贷款的突出优点，也是再贷款的局限所在。无抵押会带来信用风险问题，央行资产有可能会遭受损失，历史上由于再贷款在央行账目上产生坏账的案例并不鲜见。因此，我们一直认为，短期内再贷款可以充当提供基础货币的过渡职能，但长期来看仍需完善央行的合格抵押品框架。现在看起来，PSL可能正是在央行在完善合格抵押品框架上作出的重要推进。</p>

<p>然后我又脑补为通俗版:</p>

<ul>
<li><p>央行采用外汇占款发行人民币的老路子越来越难了，美国加息，外汇流出压力大啊。</p></li>
<li><p>现在我要以国内资产来定价发行货币了</p></li>
</ul>


<h4>好吧，看起来这不是放水，顶多可以称之为定向宽松。那么是不是就不用紧张通胀了呢？</h4>

<p>完全不是！</p>

<p>类比一下，这其实是股市里面的一种对敲手法。</p>

<p>央行最终收下的抵押品不外乎还是地方财政的资产，那地方财政最大的抵押资产是什么呢？还是土地。</p>

<p>发出去的货币标的其实就是不断推升的地价。</p>

<p>这下好了，其实是央行和地方政府联手对敲，把地价炒高了，还多出来一种发行货币的手段，顺便把高杠杆风险转给平头百姓，一箭三雕啊。</p>

<p>兴，百姓苦；亡，百姓苦</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coincheck被盗5亿个XEM]]></title>
    <link href="http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem/"/>
    <updated>2018-02-02T21:16:43+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem</id>
    <content type="html"><![CDATA[<p>2018-01-26,Coincheck 被盗 5 亿个 XEM, 这个数目估计是史上最大了，hacker 的账户地址是这里:</p>

<p><a href="http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG">http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG</a></p>

<p>按照 coinmarketcap 的市场价来算，现在 5 亿个 XEM 价值大概 4 亿美元</p>

<p>另外可能是 coincheck 自己的防护，他们的 Ripple 钱包也有一笔大额的转账:</p>

<p><a href="https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8">https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8</a></p>

<p>有将近 1 亿个 xrp 转账到了一个地址，这个地址貌似有 30 亿个 xrp.</p>

<p>这笔转账可能是 coincheck 正在审计，不是 hack 行为。</p>

<p>除去 MTGOX 那次，Coincheck 的这次悲剧不论数量还是市场价格估计都是史上最强了</p>

<p>2018-01-28, Coincheck公布了补偿措施</p>

<p><a href="http://corporate.coincheck.com/2018/01/28/30.html">http://corporate.coincheck.com/2018/01/28/30.html</a></p>

<p>共损失 52300,0000 个 XEM，按照被偷时的币值返还，每个币 88 日元</p>

<p>额，貌似总额超过 25 亿人民币了</p>

<p>最奇怪的是，直到2018-02-01，市场才起了反应，开始下跌。</p>

<p>这个赌博的场子越来越让人看不懂了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block Chain White Papers]]></title>
    <link href="http://happy123.me/blog/2018/01/09/block-chain-white-papers/"/>
    <updated>2018-01-09T16:42:45+08:00</updated>
    <id>http://happy123.me/blog/2018/01/09/block-chain-white-papers</id>
    <content type="html"><![CDATA[<h2>比特币白皮书</h2>

<h4>中文版</h4>

<p><a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a></p>

<h4>英文版</h4>

<p><a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p>

<h2>以太坊白皮书</h2>

<h4>中文版</h4>

<p><a href="http://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6">http://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6</a></p>

<h4>英文版</h4>

<p><a href="https://github.com/ethereum/wiki/blob/master/drafts/%5Benglish%5D-old-ethereum-whitepaper.md">https://github.com/ethereum/wiki/blob/master/drafts/%5Benglish%5D-old-ethereum-whitepaper.md</a></p>
]]></content>
  </entry>
  
</feed>
