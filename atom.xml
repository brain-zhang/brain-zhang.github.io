<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-07-27T11:27:30+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[史上最可怕的赌局FOMO3D]]></title>
    <link href="http://happy123.me/blog/2018/07/27/shi-shang-zui-ke-pa-de-du-ju-fomo3d/"/>
    <updated>2018-07-27T03:32:39+08:00</updated>
    <id>http://happy123.me/blog/2018/07/27/shi-shang-zui-ke-pa-de-du-ju-fomo3d</id>
    <content type="html"><![CDATA[<p>人类骨子里面存在赌博的基因。从形形色色的资本市场，到我今天几点起床，好听一点，是一种概率的博弈，难听一点，就是赌博。</p>

<p>互联网伊始，在其他人纷纷吹嘘空中楼阁的时候，最先盈利的，是赌场。</p>

<p>区块链技术发展至今，落地的应用，无它，投机赌博尔。</p>

<p>从最初的SatoshiDice到primedice，到各种DApp的赌博应用，我想不久之后，澳门和拉斯维加斯会面临重大挑战。</p>

<p>第一次搞明白primedice和SatoshiDice的原理时，深深为之震撼，如此透明的博彩程序，在我看来已经到达赌博行业的顶尖水准了，后来者要超越，无非是内容上添砖加瓦，搞个美女营销之类的，技术上没啥改进余地了。</p>

<p>事实证明，Too Yong。人类在赌博业上的创新永无止境。</p>

<p>事实上，最近出来一个我认为史无前例的精巧，可怕，糅合了庞氏骗局，概率论，庄家，小白，顶级黑客，古典赌博术设计的区块链应用。而且，他非常坦诚，告诉你，我就是传销，就是骗局，你来了就是送我钱的，但是还是让人欲罢不能。事实上，我不怕丢人，我也投了一点小钱在里面，我也是庞氏骗局的被洗脑者。所有读到这里的人，要高能预警提醒你，下面文章所有的内容，都是洗脑文，写这篇文章的人已经中毒了，您应该带着批判的思维去审视这些知识。</p>

<p>再提醒一遍，下面所有的内容都是传销受害者的一家之言，不要上当。</p>

<!-- more -->


<p>================================================================</p>

<p>这个游戏叫做Fomo3D，是建立在以太坊的智能合约基础上的一款DApp，是一个实盘的旁氏骗局，玩法综合了 <code>传销+一元夺宝+博彩+资金盘+炒币</code> 的各样姿势，堪称区块链投机诈骗时代的集大成者。相比它，什么发行空气币，搞ICO的做法实在是弱爆了。</p>

<p>先讲讲它的开发团队，非常的有Geek范，他们首先很坦诚，称自己的游戏为“退出骗局（exit-scam）”，这个游戏的官方域名就是:</p>

<p><a href="https://exitscam.me/">https://exitscam.me/</a></p>

<p>而且他们自称是反区块链主义者，发明这个游戏出来就是让人认识到比特币、以太坊这些东西就是骗人的，是个巨大的博傻游戏，他们要劝人退出这个骗局。</p>

<p>劝你退出的方法很简单，就是他们发明了Fomo3D这个游戏骗光你的币，而且是正大光明的声明我就是来骗你的。</p>

<h4>Fomo3D啥意思?</h4>

<p>FOMO=fear of missing out，翻译成中文就是“怕错过”。这名字取得太应景了。实际上他们前面还做过一款叫做P3D（Proof of Weak Hands 3D）的庞氏类游戏，也曾一度引起轰动。当然，崩盘以前最后的一波投资者就比较难看。因此，这个游戏里面处处设法弄一些资金去给P3D填锅。</p>

<p>3D也是团队的一个调侃，代表除了单纯的旁氏，他们还搞出了另外两种骗你钱的姿势~~</p>

<p>明知是骗人我还要投入其中，你太小看我的智商了吧，你以为我是P2P的大妈还是A股的韭菜啊，我傻啊~~~</p>

<p>且让我们细细看来。</p>

<h2>规则：</h2>

<p>完整的说明请参见官方wiki：</p>

<p><a href="https://fomo3d.hostedwiki.co/pages/Fomo3D%20Explained">https://fomo3d.hostedwiki.co/pages/Fomo3D%20Explained</a></p>

<p>这个游戏其实是一个挺复合型的游戏。它的主合约有一千多行代码，还有几个辅助合约，已经算是相当复杂的了。从游戏来说，他包含几个机制：</p>

<h4>彩票：</h4>

<p>可以随时购买一注彩票；存在4种不太一样的一样的彩票（分成了四种模式，每种模式用一种动物指代：鲸鱼、蛇、牛、熊），每一种的返还方式略有区别，但是共用奖池；分大奖和小奖（随机空投），小奖实时开奖，实时结算；大奖奖池累计，目前累计到2w eth（1000w美金）</p>

<h4>一元拍卖：</h4>

<p>每个出价的人都得交一笔钱（这是一元拍卖和传统拍卖的最大区别）；每次有人出价，拍卖时间顺延30秒；如果拍卖时间结束，最后一个出价的人，获得商品&mdash;&mdash;这里没有真实商品，就是获得整个奖池；</p>

<h4>分红币：</h4>

<p>每个持有币的人可以从后面的入场资金获得固定分红；分红完全平均，每一个token（在下面我会交替使用token，币，key，F3D这几种说法，意思都一样）获得分红都是相等的，不含随机性；整盘游戏结束的时候还有一个最终分红；</p>

<h4>推荐/传销机制：</h4>

<p>每个人可以生成推广链接；其他人通过推荐链接入场，他的消费中10%直接奖励给推荐人；用户可以更换推荐人链接，如果不怎么做，他的后续消费将持续给别人提供奖励；</p>

<hr />

<p>相信这么说你可能要晕了，我们综合起来描述一下:</p>

<h4>首先合约提供了一种股份，他们称之为Key，你需要用Eth去买Key，拥有Key的人，就在游戏规定的时间内享有分红权，能源源不断的获取分红；</h4>

<ul>
<li><p>KEY的价格 = 0.000075 + 0.00000000015625*已有KEY的总量</p></li>
<li><p>获利 = （ 提现时KEY总量 -买入时KEY总量 ）* 分润率</p></li>
<li><p>Key不能卖，就是说你买了Key后只能握在手里</p></li>
</ul>


<p>这不就是尽早入场，尽早得利的老掉牙的骗局吗，最后一拨人接盘；有啥新鲜的？</p>

<h4>且慢，我们看到，除了分红之外，其实整个池子还是剩下近一半币的；所以除了庞氏，他还引入了另外一个模式，一元夺宝:</h4>

<ul>
<li>一轮游戏的时间限定为24小时，当游戏时间结束时，最后一个买key的人，可以独享奖池48%份额。</li>
</ul>


<p>也就是说，越到游戏快结束的最后1分钟，碰运气去博的人会越来越多，而且到时候奖池里面的数字会惊人的大，比如现在(2018-07-27 03:00:00 UTF+8)，池子里面已经积累20000+ 的eth了，超过一千万美元。</p>

<ul>
<li>当游戏时间&lt;24小时，每有一个人买一个key，游戏的时间会延长30秒。</li>
</ul>


<p>当游戏快结束时，大家都去博大奖，反而会让游戏的时间延长，理论上来说，这个延长会无穷无尽，所以这个游戏的第一局会持续到永远&hellip;&hellip;.，直到以太坊破灭</p>

<h4>为了让持有Key的人玩的更有乐子，他们还设计了一种空投机制，奖池会随机发币给key持有人，持有Key越多的人，越容易中奖</h4>

<h4>另外团队还有另外一款Token，就是空气币叫P3D，凡是持有P3D的人也能从奖池里面分一杯羹，这个P3D的设计是另外一个庞氏骗局，可以说是骗上加骗，强强联合了</h4>

<h4>最后的最后，为了找韭菜，他们还设计了常见的推荐机制</h4>

<p>我投0.1Eth，就可以得到一个推荐链接，凡是点击这个链接进来的人，我都能拿奖励；所以大家很快就会看到各类自媒体的科普文章中，夹带类似以下格式的链接，你点进去买就立即是一个合格的韭菜了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>https://exitscam.me/1
</span><span class='line'>
</span><span class='line'>https://exitscam.me/eth
</span><span class='line'>
</span><span class='line'>https://exitscam.me/go
</span><span class='line'>
</span><span class='line'>~~~</span></code></pre></td></tr></table></div></figure>


<p>看到这里，你是不是已经叹服它堪称史上集大成的诈骗机制了，这个产品经理洞悉了人性，发明了这个集传销，庞氏骗局，游戏，彩票，资金盘于一体的行为艺术，实在是应该去拉斯维加斯大展身手的；</p>

<p>当然，也许人家已经看明白区块链迟早会革掉传统赌博行业的命，早早投身这个大潮来了~~~</p>

<p>少年，你是不是急切的问，这个游戏咋玩啊，快给个教程链接我体验一下 233333~</p>

<h4>且慢，我都说了这是个骗人的局，而且，搞明白它的设计细节，进行概率测算之后，我唯有四字形容：叹为观止。</h4>

<h2>规则细节</h2>

<p><del> 待续</del></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrate Vm Instances and Snapshots From Different Vps Supporters or Accounts]]></title>
    <link href="http://happy123.me/blog/2018/07/21/migrate-vm-instances-and-snapshots-from-different-vps-supporters-or-accounts/"/>
    <updated>2018-07-21T09:11:55+08:00</updated>
    <id>http://happy123.me/blog/2018/07/21/migrate-vm-instances-and-snapshots-from-different-vps-supporters-or-accounts</id>
    <content type="html"><![CDATA[<p>虽然已经进入X时代了，但电脑城装机习惯性还是用Ghost，无他，习惯方便。</p>

<p>Linux上面系统迁移，网上搜一搜，大批文章还是原始的dd, rsync之类；当然，不是说他不行，而是面向小白实在是有点坑啊。</p>

<p>云时代，不同厂商间基本都提供了<code>快照</code>+<code>在线热迁移</code>的方案了，用起来也很舒服。</p>

<p>那么，作为一个VPS小白用户，怎么在不同的账号，或者说不同的厂商之间，迁移我的Linux系统呢？</p>

<p>比如我在vultr上面有两个账号，vultr的快照功能是很赞的，免费、速度快、生成虚机靠谱；</p>

<p>那么问题来了，怎么把账号A的Linux A迁移到账号B的Linux B虚机上呢？</p>

<p>官方回复是还没有考虑这个功能，然后Linux怎么可能做不到这种简单的事情呢？当然立刻就有人回复了详细的搞法，还贴心的附录了视频:</p>

<p><a href="https://discuss.vultr.com/discussion/104/snapshot-image-downloads/p2">https://discuss.vultr.com/discussion/104/snapshot-image-downloads/p2</a></p>

<!-- more -->


<h4>我们也嘴炮一下整个过程:</h4>

<ol>
<li><p>对Linux A建立SnapShot A</p></li>
<li><p>从SnapShot A创立一台虚机 (注意这台虚机的磁盘要比Linux A的磁盘大，比如Linux A是5$的套餐15GB，那么最好建立一个20$的套餐45GB)</p></li>
<li><p>vultr 有挂载光盘的功能，可以挂载一个linux live CD,用这张Live CD启动新虚机</p></li>
<li><p>dd 命令完全拷贝原有磁盘</p>

<p> dd if=/dev/vtbd0 bs=1m | gzip -c | ssh -e none myolduser@myoldserverip &lsquo;cat > backupsnapshot.iso.gz&rsquo;</p></li>
<li><p>账号B开一台虚机，把backupsnapshot.iso.gz拷贝过去</p></li>
<li><p>同样挂载Live CD，反向dd，恢复文件系统</p></li>
<li><p>重启，改配置，赋权限，搞定</p></li>
</ol>


<p>说是嘴炮，是因为我之前硬盘dd对拷过，对于速度和之后的配置兼容深为烦恼，更不用说KVM上面用这个招数去做迁移了，我一个坑都不想踩的。</p>

<p>光是看看上面一波操作，我就没兴趣折腾了。当然也有很多人的乐趣就是折腾，但是年纪大了就老是想偷懒。</p>

<p>之前在不同物理机之间做Linux迁移，用clonezilla居多，虽然有一些Raid方面的支持会有问题，总体来说我对它的稳定性和便利性有巨大信任，但从来没有在KVM上搞过，这次我完整实验了一把，效果MAX。</p>

<h4>下面我们说说怎么用clonezilla把上面繁琐的手工操作搞得不那么痛苦一点:</h4>

<ol>
<li><p>先去clonezilla.org 官网，找到下载地址，好吧，我已经帮你找好了:</p>

<p> <a href="http://onet.dl.osdn.jp/clonezilla/69273/clonezilla-live-2.5.5-38-amd64.iso">http://onet.dl.osdn.jp/clonezilla/69273/clonezilla-live-2.5.5-38-amd64.iso</a></p></li>
<li><p>vultr很贴心的提供了从url上传镜像的功能，我们到下面这个功能项中把iso镜像的url填进去，添加clonezilla镜像文件到vultr:</p>

<p> <a href="https://my.vultr.com/iso/add/">https://my.vultr.com/iso/add/</a></p></li>
<li><p>点开虚机Linux A，点击<code>Settings</code> &ndash;> <code>Custom ISO</code> &ndash;> 选择clonezilla &ndash;> 点击 <code>Attach ISO and Reboot</code></p></li>
<li><p>用VNC连接虚机，进入clonezilla的界面</p></li>
<li><p>进入菜单项，<code>第一菜单800X600分辨率</code> &ndash;> <code>简体中文</code> &ndash;> <code>使用再生龙</code></p></li>
<li><p>选择 <code>remote-source 进入远程设备克隆的源端</code></p></li>
<li><p>选择 <code>初学模式：接受默认的选择</code></p></li>
<li><p>选择 <code>复制本机硬盘到它机硬盘</code></p></li>
<li><p>选择 <code>设定固定IP地址</code></p></li>
<li><p>设定IP,子网掩码，网关,域名服务器，如果机器有多块网卡的话，一般会列出网卡名字和MAC地址供你选择，vultr一般是双网卡(如果你启用了内网地址的话),网络信息在vultr的主机settings中能查到。</p></li>
<li><p>选择要克隆的硬盘，设定没有问题的话，下面一路YES下去，机器就会进入等待目标端连接的状态</p></li>
<li><p>在账号B的Linux B中重复1-11步操作，不同的是第6步选择目标端，第8步选择 <code>从镜像文件恢复至本机硬盘</code>, 之后填入Linux A的IP地址，就可以开始克隆对拷了</p></li>
<li><p>我在不同vultr的账号中测试了Ubuntu16.04, Centos7.1, FreeBSD 10的迁移，效果MAX</p></li>
</ol>


<p>看起来步骤不少，熟练了还是能迅速操作的，clonezilla赞一个</p>

<h4>一点小ToolTIps:</h4>

<ul>
<li><p>这个方法其实可以适用所有KVM虚机迁移，所以只要服务商开了自定义镜像挂载的功能，都可以跨公网对拷</p></li>
<li><p>如果A和B不能直接通信的话，可以开一台中转机器C，在Linux A的一端把硬盘 clone为镜像文件，通过SSH文件服务器的方式转存到C上，然后在B上连接SSH文件服务器C，从而还原系统; 提示一下，其实生成的镜像文件挺小的，比dd之后压缩还小的多</p></li>
<li><p>如果clone的时候报错，一般是A 端的文件系统有损坏，这个时候可以简单的执行 <code>shutdown -rF now</code> ,重启后自动修复一把，之后再挂载clonezilla ISO进行克隆</p></li>
</ul>


<h4>最后，让我们期望所有的服务商都能提供 qcow2 的导入导出功能</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crawler ABC]]></title>
    <link href="http://happy123.me/blog/2018/07/04/crawler-abc/"/>
    <updated>2018-07-04T19:04:58+08:00</updated>
    <id>http://happy123.me/blog/2018/07/04/crawler-abc</id>
    <content type="html"><![CDATA[<p>一个小爬虫的主要的套路就是requests, beautifulsoup, phantomjs.</p>

<!-- more -->


<h2>requests</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def get_html(url):
</span><span class='line'>    headers = {
</span><span class='line'>        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0',
</span><span class='line'>        'Accept': 'application/json, text/plain, */*',
</span><span class='line'>        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',
</span><span class='line'>        'Accept-Encoding': 'gzip, deflate, br',
</span><span class='line'>        'Content-Type': 'application/x-www-form-urlencoded',
</span><span class='line'>    }
</span><span class='line'>    resp = requests.get(url, headers=headers)
</span><span class='line'>    if resp.status_code == 200:
</span><span class='line'>        return resp.content
</span><span class='line'>    else:
</span><span class='line'>        raise ValueError("Not valid response:{}".format(resp.content))
</span></code></pre></td></tr></table></div></figure>


<h2>beautifulsoup</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from bs4 import BeautifulSoup
</span><span class='line'>def get_username(html):
</span><span class='line'>    soup = BeautifulSoup(html, 'lxml')
</span><span class='line'>    user_div = soup.find(id='uhd')
</span><span class='line'>    username = user_div.find('h2', class_='mt').get_text().strip()
</span><span class='line'>    return username</span></code></pre></td></tr></table></div></figure>


<h2>phantomjs</h2>

<p>用法非常简单，但是每次都得去查文档，封装成一个傻瓜类比较实在</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class WebClient(object):
</span><span class='line'>
</span><span class='line'>    USER_AGENTS = [
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",
</span><span class='line'>        "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",
</span><span class='line'>        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
</span><span class='line'>        "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
</span><span class='line'>        "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",
</span><span class='line'>        "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",
</span><span class='line'>        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",
</span><span class='line'>        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",
</span><span class='line'>        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"
</span><span class='line'>    ]
</span><span class='line'>
</span><span class='line'>    def __init__(self, phantomjs_driver_path='/usr/local/bin/phantomjs'):
</span><span class='line'>        # 引入配置对象DesiredCapabilities
</span><span class='line'>        dcap = dict(DesiredCapabilities.PHANTOMJS)
</span><span class='line'>
</span><span class='line'>        # 从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器
</span><span class='line'>        dcap["phantomjs.page.settings.userAgent"] = (random.choice(self.USER_AGENTS))
</span><span class='line'>
</span><span class='line'>        # 不载入图片，爬页面速度会快很多
</span><span class='line'>        dcap["phantomjs.page.settings.loadImages"] = False
</span><span class='line'>
</span><span class='line'>        # 设置代理
</span><span class='line'>        # service_args = ['--proxy=127.0.0.1:1080', '--proxy-type=http']
</span><span class='line'>
</span><span class='line'>        # 打开带配置信息的phantomJS浏览器
</span><span class='line'>        self._driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap)
</span><span class='line'>
</span><span class='line'>        # 隐式等待5秒，可以自己调节
</span><span class='line'>        self._driver.implicitly_wait(5)
</span><span class='line'>
</span><span class='line'>        # 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项
</span><span class='line'>        # 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。
</span><span class='line'>        self._driver.set_page_load_timeout(10)
</span><span class='line'>        # 设置10秒脚本超时时间
</span><span class='line'>        self._driver.set_script_timeout(10)
</span><span class='line'>
</span><span class='line'>    @property
</span><span class='line'>    def driver(self):
</span><span class='line'>        return self._driver
</span></code></pre></td></tr></table></div></figure>


<p>用起来也很简单，拿登陆163邮箱做例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def login_163(email, password):
</span><span class='line'>    login_url = 'http://m65.mm.mail.163.com/'
</span><span class='line'>    driver = WebClient().driver
</span><span class='line'>    driver.get(login_url)
</span><span class='line'>    driver.implicitly_wait(10)
</span><span class='line'>
</span><span class='line'>    try:
</span><span class='line'>        driver.execute_script('document.querySelector(".m-footer").querySelector("a").click();')
</span><span class='line'>        driver.execute_script('document.getElementById("entryMail").click();')
</span><span class='line'>    except Exception as _:
</span><span class='line'>        pass
</span><span class='line'>
</span><span class='line'>    time.sleep(3)
</span><span class='line'>    driver.find_element_by_xpath('//input[@name="username"]').send_keys(email.split('@')[0])
</span><span class='line'>    driver.find_element_by_xpath('//input[@name="password"]').send_keys(password)
</span><span class='line'>    mail_select = Select(driver.find_element_by_xpath('//select[@name="domain"]'))
</span><span class='line'>    mail_select.select_by_value(email.split('@')[-1])
</span><span class='line'>    # driver.save_screenshot(email + '.png')
</span><span class='line'>
</span><span class='line'>    # submit
</span><span class='line'>    driver.find_element_by_id('submit').submit()
</span><span class='line'>    driver.implicitly_wait(10)
</span><span class='line'>    time.sleep(5)
</span><span class='line'>    # driver.save_screenshot(email + '.login.png')
</span><span class='line'>
</span><span class='line'>    login_info = driver.find_element_by_xpath('//div[@class="fgreet"]/strong').text
</span><span class='line'>    driver.quit()
</span><span class='line'>
</span><span class='line'>    return login_info.strip() == email</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Grep Obtain Patterns From File]]></title>
    <link href="http://happy123.me/blog/2018/07/04/how-to-grep-obtain-patterns-from-file/"/>
    <updated>2018-07-04T18:06:55+08:00</updated>
    <id>http://happy123.me/blog/2018/07/04/how-to-grep-obtain-patterns-from-file</id>
    <content type="html"><![CDATA[<p>有一个100G的大文本文件 emailinfo.dict，包含邮箱及用户昵称; 格式为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hello@163.com,你是我的海
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>有一个用户名文件user.txt，格式为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>aaa
</span><span class='line'>xxxx
</span><span class='line'>....</span></code></pre></td></tr></table></div></figure>


<p>我们希望找出emailinfo.dict中，以user.txt中用户名开头的所有内容。</p>

<p>首先将user.txt内容改为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>^aaa
</span><span class='line'>^xxxx
</span><span class='line'>....</span></code></pre></td></tr></table></div></figure>


<p>然后执行:</p>

<pre><code>grep -G -f user.txt emailinfo.dict
</code></pre>

<p>这个<code>-G</code>参数又花了我半个小时去读文档，我都不知道第几次做这种事情了。人年纪大了果然只能靠笔记。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peewee ABC]]></title>
    <link href="http://happy123.me/blog/2018/07/03/peewee-abc/"/>
    <updated>2018-07-03T11:10:09+08:00</updated>
    <id>http://happy123.me/blog/2018/07/03/peewee-abc</id>
    <content type="html"><![CDATA[<p>在我用了又一个小时的时间去温习sqlchemy丰富的文档后，我放弃治疗了。</p>

<p>我的智商还是适合比较简单的幼儿化的Python库，于是我转向Peewee了。</p>

<h2>定义Model</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from peewee import SqliteDatabase, Model, CharField
</span><span class='line'>
</span><span class='line'>db = SqliteDatabase('testdb.sqlite3')
</span><span class='line'>
</span><span class='line'>class User(Model):
</span><span class='line'>    username = CharField(index=True)
</span><span class='line'>    password = CharField()
</span><span class='line'>    email = CharField(index=True)
</span><span class='line'>    birthday = DateField()
</span><span class='line'>    is_relative = BooleanField()
</span><span class='line'>
</span><span class='line'>    class Meta:
</span><span class='line'>        database = db
</span></code></pre></td></tr></table></div></figure>


<h2>创建</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; db.connect()
</span><span class='line'>&gt;&gt;&gt; db.create_tables([User])</span></code></pre></td></tr></table></div></figure>


<h2>保存</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; user_record = User(name='Bob', password="", email="hello@world.com", birthday=date(1960, 1, 15), is_relative=True)
</span><span class='line'>&gt;&gt;&gt; user_record.save()
</span></code></pre></td></tr></table></div></figure>


<h2>批量插入</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fields = [User.username, User.password, User.email, User.birthday, User.is_relative]
</span><span class='line'>user_records.append(
</span><span class='line'>    (username, password, email, birthday, True),
</span><span class='line'>    (username, password, email, birthday, True),
</span><span class='line'>    (username, password, email, birthday, True),
</span><span class='line'>)
</span><span class='line'>User.insert_many(user_records, fields=fields).execute()
</span></code></pre></td></tr></table></div></figure>


<h2>查询</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for user in User.select().where(User.username.contains(username)):
</span><span class='line'>    print(user.username ....)</span></code></pre></td></tr></table></div></figure>


<h2>关闭</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; db.close()</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Set Proxy for Git]]></title>
    <link href="http://happy123.me/blog/2018/06/11/how-to-set-proxy-for-git/"/>
    <updated>2018-06-11T11:12:20+08:00</updated>
    <id>http://happy123.me/blog/2018/06/11/how-to-set-proxy-for-git</id>
    <content type="html"><![CDATA[<h3>全局设置和取消:</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global https.proxy http://127.0.0.1:1080
</span><span class='line'>
</span><span class='line'>git config --global https.proxy https://127.0.0.1:1080
</span><span class='line'>
</span><span class='line'>git config --global --unset http.proxy
</span><span class='line'>
</span><span class='line'>git config --global --unset https.proxy</span></code></pre></td></tr></table></div></figure>


<h3>local设置和取消:</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config  https.proxy http://127.0.0.1:1080
</span><span class='line'>
</span><span class='line'>git config  https.proxy https://127.0.0.1:1080
</span><span class='line'>
</span><span class='line'>git config  --unset http.proxy
</span><span class='line'>
</span><span class='line'>git config  --unset https.proxy</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Becoming Warren Buffett]]></title>
    <link href="http://happy123.me/blog/2018/06/10/becoming-warren-buffett/"/>
    <updated>2018-06-10T23:04:31+08:00</updated>
    <id>http://happy123.me/blog/2018/06/10/becoming-warren-buffett</id>
    <content type="html"><![CDATA[<p>看了一遍 《Becoming Warren Buffett》 这部纪录片。</p>

<p>印象里巴菲特总是与成功学书籍联系在一起，作为股神，他的公司Berkshire Hathaway的股票价格达到了近$300,000一股，实在是让人叹为观止。</p>

<p>后来有时间仔仔细细读了他每年致股东的信，距离一下子拉近了，他确实是个不凡的人。</p>

<p>巴菲特不同于一般的投机者，他是一个受人尊敬的人。人们尊敬他，并不仅仅是因为他的富有：</p>

<h3>1. 巴菲特很早就确定了自己喜欢做什么，自己的人生信条是什么，并用一生去实践。</h3>

<p>大部分人一辈子也不明白自己到底喜欢做什么，就这样浑浑噩噩一生过去了。</p>

<p>早早找到自己喜欢做的事情，才能拥有充实的人生。</p>

<p>当你发现自己内心深处的期望后，要有勇气去克服困难，并尽一切努力去追寻它，守护它；</p>

<p>全世界只有你最了解自己想要什么，在这一方面，其他任何人的意见都不值得参考；</p>

<p>也许你说这是一种固执，但是如果你有了信念，不要轻易动摇，用你的一生或者半生去实践这个信念。</p>

<p>所谓信念，就是值得你赌上一生去判断对错的东西。</p>

<h3>2. 巴菲特洞悉了时间之谜。他遵循内心的信念，数十年如一日的耐心等待，他是少数能与时间友好相处的那个人。</h3>

<p>人在生物学上就是一种短视的动物，早在人类初期，生存环境恶劣，那时候的人类不得不把大部分精力放在眼前。筹划未来是一种负担，因为你不知道明天会发生什么，自己能不能活下去。</p>

<p>随着科技水平的提高，人们的寿命也不断提高，但是&#8221;只顾眼前&#8221;是刻在人类进化的基因里面的，不会轻易改变。所以人们今晚做出的决定，明天又会被自己轻易否决。</p>

<p>人们焦虑的追逐时间却往往没有所得，基因诱使我们焦虑。让我们短视，急于求成。</p>

<p>只有那些真正把握信念的人才能不为所动，巴菲特就是其中的佼佼者。</p>

<p>让我们记住  &ldquo;不为所动&#8221;，<code>耐心</code>是需要人类不断锻炼自己才能拿到的美德。</p>

<h3>3. 巴菲特的故事里面包含了信念、坚韧、固执、耐心、快乐这些字眼。</h3>

<p>他从一而终的守护自己的观点，并实践终身。就像是运动员不断超越极限，我们看到一个自律的人究竟能达到什么样的高度，这份了不起的坚守打动了我们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Split Large ‘tar’ Archive Into Multiple Files of Certain Size]]></title>
    <link href="http://happy123.me/blog/2018/06/10/how-to-split-large-tar-archive-into-multiple-files-of-certain-size/"/>
    <updated>2018-06-10T21:50:43+08:00</updated>
    <id>http://happy123.me/blog/2018/06/10/how-to-split-large-tar-archive-into-multiple-files-of-certain-size</id>
    <content type="html"><![CDATA[<p>有时候需要压缩文件的时候同时分割一下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tar czvf - -C /mnt/g/dict/ weakpass_merge.dict |split -b 10000M - "weakpass.part.tar.gz."</span></code></pre></td></tr></table></div></figure>


<p>还原:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat weakpass.part.tar.gz.*|tar zxvf</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指数ETF漫谈]]></title>
    <link href="http://happy123.me/blog/2018/05/15/zhi-shu-etfman-tan/"/>
    <updated>2018-05-15T13:43:23+08:00</updated>
    <id>http://happy123.me/blog/2018/05/15/zhi-shu-etfman-tan</id>
    <content type="html"><![CDATA[<p>以下全是个人偏见，记录下看看将来会不会有所成长。</p>

<h2>散户跑赢市场的唯一机会就是指数基金</h2>

<!-- more -->


<p>目前曾经投过的几个指数挨个来数一数:</p>

<h3>美国市场</h3>

<ul>
<li>博时标普500ETF(513500)</li>
</ul>


<p>成立时间早，管理费0.6%，托管费0.25%；池子小(4.5亿)，受外汇政策影响大，目前美股的市盈率在高位，小散投资他的唯一理由就是看空人民币，找美元计价的资产。</p>

<p>但其规模太小，手续费用高，对小散来说是鸡肋；对大户来说，不如直接开个香港账户去海外投资了</p>

<ul>
<li>广发纳斯达克100ETF(159941)</li>
</ul>


<p>管理费0.8%，托管费0.25%，池子更小，更鸡肋；不论是大户散户，想要投资美股的话直接办个香港永隆银行的卡，出金去QQQ划算</p>

<h4>总结</h4>

<p>在国内投资美股ETF，没有好的基金渠道；除非极度看空人民币，实在没有精力去办香港卡出金，可以适当持有一点，但总的来说是鸡肋；目前比较靠谱的做法还是香港办卡，开个IB之类的去投资美股</p>

<h3>港股市场</h3>

<ul>
<li>易方达恒生H股ETF(510900)</li>
</ul>


<p>目前H股的PE大概在10左右，在历史上还是处于比较高的位置；但是人民币接下来的几年必然有一个贬值区间，港币的联系汇率制度目前来看不会变化，所以投资H股是没有美股投资渠道的一个心理补充办法</p>

<ul>
<li>华夏沪港通恒生ETF(513660)</li>
</ul>


<p>目前恒生ETF的PE大概在11，投资价值跟H股类似；但是恒生指数的权重股更为全面，盘子更大，所以目前定投恒生ETF是个相对可以的时机</p>

<p>值得注意的是华夏还有一个类似的产品<code>513600</code>，同样是恒生ETF，不过资金是沪港通出现之前，走的外汇额度来购买的，受外汇政策影响大，手续费高一点； <code>513660</code>走的是沪港通，现在来看定投它比较合适；</p>

<h3>国内市场</h3>

<ul>
<li>南方中证500ETF(510500)</li>
</ul>


<p>目前中证ETF的PE已经到了26左右，从历史来看已经到相当低的位置了，当然和港股以及美股是没得比；但是现在是一个开始定投的好时机</p>

<ul>
<li>华夏上证50ETF(510050)</li>
</ul>


<p>上证50的PE在11左右，定投的话虽然不是绝佳入场时机，但做好三年打算的话也不会亏的；但是我不推荐，理由在后面说</p>

<ul>
<li>华泰柏瑞沪深300ETF(510300)</li>
</ul>


<p>沪深300的PE在13左右，历史来看百分比位置和50ETF差不多，>60%；但是沪深300的权重股更广泛，波动更大，定投的话要比50ETF更合适，但是同样不推荐，理由后边说</p>

<ul>
<li>华泰柏瑞上证红利ETF(510880)</li>
</ul>


<p>这个是可以推荐的，目前红利指数的PE也已经到了一个历史低点，相对于上证50，这个指数的成长性类似，但是分红是稳稳的，所以他的打分要高于50ETF</p>

<h2>一些思考</h2>

<h4>国内的股市总体上是一个零和博弈</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>股市产生的收益=上市公司的利润+股民的投入-（印花税+手续费+上市公司圈走的钱 +融资利息+配资公司的利息+套利成功者的利润）</span></code></pre></td></tr></table></div></figure>


<p>（印花税+手续费），这两项的抽血与交易量正相关，现在中国股市的交易量都在万亿级别，也就是说交易手续的损耗如果按万三来算，这每天起码三亿多消耗是逃不掉的。印花税千一的话，又收十亿，这些是纯成本，没法避免的。
上市公司圈走的钱，包括IPO和再融资等等，股民朋友们银转证，把钱从自己的银行账户里划出去打新股后，这钱就到了上市公司的账上了。如果上市公司产生的利润及不上股市里融资圈走的钱的话，就是纯付出了。
融资入场者的利息，这个也是纯成本，如果融资流入的速度大于利息支出的速度的话，我们能看到的是正贡献，这都体现在股民的投入里，利息是纯成本。</p>

<p>根据2017年的公开市场数据估算一下，现在的股市确实约等于零和博弈:</p>

<p><a href="https://www.zhihu.com/question/27047936">https://www.zhihu.com/question/27047936</a></p>

<h4>零和博弈，基本上可以说是赌场了</h4>

<p>既然是赌场，赌神有且只有一个，就是庄家；</p>

<p>散户挣钱，只有两个解释:</p>

<ul>
<li><p>我挣钱是因为对手赔钱</p></li>
<li><p>庄家吃肉，我喝汤</p></li>
</ul>


<h4>谁是庄家</h4>

<p>敬爱的朱总理是个直白的汉子，1999年5月，已是国务院总理的朱镕基批示证监会，“股票市场要为国有企业脱困和推行股份制服务”</p>

<p>要找附和赞同的人，有的是：比如:</p>

<p><a href="http://www.iceo.com.cn/com2013/2014/1210/298403.shtml">http://www.iceo.com.cn/com2013/2014/1210/298403.shtml</a></p>

<p>股市的大庄家是国家、国企；券商跟着收个茶水费；其他人都喝汤</p>

<h4>要坚定不疑的跟着庄家走</h4>

<p>上证50是庄家的扛把子台桌，但是庄家不会让你吃肉的，所以50ETF的PE从不会太高；</p>

<p>庄家不让我吃肉，我只好投资红利指数喝点汤，这点汤庄家还是愿意给的，因为毕竟需要有赌客来捧场子</p>

<h4>光喝汤跑不赢CPI，怎么办</h4>

<p>只能从其它散户(赌客)那里想办法。</p>

<p>上证50ETF是庄家的台桌，散户的台桌在哪里？</p>

<p>沪深300？ 不行，里面有不少桌子是庄家的。</p>

<p>创业板？不要提了，那是老千的台桌，小散不要凑热闹。</p>

<p>中证500ETF：真正的零和博弈台桌，它是庄家留给我们的场子，庄家允许这里出现几个幸运儿；所以500ETF的PE到了25了，我们便惊呼好便宜，历史低点；</p>

<p>我们需要在这里打胜仗。</p>

<p>能长期战胜市场的人是不存在的，百战不殆的赌神也是不存在的，但是我们只需要打败50%的人就可以了；</p>

<p>有个著名的赌徒谬误：赌大小，只赌大或者只赌小；每次失败，赌注加倍，只要资金足够多，总能赢；</p>

<p>如果是50%绝对公平的场子，这个赌徒最终会万劫不复；</p>

<p>幸运的是，这个场子总是很多作弊的人，很多自做聪明的人，很多意外保证这不是一个50%的场子；这个时候请参考耶鲁公开课《博弈论》的一二节。</p>

<p>另外这个场子目前只能赌大，所以我们要做的事情就简单了：</p>

<p><code>在大多数人都看小的时候，开大，一次一次加注</code></p>

<p>换成人话就是在市场低点的时候定投中证500ETF，每周下注，下注三年；共3X56 注，大多数人撑不过三年，你就赢了；</p>

<h4>庄家从来不大喊我是庄家，相反他还会掩饰自己是庄家的事实</h4>

<p>所以庄家会说场子不止有我这一个，你也可以去沪港通，港股通巴拉巴拉</p>

<p>所以我们求一个保险垫，目前看来美国进入加息周期，所以美元计价的资产可以考虑，我们下注恒生ETF来打底，它是你叫板庄家的棺材本；梦想还是要有的，万一庄家睡着了呢</p>

<ul>
<li><p>标普500ETF的PE到了25我们称之为危险的泡沫，中证500ETF的PE到了25我们惊呼历史低点</p></li>
<li><p>360在美股估值600亿CNY，回来披个马甲就是4000亿CNY</p></li>
</ul>


<h2>庄家猛于虎</h2>

<h4>最后的策略是:</h4>

<ul>
<li><p>每周下注一手中证500ETF赌大小</p></li>
<li><p>每周下注一手红利ETF喝汤</p></li>
<li><p>每周下注一手恒生ETF叫板庄家</p></li>
</ul>


<h2>保持自信，不动如山</h2>

<p>与君共勉之</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python处理中文标点符号]]></title>
    <link href="http://happy123.me/blog/2018/05/14/pythonchu-li-zhong-wen-biao-dian-fu-hao/"/>
    <updated>2018-05-14T09:03:13+08:00</updated>
    <id>http://happy123.me/blog/2018/05/14/pythonchu-li-zhong-wen-biao-dian-fu-hao</id>
    <content type="html"><![CDATA[<p>中文文本中可能出现的标点符号来源比较复杂，通过匹配等手段对他们处理的时候需要格外小心，防止遗漏。以下为在下处理中文标点的时候采用的两种方法:</p>

<!-- more -->


<h3>中文标点集合</h3>

<h4>比较常见标点有这些：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>！？｡＂＃＄％＆＇（）＊＋，－／：；＜＝＞＠［＼］＾＿｀｛｜｝～｟｠｢｣､、〃》「」『』【】〔〕〖〗〘〙〚〛〜〝〞〟〰〾〿–—‘’‛“”„‟…‧﹏.</span></code></pre></td></tr></table></div></figure>


<p>调用zhon包的zhon.hanzi.punctuation函数即可得到这些中文标点。</p>

<p>如果想用英文的标点，则可调用string包的string.punctuation函数可得到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>!"#$%&\'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</span></code></pre></td></tr></table></div></figure>


<p>因此，比如需要将所有标点符号去除，可以进行以下操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; import re
</span><span class='line'>&gt;&gt;&gt; from zhon.hanzo import punctuation
</span><span class='line'>&gt;&gt;&gt; line = "测试。。去除标点。。"
</span><span class='line'>&gt;&gt;&gt; print re.sub("[{}]+".format(punctuation), "", line.decode("utf-8")) # 需要将str转换为unicode</span></code></pre></td></tr></table></div></figure>


<p>当然，如果想去除重复的符号而只保留一个，那么可以用\1指明：比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; re.sub(ur"([{}])+".format(punctuation), "\1", line.decode("utf-8"))</span></code></pre></td></tr></table></div></figure>


<p>你也可以手工指定这些标点符号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>punctuation = """！？｡＂＃＄％＆＇（）＊＋－／：；＜＝＞＠［＼］＾＿｀｛｜｝～｟｠｢｣､、〃》「」『』【】〔〕〖〗〘〙〚〛〜〝〞〟〰〾〿–—‘’‛“”„‟…‧﹏"""
</span><span class='line'>re_punctuation = "[{}]+".format(punctuation)
</span><span class='line'>line = re.sub(re_punctuation, "", line)</span></code></pre></td></tr></table></div></figure>


<h3>可以通过直接指定unicode码范围的办法来strip，比如:</h3>

<p>去除所有半角全角符号，只留字母、数字、中文</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def remove_punctuation(line):
</span><span class='line'>    rule = re.compile(ur"[^a-zA-Z0-9\u4e00-\u9fa5]")
</span><span class='line'>    line = rule.sub('',line)
</span><span class='line'>    return line</span></code></pre></td></tr></table></div></figure>


<p>汉字的范围为”\u4e00-\u9fa5“，这个是用Unicode表示的，所以前面必须要加”u“；字符”r“的意思是表示忽略后面的转义字符，这样简化了后面正则表达式里每遇到一个转义字符还得挨个转义的麻烦</p>

<h3>最后可以组合成为一个函数</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def remove_punctuation(line, strip_all=True):
</span><span class='line'>    if strip_all:
</span><span class='line'>        rule = re.compile(ur"[^a-zA-Z0-9\u4e00-\u9fa5]")
</span><span class='line'>        line = rule.sub('',line)
</span><span class='line'>    else:
</span><span class='line'>        punctuation = """！？｡＂＃＄％＆＇（）＊＋－／：；＜＝＞＠［＼］＾＿｀｛｜｝～｟｠｢｣､、〃》「」『』【】〔〕〖〗〘〙〚〛〜〝〞〟〰〾〿–—‘’‛“”„‟…‧﹏"""
</span><span class='line'>        re_punctuation = "[{}]+".format(punctuation)
</span><span class='line'>        line = re.sub(re_punctuation, "", line)
</span><span class='line'>
</span><span class='line'>    return line.strip()</span></code></pre></td></tr></table></div></figure>


<h3>清洗完毕后，有时候我们希望按照多个标点符号来分割</h3>

<p>比如只要遇到中文或英文的逗号和句号等符号就分割，可以直接用translate把这些符号翻译为统一的分隔符，再split:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>strip_chars = '？"。.，,《》[]〖〗“”'
</span><span class='line'>single_line = single_line.translate(str.maketrans(dict.fromkeys(strip_chars, '#')))
</span><span class='line'>single_line = single_line.split('#')</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Improve Performance Your Cmd by Parallel]]></title>
    <link href="http://happy123.me/blog/2018/05/06/how-to-improve-performance-your-cmd-by-parallel/"/>
    <updated>2018-05-06T09:32:03+08:00</updated>
    <id>http://happy123.me/blog/2018/05/06/how-to-improve-performance-your-cmd-by-parallel</id>
    <content type="html"><![CDATA[<p>有很多时候，处理一个大文件，常规命令并不能很好的利用多核</p>

<!-- more -->


<p>例如，一个1T的文本，百亿条数据，我想要:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wc -l test.txt</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fgrep xxxx test.txt</span></code></pre></td></tr></table></div></figure>


<p>一般机器就会自觉进入<code>一核有难，其它核点赞</code>的看戏模式。</p>

<p>我花钱配了这么多核，加了这么多内存，不是让大家来看戏的。于是祭出<code>parallel</code>~</p>

<h2>原理</h2>

<p>parallel 是一个perl脚本，通过分割输入，并行处理的方式来加速执行命令。</p>

<p>例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wc -l test.txt</span></code></pre></td></tr></table></div></figure>


<p>简单想想就是用个for循环split文件，挨个wc，然后相加。parallel就是自动帮你把这类事情做掉而已。大道不过两三行，所谓外部排序，Map-Reduce莫不如是。</p>

<h2>安装 (ubuntu 16.04LTS)</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> apt-get install parallel</span></code></pre></td></tr></table></div></figure>


<h2>示例</h2>

<h4>最快的办法计算一个大文件的行数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --pipe wc -l | awk '{s+=$1} END {print s}'</span></code></pre></td></tr></table></div></figure>


<p>非常的巧妙，先使用parallel命令‘mapping’出大量的wc -l调用，形成子计算，最后通过管道发送给awk进行汇总</p>

<h4>SED, 想在一个巨大的文件里使用sed命令做大量的替换操作吗？</h4>

<p>常规做法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sed s^old^new^g bigfile.txt</span></code></pre></td></tr></table></div></figure>


<p>现在你可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --pipe sed s^old^new^g</span></code></pre></td></tr></table></div></figure>


<h4>GREP 一个非常大的文本文件</h4>

<p>以前你可能会这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep pattern bigfile.txt</span></code></pre></td></tr></table></div></figure>


<p>现在你可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --pipe grep 'pattern'</span></code></pre></td></tr></table></div></figure>


<p>或者这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt | parallel --no-notice --block 10M --pipe grep 'pattern'</span></code></pre></td></tr></table></div></figure>


<p>这第二种用法使用了 –block 10M参数，这是说每个内核处理1千万行——你可以用这个参数来调整每个CUP内核处理多少行数据。</p>

<h4>压缩一个非常大的文件</h4>

<p>bzip2是比gzip更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。</p>

<p>以前的做法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.bin | bzip2 --best &gt; compressedfile.bz2</span></code></pre></td></tr></table></div></figure>


<p>现在这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.bin | parallel --no-notice --pipe --recend '' -k bzip2 --best &gt; compressedfile.bz2</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>作为一个Python党，经常写一些<code>用过即弃</code>的边角料脚本</p>

<p>比如最近要把一个1T的文件汉字全部转换为拼音，初版当然是这样的:</p>

<h4>版本1</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>with io.open(sys.argv[1], encoding='utf-8') as fp:
</span><span class='line'>    for line in fp:
</span><span class='line'>        print(lazy_pinyin(line))</span></code></pre></td></tr></table></div></figure>


<p>lazy_pinyin的效率奇慢无比，这回陷入了一核有难，其它核+内存+磁盘全部看戏模式</p>

<p>作为一个初级合格的Python开发人员，你当然说要用process，于是我们有了第二版:</p>

<h4>版本2</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from multiprocessing import Pool
</span><span class='line'>pool = Pool(16)
</span><span class='line'>with io.open(sys.argv[1], encoding='utf-8') as fp:
</span><span class='line'>    pool.map(lazy_pinyin, fp, 16)
</span><span class='line'>    pool.close()
</span><span class='line'>    pool.join()</span></code></pre></td></tr></table></div></figure>


<p>嗯，很好，16个核都跑起来了；但是你有很快尴尬的发现，map把文件一把load进来，内存有难了</p>

<h4>~~~~</h4>

<p>作为一个初级合格的Python开发人员，你当然说不要一把读进来，要用chunk_read，一次读一块，或者更高级一点，直接用mmap映射进内存巴拉巴拉</p>

<h4>少年，这还是那个边角料脚本吗，你已经在它上面操心一个小时了，还能不能愉快的玩耍了</h4>

<p>让 parallel来拯救你</p>

<h4>版本3</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import fileinput
</span><span class='line'>
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    for line in fileinput.input():
</span><span class='line'>        lazy_pinyin(line)</span></code></pre></td></tr></table></div></figure>


<p>然后执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat bigfile.txt| parallel --no-notice --pipe python pinyinconv.py &gt; pinyin.result</span></code></pre></td></tr></table></div></figure>


<p>享受所有CPU满负荷运载的工头压榨工人的快感吧</p>

<h2>一些扩展</h2>

<ul>
<li>为啥所有的parallel都带有一个奇怪的&mdash;no-notice?</li>
</ul>


<p>嗯，虽然这个作者非常非常好，但是他总是在命令前面输出一些捐助提示；当然我并不是讨厌这种做法，但看多了总有些疲劳，你懂的~~</p>

<ul>
<li>我有一些参数想传给程序，怎么办？</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> seq 3|parallel --no-notice -q echo seq{}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这个命令很好，但是语法好像啰嗦了一些，还有其它的替代命令吗？</li>
</ul>


<p>嗯~ o(<em>￣▽￣</em>)o，还是有的，xargs有个-n参数，类似的效果，不过功能弱化很多，基本上是鸡肋</p>

<h2>参考:</h2>

<h4>手册:</h4>

<p><a href="https://www.gnu.org/software/parallel/parallel_tutorial.html">https://www.gnu.org/software/parallel/parallel_tutorial.html</a></p>

<h4>资料:</h4>

<p><a href="http://www.freeoa.net/osuport/sysadmin/use-gnu-parallel-multi-core-speed-up-cmd_2343.html">http://www.freeoa.net/osuport/sysadmin/use-gnu-parallel-multi-core-speed-up-cmd_2343.html</a></p>

<p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1bnzu1pmog27t">https://cloud.tencent.com/developer/support-plan?invite_code=1bnzu1pmog27t</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Sort a Very Very Very Big File]]></title>
    <link href="http://happy123.me/blog/2018/05/03/how-to-sort-a-very-very-very-big-file/"/>
    <updated>2018-05-03T07:21:50+08:00</updated>
    <id>http://happy123.me/blog/2018/05/03/how-to-sort-a-very-very-very-big-file</id>
    <content type="html"><![CDATA[<p>sort -uo 一个1T的文件，让最高配的google cloud instance (48 core/512G)崩溃了<del>，可惜了我的$30，白白跑了那么长时间</del></p>

<p>网上搜索都是how to sort a big file，那我这个属于very very very big big big file了~~</p>

<p>不管是并行也好，管道也好，用了各种奇技淫巧就是敌不过人家 very very big~</p>

<p>不要跟我谈什么外排，归并，位图，bloom filter，redis hash去重，我就是不想折腾，最后只有分割手动外排搞定~~</p>

<h3>把大象装进冰箱分为几步？</h3>

<h3>三步:</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>split -l 1000000000 huge-file small-chunk
</span><span class='line'>
</span><span class='line'>for X in small-chunk*; do sort -u &lt; $X &gt; sorted-$X; done
</span><span class='line'>
</span><span class='line'>sort -u -m sorted-small-chunk* &gt; sorted-huge-file && rm -rf small-chunk* sorted-small-chunk*</span></code></pre></td></tr></table></div></figure>


<h3>小TIPS:</h3>

<p>如果只要去重不要排序的话，尽量不要用 sort -u或者sort | uniq，这个是nLog(n)的效率，让人捉急。</p>

<p>可以利用awk的数组是内存hash表的特性，直接awk来做，前提是你内存够大，瞎估估需要十倍于数据的内存吧:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat xxxxx zzz | awk '{ if (!seen[$0]++) { print $0; } }' &gt; xxx_zzz.uniq.txt</span></code></pre></td></tr></table></div></figure>


<h3>PS:</h3>

<p>我后来又看了一下GNU Sort的实现描述，它说已经用了外排了，但是实际使用还是不给力，暂时迷惑中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get Intersection of Two Big Files]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-get-intersection-of-two-big-files/"/>
    <updated>2018-05-01T22:18:33+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-get-intersection-of-two-big-files</id>
    <content type="html"><![CDATA[<p>两个大文件，a.txt和b.txt两个文件的数据都是逐行呈现的， 如何求他们的交集、并集和差集。</p>

<p>用sort+uniq直接搞定:</p>

<h2>交集</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sort a.txt | uniq &gt; aa.txt
</span><span class='line'>$ sort b.txt | uniq &gt; bb.txt
</span><span class='line'>$ cat aa.txt bb.txt | sort | uniq -d</span></code></pre></td></tr></table></div></figure>


<h2>并集</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat a.txt b.txt | sort | uniq</span></code></pre></td></tr></table></div></figure>


<h2>差集</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sort a.txt | uniq &gt; aa.txt
</span><span class='line'>$ sort b.txt | uniq &gt; bb.txt
</span><span class='line'>$ cat aa.txt bb.txt bb.txt | sort | uniq -u</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在开搞 bloom filter或者bitmap 或者grep -f之前可以先组合工具来一个</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Parallel All Cmds for Linux]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-parallel-all-cmds-for-linux/"/>
    <updated>2018-05-01T13:07:20+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-parallel-all-cmds-for-linux</id>
    <content type="html"><![CDATA[<p>grep 一个100GB的文件总是很有压力，怎么才能提速呢?</p>

<h3>瞎优化</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LC_ALL=C fgrep -A 5 -B 5 'xxxxx.password' allpassseed.txt</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p><code>LC_ALL=C</code>比<code>LC_ALL=UTF-8</code>要块</p></li>
<li><p>不需要正则的话，用fgrep可以提速</p></li>
</ul>


<h3>不过这样优化总是治标不治本，下面隆重推出linux 里面parallel all cmds的perl工具</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat allpassseed.txt |parallel  --pipe  --no-notice grep -f xxxxx.password</span></code></pre></td></tr></table></div></figure>


<p>使用parallel ，和不使用parallel直接grep。结果显而易见，相差 20 倍。这比用啥 ack，ag优化效果明显多了</p>

<h3>xargs也有一个-n的多核选项，可以作为备用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ time echo {1..5} |xargs -n 1  sleep
</span><span class='line'>
</span><span class='line'>real    0m15.005s
</span><span class='line'>user    0m0.000s
</span><span class='line'>sys 0m0.000s</span></code></pre></td></tr></table></div></figure>


<p>这一条xargs把每个echo的数作为参数传给sleep ，所以一共sleep了 1+2+3+4+5=15秒。</p>

<p>如果使用 -P 参数分给5个核，每个核各sleep 1,2,3,4,5秒，所以执行完之后总共sleep的5秒。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ time echo {1..5} |xargs -n 1 -P 5 sleep
</span><span class='line'>
</span><span class='line'>real    0m5.003s
</span><span class='line'>user    0m0.000s
</span><span class='line'>sys 0m0.000s</span></code></pre></td></tr></table></div></figure>


<ul>
<li>引自:</li>
</ul>


<p><a href="https://www.jianshu.com/p/c5a2369fa613">https://www.jianshu.com/p/c5a2369fa613</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Calling Multiple Commands Through Xargs]]></title>
    <link href="http://happy123.me/blog/2018/05/01/how-to-calling-multiple-commands-through-xargs/"/>
    <updated>2018-05-01T09:25:03+08:00</updated>
    <id>http://happy123.me/blog/2018/05/01/how-to-calling-multiple-commands-through-xargs</id>
    <content type="html"><![CDATA[<p>有时候想在xargs后面接多条命令，这个时候直接加<code>;</code>是不行的，要这样做:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat a.txt | xargs -I@  sh -c 'command1; command2; ...'</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Compress All Find Files to Single Line Argv]]></title>
    <link href="http://happy123.me/blog/2018/04/30/how-to-compress-all-find-files-to-single-line-argv/"/>
    <updated>2018-04-30T10:39:39+08:00</updated>
    <id>http://happy123.me/blog/2018/04/30/how-to-compress-all-find-files-to-single-line-argv</id>
    <content type="html"><![CDATA[<p>有时候find的所有文件要合并为一个argv管道到一个命令里面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>find /path/to/directory/ -name *.csv -print0 | xargs -0 -I file cat file &gt; merged.file</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Sort Big Files]]></title>
    <link href="http://happy123.me/blog/2018/04/27/how-to-sort-big-files/"/>
    <updated>2018-04-27T17:03:22+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/how-to-sort-big-files</id>
    <content type="html"><![CDATA[<p>在linux要排序一个100G的文件，压力比较大</p>

<p>并行解决之:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort -S 50% --parallel=2 -uo list-sorted.txt list.txt</span></code></pre></td></tr></table></div></figure>


<p>注意这一招在管道里面行不通，所以要用管道的话一定要先重定向到一个文件里面中转一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Strange Bitcoin Transaction]]></title>
    <link href="http://happy123.me/blog/2018/04/27/a-strange-bitcoin-transaction/"/>
    <updated>2018-04-27T14:24:30+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/a-strange-bitcoin-transaction</id>
    <content type="html"><![CDATA[<p>在之前的<a href="http://happy123.me/blog/2018/04/24/cryptocurrency-security/">谈谈比特币的地址安全问题</a>这篇文章中，我们谈到一个名为&#8221;LBC&#8221;的项目，这个项目通过暴力碰撞企图打捞到一些什么东西。</p>

<p>令人惊奇的是，他们真的碰到了几个地址。对他们最近发现的4个地址做了一下分析，发现了更让人惊奇的事情。</p>

<p>他们最近的四个发现是:</p>

<!-- more -->


<h4>2017-11-15 01:25:58 UTC</h4>

<ul>
<li><p>private key:0x236fb6d5ad1f43</p></li>
<li><p>hash160:cb66763cf7fde659869ae7f06884d9a0f879a092</p></li>
<li><p>address:1KYUv7nSvXx4642TKeuC2SNdTk326uUpFy</p></li>
<li><p>balance:0.054 BTC</p></li>
</ul>


<h4>2017-09-04 16:54:48 UTC</h4>

<ul>
<li><p>private key:0x180788e47e326c.</p></li>
<li><p>hash160:2f4870ef54fa4b048c1365d42594cc7d3d269551</p></li>
<li><p>address:15K1YKJMiJ4fpesTVUcByoz334rHmknxmT</p></li>
<li><p>balance: 0.053 BTC</p></li>
</ul>


<h4>2017-04-21 12:50:55 UTC</h4>

<ul>
<li><p>private key:0xefae164cb9e3c.</p></li>
<li><p>hash160: 36af659edbe94453f6344e920d143f1778653ae7</p></li>
<li><p>address:15z9c9sVpu6fwNiK7dMAFgMYSK4GqsGZim</p></li>
<li><p>balance:0.052 BTC</p></li>
</ul>


<h4>2017-04-05 02:23:00 UTC</h4>

<ul>
<li><p>private key:0x75070a1a009d4.</p></li>
<li><p>hash160:ef6419cffd7fad7027994354eb8efae223c2dbe7</p></li>
<li><p>address:1NpnQyZ7x24ud82b7WiRNvPm6N8bqGQnaS</p></li>
<li><p>balance:0.051 BTC</p></li>
</ul>


<h3>账户的余额依次递增，分别为0.051 &ndash;> 0.052 &ndash;> 0.053 &ndash;> 0.054</h3>

<h3>这也太凑巧了吧，为什么LBC的网站上没有小于0.051之前的数额呢</h3>

<p>一番追踪之后，我们发现了下面这笔交易:</p>

<p><a href="https://btc.com/08389f34c98c606322740c0be6a7125d9860bb8d5cb182c02f98461e5fa6cd15">https://btc.com/08389f34c98c606322740c0be6a7125d9860bb8d5cb182c02f98461e5fa6cd15</a></p>

<p>在2015年初的时候就有人对于比特币的安全模型提出过一个严肃的检验，他构造了以上这笔交易。</p>

<p>这笔交易的每个输出地址的私钥是这样构造的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>000...........................00001
</span><span class='line'>0000..........................000011
</span><span class='line'>0000.........................0000111
</span><span class='line'>0000........................00001000
</span><span class='line'>0000.......................000010101
</span><span class='line'>0000......................0000110001
</span><span class='line'>0000.....................00001001100
</span><span class='line'>0000....................000011100000
</span><span class='line'>0000...................0000111010011
</span><span class='line'>0000..................00001000000010
</span><span class='line'>0000.................000010010000011
</span><span class='line'>0000................0000101001111011
</span><span class='line'>0000...............00001010001100000
</span><span class='line'>0000..............000010100100110000
</span><span class='line'>0000.............0000110100011110011
</span><span class='line'>0000............00001100100100110110
</span><span class='line'>0000...........000010111011001001111
</span><span class='line'>0000..........0000110000100000001101
</span><span class='line'>0000.........00001010111010010011111
</span><span class='line'>0000........000011010010110001010101
</span><span class='line'>0000.......0000110111010010100110100
</span><span class='line'>0000......00001011011110010000001111
</span><span class='line'>0000.....000010101010110111001010010
</span><span class='line'>0000....0000110111000010101000000100</span></code></pre></td></tr></table></div></figure>


<p>第n个输出值为n mBTC，它的私匙(二进制)从右到第n位，也就是1，然后剩下的部分是随机的。</p>

<p>在我写这篇文章的时候，这批地址里面的余额已经被花费到了第54个地址，其实我猜就是LBC那帮人碰撞到的最大值(但是奇怪的是LBC的统计页面上没有包括这几个地址，我怀疑还有另外一个私下的类似LBC的组织在碰撞)</p>

<p>也许是币价飞涨，从第161个地址之后的币应该是被持有人花掉了。但是从55-160这个区间里面的币还安然无恙，这个价值加起来也不算小了。</p>

<p>这似乎是经过深思熟虑的~~也许是一个实验，看看在产出被拿走之前的时间。我认为这确实是个有趣的实验，比特币世界总不乏一些有趣的人。</p>

<p>少年，拿起你手中的显卡算力，2<sup>55</sup>级别的碰撞似乎不是那么遥不可及，让我们看看第55个幸运儿什么时候诞生。</p>

<ul>
<li>引用资料:</li>
</ul>


<p><a href="https://rya.nc/forensic-bitcoin-cracking.html">https://rya.nc/forensic-bitcoin-cracking.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Dump Csv From Sqlite3]]></title>
    <link href="http://happy123.me/blog/2018/04/27/how-to-dump-csv-from-sqlite3/"/>
    <updated>2018-04-27T08:57:22+08:00</updated>
    <id>http://happy123.me/blog/2018/04/27/how-to-dump-csv-from-sqlite3</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>/usr/bin/sqlite3 test.db &lt;&lt;!
</span><span class='line'>.headers on
</span><span class='line'>.mode csv
</span><span class='line'>.output out.csv
</span><span class='line'>select username,password,email from passhouse order by site;
</span><span class='line'>!</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[寻找并删除Git记录中的大文件]]></title>
    <link href="http://happy123.me/blog/2018/04/26/purge-large-files-in-gitrepo/"/>
    <updated>2018-04-26T13:36:16+08:00</updated>
    <id>http://happy123.me/blog/2018/04/26/purge-large-files-in-gitrepo</id>
    <content type="html"><![CDATA[<p>有时候gitignore没做好，一不小心就又进来一个二进制文件</p>

<p>在重复了N次Google之后，还是记一下吧</p>

<!-- more -->


<ol>
<li>首先通过rev-list来找到仓库记录中的大文件：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '{print$1}')"</span></code></pre></td></tr></table></div></figure>


<ol>
<li>然后通过filter-branch来重写这些大文件涉及到的所有提交（重写历史记录）：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git filter-branch -f --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch your-file-name' --tag-name-filter cat -- --all</span></code></pre></td></tr></table></div></figure>


<ol>
<li>再删除缓存的对象，顺便瘦身一下:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
</span><span class='line'>git reflog expire --expire=now --all
</span><span class='line'>git gc --prune=now</span></code></pre></td></tr></table></div></figure>


<p>打完收工</p>
]]></content>
  </entry>
  
</feed>
