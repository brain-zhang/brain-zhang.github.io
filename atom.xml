<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-10-23T15:39:50+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[brain-zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-5]]></title>
    <link href="https://happy123.me/blog/2019/09/22/wu-en-da-ji-qi-xue-xi-bi-ji-5/"/>
    <updated>2019-09-22T18:01:34+08:00</updated>
    <id>https://happy123.me/blog/2019/09/22/wu-en-da-ji-qi-xue-xi-bi-ji-5</id>
    <content type="html"><![CDATA[<p class="info">降维，异常检测，推荐系统，大规模机器学习</p>

<!-- more -->

<h2 id="section">数据压缩</h2>

<h4 id="section-1">降维问题</h4>

<p>假设我们未知两个的特征： 𝑥1 :长度, 用厘米表示； 𝑥2：是用英寸表示同一物体的长度。</p>

<p>这给了我们高度冗余表示，也许不是两个分开的特征  𝑥1  和  𝑥2 ，这两个基本的长度度量，我们可以减少数据到一维。</p>

<p>假使我们有有关于许多不同国家的数据，每一个特征向量都有 50 个特征（如，GDP，人均GDP，平均寿命等）。如果要将这个 50 维的数据可视化是不可能的。使用降维的方法将其降至 2 维，我们便可以将其可视化了。</p>

<h4 id="pca-">PCA 降维算法</h4>

<p>在 PCA 中，我们要做的是找到一个方向向量（Vector direction），
当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。
方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。</p>

<p>主成分分析与线性回归是两种不同的算法。
主成分分析最小化的是投射误差（Projected Error），而线性回归尝试的是最小化预测误差。
线性回归的目的是预测结果，而主成分分析不作任何预测。</p>

<p>过程：</p>

<ol>
  <li>均值归一化 (mean normalization)。计算出所有特征的均值，然后令 𝑥𝑗=𝑥𝑗−𝜇𝑗 。如果特征是在不同的数量级上，我们还需要将其除以标准差  𝜎2 。</li>
  <li>计算协方差矩阵（covariance matrix）Σ：</li>
  <li>是计算协方差矩阵 Σ 的特征向量（eigenvectors）: 可以利用奇异值分解（singular value decomposition 理解 SVD）来求解，[U, S, V]= svd(Σ)。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">
</span><span class="line">def covariance_matrix(X):
</span><span class="line">    """
</span><span class="line">    Args:
</span><span class="line">        X (ndarray) (m, n)
</span><span class="line">    Return:
</span><span class="line">        cov_mat (ndarray) (n, n):
</span><span class="line">            covariance matrix of X
</span><span class="line">    """
</span><span class="line">    m = X.shape[0]
</span><span class="line">
</span><span class="line">    return (X.T @ X) / m
</span><span class="line">
</span><span class="line">
</span><span class="line">def normalize(X):
</span><span class="line">    """
</span><span class="line">        for each column, X-mean / std
</span><span class="line">    """
</span><span class="line">    X_copy = X.copy()
</span><span class="line">    m, n = X_copy.shape
</span><span class="line">
</span><span class="line">    for col in range(n):
</span><span class="line">        X_copy[:, col] = (X_copy[:, col] - X_copy[:, col].mean()) / X_copy[:, col].std()
</span><span class="line">
</span><span class="line">    return X_copy
</span><span class="line">
</span><span class="line">def pca(x, keep_dims=None):
</span><span class="line">    if not keep_dims:
</span><span class="line">        keep_dims = x.shape[1] - 1
</span><span class="line">    # 进行归一化
</span><span class="line">    normalize_x = normalize(x)
</span><span class="line">    # 求出协方差矩阵
</span><span class="line">    cov_x = covariance_matrix(x)
</span><span class="line">    # 奇异值分解
</span><span class="line">    U, S, V = np.linalg.svd(cov_x)  # U: principle components (n, n)
</span><span class="line">    # 选取前 keep_dims 维特征
</span><span class="line">    reduction = U[:, :keep_dims]
</span><span class="line">    # 得到降维的结果
</span><span class="line">    return np.matmul(x, reduction)
</span><span class="line">
</span><span class="line">x = np.random.uniform(size=(10, 10))
</span><span class="line">pca(x).shape</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">异常检测</h2>

<p>用途:</p>

<ol>
  <li>
    <p>识别欺骗。特征：用户多久登录一次，访问过的页面，在论坛发布的帖子数量，甚至是打字速度等。构建模型来识别那些不符合该模式的用户,</p>
  </li>
  <li>
    <p>数据中心。特征：内存使用情况，被访问的磁盘数量，CPU 的负载，网络的通信量等。构建模型来判断某些计算机是不是有可能出错了。</p>
  </li>
</ol>

<h4 id="section-3">高斯分布</h4>

<p>如果变量 𝑥 符合高斯分布 𝑥 𝑁(𝜇,𝜎2) , 则其概率密度函数为：</p>

<script type="math/tex; mode=display">
p(x,\mu, \sigma^2) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-\mu)^2}{2\sigma^2})
</script>

<h4 id="section-4">高斯分布的异常检测算法</h4>

<p>对于每一个样本值，计算特征，并以此估算高斯分布中的𝜇 和𝜎2的估计值;</p>

<p>以此来绘制一个估计函数，在这个估计函数之外的值即异常值；</p>

<p>模型计算  𝑝(𝑥) :</p>

<script type="math/tex; mode=display">
p(x)=\prod_{j=1}^n p(x_j;\mu_j,\sigma^2_j)=\prod_{j=1}^n \frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma^2_j})
</script>

<script type="math/tex; mode=display">
p(x)=\prod_{j=1}^n p(x_j;\mu_j,\sigma^2_j)=\prod_{j=1}^n \frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma^2_j})
</script>

<p>当  𝑝(𝑥)&lt;𝜀 时，为异常。</p>

<h4 id="section-5">开发和评价一个异常检测系统</h4>

<ol>
  <li>根据测试集数据，我们估计特征的平均值和方差并构建 𝑝(𝑥) 函数</li>
  <li>对交叉检验集，我们尝试使用不同的 𝜀 值作为阀值，并预测数据是否异常，根据F1值或者查准率与查全率的比例来选择 𝜀</li>
  <li>选出 𝜀 后，针对测试集进行预测，计算异常检验系统的 F1 值，或者查准率与查全率之比。</li>
</ol>

<h4 id="section-6">特征选择</h4>

<p>我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小），例如，在检测数据中心的计算机状况的例子中，我们可以用 CPU 负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。</p>

<h4 id="section-7">多元高斯分布</h4>

<p>TODO…</p>

<h2 id="section-8">推荐系统</h2>

<h4 id="section-9">协同过滤</h4>

<p>TODO….</p>

<h2 id="section-10">大规模机器学习</h2>

<h4 id="section-11">大型数据集的学习</h4>

<p>我们应该怎样应对一个有 100 万条记录的训练集？</p>

<p>以线性回归模型为例，每一次梯度下降迭代，我们都需要计算训练集的误差的平方和，如果我们的学习算法需要有 20 次迭代，这便已经是非常大的计算代价。</p>

<p>首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用 1000 个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。</p>

<h4 id="section-12">随机梯度下降</h4>

<p>随机梯度下降算法在每一次计算之后便更新参数 θ，而不需要首先将所有的训练集求和，在梯度下降算法还没有完成一次迭代时，随机梯度下降算法便已经走出了很远。但是这样的算法存在的问题是，不是每一步都是朝着”正确”的方向迈出的。因此算法虽然会逐渐走向全局最小值的位置，但是可能无法站到那个最小值的那一点，而是在最小值点附近徘徊。</p>

<h4 id="section-13">小批量梯度下降</h4>
<p>小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数 b 次训练实例，便更新一次参数 θ。</p>

<p>通常我们会令 b 在 2-100 之间。这样做的好处在于，我们可以用向量化的方式来循环 b 个训练实例，如果我们用的线性代数函数库比较好，能够支持平行处理，那么算法的总体表现将不受影响（与随机梯度下降相同）。</p>

<h4 id="map-reduce--">Map Reduce 和 数据并行</h4>

<p>Map Reduce和数据并行对于大规模机器学习问题而言是非常重要的概念。</p>

<p>之前提到，如果我们用批量梯度下降算法来求解大规模数据集的最优解，我们需要对整个训练集进行循环，计算偏导数和代价，再求和，计算代价非常大。如果我们能够将我们的数据集分配给多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计算的结果汇总然后再求和。这样的方法叫做Map Reduce。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-4]]></title>
    <link href="https://happy123.me/blog/2019/09/18/wu-en-da-ji-qi-xue-xi-bi-ji-4/"/>
    <updated>2019-09-18T16:59:17+08:00</updated>
    <id>https://happy123.me/blog/2019/09/18/wu-en-da-ji-qi-xue-xi-bi-ji-4</id>
    <content type="html"><![CDATA[<p class="info">机器学习系统设计思路，向量机，聚类</p>

<!-- more -->

<h2 id="section">机器学习系统设计</h2>

<h4 id="section-1">确定优先级</h4>

<ul>
  <li>如何设计一个垃圾邮件分类器算法?</li>
</ul>

<ol>
  <li>
    <p>首先，决定如何选择并表达特征向量x：可以选择一个由 100 个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否有在邮件中出现，来获得我们的特征向量（出现为 1，不出现为 0），尺寸为 100×1。</p>
  </li>
  <li>收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件的样本</li>
  <li>基于邮件的路由信息开发一系列复杂的特征</li>
  <li>基于邮件的正文信息开发一系列复杂的特征，包括考虑截词的处理</li>
  <li>为探测刻意的拼写错误（例如: 把 watch 写成 w4tch）开发复杂的算法</li>
</ol>

<h4 id="section-2">误差分析</h4>

<p>构建一个学习算法的推荐方法为：</p>

<ol>
  <li>从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法</li>
  <li>绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</li>
  <li>进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的实例，看看这些实例是否有某种系统化的趋势</li>
</ol>

<h4 id="section-3">不对称分类的误差</h4>

<p>偏斜类（skewed classes）问题，表现为训练集中有非常多的同一种类的实例，只有很少或没有其他类的实例。</p>

<ul>
  <li>
    <p>查准率（Precision） = TP/（TP+FP）。
例：肿瘤预测中，在所有预测有恶性肿瘤的病人中，实际上有恶性肿 瘤的病人的百分比，越高越好。</p>
  </li>
  <li>
    <p>查全率（Recall） = TP/（TP+FN）。
例：肿瘤预测中，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p>
  </li>
</ul>

<p>对于肿瘤预测来说, 查全率更重要</p>

<h4 id="section-4">精确率和召回率的权衡</h4>

<p>如果希望只在非常确信的情况下预测为真（肿瘤为恶性），即我们希望更高的查准率，我们可以使用比 0.5 更大的阀值，如 0.7，0.9。这样做我们会减少错误预测病人为恶性肿瘤的情况，同时却会增加未能成功预测肿瘤为恶性的情况。</p>

<p>如果我们希望提高查全率，尽可能地让所有有可能是恶性肿瘤的病人都得到进一步地检查、诊断，我们可以使用比 0.5 更小的阀值，如 0.3。</p>

<p>选择阈值的一种方法是是计算 F1 值（F1 Score），其计算公式为：</p>

<script type="math/tex; mode=display">
F_1Score = 2\frac{PR}{P+R}
</script>

<h4 id="section-5">机器学习数据</h4>

<p>关于机器学习数据与特征值的选取比较有效的检测方法：</p>

<ol>
  <li>
    <p>一个人类专家看到了特征值 x，能很有信心的预测出 y 值吗？因为这可以证明 y 可以根据特征值 x 被准确地预测出来。</p>
  </li>
  <li>
    <p>我们实际上能得到一组庞大的训练集，并且在这个训练集中训练一个有很多参数的学习算法吗？</p>
  </li>
</ol>

<h2 id="section-6">向量机</h2>

<h4 id="section-7">支持向量机</h4>

<p>简称 SVM，在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p>

<p>老实说，向量机没有理解；它是作为一种分类器来使用的，他画出来的分类线比线性回归和逻辑回归的偏差更小；简称大间距分类器，意思是分类线的到每一个样本点的距离，都保持最大间隔，这样就跟具有鲁棒性，分的就明显；</p>

<h4 id="section-8">核函数</h4>

<p>TODO，待理解</p>

<h2 id="section-9">非监督学习</h2>

<h4 id="k-means">K-Means算法</h4>

<p>K-均值是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。假设我们想要将数据聚类成 n 个组，其方法为:</p>

<ol>
  <li>选择 k 个随机的点，称为聚类中心（cluster centroids）；</li>
  <li>对于数据集中的每一个数据，按照距离 K个中心点的距离，将其与距离最近的中心点关联起来，与同一个中心点关联的所有点聚成一类；</li>
  <li>计算每一个组的平均值，将该组所关联的中心点移动到平均值的位置；</li>
  <li>重复步骤 2-4 直至中心点不再变化。</li>
</ol>

<h4 id="section-10">优化</h4>

<p>𝜇𝑐(𝑖) 代表与𝑥(𝑖) 最近的聚类中心点。优化目标便是找出使得代价函数最小的𝑐(1),𝑐(2),…𝑐(𝑚)和 𝜇1,𝜇2,…,𝜇𝑘。</p>

<ul>
  <li>K-均值迭代算法</li>
</ul>

<ol>
  <li>第一个循环(cluster assignment)是用于减小 𝑐(𝑖) 引起的代价</li>
  <li>第二个循环(move centroid)则是用于减小 𝜇𝑖 引起的代价。</li>
</ol>

<h4 id="section-11">随机初始化</h4>

<p>随机初始化所有的聚类中心点的做法：</p>

<ol>
  <li>我们应该选择 K &lt; m，即聚类中心点的个数要小于所有训练集实例的数量</li>
  <li>随机选择 K 个训练实例，然后令 K 个聚类中心分别与这 K 个训练实例相等</li>
</ol>

<h4 id="section-12">选择聚类数目</h4>

<p>改变 聚类数k 值，运行K-均值聚类方法，然后计算成本 函数或者计算畸变函数 J。</p>

<p>我们可能会得到一条这样像肘部的曲线，这就是“肘部法则”所做的。
这种模式下，它的畸变值会迅速下降，从 1 到 2，从 2 到 3 之后，你会在 3 的时候达到一个肘点。
在此之后，畸变值就下降的非常慢，我们就选这个转折点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-3]]></title>
    <link href="https://happy123.me/blog/2019/09/16/wu-en-da-ji-qi-xue-xi-bi-ji-3/"/>
    <updated>2019-09-16T16:55:56+08:00</updated>
    <id>https://happy123.me/blog/2019/09/16/wu-en-da-ji-qi-xue-xi-bi-ji-3</id>
    <content type="html"><![CDATA[<p class="info">神经网络学习, 反向传播算法， 模型优化</p>

<!-- more -->

<h2 id="section">神经网络学习</h2>

<h4 id="section-1">为什么需要神经网络</h4>

<p>普通的逻辑回归模型，不能有效地处理大量的特征，这时候我们需要神经网络。</p>

<h4 id="section-2">神经元和大脑</h4>

<p>大脑是个通用处理机，同样的一部分大脑区域，可以处理声音、视觉、味觉等多种信号；</p>

<p>从某种意义上来说，如果我们能找出大脑的学习算法，然后在计算机上执 行大脑学习算法或与之相似的算法，也许这将是我们向人工智能迈进做出的最好的尝试。人工智能的梦想就是：有一天能制造出真正的智能机器。</p>

<h4 id="section-3">模型表示</h4>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190916/bg1.jpg" alt="" /></p>

<p>第一层称为输入层（Input Layer），最后一 层称为输出层（Output Layer），中间一层称为隐藏层（Hidden Layers）。在神经网络中，参数又可被称为权重（weight）。我们为每一层都增加一个偏差单位（bias unit）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">
</span><span class="line">def sigmoid(x):
</span><span class="line">    return 1/(1+np.exp(-x))
</span><span class="line">
</span><span class="line">def net():
</span><span class="line">    # todo 确定输入和权重的维度
</span><span class="line">    X = np.array([[1],[-2],[3],[-4]])
</span><span class="line">    theta1 = np.random.uniform(size=(3, 4))
</span><span class="line">    hidden_input = sigmoid(np.matmul(theta1,X))
</span><span class="line">    print('hidden_input',hidden_input)
</span><span class="line">    hidden_input = np.insert(hidden_input, 0, [1], axis=0)
</span><span class="line">    print('hidden_input',hidden_input)
</span><span class="line">    theta2 = np.random.uniform(size=(1, 4))
</span><span class="line">    output = sigmoid(np.matmul( theta2,hidden_input))
</span><span class="line">    return output</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-4">模型的表示实例</h4>

<p>从本质上讲，神经网络能够通过学习得出其自身的一系列特征。</p>

<p>在普通的逻辑回归中，我们被限制为使用数据中的原始特征 𝑥0,𝑥1,𝑥2,𝑥3 我们虽然可以使用一些二项式项来组合这些特征，但是我们仍然受到这些原始特征的限制。</p>

<p>在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。</p>

<p>神经网络中，单层神经元（无中间层）的计算可用来表示逻辑运算，比如逻辑与（AND）、逻辑或（OR）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># 实现AND函数
</span><span class="line">import numpy as np
</span><span class="line">
</span><span class="line">def sigmoid(x):
</span><span class="line">    return 1/(1+np.exp(-x))
</span><span class="line">
</span><span class="line">class Net():
</span><span class="line">    def __init__(self,theta):
</span><span class="line">        self.theta=theta
</span><span class="line">    def run(self,X):   
</span><span class="line">        output = sigmoid(np.matmul(self.theta,X))
</span><span class="line">        return output
</span><span class="line">
</span><span class="line">net = Net(np.array([[-30,20,20]]))</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-5">多分类任务</h4>

<p>one-hot的基本思想：将离散型特征的每一种取值都看成一种状态，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。</p>

<p>如果分类问题有四个结果，
我们不会将y的取值为：0，1，2，3 而是会将y表示为一个1*4的向量</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">import tqdm
</span><span class="line">def onehot(x):
</span><span class="line">    unique_values = list(set(x))
</span><span class="line">    number_of_dimension = len(unique_values)
</span><span class="line">    onehot_features = np.zeros(shape=(len(x), number_of_dimension))
</span><span class="line">    for row in tqdm.tqdm(range(len(x))):
</span><span class="line">        onehot_features[row, unique_values.index(x[row])] = 1
</span><span class="line">    return onehot_features</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-6">反向传播算法</h2>

<h4 id="section-7">代价函数</h4>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/20190916/bg2.jpg" alt="" /></p>

<p>通过代价函数来观察算法预测的结果与真实情况的误差有多大，与逻辑回归唯一不同的是，对于每一行特征，我们都会给出 K 个预测，基本上我们可以利用循环，对每一行特征都预测 K 个不同结果，然后在利用循环
在 K 个预测中选择可能性最高的一个，将其与 y 中的实际数据进行比较。 </p>

<h4 id="section-8">反向传播</h4>

<p>计算神经网络预测结果的时候我们采用了一种正向传播方法，我们从第一层开始正向一层一层进行计算，直到最后一层的 ℎ𝜃(𝑥) </p>

<p>计算代价函数的偏导数，我们需要采用一种反向传播算法，也就是首先计算最后一层的误差，然后再一层一层反向求出各层的误差，直到倒数第二层。</p>

<p>老实说，反向传播的原理推导一直没搞明白，留一个通俗版先不求甚解：</p>

<p>https://www.jefkine.com/general/2016/09/05/backpropagation-in-convolutional-neural-networks/</p>

<p>最后，反向传播是为了提升神经网络学习模型中梯度下降的训练速度；是一种快速计算导数的方法；</p>

<h4 id="section-9">梯度校验</h4>

<p>名词跟梯度下降很相似，但是作用不一样；</p>

<p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。</p>

<p>为了避免这样的问题，我们采取一种叫做梯度的数值检验（Numerical Gradient Checking）的方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。</p>

<p>对梯度的估计采用的方法是在代价函数上沿着切线的方向选择离两个非常近的点然后计算两个点的平均值用以估计梯度。即对于某个特定的 𝜃 ，我们计算出在  𝜃−𝜎 处和 𝜃+𝜎 的代价值（ 𝜎 是一个非常小的值，通常选取 0.001），然后求两个代价的平均，用以估计在 𝜃 处的代价值。</p>

<p>当 𝜃 是一个向量时，我们则需要对偏导数进行检验。因为代价函数的偏导数检验只针对一个参数的改变进行检验，下面是一个只针对 𝜃1 进行检验的示例：</p>

<script type="math/tex; mode=display">
\frac{\partial}{\partial\theta_1} = \frac{J(\theta_1+\sigma_1,\theta_2,\theta_3,...,\theta_n)-J(\theta_1-\sigma_1,\theta_2,\theta_3,...,\theta_n)}{2\sigma}
</script>

<h4 id="section-10">随机初始化</h4>

<p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为 0，这样的 初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。</p>

<p>如果我们令所有的初始参数都为 0，这将意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非 0 的数，结果也是一样的。</p>

<p>我们通常初始参数为正负 ε 之间的随机值，假设我们要随机初始一个尺寸为 10×11 的参数矩阵，代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a= np.random.rand(10,11) # 机初始一个尺寸为 10×11 的参数矩阵
</span><span class="line">print(a)</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-11">小结:</h4>

<ol>
  <li>参数的随机初始化</li>
  <li>利用正向传播方法计算所有的 hθ(x)</li>
  <li>编写计算代价函数 J 的代码</li>
  <li>利用反向传播方法计算所有偏导数</li>
  <li>利用数值检验方法检验这些偏导数</li>
  <li>使用优化算法来最小化代价函数</li>
</ol>

<h2 id="section-12">神经网络优化</h2>

<p>当我们建立一个神经网络学习模型之后，如何检验他到底好不好用？ 如果不好用，该怎样优化？</p>

<h4 id="section-13">假设检验</h4>

<p>为了检验算法是否过拟合，我们将数据分成训练集和测试集，通常用70%的数据作为训练集，用剩下30%的数据作为测试集。</p>

<ul>
  <li>线性回归模型，我们利用测试数据集计算代价函数J ；</li>
</ul>

<script type="math/tex; mode=display">
J_{test}(\theta)=\frac{1}{2m_{test}}\sum^{m_{test}}_{i=1}({h_\theta(x^{(i)}_{test})-y^{(i)}_{test}})^2
</script>

<ul>
  <li>逻辑回归模型，我们可以利用测试数据集来计算代价函数：</li>
</ul>

<script type="math/tex; mode=display">
J_{test}(\theta)=-\frac{1}{m_{test}}\sum^{m_{test}}_{i=1}(y^{(i)}_{test}\log{h_\theta(x^{(i)}_{test})}+(1-y^{(i)}_{test}）\log{(1-h_\theta(x^{(i)}_{test}))})
</script>

<h4 id="section-14">模型选择与训练集</h4>

<p>显然越高次数的多项式模型越能够适应我们的训练数据集，但是适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用交叉验证集来帮助选择模型。</p>

<p>交叉验证集：训练集（train）用60%的数据，交叉验证集（validation）用20%的数据，测试集(test)用20%的数据</p>

<p>模型选择的方法为：</p>

<ol>
  <li>使用训练集训练出 10 个模型</li>
  <li>用 10 个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</li>
  <li>选取代价函数值最小的模型</li>
  <li>用步骤 3 中选出的模型对测试集计算得出推广误差（代价函数的值）</li>
</ol>

<h4 id="section-15">诊断偏差和方差</h4>

<p>诊断偏差或是方差，即判断欠拟合还是过拟合;</p>

<ul>
  <li>训练集误差和交叉验证集误差都很高时：高偏差(欠拟合)</li>
  <li>训练集误差很小, 且交叉验证集误差远大于训练集误差时：高方差(过拟合)</li>
</ul>

<h4 id="section-16">正则化，偏差和方差</h4>

<p>选择 𝜆 的方法为：</p>

<ol>
  <li>使用训练集训练出 12 个不同程度正则化的模型</li>
  <li>用 12 模型分别对交叉验证集计算的出交叉验证误差</li>
  <li>选择得出交叉验证误差最小的模型</li>
  <li>运用步骤 3 中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与 𝜆 的值绘制在一张图表上：</li>
</ol>

<ul>
  <li>当 𝜆 较小时，训练集误差较小（过拟合）而交叉验证集误差较大</li>
  <li>随着 𝜆 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</li>
</ul>

<h4 id="section-17">学习曲线</h4>

<p>学习曲线是将训练集误差和交叉验证集误差作为训练集实例数量（m）的函数绘制的图表。</p>

<p>思想是：当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据。</p>

<p>当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。</p>

<h4 id="section-18">小结</h4>

<ul>
  <li>获得更多的训练实例——解决高方差</li>
  <li>尝试减少特征的数量——解决高方差</li>
  <li>尝试获得更多的特征——解决高偏差</li>
  <li>尝试增加多项式特征——解决高偏差</li>
  <li>尝试减少正则化程度 λ——解决高偏差</li>
  <li>
    <p>尝试增加正则化程度 λ——解决高方差</p>
  </li>
  <li>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小</li>
  <li>使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paste Fails When Using Bracketed-paste-magic on zsh5.1.1]]></title>
    <link href="https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1/"/>
    <updated>2019-09-13T10:50:31+08:00</updated>
    <id>https://happy123.me/blog/2019/09/13/paste-fails-when-using-bracketed-paste-magic-on-zsh5-dot-1-1</id>
    <content type="html"><![CDATA[<p>突然碰到了zsh5.1.1的一个bug，粘贴中文的时候会把shell freeze；</p>

<p>不知道是不是on-my-zsh升级的时候搞坏的，一通搜索发现了这个:</p>

<p>https://github.com/zsh-users/zsh-autosuggestions/issues/102</p>

<p>没有升级zsh，我直接到配置文件里把那段自动转义的功能注释掉了，嗯，简单粗暴~~~这东西我也不想天天升级；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~/.oh-my-zsh/lib/misc.zsh</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eltoo-闪电和离线契约更新机制]]></title>
    <link href="https://happy123.me/blog/2019/09/13/eltoo-shan-dian-he-chi-xian-qi-yue-geng-xin-ji-zhi/"/>
    <updated>2019-09-13T10:29:32+08:00</updated>
    <id>https://happy123.me/blog/2019/09/13/eltoo-shan-dian-he-chi-xian-qi-yue-geng-xin-ji-zhi</id>
    <content type="html"><![CDATA[<p class="info">在我们之前的文章中，对闪电网络的来龙去脉和原理做了详尽的分析；我们提出，相对于现在的传统支付技术，闪电网络技术有一个不可思议的跨越，用时髦一点的话来说，这是次世代的支付技术，假以时日，我相信它的未来不可限量；</p>

<p>闪电网络可以说是比特币二层网络技术的急先锋，它除了开拓比特币的支付愿景，还在很多层面对将来二层网络的发展提出了很多基础协议功能；这一切目前都收集在闪电网络基础技术规范，简称BOLT(Basis of Lightning Technology文档中；</p>

<p>https://github.com/lightningnetwork/lightning-rfc</p>

<!-- more -->

<p>仔细阅读BOLT就会发现，闪电网络并不是一个单一的协议，它是一整套协议，并且许多部分都被设计为可替代的；最典型的就是支付通道的部分；</p>

<p>为了保证支付通道双方不作弊，需要给作弊方施加足够的惩罚威慑，目前的支付通道采用的惩罚机制称为 “L2-penalty”机制；这是是JosephPoon和Thaddeus Dryja在原版Lightning Network白皮书中发明的协议;因此也被称为<code>Poon-Dryja通道</code>;</p>

<p>除了这种实现，其实还有另外一种双向支付通道协议，称为[双工小额支付渠道（DMC）]，由Decker和Wattenhofer [2015年]发明。Christian Decker是Blockstream的开发人员，后来blockstream将这个协议进一步完善，发展为Eltoo规范，并在2018年提出；</p>

<p>Eltoo简化了惩罚机制，效率更高，不仅能用于支付渠道当中，还有一个更广泛的应用，打开人任意多方(&lt;7)在二层网络上实现智能合约的可能性；</p>

<p>这个原理讲起来脑洞很大，我读它的论文的时候又一次感叹: 还有这种操作？</p>

<p>看来比特币社区的技术发展已经远远走到了时代的前面，你不能说比特币的技术是老旧的，以目前的发展来看，比特币的底层架构之稳健，足够支持更多的未来黑科技运行在上面；</p>

<p>…….TODO 需要填坑</p>

<p>Eltoo的实施需要一个软分叉，需要现有的比特币主网支持名为<code>SIGHASH_NOINPUT</code>的操作符，结合Schnorr 签名技术，将来会实现许多非常有意思的功能；</p>

<p>最后再强调一遍，闪电网络不仅仅是一个支付的技术，他为比特币二层网络的各种应用构建提供了基础，相信在未来，会出现很多神奇的应用，有多神奇我无法想象；但这个技术绝不是一时的噱头，现在种种迹象表明，它会为比特币开启下一个十年；</p>

<p>引用资料:</p>

<p>https://blockstream.com/2018/04/30/en-eltoo-next-lightning/</p>

<p>https://blockstream.com/eltoo.pdf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-2]]></title>
    <link href="https://happy123.me/blog/2019/09/11/wu-en-da-ji-qi-xue-xi-2/"/>
    <updated>2019-09-11T10:53:38+08:00</updated>
    <id>https://happy123.me/blog/2019/09/11/wu-en-da-ji-qi-xue-xi-2</id>
    <content type="html"><![CDATA[<p class="info">Logistic回归， 正则化</p>

<!-- more -->

<h2 id="logistic">1-Logistic回归</h2>

<h4 id="section">分类</h4>

<p>逻辑回归 (Logistic Regression)是分类问题的一个代表算法，这是目前最流行使用最广泛的一种学习算法。</p>

<p>我们将因变量(dependant variable)可能属于的两个类分别称为负向类（negative class）和 正向类（positive class），则因变量  𝑦∈0,1 ，其中 0 表示负向类，1 表示正向类。</p>

<p>分类问题下，可以采用逻辑回归的分类算法，这个算法的性质是：它的输出值永远在 0 到 1 之间。 它适用于标签 y 取值离散的情况，如：1 0 0 1。</p>

<h4 id="section-1">假设陈述</h4>

<p>分类问题，希望分类器的输出值在 0 和 1 之间，因此，假设函数需要满足预测值要在 0 和 1 之间。</p>

<p>回归模型的假设是：</p>

<script type="math/tex; mode=display">
h_\theta(x)=g(\theta^TX)
</script>

<p>其中：</p>

<ul>
  <li>
    <p>X 代表特征向量</p>
  </li>
  <li>
    <p>g 代表逻辑函数（logistic function）, 是一个常用的逻辑函数为 S形函数（Sigmoid function），公式为：</p>
  </li>
</ul>

<script type="math/tex; mode=display">
g(z) = \frac{1}{1+e^{-z}}
</script>

<ul>
  <li>python 代码实现sigmoid函数：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">def sigmoid(z):
</span><span class="line">    return 1 / (1 + np.exp(-z))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>结合起来，获得逻辑回归的假设：</p>

<script type="math/tex; mode=display">
h_\theta(x) =  \frac{1}{1+e^{-\theta^TX}}
</script>

<table>
  <tbody>
    <tr>
      <td>𝜃(𝑥) 的作用是，对于给定的输入变量，根据选择的参数计算输出变量为1 的可能性 （estimated probablity），即  ℎ𝜃(𝑥)=𝑃(𝑦=1</td>
      <td>𝑥;𝜃) 。</td>
    </tr>
  </tbody>
</table>

<h4 id="section-2">代价函数</h4>

<p>逻辑回归的代价函数为：</p>

<script type="math/tex; mode=display">
J(\theta)= \frac{1}{m}\sum^m_{i=1}Cost(h_\theta(x^{(i)}), y^{(i)})
</script>

<p>其中:</p>

<script type="math/tex; mode=display">
Cost(h_\theta(x), y)=-y\times{log(h_\theta(x))}-(1-y)\times{log(1-h_\theta(x))}
</script>

<p>代入代价函数:</p>

<script type="math/tex; mode=display">
J(\theta) = -\frac{1}{m}\sum^m_{i=1}[y^{(i)}log(h_\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]
</script>

<ul>
  <li>逻辑回归代价函数的Python代码实现：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">def cost(theta, X, y):
</span><span class="line">    theta = np.matrix(theta)
</span><span class="line">    X = np.matrix(X)
</span><span class="line">    y = np.matrix(y)
</span><span class="line">    first = np.multiply(-y, np.log(sigmoid(X * theta.T)))
</span><span class="line">    second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T)))
</span><span class="line">    return np.sum(first - second) / (len(X))</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-3">简化代价函数和梯度下降</h4>

<script type="math/tex; mode=display">
\theta_j := \theta_j - \alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j
</script>

<p>这个更新规则和之前用来做线性回归梯度下降的式子是一样的， 但是假设的定义发生了变化。即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p>

<h4 id="section-4">多分类任务 一对多</h4>

<p>邮件归类， 假如说你现在需要一个学习算法能自动地将邮件归类到不同的文件夹里，区分开来自工作的邮件、来自朋友的邮件、来自家人的邮件或者是有关兴趣爱好的邮件，那么，就有了一个四分类问题：其类别有四个，分别用 y=1、y=2、y=3、y=4 来代表。</p>

<p>多分类的关键就是构建多个逻辑分类函数；具体：</p>

<p>我们将多个类中的一个类标记为正向类（y=1），然后将其他所有类都标记为负向类，这个模型记作 ℎ(1)𝜃(𝑥)。接着，类似地第我们选择另一个类标记为 正向类（y=2），再将其它类都标记为负向类，将这个模型记作  ℎ(2)𝜃(𝑥) ,依此类推。 最后我们得到一系列的模型简记为：</p>

<script type="math/tex; mode=display">
h^{(i)_\theta(x)} = p(y=i|x;\theta)
</script>

<p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。 总之，我们已经把要做的做完了，现在要做的就是训练这个逻辑回归分类器： ℎ(𝑖)𝜃(𝑥) ， 其中 i对应每一个可能的y=i，最后，为了做出预测，我们给出输入一个新的 x 值做预测。我们要做的就是在我们三个分类器里面输入 x，然后我们选择一个让  ℎ(𝑖)𝜃(𝑥) 最大的 i，即</p>

<script type="math/tex; mode=display">
\max_ih^{(i)_\theta(x)}
</script>

<h2 id="section-5">2-正则化</h2>

<h4 id="section-6">过拟合问题</h4>

<p>就以多项式理解，x 的次数越高，拟合的越好，但相应的预测的能力就可能变差。</p>

<p>如何解决？</p>

<ul>
  <li>
    <p>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如 PCA, LDA），缺点是丢弃特征的同时，也丢弃了这些相应的信息；</p>
  </li>
  <li>
    <p>正则化。 保留所有的特征，但是减少参数的大小（magnitude），当我们有大量的特征，每个特征都对目标值有一点贡献的时候，比较有效。</p>
  </li>
  <li>
    <p>还有一个解决方式就是增加数据集,因为过拟合导致的原因就过度拟合测试数据集, 那么增加数据集就很大程度提高了泛化性了.</p>
  </li>
</ul>

<h4 id="section-7">代价函数</h4>

<p>正则化的基本方法：对高次项添加惩罚值，让高次项的系数接近于0。</p>

<p>假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：</p>

<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m} [ \sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2} + \lambda\sum_{j=1}^n\theta^2_j  ]
</script>

<p>其中 𝜆 又称为正则化参数（Regularization Parameter）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">def mseWithRegular(predict, y, w, lmd=0.1):
</span><span class="line">    '''
</span><span class="line">        predict: 模型输出
</span><span class="line">        y: 真实标签
</span><span class="line">        w: 模型权重
</span><span class="line">        lmd: 正则化参数
</span><span class="line">    '''
</span><span class="line">    constrct_loss = np.sum((predict - y) ** 2)
</span><span class="line">    experience_loss = lmd * np.sum(w ** 2)
</span><span class="line">    loss = (constrct_loss + experience_loss) / (2 * len(predict))
</span><span class="line">    return loss
</span><span class="line">
</span><span class="line">predict = np.array([1, 1.5, 2])
</span><span class="line">y = np.array([0.9, 1.4, 2.1])
</span><span class="line">w = np.array([[1], [1], [1]])
</span><span class="line">mseWithRegular(predict, y, w)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果选择的正则化参数 𝜆 过大，则会把所有的参数都最小化了，导致模型变成  ℎ𝜃(𝑥)=𝜃0 ，造成欠拟合。</p>

<p>所以对于正则化，我们要取一个合理的λ的值，这样才能更好的应用正则化。</p>

<h4 id="section-8">线性回归正则化</h4>
<p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程</p>

<p>正则化线性回归的代价函数为：</p>

<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m} [ \sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2} + \lambda\sum_{j=1}^n\theta^2_j ]
</script>

<ul>
  <li>梯度下降使代价函数最小化</li>
</ul>

<script type="math/tex; mode=display">
\theta_j := \theta_j (1-a\frac{\lambda}{m})- \alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j
</script>

<ul>
  <li>正规方程来求解正则化线性回归模型</li>
</ul>

<p>TODO: 暂时没有理解</p>

<h4 id="section-9">逻辑回归正则化</h4>

<p>针对逻辑回归问题，我们在之前的课程已经学习过两种优化算法：梯度下降法，更高级的优化算法需要你自己设计代价函数 𝐽(𝜃) 。</p>

<p>给代价函数增加一个正则化的表达式，得到代价函数:</p>

<script type="math/tex; mode=display">
J(\theta) = \frac{1}{m}\sum^m_{i=1}[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)}log(1-h_\theta(x^{(i)}))]+\frac{\lambda}{2m}\sum_{j=1}^n\theta^2_j
</script>

<p>代码实现:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">def sigmoid(x, derivative=False):
</span><span class="line">    sigm = 1. / (1. + np.exp(-x))
</span><span class="line">    if derivative:
</span><span class="line">        return sigm * (1. - sigm)
</span><span class="line">    return sigm
</span><span class="line">
</span><span class="line">def costReg(theta, X, y, learningRate):
</span><span class="line">    theta = np.matrix(theta)
</span><span class="line">    X = np.matrix(X)
</span><span class="line">    y = np.matrix(y)
</span><span class="line">    first = np.multiply(-y, np.log(sigmoid(X * theta.T)))
</span><span class="line">    second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T)))
</span><span class="line">    reg = (learningRate / 2 * len(X)) * np.sum(np.power(theta[:,1:theta.shape[1]], 2))
</span><span class="line">    return np.sum(first - second) / (len(X)) + reg</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后，它的梯度下降看上去同正则化的线性回归一样，但是由于假设ℎ𝜃(𝑥)=𝑔(𝜃𝑇𝑋) ，所以与线性回归不同。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicode String Parse With Python and Fileinput]]></title>
    <link href="https://happy123.me/blog/2019/09/06/unicode-string-parse-with-python-and-fileinput/"/>
    <updated>2019-09-06T11:41:03+08:00</updated>
    <id>https://happy123.me/blog/2019/09/06/unicode-string-parse-with-python-and-fileinput</id>
    <content type="html"><![CDATA[<p>用fileinput模块parse数据很方便:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import fileinput
</span><span class="line">
</span><span class="line">if __name__ == '__main__':
</span><span class="line">    for line in fileinput.input():
</span><span class="line">        sys.stdout.write(line)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但有时候会碰到UnicodeDecodeError:</p>

<p>比如执行:</p>

<!-- more -->

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">echo -e "foo\x80bar" |python3 testinput.py
</span><span class="line">
</span><span class="line">...
</span><span class="line">UnicodeDecodeError: 'utf8' codec can't decode byte 0x80 in position 3: invalid start byte</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这种错误还不好用<code>try .. catch</code>忽略掉，因为它是在fileinput模块中自己parse的；</p>

<p>Python2的时候很罗嗦，需要自己用codecs去判断之后，才能parse;</p>

<p>Python3总算是引入了一个openhook参数，可以自己hook处理了；</p>

<p>最简单的处理方式:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import fileinput
</span><span class="line">import io
</span><span class="line">import sys
</span><span class="line">
</span><span class="line">if __name__ == '__main__':
</span><span class="line">    sys.stdin = io.TextIOWrapper(sys.stdin.buffer, errors='replace')
</span><span class="line">    for line in fileinput.input(openhook=fileinput.hook_encoded("utf-8")):
</span><span class="line">        sys.stdout.write(line)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>参考:</p>

<p>https://stackoverflow.com/questions/24754861/unicode-file-with-python-and-fileinput</p>

<p>https://bugs.python.org/issue26756</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[吴恩达机器学习笔记-1]]></title>
    <link href="https://happy123.me/blog/2019/09/01/wu-en-da-ji-qi-xue-xi-bi-ji/"/>
    <updated>2019-09-01T15:59:41+08:00</updated>
    <id>https://happy123.me/blog/2019/09/01/wu-en-da-ji-qi-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p class="info">这个系列教程大名鼎鼎，之前我都是用到啥就瞎试一通；最近花了两个周，认认真真把这些基础知识重新学了一遍；做个笔记；
苏老泉二十七始发愤，我这比他还落后；不过求知的旅途，上路永远不嫌晚，我一直在路上；</p>

<!-- more -->

<h2 id="supervised-learning">1-监督学习（Supervised Learning)</h2>

<p>根据训练数据是否拥有标记信息，学习任务可大致被分为两类：</p>

<ul>
  <li>
    <p>监督学习（Supervised Learning）监督学习的代表是回归和分类。</p>

    <ul>
      <li>回归:预测连续值的模型: 已知房子大小和房价数据集，预测某一房子的价格</li>
      <li>分类:预测离散值的模型: 已知肿瘤性质和大小数据集，预测肿瘤是否良性</li>
    </ul>
  </li>
  <li>
    <p>无监督学习（Unsupervised Learning） 无监督学习的代表是聚类。</p>
  </li>
</ul>

<h2 id="section">2-单变量线性回归</h2>

<h4 id="section-1">模型表示</h4>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta_{0} + \theta_{1}x
</script>

<h4 id="section-2">代价函数</h4>

<p>求两个值，使模型最为匹配当前数据集；求解匹配度的过程提炼出代价函数；代价函数值越小，匹配度越高</p>

<script type="math/tex; mode=display">
J(\theta_{0}, \theta_{1}) = \frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2}
</script>

<p>当𝜃1=0时，代价函数为一抛物线；
当𝜃0，𝜃1都不为0时，代价函数为一三维曲面；</p>

<h4 id="section-3">自动求解代价函数</h4>

<p>我们我们有函数  𝐽(𝜃0,𝜃1) , 可以不断的调整  𝜃0  和  𝜃1 , 来使得  𝐽(𝜃0,𝜃1)  , 直到  𝐽(𝜃0,𝜃1)  达到最小值为止</p>

<p>梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数 𝐽(𝜃0,𝜃1) 的最小值。</p>

<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合 (𝜃0,𝜃1,……,𝜃𝑛)  ，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到抵达一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。</p>

<p>帅气的梯度下降算法公式:</p>

<script type="math/tex; mode=display">
\theta_{j} := \theta_{j} - \alpha\frac{\partial}{\partial{\theta_{j}}}J(\theta)
</script>

<p>对 𝜃 赋值，使得  𝐽(𝜃) 按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中 𝛼 是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p>

<ul>
  <li>如果 𝛼 太小了，即我的学习速率太小，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</li>
  <li>如果 𝛼 太大，那么梯度下降法可能会越过最低点，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，最终会导致无法收敛，甚至发散。</li>
</ul>

<h2 id="section-4">3-矩阵和向量</h2>

<h4 id="x2">一个2X2矩阵</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a=np.array([[1, 2], [3, 4]])
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-5">向量是列数为1的特殊矩阵:</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b = np.array(np.zeros((3,1)))
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-6">矩阵的加法</h4>

<p>行列数相等的才可以做加法，两个矩阵相加就是行列对应的元素相加。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a = np.mat([[1,0],[2,5],[3,1]])
</span><span class="line">b = np.mat([[4,0.5],[2,5],[0,1]])
</span><span class="line">print ("a: \n",a, "\nb: \n",b)
</span><span class="line">print ("a+b: \n",a+b)  # a + b，矩阵相加
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-7">矩阵的标量乘法</h4>

<p>矩阵和标量的乘法也很简单,就是矩阵的每个元素都与标量相乘。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">print ("a: \n",a)
</span><span class="line">print ("3*a: \n",3* a)  #矩阵标量乘法
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-8">向量乘法</h4>
<p>m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">a = np.mat([[-1,2],[2,3]])
</span><span class="line">c = np.mat([[3],[4]])
</span><span class="line">ac = a * c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-9">矩阵乘法的性质</h4>
<ul>
  <li>矩阵的乘法不满足交换律： 𝐴×𝐵≠𝐵×𝐴</li>
  <li>矩阵的乘法满足结合律。即： 𝐴×（𝐵×𝐶）=（𝐴×𝐵）×𝐶</li>
  <li>在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，本讲义都用 I 代表单位矩阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0。</li>
</ul>

<h4 id="section-10">逆矩阵</h4>

<p>矩阵 A 是一个 m×m 矩阵（方阵），如果有逆矩阵，则：𝐴𝐴−1=𝐴−1𝐴=𝐼</p>

<p>没有逆矩阵的矩阵, 称为奇异 (singlar/degenerate)矩阵</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import numpy as np
</span><span class="line">
</span><span class="line">a = np.mat([[1,2],[3,4]])
</span><span class="line">print ('a:\n',a)
</span><span class="line">res = np.linalg.inv(a)
</span><span class="line">print('a inverse:\n', res)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>备注: 再octave中，可以用pinv函数(伪逆矩阵)对奇异矩阵求逆；</p>

<h4 id="section-11">矩阵转置</h4>

<p>设 A 为 m×n 阶矩阵（即 m 行 n 列），第 i 行 j 列的元素是 a(i,j)，即：A=a(i,j) 定义 A 的转置为这样一个 n×m 阶矩阵 B，满足 B=a(j,i)，即 b (i,j)=a (j,i)（B 的第 i 行第 j 列元素是 A 的第 j 行第 i 列元素），记  𝐴𝑇=𝐵 。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">a = np.mat([[1,2],[3,4]])
</span><span class="line">print ('a:\n',a)
</span><span class="line">res = a.T
</span><span class="line">print('a transpose:\n', res)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-12">4-多变量线性回归</h2>

<ul>
  <li>引入多种特征后的假设h模型</li>
</ul>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta_{0} + \theta_{1}x_{1} + \theta_{2}x_{2} + ... + \theta_{n}x_{n}
</script>

<p>此时模型中的参数是一个 n+1 维的向量，任何一个训练实例也都是 n+1 维的向量，特征矩阵 X 的维度是 m*(n+1)。 因此公式可以简化为：</p>

<script type="math/tex; mode=display">
h_{\theta}(x) = \theta^TX
</script>

<h4 id="section-13">多变量梯度下降</h4>

<p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价 函数是所有建模误差的平方和，即：</p>

<script type="math/tex; mode=display">
J(\theta_{0}, \theta_{1}...\theta_{n}) = \frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^{2}
</script>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># 代价函数的python代码实现
</span><span class="line">def Cost(X, y, theta):
</span><span class="line">    inner = np.power(((X * theta.T) - y), 2)
</span><span class="line">    return np.sum(inner) / (2 * len(X))
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-14">梯度下降 - 特征缩放</h4>

<p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这可以帮助梯度下降算法更快地收敛。</p>

<p>解决的方法是尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。</p>

<p>最简单的方法是令：</p>

<script type="math/tex; mode=display">
x_n = \frac{x_n - \mu_n}{s_n}
</script>

<p>其中,  𝜇𝑛 是平均值， 𝑠𝑛 是标准差。</p>

<h4 id="section-15">梯度下降 - 学习率</h4>

<ul>
  <li>如果学习率 𝛼 过小，则达到收敛所需的迭代次数会非常高；</li>
  <li>如果学习率 𝛼 过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</li>
</ul>

<p>通常可以考虑尝试些学习率： 0.01，0.03，0.1，0.3，1，3，10; 3倍增长</p>

<h4 id="section-16">特征与多项式回归</h4>

<p>如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。因为幂运算很容易拉大特征之间尺度的差距</p>

<h4 id="section-17">正规方程</h4>

<p>假设我们的训练集特征矩阵为 X（包含了 𝑥0=1 ）并且我们的训练集结果为向量 y， 则利用正规方程解出向量</p>

<script type="math/tex; mode=display">
\theta = (X^TX)^{-1}X^Ty
</script>

<p>只要特征变量的数目并不大，标准方程是一个很好的计算参数 𝜃 的替代方法。具体地说，只要特征变量的数量小于一万，通常使用标准方程法，而不使用梯度下降法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理想中的比特币全节点实现]]></title>
    <link href="https://happy123.me/blog/2019/08/18/li-xiang-zhong-de-bi-te-bi-quan-jie-dian-shi-xian/"/>
    <updated>2019-08-18T15:59:29+08:00</updated>
    <id>https://happy123.me/blog/2019/08/18/li-xiang-zhong-de-bi-te-bi-quan-jie-dian-shi-xian</id>
    <content type="html"><![CDATA[<p>虽然比特币已经运行十年，各式各样的比特币全节点实现已经很多了，但是我觉得还是有必要再增添一员；</p>

<p>我理想中的比特币全节点实现是这样的:</p>

<ul>
  <li>他的核心是模块化可拆分的</li>
  <li>他的核心不包括挖矿和钱包，可以为这两个功能提供接口作为插件来实现，但是不要耦合到核心里面</li>
  <li>他要实现BIP-157和BIP-158，不能为了导入一个新私钥就重新扫描一遍区块链</li>
  <li>他要兼容Lightning，并实现其瞭望塔功能</li>
  <li>交易存储最好用merkle-patricia-tree来实现，如此一来像ElectrumX这样的服务节点就可以去掉了</li>
  <li>他必须原生支持所有的SPV钱包调用，并形成一个BIP规范</li>
  <li>他必须可以是纯SPV，可以是全Block，也可以从一个checkpoint之后只存储需要的block</li>
  <li>最后，他最好能运行在一台1Core 1G 1M的小VPS上面</li>
</ul>

<p>我好像真贪心呢^_^</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Flask RestAPI集成Swagger UI]]></title>
    <link href="https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui/"/>
    <updated>2019-08-18T15:38:02+08:00</updated>
    <id>https://happy123.me/blog/2019/08/18/wei-flask-restapiji-cheng-swagger-ui</id>
    <content type="html"><![CDATA[<p>花了半天时间，给<a href="https://github.com/brain-zhang/chainhorn">chainhorn</a>集成了Swagger;</p>

<p>虽然这种事情已经做过好几遍了，但是不读文档还是没辙；我把这种半吊子形容为“我认识人民币，但是画不出来…T_T”</p>

<p>还是老老实实流水账记一下吧:</p>

<!-- more -->

<h3 id="section">依赖组件</h3>

<ul>
  <li><a href="https://flask-restplus.readthedocs.io">flask-restplus</a></li>
</ul>

<p>restplus能让人很方便的通过几个decorator就可以集成很漂亮的restapi，它提供了api命名空间、Request和Response解析以及Swagger UI的集成</p>

<p>另外，flask-restplus的文档和例子写的非常简洁清晰，赞一个。</p>

<ul>
  <li><a href="https://flask-httpauth.readthedocs.io/en/latest/">flask-httpauth</a></li>
</ul>

<p>用来集成验证机制，支持基本的密码验证、Token验证；短小精悍，够用了</p>

<h3 id="section-1">起步</h3>

<p>引用官网的例子:</p>

<h4 id="api">构建api对象</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from flask import Flask
</span><span class="line">from flask_restplus import Api, Resource, fields
</span><span class="line">from werkzeug.contrib.fixers import ProxyFix
</span><span class="line">
</span><span class="line">app = Flask(__name__)
</span><span class="line">app.wsgi_app = ProxyFix(app.wsgi_app)
</span><span class="line">
</span><span class="line">api = Api(app, version='1.0', title='Chainhorn API',
</span><span class="line">    description='A simple ChainHorn API',
</span><span class="line">)
</span><span class="line">
</span><span class="line">ns = api.namespace('node', description='node operations')
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最重要的是构建了<code>api</code>对象，这样就可以为后面的资源增加url路由、参数解析同能；</p>

<p>下面紧跟着构建了一个<code>ns</code> –<code>namespace</code>对象，作用是为不同的资源，不同的url分组，这样最后反映到界面上好看一点；</p>

<h4 id="section-2">修饰</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ns.route('')
</span><span class="line">  class NodeGetInfo(Resource):
</span><span class="line">      @ns_node.doc('get node info')
</span><span class="line">      def get(self):
</span><span class="line">          '''get node info'''
</span><span class="line">          info = spv.getinfo()
</span><span class="line">          return {'nodeinfo': info}, 200
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最简单的，用<code>@ns.route('')</code>，就定义了根url， 然后后面的套路都是相似的，为资源实现get方法，就直接响应 http Get请求了；</p>

<h4 id="request">Request参数处理</h4>

<p>如果直接在url后面跟参数，那么很方便的用 <code>ns.param</code>定义一下即可:
下面这个函数就直接接受一个 <code>/broadcast/tx12345</code> 这样的tx12345作为参数<code>tx</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ns.route('/broadcast/&lt;string:tx&gt;')
</span><span class="line">  class WalletBroadcastTx(Resource):
</span><span class="line">      @ns.doc('broadcast raw tx')
</span><span class="line">      @ns.param('tx', 'The transaction hash identifier')
</span><span class="line">      def post(self, tx):
</span><span class="line">          '''broadcast raw tx'''
</span><span class="line">          sendrawtransaction(spv, tx)
</span><span class="line">          return {'broadcast': 'ok'}, 200
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果要放在FormData里面，可以用<code>ns.expect</code>来限制；它可以接受一个对象传入；比如上面的例子，要把<code>tx</code>字段放到POST请求的Form Data中，要这样做:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">TxModel = {'tx': fields.String(required=True, description='The hex tx')}
</span><span class="line">@ns.route('/broadcast')
</span><span class="line">  class WalletBroadcastTx(Resource):
</span><span class="line">      @ns.doc('broadcast raw tx')
</span><span class="line">      @ns.expect(TxModel, 200)
</span><span class="line">      def post(self, tx):
</span><span class="line">          '''broadcast raw tx'''
</span><span class="line">          sendrawtransaction(spv, api.payload['tx'])
</span><span class="line">          return {'broadcast': 'ok'}, 200
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="response">Response参数处理</h4>

<p>同样的，如果需要返回一个对象，在界面上出现这个对象的详细描述信息，可以用<code>marshal_with</code>和<code>marshal_list_with</code>来修饰；</p>

<p>具体请参考:</p>

<p>https://flask-restplus.readthedocs.io/en/stable/parsing.html</p>

<h4 id="section-3">用户验证</h4>

<p>例如，为API加上HTTP Token Auth，要用到<code>HTTPTokenAuth</code>对象；</p>

<p>首先我们先定义验证规则:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">auth = HTTPTokenAuth()
</span><span class="line">tokens = {
</span><span class="line">  'APIKEY':'hello',
</span><span class="line">  "APPID": "chainhorn"
</span><span class="line">}
</span><span class="line">
</span><span class="line">@auth.verify_token
</span><span class="line">def verify_token(token):
</span><span class="line">  if request.headers.get('APIKEY', '').strip()==tokens['APIKEY'] and \
</span><span class="line">     request.headers.get('APPID', '').strip() == tokens['APPID']:
</span><span class="line">      return True
</span><span class="line">  else:
</span><span class="line">      return False
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后在每个url 请求处理函数前面加上修饰符<code>auth_login_required</code>；比如我们最开始的例子:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ns.route('')
</span><span class="line">class NodeGetInfo(Resource):
</span><span class="line">  @ns.doc('get node info')
</span><span class="line">  @auth.login_required
</span><span class="line">  def get(self):
</span><span class="line">      '''get node info'''
</span><span class="line">      info = spv.getinfo()
</span><span class="line">      return {'nodeinfo': info}, 200
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样后台验证就有了；那么前台输入呢？</p>

<p>这个例子里面，我们需要前台输入的时候在HTTP Header里面传入两个Key: APIKEY和APPKEY；直接用用Swagger UI自带的组件实现就可以了，把api对象构造为:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">AUTHORIZATIONS = {
</span><span class="line">    'apikey': {
</span><span class="line">        'type': 'apiKey',
</span><span class="line">        'in': 'header',
</span><span class="line">        'name': 'APIKEY'
</span><span class="line">    },
</span><span class="line">    'appid': {
</span><span class="line">        'type': 'apiKey',
</span><span class="line">        'in': 'header',
</span><span class="line">        'name': 'APPID'
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">api = Api(app,
</span><span class="line">        version='v1',
</span><span class="line">        authorizations=AUTHORIZATIONS,
</span><span class="line">        security=list(AUTHORIZATIONS.keys()),
</span><span class="line">        title='Chainhorn API',
</span><span class="line">        description='Chainhorn API',
</span><span class="line">)
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样默认所有的API访问都需要 在HTTP Header中传入两个Key: APIKEY和APPKEY，如果值不对的话就会访问失败；</p>

<p>此时前台的界面是这样的:</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/201908/bg3.jpg" alt="Auth1" /></p>

<p>可以点击右上角的Authorize一次性设置所有API的访问密钥；</p>

<p><img src="https://raw.githubusercontent.com/brain-zhang/memoryboxes.github.io/source/images/201908/bg4.jpg" alt="Auth2" /></p>

<p>也可以在每个API的右上角设置访问密钥；</p>

<p>当然，我们目前的密钥是后台写死的，你可以引入一个三方库为每个用户生成不同的密钥存到数据库里面，然后每次验证~~~</p>

<h3 id="section-4">综合例子</h3>

<p>最后，在github上面有个集大成的例子,值得推荐</p>

<p>https://github.com/frol/flask-restplus-server-example</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using a GPG Key and Ssh Auth]]></title>
    <link href="https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth/"/>
    <updated>2019-08-16T16:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/16/using-a-gpg-key-and-ssh-auth</id>
    <content type="html"><![CDATA[<p>在我的一台服务器被数不清的脚本小子暴力尝试登陆N次后，我下定决心将所有的开发环境换成统一的ssh key；并禁止用户登陆；</p>

<p>其中最折腾的部分就是使用我的GPG Key统一所有的ssh 环境；我也很纳闷，为什么自己没有早点搞定这些事情；</p>

<p>众所周知，GPG和Openssl的key是不兼容的，所以统一环境还是花了不少时间，主要是参考了这篇文章：</p>

<p>https://ryanlue.com/posts/2017-06-29-gpg-for-ssh-auth</p>

<p>常用命令:
<!-- more --></p>

<h3 id="gpg">GPG</h3>

<ul>
  <li>生成证书</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --gen-key
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>生成撤销证书</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --gen-revoke [用户ID]
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>列出所有密钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --list-keys
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>输出</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/home/brain/.gnupg/pubring.gpg
</span><span class="line">-------------------------------
</span><span class="line">pub   4096R/xxxxxxxx 2018-08-16
</span><span class="line">uid                  brain.zhang (happy123.me) &lt;brain.zhangbin#xxx.com&gt;
</span><span class="line">sub   4096R/yyyyyyyy 2018-08-16
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示subkey。</p>

<ul>
  <li>输出密钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --armor --output public-key.txt --export [用户ID]
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>输出密钥时转换私钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --armor --output private-key.txt --export-secret-keys
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>上传公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --keyserver keys.gnupg.net --send-keys [pub key ID] 
</span><span class="line">...
</span><span class="line">gpg --keyserver keys.gnupg.net --search-keys brain.zhang
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>生成公钥指纹供别人检查</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --fingerprint [用户ID]
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>加密文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>解密文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --decrypt demo.en.txt --output demo.de.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>对文件签名</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --clearsign demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>获得单独的签名文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --armor --detach-sign demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>验证签名</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --verify demo.txt.asc demo.txt
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section">导入第三方公钥</h3>

<ul>
  <li>获得公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --keyserver keys.gnupg.net --search-keys &lt;user ID&gt;
</span><span class="line">...
</span><span class="line">gpg --keyserver hkp://subkeys.pgp.net --search-keys brain.zhang
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>验证公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> gpg --edit-key &lt;key ID&gt;
</span><span class="line">
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入quit 退出。</p>

<h3 id="githubgpg">在Github中使用GPG</h3>

<ul>
  <li>输出key id</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gpg --list-secret-keys --keyid-format LONG
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>设置提交</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> git config  user.signingkey &lt;key ID&gt;
</span><span class="line">
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>对单次提交进行签名： </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git commit -S -m "-S选项表示对此次提交使用gpg进行签名"
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>签名标签</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git tag -s &lt;tag&gt;
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="ssh-server-gen">ssh server gen</h3>

<ul>
  <li>制作密钥对</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[root@host ~]$ ssh-keygen 
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>把生成的/root/.ssh/id_rsa.pub拷贝到在服务器上，安装公钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[root@host ~]$ cd .ssh
</span><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys
</span><span class="line">[root@host .ssh]$ chmod 600 authorized_keys
</span><span class="line">[root@host .ssh]$ chmod 700 ~/.ssh
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>设置 SSHD，打开密钥登录功能
编辑 /etc/ssh/sshd_config 文件，进行如下设置：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PubkeyAuthentication yes
</span><span class="line">PermitRootLogin yes
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</li>
</ul>

<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>

<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>

<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>

<ul>
  <li>验证无误，关闭密码登陆</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PasswordAuthentication no
</span><span class="line">[root@host .ssh]$ service sshd restart
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Requests Post for 5 Styles]]></title>
    <link href="https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles/"/>
    <updated>2019-08-09T09:13:32+08:00</updated>
    <id>https://happy123.me/blog/2019/08/09/python-requests-post-for-5-styles</id>
    <content type="html"><![CDATA[<h4 id="requestspost">requests库发送post请求的五种姿势;</h4>

<!-- more -->

<h4 id="applicationx-www-form-urlencoded">1.application/x-www-form-urlencoded</h4>

<p>最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。请求类似于下面这样:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST http://www.example.com HTTP/1.1    Content-Type:
</span><span class="line">application/x-www-form-urlencoded;charset=utf-8
</span><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>requests默认处理就是这种方式， exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">url = 'http://httpbin.org/post'
</span><span class="line">d = {'key1': 'value1', 'key2': 'value2'}
</span><span class="line">r = requests.post(url, data=d)
</span><span class="line">print r.text
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="multipartform-data">2.multipart/form-data</h4>

<p>除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。
这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值:</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from requests_toolbelt import MultipartEncoder
</span><span class="line">import requests
</span><span class="line">
</span><span class="line">m = MultipartEncoder(
</span><span class="line">    fields={'field0': 'value', 'field1': 'value',
</span><span class="line">            'field2': ('filename', open('file.py', 'rb'), 'text/plain')}
</span><span class="line">    )
</span><span class="line">
</span><span class="line">r = requests.post('http://httpbin.org/post', data=m,
</span><span class="line">                  headers={'Content-Type': m.content_type})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="applicationjson">3.application/json</h4>

<p>application/json 这个 Content-Type作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">url = 'http://httpbin.org/post'
</span><span class="line">s = json.dumps({'key1': 'value1', 'key2': 'value2'})
</span><span class="line">r = requests.post(url, data=s)
</span><span class="line">print r.text
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',data=json.dumps({'key1':'value1','key2':'value2'}),headers={'Content-Type':'application/json'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',json=key1,headers={'Content-Type':'application/json'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="textxml">4. text/xml</h4>
<p>跟json类似，XML 作为编码方式的远程调用规范。</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',data='&lt;?xml  ?&gt;',headers={'Content-Type':'text/xml'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="binary">5. binary</h4>

<p>直接二进制流数据传输，多用于上传图片</p>

<p>requests exp:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">requests.post(url='',files={'file':open('test.xls','rb')},headers={'Content-Type':'binary'})
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">url = 'http://httpbin.org/post'
</span><span class="line">files = {'file': open('report.txt', 'rb')}
</span><span class="line">r = requests.post(url, files=files)
</span><span class="line">print r.text
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSL&TLS Tips]]></title>
    <link href="https://happy123.me/blog/2019/08/04/ssl-tls-tips/"/>
    <updated>2019-08-04T09:35:42+08:00</updated>
    <id>https://happy123.me/blog/2019/08/04/ssl-tls-tips</id>
    <content type="html"><![CDATA[<p>每天的日常编码工作：就是解决一个问题的时候再创造另外一个问题 Orz…..</p>

<p>话说刚才生成一个私钥的时候， Python3绑定libssl1.1 又崩了；正在痛苦思考中~~~</p>

<!-- more -->

<p>现在有两个选择:</p>

<ol>
  <li>放弃ssl动态库调用，反正我只用ECDSA，所以找个原生库来用好啦</li>
  <li>死磕openssl，把它彻底搞明白</li>
</ol>

<p>利弊权衡之下我选择了1，不过当然我也在2上花了一点时间，复习了一下基础知识，在此记录下来。</p>

<h3 id="libssl3">libssl3是个什么东东</h3>

<p>在探究libssl.so的时候，我无意发现我的系统里面还有一个libssl3.so；这个是什么东东？我印象里面openssl还只有1.x版本才对；</p>

<p>我在ubuntu16.04下查看这个so文件来源;</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ locate libssl3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libssl3.so
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>nm看一下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ nm /usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">nm: /usr/lib/x86_64-linux-gnu/libssl3.so: no symbols
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>奇怪，没有任何符号；继续用ldd看一下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ ldd /usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">ldd /usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffe833bb000)
</span><span class="line">        libnss3.so =&gt; /usr/lib/x86_64-linux-gnu/libnss3.so (0x00007faf3cc8a000)
</span><span class="line">        libnssutil3.so =&gt; /usr/lib/x86_64-linux-gnu/libnssutil3.so (0x00007faf3ca5d000)
</span><span class="line">        libplc4.so =&gt; /usr/lib/x86_64-linux-gnu/libplc4.so (0x00007faf3c858000)
</span><span class="line">        libnspr4.so =&gt; /usr/lib/x86_64-linux-gnu/libnspr4.so (0x00007faf3c619000)
</span><span class="line">        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf3c3fc000)
</span><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf3c032000)
</span><span class="line">        libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007faf3be18000)
</span><span class="line">        libplds4.so =&gt; /usr/lib/x86_64-linux-gnu/libplds4.so (0x00007faf3bc14000)
</span><span class="line">        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf3ba10000)
</span><span class="line">        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007faf3b808000)
</span><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007faf3d21d000)
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>嗯，找到了一个有意思的依赖:libnss3.so</p>

<p>再用命令dpkg看一下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ dpkg -S /usr/lib/x86_64-linux-gnu/libnss3.so
</span><span class="line">libnss3:amd64: /usr/lib/x86_64-linux-gnu/libnss3.so
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>基本上确定是libnss3这个库引入的libssl3.so了，最后再用dpkg确认一下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ dpkg-query -L libnss3
</span><span class="line">/.
</span><span class="line">/usr
</span><span class="line">/usr/lib
</span><span class="line">/usr/lib/x86_64-linux-gnu
</span><span class="line">/usr/lib/x86_64-linux-gnu/libnssutil3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreebl3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnssckbi.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libsoftokn3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreeblpriv3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.chk
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnssdbm3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libfreebl3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/nss/libnsssysinit.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libsmime3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libnss3.so
</span><span class="line">/usr/lib/x86_64-linux-gnu/libssl3.so
</span><span class="line">/usr/share
</span><span class="line">/usr/share/doc
</span><span class="line">/usr/share/doc/libnss3
</span><span class="line">/usr/share/doc/libnss3/copyright
</span><span class="line">/usr/share/doc/libnss3/changelog.Debian.gz
</span><span class="line">/usr/share/lintian
</span><span class="line">/usr/share/lintian/overrides
</span><span class="line">/usr/share/lintian/overrides/libnss3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="libnss3">libnss3是个什么东东?</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">apt-cache show libnss3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看了一下，发现是mozilla基金会搞得东东；再google一下，发现是自己孤陋寡闻了；</p>

<p>原来，SSL&amp;TSL的实现，不只是openssl一家独大，像Mozilla Firefox就用自家实现的Nss；</p>

<p>Google Chrome之前也是用Nss的，后来迁移到了openssl，再后来，2014年，openssl1.0.1出现了heartbeat 漏洞，Google干脆自己开了个分支，用自己定制的openssl了；</p>

<p>至于Windows平台的，还有C++阵营的，都有自己实现的ssl库，具体可参见:</p>

<p>https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</p>

<h3 id="nsscentos">nss在centos中</h3>

<p>搜素的过程中，我惊奇的发现，ubuntu和centos上面的curl，竟然链接的libssl也不一样：</p>

<p>ubuntu上的curl默认链接的是openssl，而centos上面默认链接的是libnss3；</p>

<p>耐人寻味啊，莫非redhat系的人发现了什么~~~~</p>

<p>做事要做全套，我分别切换到ubuntu16.04和centos7.2上面，看看他们官方仓库中自带的curl是如何编译的。</p>

<h4 id="centos72">centos7.2</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ rpm -q --requires curl
</span><span class="line">libc.so.6()(64bit)
</span><span class="line">libc.so.6(GLIBC_2.14)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.17)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.2.5)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.3)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.4)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.7)(64bit)
</span><span class="line">libcurl = 7.29.0-51.el7
</span><span class="line">libcurl.so.4()(64bit)
</span><span class="line">libdl.so.2()(64bit)
</span><span class="line">libnspr4.so()(64bit)
</span><span class="line">libnss3.so()(64bit)
</span><span class="line">libnssutil3.so()(64bit)
</span><span class="line">libplc4.so()(64bit)
</span><span class="line">libplds4.so()(64bit)
</span><span class="line">libpthread.so.0()(64bit)
</span><span class="line">libpthread.so.0(GLIBC_2.2.5)(64bit)
</span><span class="line">libsmime3.so()(64bit)
</span><span class="line">libssl3.so()(64bit)
</span><span class="line">libz.so.1()(64bit)
</span><span class="line">rpmlib(CompressedFileNames) &lt;= 3.0.4-1
</span><span class="line">rpmlib(FileDigests) &lt;= 4.6.0-1
</span><span class="line">rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
</span><span class="line">rtld(GNU_HASH)
</span><span class="line">rpmlib(PayloadIsXz) &lt;= 5.2-1
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>用的是libcurl = 7.29.0-51.el7；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ rpm -q --requires libcurl
</span><span class="line">/sbin/ldconfig
</span><span class="line">libc.so.6()(64bit)
</span><span class="line">libc.so.6(GLIBC_2.14)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.15)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.16)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.17)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.2.5)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.3)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.3.4)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.4)(64bit)
</span><span class="line">libc.so.6(GLIBC_2.7)(64bit)
</span><span class="line">libcom_err.so.2()(64bit)
</span><span class="line">libdl.so.2()(64bit)
</span><span class="line">libgssapi_krb5.so.2()(64bit)
</span><span class="line">libgssapi_krb5.so.2(gssapi_krb5_2_MIT)(64bit)
</span><span class="line">libidn.so.11()(64bit)
</span><span class="line">libidn.so.11(LIBIDN_1.0)(64bit)
</span><span class="line">libk5crypto.so.3()(64bit)
</span><span class="line">libkrb5.so.3()(64bit)
</span><span class="line">liblber-2.4.so.2()(64bit)
</span><span class="line">libldap-2.4.so.2()(64bit)
</span><span class="line">libnspr4.so()(64bit)
</span><span class="line">libnss3.so()(64bit)
</span><span class="line">libnss3.so(NSS_3.10)(64bit)
</span><span class="line">libnss3.so(NSS_3.12.1)(64bit)
</span><span class="line">libnss3.so(NSS_3.12.5)(64bit)
</span><span class="line">libnss3.so(NSS_3.2)(64bit)
</span><span class="line">
</span><span class="line">....
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>看到libnss3了,重点输出：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">libnss3.so
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>那么这个包是谁提供的？输入如下命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ rpm -qf /usr/lib64/libnss3.so 
</span><span class="line">    nss-3.36.0-7.1.el7_6.x86_64
</span><span class="line">~ rpm -ql nss
</span><span class="line">/etc/pki/nss-legacy
</span><span class="line">/etc/pki/nss-legacy/nss-rhel7.config
</span><span class="line">/etc/pki/nssdb
</span><span class="line">/etc/pki/nssdb/cert8.db
</span><span class="line">/etc/pki/nssdb/cert9.db
</span><span class="line">/etc/pki/nssdb/key3.db
</span><span class="line">/etc/pki/nssdb/key4.db
</span><span class="line">/etc/pki/nssdb/pkcs11.txt
</span><span class="line">/etc/pki/nssdb/secmod.db
</span><span class="line">/usr/lib64/libnss3.so
</span><span class="line">/usr/lib64/libnssckbi.so
</span><span class="line">/usr/lib64/libsmime3.so
</span><span class="line">/usr/lib64/libssl3.so
</span><span class="line">/usr/lib64/nss/libnssckbi.so
</span><span class="line">...
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>至此水落石出，还可以看到我们熟悉的证书cert8.db文件；但其实 curl 最终使用的根证书库并不是该文件。那 curl 使用的根证书文件在哪儿呢？</p>

<p>使用 curl-config 命令行工具，能够了解更多：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ curl-config --ca                        
</span><span class="line">/etc/pki/tls/certs/ca-bundle.crt
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="ubuntu1604">ubuntu16.04</h4>

<p>ubuntu16上面验证类似，不一一说明了~~~</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ dpkg-query -L libcurl3
</span><span class="line">/.
</span><span class="line">/usr
</span><span class="line">/usr/share
</span><span class="line">/usr/share/doc
</span><span class="line">/usr/share/doc/libcurl3
</span><span class="line">/usr/share/doc/libcurl3/copyright
</span><span class="line">/usr/share/doc/libcurl3/changelog.Debian.gz
</span><span class="line">/usr/share/doc/libcurl3/NEWS.Debian.gz
</span><span class="line">/usr/share/lintian
</span><span class="line">/usr/share/lintian/overrides
</span><span class="line">/usr/share/lintian/overrides/libcurl3
</span><span class="line">/usr/lib
</span><span class="line">/usr/lib/x86_64-linux-gnu
</span><span class="line">/usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0
</span><span class="line">/usr/lib/x86_64-linux-gnu/libcurl.so.3
</span><span class="line">/usr/lib/x86_64-linux-gnu/libcurl.so.4
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ apt-cache depends  libcurl3
</span><span class="line">  Depends: libc6
</span><span class="line">  Depends: libgssapi-krb5-2
</span><span class="line">  Depends: libidn11
</span><span class="line">  Depends: libldap-2.4-2
</span><span class="line">  Depends: librtmp1
</span><span class="line">  Depends: libssl1.0.0
</span><span class="line">  Depends: zlib1g
</span><span class="line">  Recommends: ca-certificates
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后寻找libcurl的依赖库:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ ldd /usr/lib/x86_64-linux-gnu/libcurl.so.4.4.0|grep ssl
</span><span class="line">libssl.so.1.0.0 =&gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fbdf8aa0000)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>验证一下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">~ apt-cache depends openssl
</span><span class="line">openssl
</span><span class="line">  Depends: libc6
</span><span class="line">  Depends: libssl1.0.0
</span><span class="line">  Suggests: ca-certificates
</span><span class="line">  
</span><span class="line">~ apt-cache rdepends  libssl1.0.0 | grep curl
</span><span class="line">  libcurl3  
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section">总结</h3>

<p>所以这就是想要解决一个问题的中途，又被带到了另外一条小路上；该说我是还有那么一点好奇心呢？还是注意力不集中呢？</p>

<p>Orz………</p>

<h3 id="section-1">参考资料:</h3>

<p>https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</p>

<p>https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter</p>

<p>https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</p>

<p>https://www.lbbniu.com/6680.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libssl Segfaults on python3.6 With Threading]]></title>
    <link href="https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading/"/>
    <updated>2019-08-03T20:23:47+08:00</updated>
    <id>https://happy123.me/blog/2019/08/03/libssl-segfaults-on-python3-dot-6-with-threading</id>
    <content type="html"><![CDATA[<p>openssl1.0.0 和 openssl1.0.1 使用Python3.6的绑定:</p>

<!-- more -->

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import ctypes
</span><span class="line">import logging
</span><span class="line">
</span><span class="line">try:
</span><span class="line">    ssl_library = ctypes.cdll.LoadLibrary('libeay32.dll')
</span><span class="line">except Exception:
</span><span class="line">    ssl_library = ctypes.cdll.LoadLibrary('libssl.so')
</span><span class="line">
</span><span class="line">def check_result(val, func, args):
</span><span class="line">    if val == 0:
</span><span class="line">        raise ValueError
</span><span class="line">    else:
</span><span class="line">        return ctypes.c_void_p(val)
</span><span class="line">
</span><span class="line">
</span><span class="line"># ssl_library.EC_KEY_new.restype = ctypes.c_void_p
</span><span class="line">ssl_library.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p
</span><span class="line">ssl_library.EC_KEY_new_by_curve_name.errcheck = check_result
</span><span class="line">
</span><span class="line">k = ssl_library.EC_KEY_new_by_curve_name(NID_secp256k1)
</span><span class="line">
</span><span class="line">if ssl_library.EC_KEY_generate_key(k) != 1:
</span><span class="line">    raise Exception("internal error")
</span><span class="line">ssl_library.EC_KEY_free(k)
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段代码在多线程的时候会出现segmentation fault error； google一下发现<code>EC_KEY_generate_key</code>并不是线程安全的；于是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">openssl_locks = [threading.Lock() for _ in range(ssl_library.CRYPTO_num_locks())]
</span><span class="line">openssl_locking_function = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_int, ctypes.c_char_p, ctypes.c_int)
</span><span class="line">openssl_threadid_function = ctypes.CFUNCTYPE(ctypes.c_ulong)
</span><span class="line">
</span><span class="line">@openssl_locking_function
</span><span class="line">def openssl_lock(mode, type, file, line):
</span><span class="line">    if (mode &amp; CRYPTO_LOCK) != 0:
</span><span class="line">        openssl_locks[type].acquire()
</span><span class="line">    else:
</span><span class="line">        openssl_locks[type].release()
</span><span class="line">
</span><span class="line">@openssl_threadid_function
</span><span class="line">def openssl_threadid():
</span><span class="line">    v = threading.current_thread().ident
</span><span class="line">    return v
</span><span class="line">
</span><span class="line">ssl_library.CRYPTO_set_id_callback(openssl_threadid)
</span><span class="line">ssl_library.CRYPTO_set_locking_callback(openssl_lock)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>诡异的是还是不定时的crash掉，又一通google之后发现是openssl1.0.0的实现问题，参考:</p>

<p>https://bugs.python.org/issue29340</p>

<p>需要升级至openssl1.1.0；</p>

<p>这个是今天我在实现一个简单的比特币钱包的时候发现的，用函数名google了一通没发现问题；挂上gdb才追踪到了lib库里面；</p>

<p>我当时通读了electrum的代码，还纳闷他为啥自己实现了一遍ECDSA，这回明白了；</p>

<p>原来解决这种问题还蛮有兴致的，现在是越来越懒，有时候觉得这样效率真低啊，难道已经到了智力衰退期了，话说程序员有个35岁限制，我原来是不信的，现在有点体会了~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticserach Tips]]></title>
    <link href="https://happy123.me/blog/2019/07/24/elasticserach-tips/"/>
    <updated>2019-07-24T10:17:05+08:00</updated>
    <id>https://happy123.me/blog/2019/07/24/elasticserach-tips</id>
    <content type="html"><![CDATA[<p>elasticsearch升级到7.x；改动不小，命令从头再捋一遍；</p>

<p>PS:感叹elasticsearch在搜索和大数据聚合上面做的了不起的工作！ 细致入微，基本上在工程层面解决了数不清的细节问题，了不起的产品设计和再创造，了不起的工作量！ 就像docker重新唤醒容器技术一样，elasticsearch在Lucene之上的构建为个人数据分析和企业数据梳理开创新时代。 如果有条件，我是极为愿意买入他们的股票的。</p>

<!-- more -->

<h2 id="section">文档操作</h2>

<h4 id="section-1">增加一条记录</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PUT /website/_doc/1
</span><span class="line">{
</span><span class="line">  "title": "My 2 blog entry",
</span><span class="line">  "text":  "I am starting to get the hang of this...",
</span><span class="line">  "date":  "2014/01/02"
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-2">修改</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST /website/_update/1
</span><span class="line">{
</span><span class="line">   "doc" : {
</span><span class="line">      "tags" : [ "testing..." ],
</span><span class="line">      "views": 0
</span><span class="line">   }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-3">查询</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">
</span><span class="line">GET /website/_source/1
</span><span class="line">
</span><span class="line">GET /website/_mget 
</span><span class="line">{
</span><span class="line">    "ids" : [ "2", "1" ]    
</span><span class="line">}
</span><span class="line">
</span><span class="line">GET /_search
</span><span class="line">{
</span><span class="line">    "query": YOUR_QUERY_HERE
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-4">删除</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">DELETE /website/_doc/1
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="api">文档功能API</h2>

<h4 id="section-5">获取映射信息</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_mapping
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-6">测试分析器</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_analyze
</span><span class="line">{
</span><span class="line">  "field": "tweet",
</span><span class="line">  "text": "Black-cats" 
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-7">多层级对象用扁平化的方法来存储，比如</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">  "gb": {
</span><span class="line">    "tweet": { 
</span><span class="line">      "properties": {
</span><span class="line">        "tweet":            { "type": "string" },
</span><span class="line">        "user": { 
</span><span class="line">          "type":             "object",
</span><span class="line">          "properties": {
</span><span class="line">            "id":           { "type": "string" },
</span><span class="line">            "gender":       { "type": "string" },
</span><span class="line">            "age":          { "type": "long"   },
</span><span class="line">            "name":   { 
</span><span class="line">              "type":         "object",
</span><span class="line">              "properties": {
</span><span class="line">                "full":     { "type": "string" },
</span><span class="line">                "first":    { "type": "string" },
</span><span class="line">                "last":     { "type": "string" }
</span><span class="line">              }
</span><span class="line">            }
</span><span class="line">          }
</span><span class="line">        }
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>会被转换为如下内部对象:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    "tweet":            [elasticsearch, flexible, very],
</span><span class="line">    "user.id":          [@johnsmith],
</span><span class="line">    "user.gender":      [male],
</span><span class="line">    "user.age":         [26],
</span><span class="line">    "user.name.full":   [john, smith],
</span><span class="line">    "user.name.first":  [john],
</span><span class="line">    "user.name.last":   [smith]
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="nested-object">内部对象数组会丢失一部分相关信息，我们需要用嵌套对象(nested object)来处理</h4>

<h2 id="section-8">查询</h2>

<h4 id="section-9">查询语句的结构</h4>

<ul>
  <li>一个查询语句 的典型结构：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    QUERY_NAME: {
</span><span class="line">        ARGUMENT: VALUE,
</span><span class="line">        ARGUMENT: VALUE,...
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>如果是针对某个字段，那么它的结构如下：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    QUERY_NAME: {
</span><span class="line">        FIELD_NAME: {
</span><span class="line">            ARGUMENT: VALUE,
</span><span class="line">            ARGUMENT: VALUE,...
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>一条复合语句</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    "bool": {
</span><span class="line">        "must": { "match":   { "email": "business opportunity" }},
</span><span class="line">        "should": [
</span><span class="line">            { "match":       { "starred": true }},
</span><span class="line">            { "bool": {
</span><span class="line">                "must":      { "match": { "folder": "inbox" }},
</span><span class="line">                "must_not":  { "match": { "spam": true }}
</span><span class="line">            }}
</span><span class="line">        ],
</span><span class="line">        "minimum_should_match": 1
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-10">实战查询</h4>

<ul>
  <li>精确查询</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "constant_score" : {
</span><span class="line">      "filter":{
</span><span class="line">        "term": {
</span><span class="line">          "title": "helloworld"
</span><span class="line">        }
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>多词组合</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match": {
</span><span class="line">            "title": {      
</span><span class="line">                "query":    "BROWN DOG!",
</span><span class="line">                "operator": "and"
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>短语匹配</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match_phrase": {
</span><span class="line">            "title": "quick brown fox"
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>混合短语匹配</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match_phrase": {
</span><span class="line">            "title": {
</span><span class="line">                "query": "quick fox",
</span><span class="line">                "slop":  1
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>正则查询 (性能慢)</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /my_index/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "wildcard": {
</span><span class="line">            "postcode": "W?F*HW" 
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>智能匹配</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /my_index/_search
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "match_phrase_prefix" : {
</span><span class="line">            "brand" : {
</span><span class="line">                "query":          "johnnie walker bl",
</span><span class="line">                "max_expansions": 50
</span><span class="line">                }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>控制精度</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "match": {
</span><span class="line">      "title": {
</span><span class="line">        "query":                "quick brown dog",
</span><span class="line">        "minimum_should_match": "75%"
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "bool": {
</span><span class="line">      "should": [
</span><span class="line">        { "match": { "title": "brown" }},
</span><span class="line">        { "match": { "title": "fox"   }},
</span><span class="line">        { "match": { "title": "dog"   }}
</span><span class="line">      ],
</span><span class="line">      "minimum_should_match": 2 
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>按受欢迎度提升权重</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /blogposts/post/_search
</span><span class="line">{
</span><span class="line">  "query": {
</span><span class="line">    "function_score": { 
</span><span class="line">      "query": { 
</span><span class="line">        "multi_match": {
</span><span class="line">          "query":    "popularity",
</span><span class="line">          "fields": [ "title", "content" ]
</span><span class="line">        }
</span><span class="line">      },
</span><span class="line">      "field_value_factor": { 
</span><span class="line">        "field": "votes" 
</span><span class="line">      }
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span><span class="line">微调:
</span><span class="line">https://www.elastic.co/guide/cn/elasticsearch/guide/current/boosting-by-popularity.html
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-11">排障</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_validate/query?explain
</span><span class="line">{
</span><span class="line">   "query": {
</span><span class="line">      "match" : {
</span><span class="line">         "text" : "really powerful"
</span><span class="line">      }
</span><span class="line">   }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-12">结果排序</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GET /website/_search
</span><span class="line">{
</span><span class="line">    "query" : {
</span><span class="line">        "bool" : {
</span><span class="line">            "filter" : { "term" : { "_id" : 1 }}
</span><span class="line">        }
</span><span class="line">    },
</span><span class="line">    "sort": { "date": { "order": "desc" }}
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-13">索引操作</h2>

<h4 id="section-14">增加</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">PUT /my_index
</span><span class="line">{
</span><span class="line">    "settings": { ... any settings ... },
</span><span class="line">    "mappings": {
</span><span class="line">        "type_one": { ... any mappings ... },
</span><span class="line">        "type_two": { ... any mappings ... },
</span><span class="line">        ...
</span><span class="line">    }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-15">删除</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">DELETE /my_index
</span><span class="line">DELETE /index_one,index_two
</span><span class="line">DELETE /index_*
</span><span class="line">DELETE /_all
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>#### 配置</p>

<ul>
  <li>number_of_shards</li>
</ul>

<p>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</p>

<ul>
  <li>number_of_replicas</li>
</ul>

<p>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>

<h4 id="section-16">重新索引</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST _reindex
</span><span class="line">{
</span><span class="line">  "source": {
</span><span class="line">    "index": "twitter"
</span><span class="line">  },
</span><span class="line">  "dest": {
</span><span class="line">    "index": "new_twitter"
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-17">释放空间</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">POST /_all/_forcemerge?only_expunge_deletes=true
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python捕获所有异常]]></title>
    <link href="https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang/"/>
    <updated>2019-06-24T12:31:08+08:00</updated>
    <id>https://happy123.me/blog/2019/06/24/pythonbu-huo-suo-you-yi-chang</id>
    <content type="html"><![CDATA[<p>摘自 - Python cookbook</p>

<p>老生常谈了，但是在Pyflake检查出E722错误时有时候又犯老毛病。人年纪大了越来越有老年痴呆倾向  -_- …..</p>

<h2 id="section">怎样捕获代码中的所有异常？</h2>

<!-- more -->

<h4 id="exception-">想要捕获所有的异常，可以直接捕获 Exception 即可：</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">   ...
</span><span class="line">except Exception as e:
</span><span class="line">   ...
</span><span class="line">   log('Reason:', e)       # Important!
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个将会捕获除了 <code>SystemExit</code> 、 <code>KeyboardInterrupt</code> 和 <code>GeneratorExit</code> 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。</p>

<h4 id="section-1">讨论</h4>

<p>捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。</p>

<p>正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def parse_int(s):
</span><span class="line">    try:
</span><span class="line">        n = int(v)
</span><span class="line">    except Exception:
</span><span class="line">        print("Couldn't parse")
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>试着运行这个函数，结果如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt;&gt;&gt; parse_int('n/a')
</span><span class="line">Couldn't parse
</span><span class="line">&gt;&gt;&gt; parse_int('42')
</span><span class="line">Couldn't parse
</span><span class="line">&gt;&gt;&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def parse_int(s):
</span><span class="line">    try:
</span><span class="line">        n = int(v)
</span><span class="line">    except Exception as e:
</span><span class="line">        print("Couldn't parse")
</span><span class="line">        print('Reason:', e)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候你能获取如下输出，指明了有个编程错误：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt;&gt;&gt; parse_int('42')
</span><span class="line">Couldn't parse
</span><span class="line">Reason: global name 'v' is not defined
</span><span class="line">&gt;&gt;&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>很明显，你应该尽可能将异常处理器定义的精准一些。 </p>

<p>不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。</p>

<h4 id="section-2">最可怕的例子是我们在处理临时文件的时候，用</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因为碍人的E722, 有人会自作聪明的改成:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except Exception:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正确的办法是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except BaseException:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者更确定的语义之下，每次都清理临时文件，这样更明确，处理更好一点:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">try:
</span><span class="line">    ....
</span><span class="line">except BaseException:
</span><span class="line">    logger.error(....)
</span><span class="line">finally:
</span><span class="line">    os.remove(temp_file)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>参考:</p>

<p>https://github.com/PyCQA/pycodestyle/issues/703</p>

<p>https://python3-cookbook.readthedocs.io/zh_CN/latest/c14/p07_catching_all_exceptions.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[复利是世界第八大奇迹-爱因斯坦真的说过这句话吗?]]></title>
    <link href="https://happy123.me/blog/2019/06/22/fu-li-shi-shi-jie-di-ba-da-qi-ji-ai-yin-si-tan-zhen-de-shuo-guo-zhe-ju-hua-ma/"/>
    <updated>2019-06-22T18:40:38+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/fu-li-shi-shi-jie-di-ba-da-qi-ji-ai-yin-si-tan-zhen-de-shuo-guo-zhe-ju-hua-ma</id>
    <content type="html"><![CDATA[<p>爱因斯坦说:”复利是世界第八大奇迹”，这句话随处可见于各类理财鸡汤文中，甚至巴菲特也在纪录片中转述过这句话，但是挺奇怪的，爱因斯坦究竟是在何种情况下说出这句“名言”？</p>

<!-- more -->

<p>遍寻Google，发现只有一个地方比较详细的考证了这个事情:</p>

<p>https://skeptics.stackexchange.com/questions/25330/did-einstein-ever-remark-on-compound-interest</p>

<h4 id="section">第一个比较权威的引证来自于《纽约时报》1983年的一期，里面有这么一段:</h4>

<blockquote>
  <p>Asked once what the greatest invention of all times was,Albert Einstein is said to have replied, ‘‘compound interest.’‘His playful sense of humor and other aspects of his personality -as well as his genius - form the subject of a bus tour Sunday to the Institute for Advanced Study at Princeton, N.J., where the physicist worked during the last 20 years of his life</p>
</blockquote>

<p>看样子好像是爱因斯坦出来参观旅游至哪里的时候，幽默回答某个媒体人士的梗；毕竟当时是名人，媒体也不会一直问物理学，就像大家追着问巴菲特比特币一样; </p>

<h4 id="bank-performance-annual-warren-gorham--lamont-1978-p509">第二个比较早的引证来自于1978年的 Bank Performance Annual, Warren, Gorham &amp; Lamont, 1978, p509:</h4>

<p>这个就很直白了，有人问投资啥比较好，爱因斯坦就幽默了一把：“复利”</p>

<p>但是爱因斯坦逝世于1955年，都隔了30多年了还有人去引证这种“小故事”可信度也太低了，类似于知乎上到处都是”鲁迅先生说~~~”</p>

<h4 id="the-american-mathematical-monthly-vol-46-no-9-nov-1939-p595">最近的最靠谱的引用来自于The American Mathematical Monthly, Vol. 46, No. 9, Nov., 1939, p595</h4>

<p>貌似是当时的数学刊物征集读者问题，然后爱因斯坦对某个数学题的解法发表了评论，并表示这道题更好的解法是“复利”综上所述，怎么也找不到爱因斯坦说“复利是世界第八大奇迹”这句话的原梗。</p>

<p>“以讹传讹”可能就是当今各种“xxx曾经说过”的诠释吧。</p>

<p>等待更多资料补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[货币是泡沫?]]></title>
    <link href="https://happy123.me/blog/2019/06/22/huo-bi-shi-pao-mo/"/>
    <updated>2019-06-22T18:31:19+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/huo-bi-shi-pao-mo</id>
    <content type="html"><![CDATA[<p>诺贝尔经济学奖得主「托马斯·萨金特」的话：客观来说，所有货币都是泡沫？</p>

<p>萨金特教授解释道：</p>

<blockquote>
  <p>“客观来说，所有货币都是泡沫，因为当一种资产交易价格高于基础价值时候就是一种泡沫。我给你一美元，虽然它就是一张纸，但是因为你我承认其交换价值，使得这个价值得以维系。一旦有人不认同了，价值共识链条也将断裂。”</p>
</blockquote>

<p>https://36kr.com/p/5164521</p>

<!-- more -->

<p>关键是”货币”、”泡沫”很难量化。</p>

<p>货币脱胎于商品，但是成为一般等价物之后，就丧失大部分的商品价值，变成纯粹的价格标签。</p>

<p>现在各国发行的纸币基础就是这个国家的信用，假如国破家亡，这些货币将会飞速贬值，这也是可以预见的。</p>

<p>某一国家的货币价格实际上就是这个国家长期信用的折现值。</p>

<p>问题是世界上没有一种方法能用来衡量某一国家的长期信用折现值有多大，而且货币的发行、经济的兴衰完全无法预测。</p>

<p>但是有一点可以保证，没有万世不灭的国家；从长久的尺度来说，一个国家必然灭亡，如果人均寿命远远超过一个国家货币的平均寿命，那么可以称之为泡沫。比如几十年前我们的粮票，本质上也是一种货币，持有粮票的人可能做梦也不会想到说废弃就废弃；但是有很多人家积攒的粮票来不及兑换，就变废纸了：从这方面看，粮票确实是个泡沫，而且直到废止(泡沫破灭)的那一刻，才确认是一个泡沫。</p>

<p>所以可以把货币存在的基础看作是人们无可奈何的选择：人们知道早晚有一天会变成废纸，但这个早晚可能持续几十年，并且迄今为止没有更好的选择：贵金属由于其物理上的局限性无法承担信用交换的职责，利害权衡之下现有的货币制度还是可以接受的。</p>

<p>这种现象放在任何一个高估的资产上面都是成立的，比如大家都知道房价是个泡沫，肯定会跌，但是要是100年之后才跌呢？泡沫是破了，但是和我有什么关系！？</p>

<p>然后衍生到数字货币。我们说数字货币这个东西有点像是宗教，他是建立在数学及信息技术基础上的。如果你愿意，也可以把它看成是一种邪教组织：吸引的小部分核心教众是相信数理逻辑甚于国家信用的一小撮人，其它的都是投机赌博传销企图蹭一把油水的人~~~</p>

<p>那么结论就很清晰了：</p>

<ol>
  <li>数字货币在初期是一种信用抢占器，他的竞争对手是传统世界里面信用缺失的行业；比如博彩、保险、黑市、洗钱、某些投机行业等，这些行业本身及其需要信用的保证，但传统的金融手段无法提供这种保证；所以我们现在看到的是场子里面骗子横行，正说明了数字货币正以强大的吸力吸引传统诈骗行业从业人员</li>
  <li>数字货币第二步的竞争对手是某些信用非常弱小的国家的法币，比如委内瑞拉、津巴布韦等等；这些国家维持泡沫的能力比较弱，所以很容易受攻击</li>
  <li>数字货币第三步的竞争对手是贵金属，当其证明自己的信用吸纳能力超过一些国家的法币之后，这个系统就变成了一个正反馈–他会源源不断的吸纳信用提升价值，然后会吸引更多教众加入其中，这一点非常像传销。但是比传销更高明的是它的核心模式可能会持续非常非常久远的时间</li>
  <li>到底能持续多久远呢？这其实取决于人们的理智和贪婪的比例；一旦进入到泡沫正反馈的快车道，我挺悲观的，毕竟人的贪婪是无度的；当风潮来临时，能守住清明，抵住诱惑不动的人其实很少，所以我觉得数字货币很有可能发展到下一阶段，就是跟非常强势的国家货币竞争了；到了这一步，可能就不是简单的经济问题了，而是主权争夺，这个阶段可能会有围绕意识形态的战争、国家独立、个人建国、卫星劫持以维持系统运转等等等等</li>
  <li>最后，抢占所有的信用高地之后，就看数字货币本身能不能维系、甚至创造信用了，这一点不好预测</li>
</ol>

<h4 id="section">如果从千年的尺度来看，除了贵金属，毫无疑问所有货币都是泡沫。</h4>

<h4 id="section-1">如果从百年的尺度来看，大部分国家的货币是泡沫。</h4>

<h4 id="section-2">如果以十年的尺度来看，也有不少国家的货币寿命小于这个时间的。</h4>

<p>最后，比特币已经运转了10年，还能持续多少年呢？这是个很有意思的问题。</p>

<p>只要没有归零，还有全节点运转，就很难说是泡沫破灭。让我们拭目以待吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于货币的历史传说]]></title>
    <link href="https://happy123.me/blog/2019/06/22/guan-yu-huo-bi-de-li-shi-chuan-shuo/"/>
    <updated>2019-06-22T16:50:46+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/guan-yu-huo-bi-de-li-shi-chuan-shuo</id>
    <content type="html"><![CDATA[<h5 id="section"><人类货币史 /></h5>

<p>https://book.douban.com/subject/27018212/</p>

<!-- more -->

<p>是的，人类社会发明了货币，但至今为止没有谁能宣称自己完全搞明白了这个东西。</p>

<p>可以跟&lt; 三千年来谁铸币&gt;以及&lt; 货币的祸害&gt; 结合起来读，这本书主要描述了历史上的一些货币趣闻，对其意义和作用倒也没有长篇大论，毫无疑问是谦虚明智的做法。</p>

<p>记录一些小tips吧：</p>

<p>==================================</p>

<h4 id="section-1">历史上曾被用作货币的物品有:</h4>

<p>● 贵金属制成的条状物（例如古代美索不达米亚、现代的国家中央银行）</p>

<p>● 盐［盐在北非、中国和地中海地区都是用于保存食物、增加风味的重要商品，曾一度充当货币；“salary”（薪水）一词源于拉丁词语sal，代表salt，意为“盐”］</p>

<p>● 牛［例如在古印度和古代非洲。“pecuniary”（金钱的）一词源于拉丁词语pecus，即“cattle”（牛）；“capital”（资本）一词源于拉丁词语capita，即“head”（头）；印度货币卢比源于rupa，即“head of cattle”（一头牛）］</p>

<p>● 奴隶（例如古罗马、古希腊、现代印度的部分地方）</p>

<p>● 可可豆、纺织物（古代墨西哥）</p>

<p>● 玛瑙贝壳（古代中国、马尔代夫）</p>

<p>● 珠子（用于非洲奴隶贸易）</p>

<p>● 羽毛（圣克鲁斯群岛、所罗门群岛）</p>

<p>● 犬牙（巴布亚新几内亚）</p>

<p>● 鲸牙（斐济）</p>

<p>● 巨型、难以移动的石盘［太平洋雅浦（Yap）岛］</p>

<p>● 刀或其他工具（非洲部分地区）</p>

<p>● 铁戒指和手镯（非洲部分地区）</p>

<p>● 铜棒［西非的蒂夫（Tiv）族］</p>

<p>● 啄木鸟头皮［加州腹地的卡罗克（Karok）人］</p>

<p>● 人头骨（苏门答腊岛）</p>

<p>● 赌场筹码［19世纪暹罗（泰国）的一些城市］</p>

<p>● 贝壳念珠珠串（美国殖民地）</p>

<p>● 烟草或库存烟草的收据（美国殖民地）</p>

<p>● 香烟（战俘集中营、战后的德国、现代监狱——香烟不受通胀影响，因为一旦价值暴跌，就会被人们立即使用）</p>

<p>● 碳排放信用额</p>

<p>● 二进制信息（例如比特币）</p>

<h4 id="section-2">关于货币的那些字眼：</h4>

<p>公元前300年左右，在罗马，铸币最初在朱诺·墨涅塔（Juno Moneta）的神庙里铸造。墨涅塔是负责庇护金钱的女神，墨涅塔也是“钱”（money）一词的词源。</p>

<p>贝类在历史上曾长期充当过货币的角色， 在汉字中，一般与钱财有关的字，全和贝有关：贡 财 败 贬 贩 贯 货 贫 贪 购 贮 账 贵 费 贰 贷 贺…； 在英文中，我们最熟悉的就是shell out了。</p>

<h4 id="section-3">货币的起源：</h4>

<p>在 1990 年代晚期，考古学家 Stanley Ambrose 发现，在肯尼亚大裂谷的一座石头掩体中，藏着一些用鸵鸟蛋壳和贝壳碎片制成的项链。他们用（40Ar/42Ar）的氩测年法，将项链的年代确定为至少 4 万年前 。在西班牙发现的动物牙齿串珠也可以被追溯到这个年代 。在黎巴嫩（Lebanon）也发现了位于旧石器时代早期的穿孔贝壳。最近，（预备作为串珠）的完整贝壳，在南非的 Blombos 洞穴被发现，可以推前到距今 7 万 5 千年前！</p>

<p>现代考古学所发掘的最早的岩画，当属阿尔塔米拉洞；距今35000年左右，这被认为是人类艺术的开端；而文字的传播就更晚了；从这方面来看，货币其实是人类最早的语言、文化乃至艺术开端。</p>

<h4 id="section-4">铸币细节：</h4>

<p>通读我们提到的这三本货币史，我们发现了一个很有意思的细节：</p>

<p>早期中国的金属铸币都是带孔的，这很容易理解–古人需要用绳子串起来方便携带，所以我们的成语中才会有”腰缠万贯”这种词；而到了近代机制铸币，采用的是冲压铸币法，机器打孔导致良品率下降，而纸币开始风行，所以我们现代的硬币基本上都没有孔了；</p>

<p>国外铸币从古罗马时期开始，貌似他们的金银铸币没有打孔的习惯，这应该是铸造工艺的限制；</p>

<p>最有意思的是，能不能打孔，其实是筛选贝类货币的重要因素！早期的加工工艺粗糙，要求贝类有足够的坚韧度才能打孔，所以并不是所有的贝类都能做货币的；</p>

<p>英格兰在 17 世纪殖民美洲之时， 他们同当地的原住民交易，仍然入乡随俗，使用贝壳货币；有个描述特别有意思：</p>

<blockquote>
  <p>美洲的印第安人使用货币已有上千年历史，而且事实证明这些货币对初来乍到的欧洲人非常有用——就除了那些怀着 “印着大人物头像才是真钱” 偏见的人。最糟糕的是，这些新英格兰地区的原住民既不用金，也不用银，他们用的是生活环境中可见到的最合适的材料——猎物骨头中可长期保存的部分。具体一点来说就是用 venus mercenaria 等硬壳蚌类的壳做成的串珠（wampum），串成项坠。  -串珠项链。交易过程中，人们会点出珠子的数目、取出来并串到新项链上。美洲原住民的串珠有时候也会被串成腰带或其它有纪念或仪式意义的东西，表明财富或者对一些条约的承诺。-</p>
</blockquote>

<blockquote>
  <p>这些蚌类在大海里才能找到，但这些串珠却远播内陆。美洲大陆的各个部落中都可以找到各种各样的贝壳货币。易洛魁人（Iriquois）从未到蚌类栖息地去搞过事情，他们所收集到的串珠财宝却冠于所有部落 。只有少数几个部落，比如 Narragansett 人，才精于制造串珠，但几百个部落（大多都是 狩猎-采集 部落）都以串珠为货币。串珠项链的长度有很大差别，而串珠的数量与项链长度成比例。项链也总可以剪断或串联形成与商品价格相应的长度。</p>
</blockquote>

<p>呵呵，这就是项链的起源；今天我们赞美这种装饰品的华丽和艺术美感，其中有多少是从原始的”财迷崇拜”心理传承下来的呢？</p>

<p>另外，在货币上打孔将其穿起来这个动作具有深远的意义！你知道我在说什么，就是现在所谓的区块链技术–同样是用一个HASH值将所有的Block穿起来；人类历史发展了上万年，在电子世代重新发明一样东西，所考虑的事情同几万年前没有什么两样，这算不算是一种惊人的巧合呢？</p>

<h4 id="section-5">关于货币的幻觉:</h4>

<p>弗里德曼的<货币的祸害>同样是一本妙书，他开篇介绍的Yap（雅浦岛）的石币系统实在太有意思了；里面他记述了人类对于财富的度量其实不过是一种幻觉！这种幻觉的顶峰，无疑是现代的黄金储备系统。</货币的祸害></p>

<p>我们都知道世界上最大的金库是在 下曼哈顿区(或者翻译为“曼哈顿下城”)街道下方80英尺深的地方，属于美联储；各国的财富都储藏在这里；<货币的祸害>中记述了一个不可思议到可笑的故事：</货币的祸害></p>

<blockquote>
  <p>1932—1933年，法兰西银行害怕美国不再钉住金本位，不再按一盎司黄金兑换20.67美元的传统价格兑换黄金。于是，法兰西银行要求纽约联邦储备银行将它存在美国的大部分美元资产，转换成黄金。为了避免将黄金装船从海上运走，法兰西银行要求联邦储备银行把黄金存到法兰西银行的会计账簿上。作为一种回应，联邦储备银行的官员来到了金库，将与那笔资产等量的金锭放入了另外几个抽屉中，并且在这几个抽屉上贴了标签或是做了记号，以表明这个抽屉里的东西是法国的财产。这样，这些抽屉就像德国人在石头上做标记一样，也有可能“用黑色笔画一个十字”来标记。</p>
</blockquote>

<blockquote>
  <p>后来的结果是，财经报纸用头条报道了这件关于“黄金的损失”以及对美国金融体系的威胁等等诸如此类的消息。美国的黄金储备开始减少，法国的黄金储备则在增加。市场认为美元走软，法郎走强。这种因法国向美国兑换黄金而造成的所谓黄金流失，是最终导致1933年银行业恐慌的众多因素之一。
联邦储备银行的看法，即由于在自己的地下室里的抽屉上做了一些标记，美元就处于一个疲软的货币地位，与雅浦岛民的看法，即由于别人在他们的石币上做了一些记号，他们就变得比以前穷了，不是异曲而同工吗？或者说，在法兰西银行的看法与雅浦家族的信念之间，即由于3000多英里以外的一个地下室里数个抽屉上的标记，法国的货币地位即增强了，与由于数百英里以外的水底下的一块石头，雅浦的家族就富裕了的看法之间，有什么真正的区别吗？就此而言，有多少人会对我们认为现存的构成自己财富的大多数东西，具有实实在在的确切的把握？我们所拥有的多数似乎是财富的东西都记录在银行的账簿上，财产要由一张称为股票的纸来确定。</p>
</blockquote>

<p>货币是一种神秘奇妙的发明，它关乎信用、权力、与时间的博弈，人的幻想，秩序，疯狂，稳定，跟我们的社会紧紧缠绕在一起。</p>

<p>引自：</p>

<p>https://nakamotoinstitute.org/shelling-out/ </p>

<p>https://book.douban.com/subject/30426677/ </p>

<p>https://book.douban.com/subject/1860877/ </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读<投资者的心灵修炼>随想]]></title>
    <link href="https://happy123.me/blog/2019/06/22/du-tou-zi-zhe-de-xin-ling-xiu-lian-sui-xiang/"/>
    <updated>2019-06-22T16:48:28+08:00</updated>
    <id>https://happy123.me/blog/2019/06/22/du-tou-zi-zhe-de-xin-ling-xiu-lian-sui-xiang</id>
    <content type="html"><![CDATA[<h4 id="section"><投资者的心灵修炼 /></h4>

<p>https://book.douban.com/subject/27079024/</p>

<!-- more -->

<p>大多数人都没有意识到的一个事实是：投资最重要的不是智商，而是情商。</p>

<p>金融市场的投资到底有多难，看看书中序言专家的总结：</p>

<blockquote>
  <p>它需要洞悉市场在泡沫膨胀与破裂的长周期循环中处在哪个阶段，需要有一套可靠的与中短线不确定性进行“试错博弈”的方法体系，需要在第一时间对纷繁的噪声和有用信息做出鉴别，需要独立挖掘和洞悉别人看不到的重要因素，需要区别统计上的相关性与真正的因果关系，需要及时把握主要矛盾的动态变化以避免刻舟求剑，需要构建超越世俗生活的“对”与“错”的哲学观念，甚至使自己成为超越任何一个哲学流派的哲学家，需要洞悉大众人性规律和自我人性的特点，进而从本我的弱点中分离出来并战胜它……</p>
</blockquote>

<blockquote>
  <p>简言之，要成为金融市场成功的投资者，不仅要有一套超越大众并适应市场特性的思维方法，更要磨练出超越大众和本我弱点的“高异心性”。</p>
</blockquote>

<p>然后看看现在无处不在的各种<code>理财秘籍</code>，汗牛充栋的炒股秘策，我们普通人只会迷失在各种噪音当中……</p>

<p>巴菲特 1998年10月15日在佛罗里达大学商学院的演讲 值得我们一读再读，让我们再摘抄一下这位智慧老人的箴言：</p>

<blockquote>
  <p>各位同学，你们毕业之后未来会怎样？我简单说说我的想法。各位在这所大学能学到大量关于投资的知识，你们将拥有成功所需的知识，既然各位能坐在这里，你们也拥有成功所需的智商，你们还有成功所需的拼劲。你们大多数人都会成功地实现自己的理想。</p>
</blockquote>

<blockquote>
  <p>但是最后你到底能否成功，不只取决于你的头脑和勤奋。我简单讲一下这个道理。奥马哈有个叫彼得•基威特的人，他说他招人的时候看三点：品行、头脑和勤奋。他说一个人要是头脑聪明、勤奋努力，但品行不好，肯定是个祸害。品行不端的人，最好又懒又蠢。</p>
</blockquote>

<blockquote>
  <p>我知道各位都头脑聪明、勤奋努力，所以我今天只讲品行。为了更好地思考这个问题，我们不妨一起做个游戏。各位都是 MBA 二年级的学生，应该很了解自己周围的同学了。假设现在你可以选一个同学，买入他今后一生之内 10% 的收入。你不能选富二代，只能选靠自己奋斗的人。请各位仔细想一下，你会选班里的哪位同学，买入他今后一生之内 10% 的收入。</p>
</blockquote>

<blockquote>
  <p>你会给所有同学做个智商测试，选智商最高的吗？未必。你会选考试成绩最高的吗？未必。你会选最有拼劲的吗？不一定。因为大家都很聪明，也都很努力，我觉得你会主要考虑定性方面的因素。好好想想，你会把赌注压在谁的身上？</p>
</blockquote>

<blockquote>
  <p>也许你会选你最有认同感的那个人，那个拥有领导能力，能把别人组织起来的人。这样的人应该是慷慨大方的、诚实正直的，他们自己做了贡献，却说是别人的功劳。我觉得让你做出决定的应该是这样的品质。找到了你最钦佩的这位同学之后，想一想他身上有哪些优秀品质，拿一张纸，把这些品质写在纸的左边。</p>
</blockquote>

<blockquote>
  <p>下面我要加大难度了。为了拥有这位同学今后一生 10% 的收入，你还要同时做空另一位同学今后一生 10% 的收入，这个更好玩。</p>
</blockquote>

<blockquote>
  <p>想想你会做空谁？你不会选智商最低的。你会想到那些招人烦的人，他们可能学成绩优秀，但你就是不想和他们打交道，不但你烦他们，别人也烦他们。为什么有人会招人烦？原因很多，这样的人可能自私自利、贪得无厌、投机取巧或者弄虚作假。类似这样的品质，你想想还有什么，请把它们写在刚才那张纸的右边。</p>
</blockquote>

<blockquote>
  <p>看看左右两边分别列出来的品质，你发现了吗？这些品质不是把橄榄球扔出 60 米，不是 10 秒钟跑完 100 米，不是相貌在全班最出众。左边的这些品质，你真想拥有的话，你可以有。</p>
</blockquote>

<blockquote>
  <p>这些是关于行为、脾气和性格的品质，是能培养出来的。在座的各位，只要你想要获得这些品质，没一个是你得不到的。再看一下右边的那些品质，那些令人生厌的品质，没一个是你非有不可的，你身上要是有，想改的话，可以改掉。大多数行为都是习惯成自然。我已经老了，但你们还年轻，想摆脱恶习，你们年轻人做起来更容易。</p>
</blockquote>

<blockquote>
  <p>常言道，习惯的枷锁，开始的时候轻的难以察觉，到后来却重的无法摆脱。这话特别在理。我在生活中见过一些人，他们有的和我年纪差不多，有的比我年轻十几二十几岁，但是他们染上了一些坏习性，把自己毁了，改也改不掉，走到哪都招人烦。他们原来不是这样的，但是习惯成自然，积累到一定程度，根本改不了了。你们还年轻，想养成什么习惯、想形成什么品格，都可以，就看你自己怎么想了。</p>
</blockquote>

<blockquote>
  <p>本•格雷厄姆，还有他之前的本•富兰克林，他们都这么做过。本•格雷厄姆十几岁的时候就观察自己周围那些令人敬佩的人，他对自己说：“我也想成为一个被别人敬佩的人，我要向他们学。”格雷厄姆发现学他敬佩的人，像他们一样为人处世，是完全做得到的。他同样观察周围遭人厌恶的人，摆脱他们身上的缺点。我建议大家把这些品质写下来，好好想想，把好品质养成习惯，最后你想买谁 10% 的收入，就会变成他。</p>
</blockquote>

<blockquote>
  <p>你已经确定拥有自己 100% 的收入，再有别人的 10%，这多好。你选择了谁，你都可以学得像他一样。
假如有一位魔法老人问我，你今后要在投资领域成为什么样的人呢？是要巴菲特那样神奇的价值投资者？是芒格那样的智慧老人？还是彼得林奇一般的一代宗师？</p>
</blockquote>

<p>我想我会回答，我希望能在这个领域成为像阿甘那样的人。</p>

<p>哈，这个世界上聪明人实在太多了。人人都不想做傻子，而事实是市场上经常是聪明人赔钱，忘掉账户的那些傻子却”傻人有傻福”。我相信，阿甘到了市场上，大概率是那个有傻福的人，为什么呢？</p>

<p>他天资不高，但有着非常好的个人品质，他宅心仁厚，简单无私，同时自强不息，坚忍不拔，大概率能成就成功和快乐的人生。就像武侠小说里面的郭靖，以中下之资登武学绝顶之境。</p>

<h5 id="section-1">我不想学聪明，我想变简单，变得”笨一点”。</h5>

<p>最令人悲哀的事实就是，所有人都是”生而就笨”的，但经过生活的种种洗礼，我们不可避免的“越来越聪明”了，而生活和市场是心理变态的虐待狂，你越聪明，他就越会设置一个更高难度让你通关，最后你发现，变聪明了并不能让通关变得更容易。</p>

<p>这个时候我们需要重新学习“怎么变得更笨”这件事，而学习变笨在大多数人看起来就是一件荒谬的事情，在生活这个虐待狂的一次次鞭策下，我们已经忘了回家的路。更悲哀的是，要想学习”变笨”，就要先变得”更聪明”：聪明到能识别我们哪些“聪明”是多余的；这真是一个解不开的线团！</p>

<p>这本书通篇很好的提醒了我们哪些“聪明”是多余的。</p>

<p>我就我现在认识最深刻的一件”多余的聪明“写在这里供大家一乐。</p>

<h3 id="section-2">谬论1：你必须择时投资以获取像样的回报:</h3>

<p>在市场上投机的人最容易进入的一个心结就是，他们看着K线图，然后开始幻想：”如果我在这个低点买入，然后在那个高点抛出~~~”</p>

<p>快醒醒吧，一个最简单最惊人的统计学结论是：即使你每次都能低买高卖，在一个长期上涨的市场里面，你获取的收益大概率不如一直拿着不放的傻瓜！</p>

<p>为什么呢？这在数学上根本不成立嘛！</p>

<p>我们把事情放简单一点，如果在一个一直上涨的市场里面，每一分钟都创新高，最优的策略是什么？</p>

<p>当然是一把买入永远不动！把投资看成是储蓄，需要钱的时候取用就可以了。你每次卖出，都是抛掉便宜筹码，将来每次买入，跟历史比较起来，都是高买低卖。</p>

<p>但是市场是涨涨跌跌的啊？我每次高点抛出之后，再在低点买入更多份额不就好了吗？</p>

<p>这就涉及到另外一个统计结论，没有人能一直正确择时，甚至都没有统计结论支持这世上是否有个人能有50%的择时正确率！</p>

<p>那么这个结论已经很明显了，如果你能在你所认为的”市场低点”买入指数，拿着不动就可以了。就是这么简单。</p>

<p>但人性的”小聪明“往往会在市场动荡的时候出来骚扰你，在你耳边撒下喀耳刻海岛海妖迷人的歌声，这个时候你大概率要为聪明付出代价！</p>

<p>但是我们又迷惑了，难道永远不卖吗？万一我需要用钱的时候正好是市场低点怎么办？</p>

<h5 id="section-3">问得好！！这就要涉及到投资的本质，即无论是投机和投资，永远是跟时间的博弈！</h5>

<p>我们首先要明确，跟时间博弈，人是永远无法胜出的。人不可避免的衰老；不论你有多么成功的业绩，多么惊人的财富积累，最终都会被时间老人收回；在时间面前，所有人都是失败者！</p>

<p>我们能做的最好结果，就是在跟时间老人的博弈棋局中，让自己每次决定的边际效用最大化，尽可能延缓失败的到来；但在这个棋局中，人生来就是被打败的！</p>

<p>任何长期投资策略往往会受到情绪的影响。诀窍在于找到一种方法，可以在你晚上安然入睡与提高长期财务目标的实现概率之间取得平衡。</p>

<p>明白这个道理，我们就坦然了，不论是低买高卖，低买低卖，高买高卖，高买低卖，只要你不去耍小聪明，就是最大的边际效用！时间老人也会尊重你这样的对手。</p>

<p>====================================================</p>

<p>就是这么一个简单的道理，我们在寻求”变笨”的道路上摔了多少跤啊，要吃多少亏，被时间老人耍多少次才能领悟到自己那点”小聪明“是多么可笑啊！</p>

<p>悲哀的是， 人性的弱点总是充满贪婪、恐惧或者是愚蠢，这是完全可以预测的，但是我们无法预测这种人性弱点的发生顺序。 人生苦短，我们不可避免的要一次次的为自己的”聪明”付出代价。</p>

<p>让我在最后描述一个我发明的隐喻吧：</p>

<blockquote>
  <p>我们每个人生下来都被安排到一场棋局当中，我们的对手是一个慈祥的时间老人。他公正无私的同时又是一个宽大为怀的人；他手里面有许许多多的筹码，比如财富，美貌，健康，聪慧，正直，坚韧，勇敢等等等等，你在牌局初始就被随机赐予了一些筹码，当然你可以用自己的时间一点一点来换取这些筹码，也可以用已经拥有却暂时不需要的筹码去换取你急需的；</p>
</blockquote>

<blockquote>
  <p>每个筹码的作用和边际效用是时刻在变化的；比如对刚出生的你，时间老人是非常慷慨的，他说，你的一份时间可以换取1份财富，或者1份美貌，或者1份正直；但是随着时间流逝，时间老人可能严苛起来，这个时候可能你的1份时间可以换取10份财富，却需要10份时间才能换取1份健康；当然，你也可以用一百份财富换取1份健康；</p>
</blockquote>

<blockquote>
  <p>当我们渐渐成长之后，棋盘旁边来了两个观棋者，生活婆婆和市场国王；看的时间长了，他们开始叽叽喳喳起来，开始对你建议：先要这个，再要那个，那个傻瓜老头算不清楚，先要这个更划算；</p>
</blockquote>

<blockquote>
  <p>然后光靠说还不满足，他们开始偷偷往你手里塞筹码，是一些写着投机赌博、自私、欺骗等等的蓝筹，你们一时骗过了时间老人，让你用一个筹码换到了大量的财富，但是时间老人慢慢回过味儿来了，他开始严厉起来，100份时间，10000份财富也换不回一份正直了，最后，你手里面只剩下大量的自私、贪婪、赌博、财富等等，你想要一份正直，信任，倾尽所有筹码也换不回来了~~~</p>
</blockquote>

<p>最好的博弈策略就是，简以至纯，承认弱点、正视弱点、规避弱点。  </p>

<p>无波真古井，有节是秋筠；人生如逆旅，我亦是行人。</p>
]]></content>
  </entry>
  
</feed>
