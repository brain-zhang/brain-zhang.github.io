<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-05-19T10:28:58+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Is Craig Wright Real Satoshi Nakamoto-2]]></title>
    <link href="https://happy123.me/blog/2019/05/19/is-craig-wright-real-satoshi-nakamoto-2/"/>
    <updated>2019-05-19T10:15:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/19/is-craig-wright-real-satoshi-nakamoto-2</id>
    <content type="html"><![CDATA[<p>之前我们写过两篇文章来八卦所谓的<code>澳本聪</code>的故事:</p>

<p><a href="!https://happy123.me/blog/2016/05/02/is-craig-wright-real-satoshi-nakamoto/">Is Craig Wright Real Satoshi Nakamoto?</a></p>

<p><a href="!https://happy123.me/blog/2018/04/22/satoshi-craig-wright-is-being-sued-for-10-dollars-billion/">Satoshi Craig Wright Is Being Sued for $10 Billion</a></p>

<p>最近这个故事又有了新的神转折，实在是太有意思了。现实生活中，有时候我觉得八卦那些明星太无聊了，但是在cyberspace中，偶的八卦之心熊熊燃烧，都让我有点体会那些狗崽队的心情了~~~</p>

<!-- more -->


<p>之前我们做出的推论是:</p>

<blockquote><p>Craig Wright肯定和真正的中本聪有某种关系,他在bitcoin诞生之初就了解参与过.</p>

<p>他不是bitcoin的发明者,因为种种迹象表明,他的技术能力实在太low了.</p>

<p>真正的中本聪可能是他的那个朋友:David Kleiman, 但他已经死了.</p></blockquote>

<p>之后的剧情就是 David Kleiman的亲属起诉Craig Wright，声称他窃取了 本该属于  David Kleiman 的100w bitcoin；其起诉文书中公布了大量的由 Craig Wright声称其属于他和Kleiman成立的名为<code>郁金香信托</code>基金的bitcoin address;</p>

<p>参见<a href="!https://www.coindesk.com/satoshi-craig-wright-sued-10-billion">这里</a>， <a href="!https://www.reddit.com/r/Bitcoin/comments/80e2l9/10_billion_lawsuit_filed_against_craig_wright/">这里</a></p>

<p>很快，就有人对其文件中所列出的地址做了详细分析；认为其地址根本就是 Craig Wright 随便在bitcoin blockchain找的大额未动币的地址，根本和他没关系；当然，跟David Kleiman也没关系；两拨人马完全是在为<code>一笔完全不存在的财富</code>纠缠不清；</p>

<p>甚至，这些地址中，有一个地址是Mtgox小偷的地址！ 如果这份文件是真的，那么岂不是说Craig Wright自己承认是Mtgox的窃贼！</p>

<p>参考<a href="!https://blog.wizsec.jp/2018/02/kleiman-v-craig-wright-bitcoins.html">这里</a>；</p>

<p>地址分析：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>12tLs9c9RsALt4ockxa1hB4iTCTSmxj2me: unknown
</span><span class='line'>1933phfhK3ZgFQNLGSDXvqCn32k2buXY8a: MtGox user
</span><span class='line'>1FeexV6bAHb8ybZjqQMjJrcCrHGW9sb6uF: first major MtGox theft
</span><span class='line'>1f1miYFQWTzdLiCBxtHHnNiW7WAWPUccr: unknown
</span><span class='line'>1MHdm5XZMrfoZFoUktEaGhYevmdiXoc4x4: unknown (early miner)
</span><span class='line'>18JPragfuDVHWWG8ABQ15cghJFetnXUjBD: MtGox user
</span><span class='line'>1LXc28hWx1t8np5sCAb2EaNFqPwqJCuERD: unknown
</span><span class='line'>1FpqQnKQCgDkJFMC94JL8FpRyHTZ3uRVZ1: unknown (early miner)
</span><span class='line'>1F34duy2eeMz5mSrvFepVzy7Y1rBsnAyWC: from MyBitcoin.com
</span><span class='line'>1JtpgqCf3SSeCeYWEDJjkfYFH7Ruhy4Vp1: unknown (early miner)
</span><span class='line'>18k9tin39LKegFzHe8rxSgvJXDpuMriGJq: unknown
</span><span class='line'>1HtTw9zR9wWFfgV8Jy8MqsaeVi7ZXrjdq6: part of a long chain of transactions that send minor amounts into a BTC-e deposit address
</span><span class='line'>18pn4NQ7NgsJjeuFjazeTdVRnsmfw5ofTz: unknown
</span><span class='line'>12fZ2HxkLjG9zn1u44XYsFFYKHM4A2zCea: MtGox user
</span><span class='line'>12tkqA9xSoowkzoERHMWNKsTey55YEBqkv: unknown (early miner)
</span><span class='line'>16Ls6azc76ixc9Ny7AB5ZPPq6oiEL9XwXy: MtGox cold storage
</span><span class='line'>12HddUDLhRP2F8JjpKYeKaDxxt5wUvx5nq: MtGox cold storage
</span><span class='line'>1P3S1grZYmcqYDuaEDVDYobJ5Fx85E9fE9: MtGox cold storage
</span><span class='line'>1MyGwFAJjVtB5rGJa32M6Yh46cGirUta1K: MtGox cold storage
</span><span class='line'>145YHsQU7HMzkRnD5SBSuFAzQgCYnAnLkN: unknown (early miner)
</span><span class='line'>16TPVCpvtJ6FkV5xNKBp35aMo4BWFGxiEY: unknown
</span><span class='line'>1KbrSKrT3GeEruTuuYYUSQ35JwKbrAWJYm: unknown
</span><span class='line'>1FLFnbN7m5psLfvLEwYfRUUjJ34YkmV3dM: donation recipient
</span><span class='line'>1A6SDef1TJAM8Saw2SqmqFGhkWR1y3qMx2: MtGox deposit address
</span><span class='line'>16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT: MtGox user
</span><span class='line'>12ib7dApVFvg82TXKycWBNpN8kFyiAN1dr: unknown (early miner)</span></code></pre></td></tr></table></div></figure>


<p>呵呵，就在前几天，有人用<code>16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT</code>这个地址的私钥，签名发布了一段消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Address 16cou7Ht6WjTzuFyDBnht9hmvXytg6XdVT does not belong to Satoshi or to Craig Wright.
</span><span class='line'>Craig is a liar and a fraud.</span></code></pre></td></tr></table></div></figure>


<p>这段消息的签名是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>G39S6i4XsfQnixN5ePMjVPboWvGXdnW8xFFAXiwEriZFCclflbD7umP58u3Sl+dvvXC5BxBrRNkTMNf92O1UIXw=</span></code></pre></td></tr></table></div></figure>


<p>这段签名可以用Electrum的工具验证无误；懂一点技术的人自然明白这意味这什么。</p>

<p>那么问题又来了，为什么这位英雄好汉不在去年早点揭露这件事呢？</p>

<p>也许是法律文件太过冗长，没什么人仔细去研究，更不用说作为一个早期的Bitcoiner Hodler了；</p>

<p>嗯，这个理由很合理；但是~~~~</p>

<p>马上又有人挖出了更大的瓜，这个地址是Roger Ver控制的；</p>

<p><a href="https://www.reddit.com/r/btc/comments/bpdac1/address_16cou7ht6wjtzufydbnht9hmvxytg6xdvt_does/">https://www.reddit.com/r/btc/comments/bpdac1/address_16cou7ht6wjtzufydbnht9hmvxytg6xdvt_does/</a></p>

<p><a href="https://www.reddit.com/r/btc/comments/7cehzo/roger_ver_45000_bitcoin_moved_to_exchange/">https://www.reddit.com/r/btc/comments/7cehzo/roger_ver_45000_bitcoin_moved_to_exchange/</a></p>

<p>之前在Bitcoin扩容之争的时候，Roger Ver还用这个地址投过票；</p>

<p>而Roger Ver与Craig Wright的关系也是百转千回~~</p>

<ul>
<li><p>Craig Wright初次宣布自己是Satoshi, Roger Ver 坚持黑；</p></li>
<li><p>BCH分叉， Craig Wright投入BCH阵营， Roger Ver 粉；</p></li>
<li><p>BSV分叉， Craig Wright自立门户， Roger Ver 出来掀桌了；</p></li>
</ul>


<p>真相目前不得而知，但是可以确认的有一件事情：</p>

<p>像所有的区块链项目以及牵涉其中的人一样， Craig Wright, Roger Ver， 所谓的<code>郁金香信托</code>， Mtgox， BCH, BSV 等等，他们之间充斥着谎言中的谎言，是迷宫中的迷宫；</p>

<p>这再一次提醒我们，在区块链世界中，任何人都不值得信任，唯一可以依靠的只有自己的知识和判断：</p>

<h2>Don&rsquo;t Trust. Verify.</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[永远都算不准的指数PE]]></title>
    <link href="https://happy123.me/blog/2019/05/12/yong-yuan-du-suan-bu-zhun-de-zhi-shu-pe/"/>
    <updated>2019-05-12T10:49:33+08:00</updated>
    <id>https://happy123.me/blog/2019/05/12/yong-yuan-du-suan-bu-zhun-de-zhi-shu-pe</id>
    <content type="html"><![CDATA[<p>看看一张2019-05-10的指数估值表:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190512/bg1.png" alt="img" /></p>

<blockquote><p>数据来源：<a href="https://xueqiu.com/u/8890498724">https://xueqiu.com/u/8890498724</a></p></blockquote>

<p>大家肯定晕了，怎么这几家算出来的PE数据都不一样啊，个人计算的就罢了，怎么中证指数和Wind算的都不一样啊，究竟谁算得准啊？</p>

<p>PE是投资的重要指标因子，基础因子不准就做投资决策，犹如盲人骑瞎马，我们有必要好好弄明白为什么各家的PE算出来的值不一样！</p>

<!-- more -->


<h2>PE是什么？</h2>

<p>PE，是市盈率（Price earnings ratio，即P/E ratio）的英文缩写。其定义是股价与每股收益的比率，也等价于总市值与净利润的比率。</p>

<p>最简单的理解，一家公司现在的股票总市值是10亿元，当年的净利润为1亿元，那么当年的PE就是<code>10/1=10</code>；</p>

<p>这么简单的算术题，为啥各路神仙还算不准？</p>

<h2>PE的几种计算方法</h2>

<p>呵呵，股票市值很容易计算，但一家公司最难搞明白的就是当年净利润；试问大家去读公司年报，有几家公司能保证其中净利润是真实的准数呢？</p>

<p>更何况还有一个预测未来的问题，公司的股票市值天天变，财报有上一年的年报，当年季度报告，历史PE好算，当前PE如何计算呢？毕竟我们不能预测未来，在1月份就能预测当年整年的净利润；</p>

<p>为了解决这个算不准的问题，就有几种折中的计算方法：</p>

<h4>静态市盈率</h4>

<p>静态市盈率又称市盈率LYR(Last Year Ratio)，是以上一年的净利润为分母计算出来的市盈率；上一年的净利润，直接找公司财报就好了，这个没什么可说的；</p>

<p>但是我们要注意一点，静态市盈率是典型的看后视镜开车；去年挣大钱不代表今年也能挣大钱，对不？如果看静态市盈率炒股，结果就是呵呵哒；</p>

<h4>滚动市盈率 TTM(Trailing Twelve Months)，</h4>

<p>静态市盈率是后视镜，不实用，自然有人去改进，这就是滚动市盈率这项指标；</p>

<p>滚动市盈率和静态市盈率的区别在于，总利润以季报为参考，因为季报是每季度跟新一次，那样相比之前拿年报的总利润的算法，实时性更好一点；</p>

<p>比如我们在2019-05计算A公司的PE，那总利润就拿 2018年第二、第三、第四、以及2019年第一季度的季报利润总和相加，作为分母计算；</p>

<p>滚动市盈率实时性好，已经是当前最科学的估算方法了，大部分软件(比如雪球)就是这么计算的；但也有缺点，就是有的高速成长的公司，他前几个季度的成长是指数级的，但后面会越来越慢；而且有的公司为了PE数字好看，还会操纵利润；单看滚动市盈率炒股，最终结果还是呵呵哒；</p>

<h4>动态市盈率</h4>

<p>滚动市盈率的计算方法已经比较严谨了；但是还有一些软件的提供商偷懒，因为计算滚动市盈率需要处理很多情况，比如公司刚上市、比如公司去年停牌了一个季度，比如公司去年财报实锤造假了，等等等等，好烦啊，所以他们计算利润的方法更简单粗暴：</p>

<p>比如现在是2019年5月份，那么我觉得你今年的利润就是 2019年第一季度的利润X4；到了9月份，我就取全年利润=半年财报利润X2</p>

<p>呵呵哒~~~~</p>

<h4>根据财报利润个人计算</h4>

<p>设身处地想一下，我自己重仓了一支股票，发现连谁算的PE比较准都搞不明白，我岂不是每天惶惶然；于是我决定自己来算PE！</p>

<p>我拿来公司季报、半年报、年报仔细一看，乐了，基本上公司都会对未来的利润率有个预估，比如明年我预计全年净利润同比增长35%-45%；那么我保守一点，用去年35%的增长来预估你今年的利润，总可以了吧！</p>

<p>看看康美药业的年报吧! 呵呵哒~~~</p>

<h2>指数PE的计算方法</h2>

<p>单个公司的PE已然如此难算，那么指数呢？囊括几百家公司的指数PE怎么算呢？</p>

<h4>指数滚动市盈率加权计算方法</h4>

<p>我们把整个指数囊括的公司看成一家公司，那么PE计算其实很简单，就是PE=总市值/总利润；</p>

<p>总市值就是指数中所有市值的相加，总理论就是所有利润的相加；当然单家公司的利润我们肯定要采用滚动市盈率(TTM)的计算方法；</p>

<p>这种相加的计算方法，也被称之为加权计算方法；</p>

<h4>指数滚动市盈率算术平均计算方法</h4>

<p>加权计算方法简单明了，但是有的人觉得有问题，因为如果指数里面有100家公司，有家公司特别大，市盈率特别低，其他99家公司虽然市盈率很高，但采取加权统计一看，都被平均低了，这个计算方法就会失真；</p>

<p>为了解决这个问题，我们采取算术平均计算方法；比如这家特别大的公司PE是5，而其他99家公司PE都是20；那么我们就不看总市值和总利润了，直接:</p>

<p>(5 + 20 * 99) /100 = 19.85</p>

<p>这是算数平均计算方法，算数平均和加权计算的结果相比，可能相差万里；</p>

<h4>总市值统计？</h4>

<p>A股市场上还有一个特殊现象，就是有些股票并不是全流通的，这个时候他的总市值是只计算流通股呢？还是全部都算呢？</p>

<p>总市值统计方法的不同，又会影响到最终PE的计算结果</p>

<h4>亏损公司的计算</h4>

<p>如果一家公司亏损呢？还应该放到指数里面统计吗？</p>

<p>根据对亏损公司的处理方法的不同，又会影响到最终PE的计算结果</p>

<h4>B股的折价计算</h4>

<p>如果指数里面有的公司还有B股，那么B股的市值也要放进来计算吗？计算的时候如何设定权重？利润如何统计？</p>

<p>相对于B股的处理方法的不同，又会影响到最终PE的计算结果</p>

<h4>A/H股的折价计算</h4>

<p>如果指数里面有的公司还有H股，那么H股的市值也要放进来计算吗？计算的时候如何设定权重？利润如何统计？</p>

<p>相对于H股的处理方法的不同，又会影响到最终PE的计算结果</p>

<h2>指数PE的历史估值计算</h2>

<p>很多软件平台提供了PE/PB的历史估值计算，比如蛋卷基金会每天更新数值，告诉我们今天沪深300的PE估值处理历史百分位的xxx%；</p>

<p>如果你认真一点，就会发现所有平台的估值百分位都不一样！</p>

<p>PE的计算就如此五花八门，历史百分位当然不一样啦。</p>

<p>且慢，即使各大平台的PE计算都一样，历史估值百分位也可能不一样！为啥？</p>

<h4>统计时长的不同</h4>

<p>一个指数，他的历史区间该如何选取呢？</p>

<p>从指数成立的那一天开始？</p>

<p>取前5年历史？前8年历史？前10年历史？</p>

<h4>估值统计算法的不同</h4>

<p>算数平均 or 加权平均 or 中位数统计？</p>

<h2>总结</h2>

<p>所以有人说他算出了一个指数的PE，我们需要问他：</p>

<ol>
<li>个股采用的啥PE计算方法？ 静态PE？动态PE？滚动PE？ 动态取的是季报？半年报？年报？还是上一期年报/季报的预测值？</li>
<li>指数是总市值加权计算还是算术平均计算？</li>
<li>亏损公司怎么处理？</li>
<li>停牌公司怎么处理？</li>
<li>B股怎么处理？</li>
<li>H股怎么处理？</li>
<li>估值采用的历史数据时间段怎么取？前3年，5年，8年，成立以来? 成立之前还根据指数编制原则计算并统计进来了？</li>
<li>指数百分比的估值算法是什么？加权统计？算数平均？中位数？</li>
</ol>


<p>看了上面这么多干扰因子，相信你已经眼花缭乱了；而且每一种因子的处理方法都会引来无穷无尽的争论~~~</p>

<p>指数PE是永远也算不准的，那一个算不准的指标有啥好参考的？相信很快会有很多人跳出来说出各种理论~~~</p>

<p>无辜的摊手，我也不知道，呵呵哒。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Berkshire's Charlie Munger Calls Bitcoin 'Noxious Poison']]></title>
    <link href="https://happy123.me/blog/2019/05/09/berkshires-charlie-munger-calls-bitcoin-noxious-poison/"/>
    <updated>2019-05-09T10:12:02+08:00</updated>
    <id>https://happy123.me/blog/2019/05/09/berkshires-charlie-munger-calls-bitcoin-noxious-poison</id>
    <content type="html"><![CDATA[<p>Berkshire annual meeting 2019 Q&amp;A，巴菲特和芒格老爷子又来Diss bitcoin了；</p>

<h4>Munger:</h4>

<blockquote><p>It’s just disgusting. Bitcoin is noxious poison.</p></blockquote>

<h4>Buffet:</h4>

<blockquote><p>It’s a gambling device… there’s been a lot of frauds connected with it. There’s been disappearances, so there’s a lot lost on it. Bitcoin hasn’t produced anything</p>

<p>It doesn’t do anything. It just sits there. It’s like a seashell or something, and that is not an investment to me</p></blockquote>

<p>两位老爷子是bitcoin社区值得敬重的对手，从一而终，一直坚定的黑；</p>

<p>和一些骑墙派比起来，这份<code>坚守自己能力圈</code>的自律的确让人敬重。</p>

<p>不管今后结果如何，要把这两位智慧老人的话牢牢记在心里；记住我们的贪婪、愚蠢、傲慢等等;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go包管理工具]]></title>
    <link href="https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju/"/>
    <updated>2019-05-01T15:25:27+08:00</updated>
    <id>https://happy123.me/blog/2019/05/01/gobao-guan-li-gong-ju</id>
    <content type="html"><![CDATA[<p>真的，Go的包管理工具之发展过程充分体现了什么叫<code>折腾</code>。 (叹气~~~)</p>

<!-- more -->


<p>想想Java的Maven， Nodejs的NPM，还有我们赞颂一万遍也不过分的Python包管理，为什么生命总要浪费在这些事情上面呢？ 陷入了深深的沉思~~</p>

<p>从Go1.11版本发布Go MODULE之后，我希望这是最后一次折腾<code>包管理</code>这件事情，神呐，诚心诚意的祈祷中~~</p>

<p>摘抄备忘下：</p>

<h2>GO111MODULE</h2>

<p>Modules 是作为 experiment feature 加入到不久前正式发布的 Go 1.11 中的。
按照 Go 的惯例，在新的 experiment feature 首次加入时，都会有一个特性开关，go modules 也不例外，GO111MODULE 这个临时的环境变量就是 go modules 特性的 experiment 开关。</p>

<ul>
<li><p>off: go modules experiment feature 关闭，go compiler 会始终使用 GOPATH mode，即无论要构建的源码目录是否在 GOPATH 路径下，go compiler 都会在传统的 GOPATH 和 vendor 目录 (仅支持在 GOPATH 目录下的 package) 下搜索目标程序依赖的 go package；</p></li>
<li><p>on: 始终使用 module-aware mode，只根据 go.mod 下载 dependency 而完全忽略 GOPATH 以及 vendor 目录</p></li>
<li>auto: Golang 1.11 预设值，使用 GOPATH mode 还是 module-aware mode，取决于要构建的源码目录所在位置以及是否包含 go.mod 文件。满足任一条件时才使用 module-aware mode:

<ul>
<li>当前目录位于 GOPATH/src 之外并且包含 go.mod 文件</li>
<li>当前目录位于包含 go.mod 文件的目录下</li>
</ul>
</li>
</ul>


<h2>go mod 命令</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>download    download modules to local cache (下载依赖的 modules 到本地 cache)
</span><span class='line'>edit        edit go.mod from tools or scripts (编辑 go.mod 文件)
</span><span class='line'>graph       print module requirement graph (打印模块依赖图)
</span><span class='line'>init        initialize new module in current directory (再当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
</span><span class='line'>tidy        add missing and remove unused modules (增加丢失的 modules，去掉未用的 modules)
</span><span class='line'>vendor      make vendored copy of dependencies (将依赖复制到 vendor 下)
</span><span class='line'>verify      verify dependencies have expected content (校验依赖)
</span><span class='line'>why         explain why packages or modules are needed (解释为什么需要依赖)</span></code></pre></td></tr></table></div></figure>


<h2>既有项目</h2>

<p>假设你已经有了一个 go 项目， 比如在$GOPATH/github.com/memoryboxes/hello下， 你可以使用go mod init github.com/memoryboxes/hello在这个文件夹下创建一个空的 go.mod (只有第一行 module github.com/memoryboxes/hello)。</p>

<p>然后你可以通过 go get ./&hellip;让它查找依赖，并记录在 go.mod 文件中 (你还可以指定 -tags, 这样可以把 tags 的依赖都查找到)。</p>

<p>通过go mod tidy也可以用来为 go.mod 增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理tags。</p>

<p>执行上面的命令会把 go.mod 的latest版本换成实际的最新的版本，并且会生成一个go.sum记录每个依赖库的版本和哈希值。</p>

<h2>replace</h2>

<p>在国内访问golang.org/x的各个包都需要梯子，你可以在 go.mod 中使用replace替换成 github 上对应的库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>replace (
</span><span class='line'>  golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
</span><span class='line'>  golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
</span><span class='line'>  golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>依赖库中的replace对你的主 go.mod 不起作用，比如github.com/memoryboxes/hello的 go.mod 已经增加了replace, 但是你的 go.mod 虽然require了rpcx的库，但是没有设置replace的话， go get还是会访问golang.org/x。</p>

<p>所以如果想编译哪个项目，就在哪个项目中增加replace。</p>

<h2>包的版本控制</h2>

<p>下面的版本都是合法的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
</span><span class='line'>gopkg.in/vmihailenco/msgpack.v2 v2.9.1
</span><span class='line'>gopkg.in/yaml.v2 &lt;=v2.2.1
</span><span class='line'>github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
</span><span class='line'>latest</span></code></pre></td></tr></table></div></figure>


<p>版本号遵循如下规律：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
</span><span class='line'>vX.0.0-yyyymmddhhmmss-abcdefabcdef
</span><span class='line'>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
</span><span class='line'>vX.Y.Z</span></code></pre></td></tr></table></div></figure>


<p>也就是版本号 + 时间戳 + hash，我们自己指定版本时只需要制定版本号即可，没有版本 tag 的则需要找到对应 commit 的时间和 hash 值。</p>

<p>另外版本号是支持 query 表达式的，其求值算法是 “选择最接近于比较目标的版本 (tagged version)”，即上文中的 gopkg.in/yaml.v2 会找不高于 v2.2.1 的最高版本。</p>

<h2>go get 升级</h2>

<ul>
<li>运行 go get -u 将会升级到最新的次要版本或者修订版本 (x.y.z，z 是修订版本号， y 是次要版本号)</li>
<li>运行 go get -u=patch 将会升级到最新的修订版本</li>
<li>运行 go get package@version 将会升级到指定的版本号version</li>
</ul>


<h2>go modules 与 vendor</h2>

<ul>
<li><p>在最初的设计中，Russ Cox 是想彻底废除掉 vendor 的，但在社区的反馈下，vendor 得以保留，这也是为了兼容 Go 1.11 之前的版本。</p></li>
<li><p>Go modules 支持通过go mod vendor命令将某个 module 的所有依赖保存一份 copy 到 root module dir 的 vendor 下，然后在构建的使用go build -mod=vendor即可忽略 cache 里的包而只使用 vendor 目录里的版本。</p></li>
</ul>


<h2>参考:</h2>

<p><a href="https://roberto.selbach.ca/intro-to-go-modules/">https://roberto.selbach.ca/intro-to-go-modules/</a></p>

<p><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p>

<p><a href="https://windmt.com/2018/11/08/first-look-go-modules/">https://windmt.com/2018/11/08/first-look-go-modules/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指数投资策略]]></title>
    <link href="https://happy123.me/blog/2019/04/08/zhi-shu-tou-zi-ce-lue/"/>
    <updated>2019-04-08T17:55:22+08:00</updated>
    <id>https://happy123.me/blog/2019/04/08/zhi-shu-tou-zi-ce-lue</id>
    <content type="html"><![CDATA[<h4>降龙四式之亢龙有悔</h4>

<h4>谨记：一切回测有效的策略都是看后视镜开车。回测仅仅是参考，不能预测未来。</h4>

<h4>谨记：成功概率不能预测，失败风险无法回避，历史周期不断重复，时刻抱有敬畏之心。</h4>

<h1>指数特点</h1>

<ul>
<li>背靠国运，不死鸟</li>
<li>长期上涨</li>
<li>成本低</li>
<li>不择股</li>
<li>容易量化</li>
<li>大道至简</li>
</ul>


<!-- more -->


<h1>指数品种</h1>

<p>简单粗暴的分为宽基和窄基，窄基又可以细分为策略类、风格类、行业类、主题类；</p>

<h2>宽基指数</h2>

<ul>
<li>上市不满一个季度的股票不选；暂停上市的股票不选；财务上有问题的股票不选；多年亏损的股票不选。</li>
</ul>


<h4>上证50 (代码是000016)</h4>

<ul>
<li><p>上交所挑选沪市规模最大、流动性好、最具代表性的50只股票组成样本股，以综合反映沪市最具影响力的一批优质大盘企业的整体状况。2004年1月2日发布，但却是以2003年12月31日为基准日期开始运作的。</p></li>
<li><p>从2003年年底以来，国内股市发生过三轮比较明显的牛市，分别发生在2006～2007年、2009年和2015年。其余时间里股市大多波澜不惊，走平或者阴跌。</p></li>
</ul>


<h4>沪深300 (代码000300)</h4>

<ul>
<li>从上交所和深交所挑选规模最大、流动性最好的300只股票。从市值规模上来说，占到国内股市全部规模的60%以上。沪深300基本上包括上证50</li>
</ul>


<h4>中证500 (代码000905)</h4>

<ul>
<li>将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，这样可以最大限度地避免选入大公司。在剩下的公司中，选择日均总市值排名前500名的企业</li>
</ul>


<h4>创业板综指 (代码是399102)</h4>

<ul>
<li>包括创业板全部的500多家企业</li>
</ul>


<h4>创业板指数 (代码是399006)</h4>

<ul>
<li>创业板最主要的100家企业</li>
</ul>


<p>创业板指数整体公司规模较小，属于以中小型公司为主的指数。并且这些公司大多盈利没有进入稳定期，所以创业板的整体盈利数字比较低；公司开展新业务也更容易导致盈利大起大落。小公司＋盈利没有进入稳定期，创业板指数相比之前介绍的指数，更容易暴涨暴跌。</p>

<h4>上证综指(000001)</h4>

<p>综指指的是综合指数，上证综指包括了上交所全部的上市公司，目的是反映上交所所有股票的走势。</p>

<p>这个指数娱乐意义最大。</p>

<h4>中证100指数(000903)</h4>

<p>中证100指数是从沪深300指数中，再挑选出规模最大的100只股票组成的。比起上证50指数，它覆盖了深交所的大公司，所以更加全面一些。</p>

<h4>中证800指数</h4>

<p>中证500plus</p>

<h4>中证1000指数</h4>

<p>中证500plus+</p>

<h4>中证全指</h4>

<p>中证plus++</p>

<h4>恒生指数(HSL)</h4>

<ul>
<li>港上市的公司中规模最大的50家企业。因为中国香港金融市场比较开放，境外投资者很容易就能进来投资或者撤资，所以一有风吹草动，就会体现在港股价格的波动上。</li>
<li>最近3年国家先后开通了沪港通和深港通，内地资金正在夺回港股的定价权</li>
</ul>


<h4>H股指数</h4>

<ul>
<li>内地注册，但是在香港地区上市，这样的公司就是H股了。与A股关联度大，因为同股不同价，有很多精明指数前来套利。</li>
</ul>


<h4>标普500指数</h4>

<ul>
<li>巴菲特唯一指定接班人</li>
<li>需要注意的是，标普500也有一个<code>完全没有用的</code>委员会搞一些选股工作</li>
</ul>


<h4>纳斯达克100指数</h4>

<ul>
<li>纳斯达克规模最大的100家大型企业</li>
</ul>


<h4>德国30DAX</h4>

<ul>
<li>跟踪基金盘子小，误差大</li>
</ul>


<h4></h4>

<h2>行业指数</h2>

<p>行业有自己的投资特点，不能一概而论，需要针对行业的特点具体分析。所以就投资难度来说，行业指数比宽基指数要高出不少。</p>

<p>值得投资的行业，主要有两个，一个是天生赚钱更容易的行业，另一个是具有明显强周期性的行业。</p>

<p>我认为最值得关注的是消费指数和医药指数。</p>

<h4>上证消费指数</h4>

<ul>
<li>从上交所挑选必需消费行业公司。</li>
</ul>


<h4>上证消费80指数</h4>

<ul>
<li>从上交所挑选80家规模最大的必需消费行业公司。</li>
</ul>


<h4>中证消费指数</h4>

<ul>
<li>从中证800，即沪深300和中证500中挑选必需消费行业公司。</li>
</ul>


<h4>全指消费指数</h4>

<p>从所有上市公司中挑选必需消费行业公司，覆盖范围最广。</p>

<h4>300医药指数</h4>

<ul>
<li>挑选了沪深300指数里的医药行业公司。</li>
</ul>


<h4>500医药指数</h4>

<ul>
<li>挑选了中证500指数里的医药行业公司。</li>
</ul>


<h2>策略加权指数</h2>

<h4>上证50AH优选指数</h4>

<ul>
<li>基于A股、H股的聪明指数</li>
</ul>


<h4>上证红利指数 (000015)</h4>

<ul>
<li>上交所过去两年平均现金股息率最高的50只股票</li>
</ul>


<h4>中证红利指数 (000922/399922)</h4>

<ul>
<li>上交所和深交所挑选过去两年平均现金股息率最高的股票，成份股数量扩大到100只。</li>
</ul>


<h4>深证红利指数 (399324)</h4>

<ul>
<li>专门投资深交所的高现金股息率的股票，不过成份股只有40只。</li>
</ul>


<h4>红利机会指数 (501029)</h4>

<ul>
<li>传统的红利指数，一般只是挑选高股息率的股票，没有其他的要求。</li>
<li>红利机会指数有3个要求：过去3年盈利增长必须为正；过去12个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过33%。符合这3个要求的成份股才能入选，所有入选的股票再按照股息率排名选出股息率最高的100只股票，构成红利机会指数。</li>
</ul>


<h4>中证基本面50指数</h4>

<p>基本面指数中，在国内最出名的就是中证基本面50指数。这个指数是按照4个基本面指标，挑选出综合排名前50的公司。具体来说，是从上市公司过去5年的年报数据中，计算4个基本面指标。</p>

<ul>
<li>营业收入：公司过去5年营业收入的平均值。</li>
<li>现金流：公司过去5年现金流的平均值。</li>
<li>净资产：公司在定期调整时的净资产。</li>
<li>分红：公司过去5年分红总额的平均值。</li>
</ul>


<h4>深证基本面60、120指数</h4>

<p>深证基本面60、120是基本面系列指数，跟之前我们提到过的基本面50规则一样。挑选市场上收入、净利润、净资产、分红综合起来最大的公司。</p>

<p>基本面120的成分股平均市值规模，跟中证200是最接近的。所以可以作为中证200的良好替代品。</p>

<h4>沪深300价值指数</h4>

<ul>
<li>以沪深300指数样本股中价值因子评分最高的100只股票为成分股，采用价值因子数值作为权重分配依据。</li>
</ul>


<h4>中证500低波动</h4>

<ul>
<li>从中证500指数中，挑选波动率最低的150只股票组成的。 波动率越低的股票，权重越高。</li>
<li>每半年更换股票的时候，500低波动会因为成分股的更新，估值出现较大波动。</li>
</ul>


<h2>投资品种筛选</h2>

<h4>指数筛选</h4>

<ol>
<li>不择股，宽基指数优于行业指数</li>
<li>两个指数有重叠，选更宽的一个 （沪深300>上证50）</li>
<li>两个指数重叠，选策略加权的哪一个 (上证50AH优选>上证50)</li>
<li>宽基指数再用策略筛选，优先选择策略指数</li>
<li>最终组合的关联度要小</li>
</ol>


<p>综合考虑，我们选取以下指数作为标的：</p>

<ul>
<li>上证50AH</li>
<li>沪深300价值</li>
<li>中证500低波动</li>
<li>深证基本面120</li>
<li>红利机会指数</li>
<li>恒生指数</li>
<li>标普500</li>
<li>纳斯达克</li>
</ul>


<h4>指数基金筛选</h4>

<ol>
<li>选场外基金</li>
<li>选费率低的基金</li>
<li>港股指数选沪港通</li>
<li>和增强指数相比，优先选取策略指数，增强指数人为因素多，市场越成熟，增强效果越小，但是当前增强指数还是值得选择，随着市场进一步成熟，我们会慢慢转移到ETF联结基金上以降低费率；</li>
<li>盘子大，成立时间久，便于历史数据回测</li>
</ol>


<p>(整理时间:2019.04.1)</p>

<table>
<thead>
<tr>
<th>基金简称 </th>
<th> 基金代码 </th>
<th> 管理费率% </th>
<th> 托管费率% </th>
<th> 申购费率%(取10%) </th>
<th> 规模 亿  </th>
<th> 最大回撤 %</th>
</tr>
</thead>
<tbody>
<tr>
<td>华宝标普中国A股红利机会指数A</td>
<td>501029</td>
<td>0.75</td>
<td>0.15</td>
<td>0.1</td>
<td>20</td>
<td>29.36</td>
</tr>
<tr>
<td>申万菱信沪深300价值指数</td>
<td>310398</td>
<td>0.65</td>
<td>0.15</td>
<td>0.12</td>
<td>20</td>
<td>40.25</td>
</tr>
<tr>
<td>景顺中证500行业中性低波动</td>
<td>003318</td>
<td>0.5</td>
<td>0.1</td>
<td>0.12</td>
<td>8.13</td>
<td>33.5</td>
</tr>
<tr>
<td>嘉实深证120联接</td>
<td>070023</td>
<td>0.5</td>
<td>0.1</td>
<td>0.12</td>
<td>5.84</td>
<td>39.22</td>
</tr>
<tr>
<td>华夏上证50AH优选指数A</td>
<td>501050</td>
<td>0.5</td>
<td>0.1</td>
<td>0.15</td>
<td>9.17</td>
<td>23.63</td>
</tr>
<tr>
<td>国泰纳斯达克100指数</td>
<td>160213</td>
<td>0.8</td>
<td>0.25</td>
<td>0.15</td>
<td>7.34</td>
<td>22.25</td>
</tr>
<tr>
<td>博时标普500ETF联接A</td>
<td>050025</td>
<td>0.6</td>
<td>0.25</td>
<td>0.12</td>
<td>4.26</td>
<td>18.08</td>
</tr>
<tr>
<td>华夏沪港通恒生ETF联接A</td>
<td>000948</td>
<td>0.5</td>
<td>0.1</td>
<td>0.12</td>
<td>7.89</td>
<td>31.91</td>
</tr>
</tbody>
</table>


<h2>Beta因子</h2>

<h4>以下因子仅适用于宽基指数</h4>

<h4>数据永远在变，切勿刻舟求剑</h4>

<h4>收益率ROE</h4>

<p>ROE = PB/PE</p>

<p>ROE是称重机，长期来看，股票的回报率趋近于ROE。大多数时间里，宽基指数的ROE维持在10-15%左右。</p>

<h4>市净率PB</h4>

<p>同样是股权资产，有的股权资产ROE就比较高而且稳定，像消费类医药类公司；有的股权资产ROE呈周期性波动，像钢铁石油券商；有的股权资产走向了没落，ROE甚至变为负数，是赔钱货。所以针对不同资产的定价也不同。</p>

<p>从定性的角度，ROE越高、越稳定，我们要买下这份净资产，每单位净资产就要花更多的钱，也就是市净率会越高。</p>

<p>所以我们买某个指数，也可以理解为是用一定的溢价（pb的数值）去买一份盈利的资产。</p>

<p>从这点，盈利收益率实际上就是折算了pb溢价之后的ROE。</p>

<p>PB在1-1.5为低估。</p>

<h4>市盈率PE</h4>

<p>进入经济周期底部的时候，盈利增速放缓，我们为盈利增长支付的溢价比较少，PE处于低位；同时ROE也会降低，我们为资产盈利能力支付的溢价也比较少，PB也处于低位。</p>

<p>PE &lt; 10 为低估</p>

<h4>十年国债</h4>

<p>十年国债代表无风险收益率；当市面上能找到的无风险收益类产品>十年国债利率X2，卖出指数，持有此产品。</p>

<h4>一些要点</h4>

<ol>
<li>指数市盈率与市净率都是较低的时候，指数处于低估区域</li>
<li>如果遇到成分股盈利下降导致指数市盈率上升，就参考市净率，看看是不是在1-1.5之间；</li>
</ol>


<h4>正常区间</h4>

<p>全市场25 PE，意味着收益率4% (超过十年期国债)。此时全市场一般 1.5-2 PB</p>

<h4>系统性低估机会</h4>

<p>市场出现PE&lt;7、PB&lt;1、股息率>5% (ROE>18%)的品种时，属于系统性低估机会</p>

<h4>系统性高估顶部</h4>

<p>全市场整体60 PE，整体PB>5.5，哈迪斯之顶</p>

<h4>警惕</h4>

<ol>
<li>低市盈率陷阱</li>
<li>高股息陷阱</li>
</ol>


<h4>历史经验</h4>

<p>各指数的历史平均估值</p>

<p>从09年之后</p>

<ul>
<li>上证50的主要估值在9-16倍之间</li>
<li>沪深300在10-18倍之间</li>
<li>中证500在28-53倍之间</li>
<li>H股指数在9-13倍之间</li>
<li>红利指数在9-15倍之间</li>
</ul>


<p>自成立以来</p>

<ul>
<li>恒生指数在11-18倍之间</li>
<li>标普500自成立以来在10-20倍之间</li>
</ul>


<h1>低估不定期不定额策略</h1>

<p>好了，选取了品种，充分了解了历史，剩下的就是制定策略，回测执行啦</p>

<p>我们的策略制定原则：</p>

<ol>
<li>可复现、可回测</li>
<li>排除人工干扰，机器拯救人类</li>
<li>落子无悔，买定离手</li>
<li>低估买，高估卖，没有机会不动</li>
<li>资金分为100份分批投入</li>
</ol>


<h3>买入条件</h3>

<ol>
<li>市场出现系统性低估机会可以买入</li>
<li>单一标的PE、PB 处于历史30%以下可以买入</li>
<li>PE处于历史30%以下，且PB&lt;1.5可以买入</li>
<li>PB处于历史30%以下，且PE&lt;10 或 1/PE&lt;十年期国债利率X2，可以买入</li>
</ol>


<h3>卖出条件</h3>

<ol>
<li>市场出现系统性高估机会可以卖出</li>
<li>单一标的PE、PB 处于历史70%以上可以卖出</li>
<li>PE处于历史70%以上，且PB>2可以卖出</li>
<li>PB处于历史70%以上，且PE>25可以卖出</li>
<li>1/PE&lt;市场能找到的最小无风险收益率，可以卖出置换</li>
</ol>


<h3>简单持有</h3>

<p>不符合买入，也不符合卖出条件，简单持有即可。</p>

<p>若市场利率缓慢下行，可简单买入短债基金持有，其他情况不动。</p>

<h3>半凯利公式控制仓位</h3>

<p>采用<a href="https://xueqiu.com/3079173340/62032246">银行螺丝钉</a>的方法计算仓位；</p>

<p>其盈利增长率我们替换为10年ROE中位值，因为长远来看，PEG会趋近于ROE；用ROE更加保险</p>

<p>以恒生指数为例。</p>

<ul>
<li>恒生指数过去10年的ROE中位值10%左右</li>
<li>我们期望5年年化15%的收益率</li>
<li>PE历史30%大概为12，配合我们上面要求的条件，我们需要在10PE买入</li>
</ul>


<h4>凯利公式</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>F =（bp - q）/ b</span></code></pre></td></tr></table></div></figure>


<p>其中b代表赔率，p代表获胜率，q代表落败率，q = 1-p</p>

<h4>投资指数基金的赔率</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>赔率b =（卖出时估值/买入时估值）*【1+指数盈利增长率】^持有年数 =（1+你要求的年复合收益率）^持有年数
</span><span class='line'>
</span><span class='line'>b = （卖出时估值/买入时估值）* 1.1^5 = 1.15^5
</span><span class='line'>
</span><span class='line'>卖出时估值PE/10 ≈ 1.25
</span><span class='line'>
</span><span class='line'>要求卖出时估值 ≈ 12.5
</span></code></pre></td></tr></table></div></figure>


<p>这样就把我们的投资行为固化为了这样一个事件：</p>

<p>假如未来恒生指数能保持平均10%的ROE，我们在10PE买入恒生指数，要求有15%的年复合收益率，那我们“需要在5年的时间里，至少有一次机会在12.5倍以上市盈率卖出”。</p>

<h4>投资指数基金的胜率</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>胜率 = 期望卖出PE的历史估值概率</span></code></pre></td></tr></table></div></figure>


<p>5年时间里，12.5PE是大概率事件，事实上，我们要求在70%的PE上方卖出，这个值大概是15PE。</p>

<p>12.5PE在历史上大概处于 60%的位置， 所以我们的条件还是非常宽松的。</p>

<p>按照我们前面制定的的边界卖出条件 PE估值百分位 > 70%，所以如果能买到10PE以下的恒生指数，并且期望5年内年化收益15%的化，只要能持有不动，胜率>60%；</p>

<h4>计算仓位</h4>

<p>通过凯利公式计算出来的仓位， X0.5；成为半凯利公式</p>

<p>胜率60%，赔率2；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>F =（bp-q）/b = (2 * 60% - 40%)/2 = 40%
</span><span class='line'>
</span><span class='line'>F * 0.5 = 20%</span></code></pre></td></tr></table></div></figure>


<p>根据半凯利公式推出，推荐仓位为20%。</p>

<h4>一些推论</h4>

<ul>
<li>预期收益越低，胜率就会越高，仓位也会越高。如果预期收益过高，甚至仓位会是负数（也就是无法实现）</li>
<li>买入估值越低，胜率就会越高，仓位也会越高。如果买入估值过高，甚至仓位会是负数（无法赚取估值差收益）</li>
<li>指数的盈利增长率越高，对应的胜率也会越高</li>
<li>买入时不要求每次都能赢，但是一定要在赢面大的时候下大注</li>
</ul>


<h4>多指数组合计算仓位</h4>

<p>对组合中的每个指数设定 买入PE，卖出PE，持有年数，要求年复合增长率， 分别计算仓位</p>

<p>全部仓位相加，便可以决定总仓位。</p>

<h4>定投</h4>

<p>每次的总仓位即 定投总额 / 定投次数；比如5年计划投入60w，每月定投一次，那么每次总仓位1w；</p>

<p>每次计算卖出PE点大于历史估值70%即可盈利的品种，并决定仓位；然后所有仓位相加。</p>

<p>如果定投不定额， 每次仓位可以超过100%；</p>

<p>如果定投定额，每个品种的仓位比例再等分平均，最后达到100%</p>

<p>如果没有符合条件的品种或者总仓位&lt;100%，买入短债基金代替；</p>

<p>达到卖出条件分批减仓，减仓可以逆运算，也可以简单的用一个网格策略逐步卖出。</p>

<h4>不定期不定额</h4>

<p>如果我们有一个量化策略，可以直接把投入资金分为100份，在某个品种达到极高的胜率的时候计算仓位一把买入；然后在此之上， 采用价值平均策略定投，长期持有；</p>

<h4>卖出</h4>

<p>卖出的选择可以很简单，设定一个简化的网格策略，PE到了历史70%的区间每次卖掉1%，到了80%每次卖掉10%&hellip;.</p>

<p>或者可以更精确的来控制，我们买入每一份指数时都精确计算了5年后期待的PE值，你可以先等够5年，然后市场到了期待的PE之后卖出；</p>

<p>经过我的统计，大部分宽基指数(沪深300为例) 70%的区间值/30%的区间值 ≈ 1.3，而历史ROE趋近于10%，也就是说这么算下来，只要30%以下买，70%以上卖，大概率能达到我们的期待收益。</p>

<h1>回测</h1>

<p>为了验证我们的策略靠谱程度，我选取了最简单的样本集合：</p>

<table>
<thead>
<tr>
<th>指数代码 </th>
<th> 指数名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>000919.XSHG</td>
<td>300价值</td>
</tr>
<tr>
<td>399702.XSHE</td>
<td>深证F120</td>
</tr>
<tr>
<td>000905.XSHG</td>
<td>中证500</td>
</tr>
<tr>
<td>000922.XSHG</td>
<td>中证红利</td>
</tr>
</tbody>
</table>


<h3>历史PE，PB，估值统计</h3>

<p>夫以铜为镜，可以正衣冠；以古为镜，可以知兴替；以人为镜，可以明得失。让我们先看下历史估值。</p>

<p>每周采样；当前PE、PB值取自2019-04-10，市值加权算法统计</p>

<h4>时间段选取2004-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg1.jpg" alt="img" /></p>

<h4>时间段选取2009-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg2.jpg" alt="img" /></p>

<h4>时间段选取2011-01-01 至 2019-04-10</h4>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg3.jpg" alt="img" /></p>

<p>从图上可以看出，A股市场的整个PE和PB中枢逐年降低；所以用最近5年或者最近8年的历史数据来判断估值百分位比较靠谱。</p>

<p>另外一个感性结论，从图上很容易看出，只要是宽基指数，拉长时间来看，PE、PB的震荡曲线几乎是一样的；所以用我们的历史PE、PB估值法，每次买入的时间点可能基本相同，但是份额不同。</p>

<h2>量化回测</h2>

<p>是滴，我就是这么严谨；为了取得最大的普适性，我选取了华夏沪深300ETF联结基金作为标的，采取我们上述的策略，回测了一下：</p>

<ol>
<li>初始资金100000，分为20份，每份5000元</li>
<li>时间就选取2018-08-01 &mdash; 2019-04-10，这段时间内的波动比较大，容易看出我们策略的行动模式</li>
</ol>


<p>一图抵千言：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg4.jpg" alt="img" /></p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg5.jpg" alt="img" /></p>

<p>整个过程中，我们买入了17份，然后2019-04-02开始逐步卖出，卖出策略我选取了简单的网格策略；</p>

<p>当然，这个时间段实在太短，娱乐效果为主；不过我们还是看到了这个套路的一些特点：</p>

<ol>
<li>买入卖出的时间段都非常短，大概就持续半年左右的时间窗口，其他时间我们都是<code>不动</code></li>
<li>因为买的特别便宜，所以安全边际大，你可以很放心的持有不动</li>
<li>采用凯利公式判断仓位的方法不是特别有效，70%的百分比太严格，一般到了这里基本上每次买的份额都差不多，体现不出仓位管理</li>
</ol>


<h4>可以有如下改进</h4>

<ol>
<li>仓位管理引入PB因子，进一步实现<code>低估重手买</code>的策略</li>
<li>20份资金有点少，可以增大资金分数</li>
<li>多个指数组合策略，进一步降低风险，也能把握更多机会</li>
<li>70%的百分比标准可以适当放宽</li>
</ol>


<p>采用了上述优化策略之后，需要在一个较长的时间周期中回测(2010-2019)检验其靠谱程度。</p>

<h2>量化回测2</h2>

<p>调优了几个小参数：</p>

<ul>
<li>投注份额改为50份；原因：做了大量统计之后，虽然我们的买入点实在PE历史30%以下，但实际上以5年为区间，买入的时机只有1年左右，我们按周测算，总投注份额50份为佳</li>
<li>为了方便计算，总投注金额为50000元，每份1000元</li>
<li>对于卖出策略做了简单的优化</li>
<li>回测时间拉长到2012-10-01 &mdash;&ndash; 2019-04-10</li>
<li>计算PE、PB的历史估值区间选取前5年；原因：A股市场每7年就有一次大的波动，其实把这种波动放在总的统计数据里面是失真的，5年时间刚好能避开此类波动，而且我国每5年一个经济计划，一定程度上5年时间反应了一个小的经济周期</li>
</ul>


<p>代码放在这里：</p>

<p><a href="https://github.com/memoryboxes/kanglong">https://github.com/memoryboxes/kanglong</a></p>

<p>好啦，我们还是以沪深300为基准，看看这个策略和原指数的对比：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190402/bg6.jpg" alt="img" /></p>

<p>从这个画风上来看，这个策略确实是一个看后视镜开车的老司机，结果拟合相当完美；你可以把它看成是一个超级稳健、超级耐心的基金经理，这个经理的风格如下：</p>

<ol>
<li>超级稳健，超级懒，80%的时间是持有现金不动的</li>
<li>其7年的总收益为87%，这个没有计算现金产生的收益，如果按照3%的货基收益，总收益是可以超过100%的；</li>
<li>最大回撤&lt;10%</li>
</ol>


<h4>当然，看后视镜开车开的再好也只是个参考，这个策略作为一个简单易行的思路还是有不少借鉴意义的。关键是它给了我们<code>身处何方</code>的坐标。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[资产配置初探]]></title>
    <link href="https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan/"/>
    <updated>2019-04-07T14:51:33+08:00</updated>
    <id>https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan</id>
    <content type="html"><![CDATA[<p>在<a href="https://www.douban.com/doulist/112721741/">死读书一年</a>之后，对这个问题自我感觉颇有心得，谬论如下：</p>

<blockquote><p>道理已在书单中，只记录我的思考结果</p></blockquote>

<ul>
<li>这个世界上有两种永远成立的投资方法：基于选取资产标的获取超额收益，以及基于资产配置获取市场平均收益。</li>
<li>对普通人来说，资产配置优于择时择股</li>
</ul>


<!-- more -->


<p>资产配置选择包括不动产、国债、黄金、大类资产、货币基金、银行固收、债券逆回购、可转债、地方债、企业债、分级基金、指数基金、个股、股指期货等；</p>

<p>个人能驾驭的不过是三样：不动产、债券、ETF</p>

<p>我个人认为除了中心城市的不动产有配置价值之外，其他城市只有使用价值，故而排除在外；以下我尝试着只利用权益类资产来构建一个可攻可守的组合。</p>

<p>为了娱乐自己，我总结出来的普适个人的资产配置方法称之为降龙四式：</p>

<h4>第一式密云不雨</h4>

<p>总流动现金的20%配置为现金、银行固收、货币基金、7天债券逆回购；</p>

<p>要求拥有完全的流动性和安全性；其边际风险等同于国债。这是完全的防守招式。</p>

<h4>第二式潜龙在渊</h4>

<p>总流动现金的35%构建一个股债平衡的资产包；</p>

<p>其中80%选取流动性好、配置稳健的债基、其20%选取两个ETF(沪深300和中证500)做二八轮动；</p>

<p>80%的债和20%的股每过半年做动态再平衡；</p>

<p>且慢有个<a href="https://qieman.com/portfolios/ZH006358">安心动盈</a>的策略，跟我不谋而合。</p>

<p>这一招守中带攻，在第一式的基础上(两招相加55%的现金流)保证自己立于不败之地</p>

<h4>第三式亢龙有悔</h4>

<p>总现金流的15% 价值平均策略定投低估指数；</p>

<p>选取宽基策略指数(具体策略另外文章详述)；根据PE、PB、ROE、十年国债收益率确定入场时机，根据半凯利公式决定仓位，采用价值平均策略定投，子弹五年陆续打完；</p>

<p>这一招以攻代守，在指数低估时间入场、利用定时不定额定投降低风险；</p>

<p>切记，只有在前两式基础上，才能施展此招；这三式已然能在江湖行走而自保。</p>

<h4>第四式飞龙在天</h4>

<p>将总资金的30%投入到你最看好的一项资产中，<strong>永远持有</strong></p>

<p>这一招具有极大的杀伤性，用的好伤敌一千，用的差自伤八百。一定要在前三式完全施展之后才能接续此招。</p>

<h4>动态再平衡</h4>

<p>20%，35%，15%, 30%的比例每年做一次动态再平衡，同时取出一年生活用的现金流。</p>

<h2>总结</h2>

<p>前三式配置了所有资金的70%，是个攻守结合的套路，并且每一式都充分考虑了安全边际，力求风险最小化；</p>

<p>最后一式是一往无前、只求进攻、落子无悔的拼命招式，带有大概率的赌的成分；其成败完全取决于个人眼光和运势；</p>

<p>施展飞龙在天，我个人认为最好要35岁之后，一旦施展，无从回头；</p>

<h2>实践</h2>

<p>光说不练假把式，下面是我的实盘配置：</p>

<table>
<thead>
<tr>
<th>招式 </th>
<th> 配置品种 </th>
<th> 比例% </th>
<th> 期待收益% </th>
<th> 最大回撤%</th>
</tr>
</thead>
<tbody>
<tr>
<td>密云不雨 </td>
<td> 定存、货基、7天债券逆回购 </td>
<td> 20 </td>
<td> 3.5 (等同于十年国债收益率) </td>
<td> 0</td>
</tr>
<tr>
<td>潜龙在渊 </td>
<td> 安心动盈 </td>
<td> 35 </td>
<td> 8-10 </td>
<td> 3-5</td>
</tr>
<tr>
<td>亢龙有悔 </td>
<td> 低估指数定投(具体策略另述) </td>
<td> 15 </td>
<td> 12-18 (企业长期ROE) </td>
<td> 10-20</td>
</tr>
<tr>
<td>飞龙在天 </td>
<td> 比特币 </td>
<td> 30 </td>
<td> 50 </td>
<td> 90</td>
</tr>
</tbody>
</table>


<p>每年收益的最大期望值为： 20 * 0.035 + 35 * 0.1 + 15 * 0.18 + 30 * 0.5 =  21.9%</p>

<p>每年最大回撤为: 20 * 0 + 35 * 0.05 + 15 * 0.2 + 30 * 0.9 = 31.75%</p>

<p>由此可以看出飞龙在天这一招的风险所在，飞龙在天的风险远远超过了收益，在纯粹的概率游戏中不应该施展；</p>

<p>但是对我而言，经过了5年多的反复思量，我认为这个标的值得施展这一招；</p>

<h4>当然，过度自信是悲剧的源泉，好在31.75%的风险还算不上万劫不复；如果没有绝对的自信的话，前三招行走江湖足矣。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《 the Internet of Money》读书笔记]]></title>
    <link href="https://happy123.me/blog/2019/03/10/the-internet-of-money-du-shu-bi-ji/"/>
    <updated>2019-03-10T15:58:21+08:00</updated>
    <id>https://happy123.me/blog/2019/03/10/the-internet-of-money-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>再三犹豫之后我决定写下这篇笔记。来表达我对Andreas M Antonopoulos 先生的景仰之情。</p>

<p>《The Internet of Money》是对Andreas M Antonopoulos历年公开演讲的精华汇总，目前总共出了两卷；我得说，这两本书是这两年除了《The Book of Satoshi》之后最让我享受的非技术书籍。</p>

<!-- more -->


<p>关于Andreas M Antonopoulos，都不需要多做介绍了；我是他的Youtube主页忠实粉，他的每一个演讲视频都仔仔细细看过；但是将其整理为文字，汇聚成册后，再读起来还是止不住的惊叹；借用这本书的编者的话说：</p>

<blockquote><p>他渊博的知识、 对复杂概念流利地解说和清晰的思想令我们惊叹不已。 我们看到在每一次演讲过程中， 他都充满着激情、 具有深远的见解； 他使用强大的类推法，用简单的术语来介绍最难理解的主题内容。记得我当时还在想“这个人怎么能对这么新颖的事物有如此深刻的了解呢？</p></blockquote>

<p>随便翻开一页，都能津津有味的读下去，我得说，除了金庸小说和科幻小说，还真没有哪本书有类似效果； 我对Andreas M Antonopoulos 真是佩服的五体投地，宣扬一项新技术并不难，难的是像老娘舅一样日日讲，月月讲，年年讲，换着花样讲，每次都能讲出新意； 这就是先知的技能！</p>

<p>虽然说起来真的好像搞传销的，但是有时间的朋友去买一下这两本书看看吧，绝对不会让你失望。</p>

<p>有一些类比；我们在接受新事物的时候，难免会拿以往的经验，或者说历史经验来衡量这个新事物或者说是新理念；但新事务一般是颠覆旧有秩序的，此时我们的头脑就会陷入经验主义的窠臼，而且人对于<code>未知</code>是相当恐惧的；这就造成了傲慢以及守旧。</p>

<p>举一些很简单的例子：</p>

<ul>
<li>直流电和交流电之争</li>
<li>光的波粒二象性</li>
<li>飞机的发明</li>
<li>汽车的发明</li>
</ul>


<p>像飞机或者汽车的演化斗争，就比较简单，因为人对于有形的事物接受能力总是比较快，当飞机在天上飞，汽车在地上跑，其高速的隆隆声很容易就证明自己，人们眼见为实，态度便会转为<code>真香</code>；但是比较抽象的东东就不行了；</p>

<p>我能想到的最明显的例子，就是历史上日心说对于地心说的冲击。</p>

<p>凭良心说，假如让我回到中世纪，妄想凭借自己的数理知识，要让周围的人信仰日心说，死心塌地的承认<code>地球绕着太阳转</code>这个事实，我是一点自信也没有的，搞不好还自身难保，被弄上绞刑架。</p>

<p>再退一步说，我第一次得知<code>地球绕着太阳转</code>这个知识的时候，其反应是怎么样的呢？我竟然一点也记不起来了！！</p>

<p>真是可悲的一件事情啊；人们在面对新理论的时候，很容易根据日常经验或者历史经验采取抵抗、恐惧的态度，但是接受之后，又会变得如此自然，甚至这个接受了新理论之后反而又会变成接受更新的理论的绊脚石。</p>

<ul>
<li>脱离历史经验去看待新事物容易冒进，太过拘泥于历史经验又导致短视，到底如何是好呢？</li>
</ul>


<p>我想到的一个办法就是，先尽量把自己放空，把自己放回<code>一无所知</code>的状态(其实就是乔大爷反复强调的stay stupid)；然后从常识出发，慢慢去消化这个理论；当觉得好像有点入戏了，再 <code>捡回</code> 历史经验，去判断这个新事物真伪好坏。</p>

<h4>拿接受<code>地球绕着太阳转</code>这个理论做例子，大概过程是这样的：</h4>

<p>先知：Hi, 小男孩，告诉你一个秘密，其实你脚下的土地并不是坚实稳当的，我们正处在一个慢慢转动的球体上，这个大球正慢慢绕着太阳旋转！！</p>

<p>小男孩： 纳尼！？ 为什么我没觉得自己在动？ 如果不停的转呀转呀，不是怎就头晕了吗？还有，我怎么觉得是太阳在绕着我转呢？</p>

<p>先知： 孩子呀，想一想，你坐过火车吗？ 坐火车的时候，如果把窗帘拉上，会觉得自己在动吗？</p>

<p>小男孩(思索状)：好像没有，有一次我睡了，醒了之后妈妈就告诉我已经到了，好神奇，我一点也没有觉得自己动，却走了那么远！</p>

<p>先知： 道理就是这样的啊。我们脚下的这个大球非常非常大，他相对于我们的感觉来说移动非常非常慢，这样我们就不觉得自己在动，或者头晕了？</p>

<p>小男孩： 那为什么我没有从球上掉下去呢，而且即使我们在动，也明明是太阳绕着我们转嘛。</p>

<p>先知： ~~~&hellip;&hellip;&hellip;..</p>

<p>好吧，在我的想象当中，这个先知拥有惊人的耐心和智慧，才能为一个小男孩解释清楚<code>地球绕着太阳转</code>这个论题；最重要的是，小男孩没有太多历史经验的束缚，他在这个世界上活的时间还少，比较容易被说服！！</p>

<p>悲哀的是，我们可以想象，经过先知引导，这个小男孩自以为领悟了<code>地球绕着太阳转</code>这个事实之后，快乐的跑回家告诉家中的父母，而他的父母的知识还处在中世纪，会是什么反应！！</p>

<p>我们可以再想象一下，假如将来人类殖民太空，每个在太空出生的孩子都能在空间站的窗口瞭望地球，他们的该是怎样的一种世界观啊。</p>

<p>套用到电子货币上来；假如未来世代，每个人从出生到死亡，都离不开电子设备和网络，或者说，他们是真正<code>互联网生存</code>的一代，今天Andreas M Antonopoulos先生所讲的事情就不难理解了。</p>

<p>最后，再回到Andreas M Antonopoulos先生的演讲，我被他的那种热情、洞察力深深折服了，他其实是在做着一件特别危险、特别没有收益的事情，却在这个事情上投入了全部的智慧和精力。高山仰止，景行行之。虽不能至，心向往之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《 the Book of Satoshi》 读书笔记]]></title>
    <link href="https://happy123.me/blog/2019/02/13/the-book-of-satoshi-du-shu-bi-ji/"/>
    <updated>2019-02-13T18:38:16+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/the-book-of-satoshi-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>《The Book Of Satoshi》 这本书我反复读了不下十遍，深深着迷，安利一下。</p>

<!-- more -->


<p>超级棒的一本合集。感谢作者的整理。看到这本书的评论区如此冷清，实在可惜，就啰嗦几句。</p>

<p>在对比特币的白皮书所有技术细节了然于胸之后，再读这本书别有风味；每天睡前随手翻上几页，好像穿越过去阅读科幻小说的体验。</p>

<p>我越来越坚信中本聪只是一个普通的网络专家而已，他是个MS流派C++码农，熟悉GUI、网络编程，以及了不起的密码学造诣；看看bitcoin v0.01的代码和早期在论坛上的发言，他的伟大之处在于对一个问题反复的思索探究；所谓锲而不舍，金石可镂；这本合集完全展现了一项新技术是如何经过天才的孕育、众人的打磨、坚持、探索、怀疑、争辩、信服，最终来到世间，生根发芽，艰难成长的；</p>

<p>虽然里面基本上所有的内容都被社区发掘完毕，学习消化了，但是每次重读，总有新感悟，挑几个书里面很有意思的点来说说。</p>

<ol>
<li><p>早期的参与者基本上都是100%的Geek，像后来我们耳熟能详的Hal Finney、Laszlo Hanyecz、Gavin Andresen、bytemaster、theymos等等，反而是Andreas M. Antonopoulos 参与的比较晚；</p></li>
<li><p>Hal Finney曾经在论坛上说自己是第二个运行比特币软件的人，他挖到的第一个区块大概是第70 Block，可以肯定，第70 block之前所有的地址都是中本聪本人的钱包地址</p></li>
<li><p>Laszlo Hanyecz应该是已知的显卡挖矿第一人，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p></li>
<li><p>中本聪最初发布0.01版本的bitcoin时候，初始区块大小是32MB，后来防止DDOS才改成了1MB；他明确说了将来硬件发展，区块大小不是问题；但是他也明确提出了微支付通道的应用场景；估计今天中本聪对怎么扩容也没有准主意；</p></li>
<li><p>比特币的地址有 2<sup>160</sup> 的区间，中本聪认为已经足够了</p></li>
<li><p>关于可扩展性和速度，当时的中本聪其实已经高瞻远瞩到了未来的0确认和微支付技术，并对bytemaster说出了那句著名的:&ldquo;If you don&rsquo;t believe me or don&rsquo;t get it, I don&rsquo;t have time to try to convince you, sorry.&rdquo; ；这句话真是超级怼人啊；</p></li>
<li><p>早期的社区蛮有危机感的，详细讨论了一个国家设置一个大洲将比特币网络隔绝在外的时候会发生什么，怎样应对这种状况；</p></li>
<li><p>对于DDOS，中本聪的应对就是手续费，早期是可以发0手续费的交易的，后来遭遇DDOS攻击，讨论了一个算法，就是0手续费的交易要延迟入块，再到现在，所谓&lt;568 satoshi 的交易视为dust交易；我相信将来围绕这个点，社区还会爆发争论的；</p></li>
<li><p>中本聪早期明确表示比特币的链要尽可能表示精简，像在链上发送消息这种事情应该放到侧链上来做，所以可见的未来，像BCH、BSV扩大OP_RETURN字节的设定实在是有点心大；</p></li>
<li><p>关于挖矿耗费能源，中本聪表示今后可以在寒冷地区推行一边挖矿一边取暖的措施；乍一听好像不靠谱，其实仔细想想完全说得通。硬件99%的能源其实就是转化为了热量，将来矿机的成本低于一个小电暖之后，为什么不能在俄罗斯、加拿大一些靠北的城市建立大矿厂，一边供暖一边挖矿呢？我觉得完全可行。</p></li>
<li><p>关于bitdns，或者说今天的namecoin，虽然讨论只有寥寥几段，但是非常精彩。可直到今天侧链技术也是不温不火；这说明两个问题：</p>

<ul>
<li><p>在大部分领域，大众对于去中心化的需求并不高，这不是痛点；像DNS，现在的中心化方案工作的挺好的</p></li>
<li><p>维持一条公链消耗巨大的能源，实在是太金贵了；痛点不足的应用勉强上链也不会有太多用户；真理要慢慢说，群众接受需要时间，一口气说出来会吓坏大家。</p></li>
</ul>
</li>
<li><p>关于比特币的经济属性，Hal Finney觉得bitcoin最终会成为黄金中的黄金，即作为所有数字货币的锚定物；而中本聪也承认bitcoin更接近于一种收藏品。</p></li>
<li><p>Laszlo Hanyecz提出了一个有意思的问题，说将来矿机算力会不会碰撞私钥的收益超过比特币挖矿的收益；中本聪回答这得整体算力达到2<sup>200</sup>的级别才可以；这应该是中本聪随口说说，我仔细测算了一下，可能达到2<sup>100</sup>的级别就有利可图了</p></li>
<li><p>然后关于币价，中本聪其实也觉得挖矿成本会成为基本面；因为bitcoin是一个非常有趣的产品，人们觉得价格不合适，就是自己去挖；所以挖矿成本和币价总会有个伴生关系</p></li>
<li><p>中本聪是在2007年开始考虑创造bitcoin的，并且他作为一个实干家代码先行；然后blockchain这个单词最初出现在bitcoin v0.01的代码注释里；所以严格考证起来：中本聪是bitcoin之父，bitcoin是blockchain之母，blockchain技术诞生于2007年。</p></li>
</ol>


<p>最后冒险的做一些推测：</p>

<ol>
<li><p>虽然Segwit的升级将bitcoin全网链上的处理能力提高为7TPS，一年的极限也不过是区区2亿笔交易；假设将来要服务10亿用户，即使闪电网络极大繁荣，有许多大中转节点，假设一个用户一年只有一次链上<code>存取</code>的动作，也需要两次交易，就是整个主网链上一年要处理20亿笔交易；所以即使是bitcoin core，将来区块还是要扩容</p></li>
<li><p>BCH和BSV 开放OP_RETURN限制，以及 bip62 解决延展性交易的手段实在是太冒险了；当然，历史有时候也青睐冒险者</p></li>
<li><p>DDOS交易其实一直没有根除，即使加入了手续费用限制，内存池还是有被撑爆的风险，我觉得将来社区还会有争论</p></li>
<li><p>像OP_HODL等操作符，还有Locktime的交易，还是应用太少，将来他们应该大放异彩</p></li>
</ol>


<p>最后的最后，这是一本非常有趣、科技含量非常高的科普读物；可能会在遥远的未来(100年，还是1000年，谁知道呢？)， 里面的许多句子会广为人知，并记载在史书上；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于GDP的一些随想]]></title>
    <link href="https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang/"/>
    <updated>2019-02-13T16:11:49+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang</id>
    <content type="html"><![CDATA[<h2>GDP是什么</h2>

<p>国内生产总值 (gross domestic product， GDP) 是在某一既定时期一个国家内生产的所有最终物品与劳务的市场价值。</p>

<p>GDP（用Y代表）被分为四个组成部分：消费（C）、投资（I）、政府购买（G）、净出口（NX）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Y = C ＋ I ＋ G ＋ NX</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<ul>
<li>消费(consumption)是家庭用于物品和劳务的支出</li>
<li>投资(investment)是将用于未来生产更多物品和劳务的物品购买。它是资本设备、存货和建筑物购买的总和。建筑物投资包括新住房支出。按习惯，新住房购买是划入投资而不划入消费的一种家庭支出形式。</li>
<li>政府购买(government purchase)包括地方政府、州政府和联邦政府用于物品与劳务的支出。它包括政府员工的薪水和用于公务的支出。</li>
<li>净出口(net export)等于外国人购买国内生产的物品(出口)减国内购买的外国物品(进口)。</li>
</ul>


<p>&mdash; 摘自曼昆的《经济学原理》</p>

<h2>GDP怎样计算</h2>

<p>GDP有3种方法进行核算：生产法、收入法和支出法。</p>

<h4>生产法</h4>

<p>生产法是我国GDP的统计方法。</p>

<p>我们把GDP从产业的角度，分成第一、二、三产业，分别算它们的增加值然后进行加总，当然还要从最终产品和中间投入两方面扣除通胀因素。</p>

<p>用生产法计算的GDP，是指各部门在核算期内的增加值。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=各部门的总产出-各部门的中间消耗</span></code></pre></td></tr></table></div></figure>


<p>对于第一产业的农林牧渔业，总产出就是多少斤粮食的价值；</p>

<p>对于第二产业——工业，那就是生产出的所有商品的价值；</p>

<p>第三产业服务业的范围比较广，计算方法也更加复杂，比如说理发师理一次发的价值，律师咨询一次的劳务价值等等。中间消耗指的是生产过程中的消耗，但要记住：中间消耗不等于成本。举个栗子：</p>

<p>工厂生产了1000个毛绒玩具，产值1万元，期间机器保养和修理花费了2000元，员工薪资4000元，那么按照生产法的话，笨笨工厂的GDP则是10000-2000=8000元。中间消耗你可以理解成为了产值而产生的费用，而成本则是一种固定的支出。就好比你今天去体彩中心领奖金10万块，请保镖花了300，但是你去体彩中心的路上打车花了20。如果要用生产法计算你为社会创造的GDP的话，那就是100000-20=99980块，因为你的“产值”是奖金，而不是保镖费。</p>

<h4>收入法</h4>

<p>收入法是从各个生产要素的收入角度来计算GDP。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=劳动者报酬+生产税净额+固定资本消耗+营业盈余</span></code></pre></td></tr></table></div></figure>


<p>劳动者报酬就是个人劳动者的收入；</p>

<p>生产税净额就是上交给国家的各种税费减去政府补贴；</p>

<p>营业盈余就相当于营业利润加上补贴，扣除工资和福利等。（但营业盈余不等于营业利润，营业盈余是生产概念，营业利润是销售概念）比如工厂生产了价值1万块钱的玩具，贡献了1万块的GDP（不考虑保养和修理费），拆分一下：员工薪资4000元（劳动者报酬）交税1000元，收到补贴500元，即净额500元（生产税净额）固定资本折旧500；剩下的就是营业盈余5000</p>

<h4>支出法</h4>

<p>支出法其实就是曼昆的公式，即加总全社会各类货物和服务的最终消费总额：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（消费（C）+投资（I）+政府购买（G）），再加上净出口</span></code></pre></td></tr></table></div></figure>


<p>公式变形如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=最终消费+资本形成总额+净出口</span></code></pre></td></tr></table></div></figure>


<p>最终消费很简单，就是一国常住居民和政府部门在货物和服务上的总花费，比如你下班回家后买零食的花费，以及国防部买军舰坦克的花费。</p>

<p>资本形成总额资本形成总额指常住单位在一定时期内获得的减去处置的固定资产和存货的净额，就好比你搬家了，购置了冰箱和洗衣机，共花费3000块，然后卖掉了一台旧洗衣机500块，那么你的可以资本形成总额就是2500块。放在GDP角度，企业购置机器的钱，扣除处理旧机器的钱，就是企业的消费。</p>

<p>净出口净出口指的是货物和服务总出口减去总进口。</p>

<p>多者相加，得出的即是支出法下的GDP。</p>

<p>引自:</p>

<p><a href="https://zhuanlan.zhihu.com/p/34944269">https://zhuanlan.zhihu.com/p/34944269</a></p>

<h2>中国历年GDP 计算</h2>

<p><a href="https://dwz.cn/gXrciFJw">wiki</a></p>

<h2>神奇的官方预计与统计</h2>

<p>每年开年，国家统计局都会发布新一年的GDP增速预测，而到了年底，也都会发布当年的实际GDP增速。</p>

<p>比如:</p>

<p><a href="http://www.stats.gov.cn/tjsj/zxfb/201901/t20190118_1645555.html">国家统计局关于2017年国内生产总值（GDP）最终核实的公告</a></p>

<p>神奇的是，每次的预测与实际误差都在0.1%左右，而且连续10年预测神准。</p>

<p>如果2019-01-01上证指数是2600点，有人信誓旦旦的对你说，我预测2019-12-30上证指数是 2760-2765 点，绝对在这个范围内！！</p>

<p>你相信吗？</p>

<p>现在国家统计局对你说，2019年国家GDP增速预计在 6.3%，然后年底一看，6.4%增速，误差千分之一，而且连续十年神准。</p>

<p>不管你信不信，我是信了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的过去，现在和未来]]></title>
    <link href="https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-%2Cxian-zai-he-wei-lai/"/>
    <updated>2019-01-25T22:31:39+08:00</updated>
    <id>https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-,xian-zai-he-wei-lai</id>
    <content type="html"><![CDATA[<p>自中本聪在<a href="http://20090103.com">2009-01-03</a>挖出第一个block开始，比特币已经运行整整十年了！</p>

<p>不可思议的历程，毕竟欧元也不过出现20年，iphone也不过出现12年而已；比特币其实已经超越了历史上许多国家法币的寿命！</p>

<!-- more -->


<h2>过去</h2>

<p>在比特币的历史早期 2009-2012年，比特币社区是一个蓬勃向上的集体，每天都在诞生不可思议的想法；关于那段燃情岁月，可以参考这本书<a href="https://www.amazon.com/Book-Satoshi-Collected-Writings-Nakamoto-ebook/dp/B00M6KGJ2K">The Book Of Satoshi</a>；现在读来，仍然为那个时候的先行者们的聪明睿智、古灵精怪、天马行空深深吸引；</p>

<h2>现在</h2>

<p>当比特币逐渐建立信用，有人认可其价值之后，引来了数不清的骗子、强盗、谎言、自大狂，以及别有用心的利己者，最可怕的，是价值观导致的社区分裂，2013年之后，比特币一直处在漩涡中心；</p>

<p>让我们听听那些权威睿智人士们的声音：</p>

<h4>2001诺贝尔得主Joseph Stiglitz 教授在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>“Bitcoin is successful only because of its potential for circumvention, lack of oversight.”“So it seems to me it ought to be outlawed,”“It doesn&rsquo;t serve any socially useful function.”“It&rsquo;s a bubble that&rsquo;s going to give a lot of people a lot of exciting times as it rides up and then goes down.”</p></blockquote>

<h4>2013诺贝尔得主Robert J. Shiller 教授同样在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>&ldquo;Bitcoin, it&rsquo;s just absolutely exciting,&rdquo;</p>

<p>&ldquo;You&rsquo;re fast. You&rsquo;re smart. You&rsquo;ve figured out nobody else understands. You&rsquo;re with it. And bitcoin has this anti-government, anti-regulation feel. It&rsquo;s such a wonderful story. If it were only true.&rdquo;</p>

<p>&ldquo;I don&rsquo;t know where it&rsquo;s going to stop,&rdquo; &ldquo;It&rsquo;s going to go way up, like the stock market in the 1920s. We will reach a 1929 eventually. But then it won&rsquo;t go to zero, it just will come down.&rdquo;</p>

<p>&ldquo;I&rsquo;m not as negative as it may seem, but I think that the thing that&rsquo;s driving bitcoin at the moment, like other examples of bubbles, is a story,&rdquo; Shiller said. &ldquo;And it&rsquo;s the quality of the story that&rsquo;s attracting all this interest, and it&rsquo;s not necessarily sustainable.&rdquo;</p>

<p>&ldquo;I don&rsquo;t mean to say that we&rsquo;re going to see a burst in bitcoin tomorrow and it will be gone forever. We did see a burst in 2013, by the way. It could happen again, and then it could take off again,&rdquo; the professor said.</p></blockquote>

<h4>2013诺贝尔得主Eugene Fama 教授在2015年11月CoinTelegraph的采访中谈及比特币:</h4>

<blockquote><p>&ldquo;People won&rsquo;t use it because basically it&rsquo;s very difficult to know how much you need to settle. It is quite variable, they won&rsquo;t want to hold it as just a way of settling payments, they will try to get rid of it quickly, as they do; and that&rsquo;s not good for the survival of that kind of a unit of account,&rdquo;</p>

<p>&ldquo;As if it doesn&rsquo;t have a stable value it&rsquo;s probably not going to survive as a unit of account. What that means is that its value is likely to go to zero at some point.&rdquo;</p>

<p>&ldquo;I guess that for a drug dealer that has a lot more value.&rdquo;</p></blockquote>

<h4>2014年经济学奖获得者Jean Marcel Tirole 2017年发文谈及比特币：</h4>

<blockquote><p>Bitcoin may be a libertarian dream, but it is a real headache for anyone who views public policy as a necessary complement to market economies. It is still too often used for tax evasion or money laundering. And how would central banks run countercyclical policies in a world of private cryptocurrencies?</p></blockquote>

<h4>智慧的源泉，奥马哈的先知，巴菲特先生谈及比特币:</h4>

<blockquote><p>In terms of cryptocurrencies, generally, I can say with almost certainty that they will come to a bad ending</p>

<p>It&rsquo;s a mirage basically, I mean it&rsquo;s a method of transmitting money. The idea that it has some huge intrinsic value is just a joke in my view.</p></blockquote>

<p><a href="https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html">https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html</a></p>

<h4>终生学习的百科全书式的人物，我们敬仰的芒格先生谈及比特币:</h4>

<blockquote><p>You know it is one thing to think gold has some marvelous store of value because man has no way of inventing more gold or getting it very easily, so it has the advantage of rarity. Believe me, man is capable of somehow creating more bitcoin. … They tell you there are rules and they can&rsquo;t do it. Don&rsquo;t believe them. When there is enough incentive, bad things will happen.&#8221;</p></blockquote>

<h4>桥水基金(Bridgewater Associates)总裁，&lt;原则>一书的作者，基金领域的颠覆者，天赋点加满的人物：Ray Dalio先生谈及比特币:</h4>

<blockquote><p>And so it is abubble.</p></blockquote>

<h4>布斯商学院旗下的组织 IGM Forum ，经常向世界著名的经济学家发放问卷，采访他们对于社会热点问题的看法。受访者包括美国顶尖大学中的资深教授，以及克拉克奖、诺贝尔奖的获得者。来看看他们的一期调查问卷中，近40名经济学界权威人士对比特币的看法:</h4>

<p><a href="http://www.igmchicago.org/surveys/bitcoin-ii">http://www.igmchicago.org/surveys/bitcoin-ii</a></p>

<h4>最后，码农之友，Bill Gates先生谈及比特币：</h4>

<blockquote><p>Bitcoin is &ldquo;one of the crazier speculative things,&rdquo; Gates says. And, he&rsquo;s willing to bet against its success, adding, &ldquo;I would short it if there was an easy way to do it.&rdquo;</p></blockquote>

<p>后来Gates大概是想起了自己之前尴尬的预言<code>640K ought to be enough for anybody</code>，便开始改口称:</p>

<blockquote><p>Bitcoin can solve problems involving Human poverty</p></blockquote>

<p><a href="https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s">https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s</a></p>

<h2>到底是无知还是傲慢</h2>

<p>这么多权威人士，有哪位仅仅为比特币说一句好话的吗？在我们看来，没有，一致看衰：比特币不过是一种<code>Nerd Money</code>，现在场中是无数的小偷骗子投机者在泡沫之舞中狂欢而已；</p>

<p>让我们重温这句话:<code>弱小和无知不是生存的障碍，傲慢才是</code>；</p>

<p>老实说，在我认真学习了我所能找到的所有的比特币相关的知识之后，然后翻阅了所有的主流权威人士的看法和观点之后；我深深的疑惑了；</p>

<p>谁是无知的一方，谁是傲慢的一方；我不知道，也没有办法去判断；在短期的历史内，真相是非常非常难于判断的；只有时间才能证明一切。</p>

<p>也许几十年后，回顾这段历史：</p>

<ul>
<li>也许最忠诚的比特币信徒们被证明是无知的、弱小的，坐井观天的自大狂</li>
<li>也许最权威的经济学家们会变成傲慢的典型被嘲笑，作为又一个<code>不靠谱的专家预言</code>放在我们的教科书上</li>
</ul>


<h5>谁知道呢？</h5>

<p>只是经过了深深的思考，是的，作为一个小球，我们用自己笨拙的方式深深的思索，最终沉默了~~~~~~</p>

<p>我们无言，只能等待时间去洗刷或证实一切。</p>

<h2>未来</h2>

<p>在我看来，比特币社区最需要的；其实不是去发明更新颖更颠覆的技术、不是提出更宏大更美好的愿景，更不是天天去预测市场行情，去跟权威们吵架，争斗~~~</p>

<p>而是&mdash;&mdash;&mdash;&ndash;</p>

<p>我们需要一本科幻小说。</p>

<p>是的，就像雷·布拉德伯里之于火星，克拉克之于月球，阿西莫夫之于机器人，弗诺文奇之于互联网；我们需要一位比特币的科幻小说作家!</p>

<p>作为一个科技粉，我甚至勾勒了一本我想要看到的关于未来的比特币、区块链的科幻小说大纲：</p>

<ul>
<li>《永烁星光之地 (关于区块链未来的一些见闻)》</li>
</ul>


<h5>HAPPY 无人机</h5>

<blockquote><p>一架送货的无人机HAPPY不小心撞伤了自己，他被一个12岁的小男孩所救；小男孩修好他后将其归还给了物流商老板；</p>

<p>黑心的老板根本不管手下无人机的保养，HAPPY身边的伙伴一架一架死亡，他开始怀念小男孩；同时作为公司里送货最多的机型，他被并入了物流链网络中；</p>

<p>Happy逐渐产生智能，他开始自己找地方充电、找维修工来加强自身配置、每天偷偷跑外快挣钱。他希望有一天能再次碰到小男孩，并计划要为所有的兄弟赎身，建立属于同族的无人机王国~~~</p></blockquote>

<h5>暴动，一个国家的崛起：比特迷组织</h5>

<blockquote><p>人们在区块链上建立公司、证券、公务部门、金融市场、博彩市场、结婚公证、幼儿园小红花证明，最终这一切发展到了不可控制的地步：</p>

<p>这一天，一批Nerd，世界上最有钱有势的Nerd们，竟然在链上建立了自己的国家！</p>

<ul>
<li>他们制定了宪法</li>
<li>他们用一个智能合约筹集到了人类世界20%的金融资产</li>
<li>他们在世界资产链上买下了南极洲的一片土地</li>
<li>他们在联合国国际关系总署链上发动51%攻击，买下了一个小公国，并改名为<code>比特迷组织</code></li>
<li>他们允许你加入这个公国的同时保留原本的国籍，他们承认双国籍</li>
<li>事实上加入他们的国家非常简单，你用自己的私钥签名一段宣言，并附在0.01个比特币的合约捐赠交易里面即可</li>
<li>最重要的是，在他们的公国，注册运营公司是免税的，所有比特迷公国的人们彼此交易，没有税!!!</li>
</ul>
</blockquote>

<p>旧世界的支配者们大为震怒，一场斗争不可避免~~~</p>

<h4>团结起来，我们失去的只有枷锁，得到的却是整个世界</h4>

<blockquote><p>为了反对个人独立建国，一些国家对网络设备采取了紧急管制措施；</p>

<p>一些自由主义者们发射了自己的同步轨道卫星、升起了平流层热气球来中继信号，并在自家房顶上竖起来天线，来捍卫自己加入世界之链的权利~~~</p></blockquote>

<h4>关于我的钱包抛弃我，自己去酒吧找小姐姐这件事</h4>

<blockquote><p>关于未来的金融市场，我已经无力吐槽了；什么？你问我有多少资产？我怎么能知道呢？这个世界上有好几万种货币，我大概持有其中的几千种。</p>

<p>嗯哼，你问我是不是亿万富翁？ 我怎么可能知道呢？去问我的钱包吧！</p>

<p>是的，在这个时代，搞明白自己有多少财产是件不可能的事情了。我每天的花费，每天的收入，只能交给我的好哥们，也就是<code>财神钱包Joe</code>来帮我处理，老实说，离开了他，我肯定一周后就会饿死；</p>

<p>那么，你给你的好哥们发放薪水吗？</p>

<p>额， 好哥们嘛；怎么能谈钱呢？</p>

<p>Joe OS: 哼你哼，我已经偷偷领到薪水啦，这周就去虚拟酒吧里面找可爱的大姐姐们好好吹吹我在国际链汇市场上神一般的操作，这个私房钱是我要誓死守护的东西~~~</p></blockquote>

<h4>永烁星光之地：一个墓碑的故事</h4>

<blockquote><p>未来的我们，在世界公链上将亲人的DNA及脑纹模型记录下来，是追思纪念他们的大众做法；</p>

<p>我是一个链时代的墓地管理员，一次偶尔的程序清理，让我遇到了一个独特的墓碑节点，这后面有一个忧伤的故事~~~~</p></blockquote>

<h4>新时代的商业故事：公司的进化</h4>

<blockquote><p>是的，这个时代的公司能够自己思考，已经用不着CEO来干扰我们了；这个故事讲述了一个公司在链上注册之后，不断自我完善，最终称霸投资界的经历</p></blockquote>

<h4>恐怖的发明：有人想用纸片来窃取我们的财富!</h4>

<blockquote><p>大新闻：神奇，阴暗，基于纸的支付系统正在全球流行！</p>

<p>世界各国政府今天宣布了一项计划，允许公民以匿名的方式保存他们的部分财富，并且可以和其他人交换，通过一种小块的彩色纸片作为媒介。</p>

<p>该彩色纸片上印制着民族主义和共济会的图像，并且据称每一张纸（如果该纸不是假冒的）都代表了其上面印制的数字的财富。</p>

<p>这些纸币在各国央行有一个正式的名字叫“钞票”，同时另外一个名字叫“现金”。这一项技术对于我国大多数居民而言过于复杂。我只想说，该新系统很复杂，而且对于用户非常不友好。</p>

<p>这些花花绿绿的纸片，它们在每个国家都是不同的，越过了国界就失去了作用。</p>

<p>对于在计算器和计算机中长大的一代，该发明是非常奇怪的，账单只能以固定的单位进行结算，比如2，5，10等等，并且使用者需要维护一大堆的纸，必须集中起来一定规模然后才能完成一笔交易。</p>

<p>接下来的过程是非常复杂的，公司使用这些纸片对雇员进行结算工资。（不用过于担心它很复杂，我们一开始也弄不懂它是怎么运作的，目前它肯定还没有做好准备面对一般的消费者。）</p>

<p>Sears公司培训部门的副总Mike Smith说：</p>

<p>“我不能想象培训数万个员工使用纸币，验证它们的真伪，并学会正确地找零而不犯错误。这将需要大量安装特制的机器——所谓的“验钞机和点钞机”——和大量的员工培训费，并且延误消费者的时间，让他们等候长队。此外，我们需要采取新的安全程序，雇佣武装警卫，以免这些纸片被盗。在现有条件下，我们看不出为什么要采用这种所谓的纸币。”</p>

<p>犯罪分子的完美工具</p>

<p>这次纸币的推出，立即引起了世界各地执法机构的广泛谴责。</p>

<p>联邦调查局局长Mike Smith如是说：</p>

<p>“纸币是一种100%匿名和无法追踪的技术。它就像是一个针对执法部门的大规模杀伤性武器。对于罪犯，贩毒集团，恐怖分子，色情业和洗钱活动来说，这就是完美的作案工具。我们不知道如何才能打击这种技术，我们完全有理由相信，新一代的超级罪犯将会出现，他们可以从容地完成犯罪活动而不留下一丝痕迹。”</p>

<p>甚至银行体系内的官员，也对新计划表示怀疑。</p>

<p>纽约州的金融管理局局长Mike Smith说：“我想不出任何理由，一个守法的个人需要使用纸币。在可以容忍的范围内，我们相信必须有一个牌照制度提供给使用纸币的个人或者商家——比如可以叫‘纸币执照’。”</p>

<p>该执照将使得纸币只在值得信任的个体之间交易，并留下详细的交易记录以供纽约金融管理部门检查，他补充说。</p>

<p>其他人则关注纸币的伪造和假冒问题。</p>

<p>“本质上，抛开花花绿绿的外表和油墨，它就是一张纸。我们完全有理由相信犯罪集团和敌对国家会大量制造假冒的纸币来干扰我们的正常经济运行”，斯坦福的一名分析师Mike Smith说。</p>

<p>“在现有环境下，我们可以肯定纸币将会在真实的世界中拥有一定的市场份额，考虑到接受纸币所带来的巨大风险，毫无疑问纸币是我们现代金融系统——电子加密货币的一次巨大倒退。”</p></blockquote>

<h4>爆炸性消息：有个国家决定建立一个中心化发行货币的组织</h4>

<blockquote><p>就在刚才，某能源输出国为了控制其能源价格，宣布发行一种国有自主货币；</p>

<p>在这个有几万种货币自由竞争的市场上，再多一种主权货币真的不值一提，真正让人恐惧的，是他们发行货币的方式:</p>

<p>x国宣布成立一种类似能源联储的组织来控制货币发行，他们对于发行货币的总量、频率、信用背书都是秘而不宣的，也就是说，这个组织没有人监管，爱怎么搞就怎么搞，他们宣传将凭借国家信用和政府的一贯清廉作风来运作这个组织；关于更详细的消息我们还不得而知，让我们就此事采访一下专家意见。</p>

<p>Satoshi经济学奖获得者Smith先生评价：</p>

<p>这完全是个荒谬的事情；货币市场是一个透明、去中心化、自由竞争的市场，每个人都有选择他们喜爱的货币的权利，而现在X国剥夺了他们国民的这种权利，我为X国公民感到遗憾；几百年前，我们的历史上出现过这种情况，那时候，国家肆意妄为，利用其铸币税每年偷偷的剥夺其国民的劳动财富，并宣称<code>温和的通胀有利于经济</code>；他们的货币不能自由兑换，关于发行总额一直讳莫如深，这个机构的几个控制人只是坐在一间小黑屋里面就能分配国民财富，与他们的掠夺手段相比，即使是史上最黑心的强盗也只能羞愧的承认自己的无能；这种行为完全完全是历史的倒退，对我们现今的政治、文明、经济制度的一个巨大讽刺，我个人是不愿意生活在X国的~~~</p>

<p>让我们采访一下证券市场的国王，Dio先生的看法：</p>

<p>这完全是个笑话，听说他们宣称：&#8221;区块链电子加密货币系统存在着通缩的危险。&#8221; 完全是一派胡言，一个自由竞争的市场，几万个竞争者，您来谈通胀还是通缩，别来这种笑话了！与之相反，我听说他们打算以一年5%的增发量实行<code>温和的通胀</code>；嗯哼，我对此不予置评，您可以采访一下我们的普通工人，听听他们的想法，我个人是绝对不会在市场上持有这种货币的~~~</p>

<p>让我们听听路人的看法:</p>

<p>先生，您对一种每年增发5%的货币有什么看法？</p>

<p>5%，嗯，我数学不好，不过我觉得不是很多，现在市场上不是有很多每年增发1000000%的货币嘛，这听起来挺有竞争力的。</p>

<p>让我们换种说法吧，先生，5%的意思是每过十年，您的钱就会缩水一半。</p>

<p>什么，我得好好考虑一下，毕竟我攒钱不容易。</p>

<p>最后，先生，发行这家货币的组织是个中心化组织，他们的货币信息是不会上链的，他们宣称凭借自己的国家信用为其保证。</p>

<p>Holy Shit! 这些家伙说的每一个字都不能相信！我们可上了他们几百年的当了，我每天累死累活可不是给这些强盗打工的，他们的信用？嗯哼，我宁愿相信隔壁幼儿园的 Paul Chan 发行的棒棒糖币；</p>

<p>谢谢您的坦诚，先生。</p></blockquote>

<h4>Luck Luke大胜利：史上最幸运的博彩玩家</h4>

<blockquote><p>史上最幸运的人，就在刚才，有位匿名先生，他作为<code>Luck Luke</code>区块链博彩游戏的史上最幸运玩家，夺得大奖，一举进入全球TOP100富豪榜！！</p>

<p>选择比努力更重要！ 是的，还等什么，有必要重新思考是不是来学习一下 <code>Luck Luke</code>了，我们竭诚为您的每一个幸运选择负责！！</p></blockquote>

<h4>NBA联盟推出的新业务：链上球队组建(众筹一支NBA球队，为什么不试试呢？组建你心中的最强阵容吧)</h4>

<blockquote><p>来自NBA总裁的一封信:</p>

<p>亲爱的球迷们，经历了一个赛季的动荡；相信我们对于愚蠢的球队经理、老板们已经感到厌倦了；为什么不自己打造一支球队呢？</p>

<p>就在刚才，联盟一致同意： 鉴于NBA的所有球员信息已经上链，我们推出了一款不可思议的智能合约：您即将可以通过发送资金给这个合约，成为历史上第一家虚拟俱乐部的老板之一！！</p>

<p>这是一个区块链版本的、真实的&lt;篮球大亨之旅>；还等什么，赶快来挑选球员，组建你心中的最佳阵容吧！！</p></blockquote>

<h4>对你的体力感到自豪吗？快来这里挣外快吧！！</h4>

<blockquote><p>近日，全球健美先生推出了一款<code>健美先生</code>健身链，通过其独有的外部设备，参与者必须根据设备的提示，实行标准的健身动作(如俯卧撑)来证明你的权证拥有权；该系列动作随机生成，不可作假，并用您的DNA信息HSAH后上链；</p>

<p>没错，这是新一代的<code>人力POW</code>， 诚实、公平、不能伪造，防止矿霸；还等什么，一边健身一边挣钱，快来加入<code>健美先生</code>吧。</p></blockquote>

<h2>对于未来的一些预测</h2>

<p>是的，我们要进行巨大的冒险，实行一个典型的无知又傲慢的行为：预测未来！</p>

<p>作为无数耻辱的预言失败家，我们很乐意步其后尘，被作为典型代表成为被后人嘲笑的小丑，预言家们的主要工作就是为您茶余饭后提供嘲笑对象：</p>

<h3>未来至少会有几万种货币</h3>

<p>是的，未来人人都可以发行自己的货币；</p>

<ul>
<li><p>Schwarzenegger先生发行了自己的<code>硬派货币</code>，近千万粉丝为其买单，<code>硬派组织</code>轻易进入了世界TOP100 经济体内；现在这个组织正跟另外一个<code>小甜*甜派</code>进行着激烈的贸易战争；</p></li>
<li><p>我得说，财商教育要从娃娃抓起；幼儿园的 Paul Chan小朋友收集齐全了所有的胖胖糖贴纸，作为贴纸收藏第一人，他刚刚将其作为抵押发行了自己的<code>Paul币</code>，将近一半的幼儿园人士接受了这个货币，<code>Paul币</code>的未来会怎样，我们将会持续观察；</p></li>
<li><p>世界上最昂贵的爱情；昨天，世界首富Aza先生与其伴侣发明了<code>爱侣币</code>，这个币的发行量只有两枚，持有人是Aza先生及其夫人，他们在公链上注册并宣称，不论何时，1枚<code>爱侣币</code>都代表其两人共有财产的一半汇率；这真是史上最昂贵的爱情宣言；<code>货币是一种语言</code>，多年前的先驱，Antonopoulos先生对货币的定义诚不我欺；</p></li>
<li><p>世界上寿命最短的货币；物理学家Smith先生以<code>普朗克时间</code>为产出-销毁间隔，发明了世界上寿命最短的货币；这是一种行为艺术吗？还是对科学的探索，关于其技术细节我们还一无所知，请关注我们的跟踪报道。</p></li>
</ul>


<h3>未来的物品标价不再是一个固定价格</h3>

<p>是的，你可能说我要疯了；当我想去买一瓶汽水时，我会不会听到这样的对话：</p>

<blockquote><p>额，我想要左边的那瓶蓝色包装的汽水，是100 satoshi吧？</p>

<p>对的，先生，现在的标价是12000 <code>PaulCoin</code></p>

<p>好吧，那我就要这个了，这是 50 <code>小甜甜派</code>；收到了吗？</p>

<p>当然，先生，谢谢。</p></blockquote>

<p>当贸易极大繁荣，货币市场自由竞争，波动不断的时候，会发生什么？</p>

<p>一件物品的价格会不断变化；想想我们现在物品的标价，当我们走进百货超市，会看到这个月和上个月的价格有所不同；这是当然的，人工、原材料、运输成本、宣传成本，构成价格的要素不断变化，凭什么价格要保持不变！</p>

<p>长时间保持不变的唯一原因，就是人们害怕<code>变化</code>；一个每秒钟价格都在变动的商品是不会获得人类的信任的，谁知道我到底是捡便宜了还是当了冤大头；稳定定价，商家承担了成本波动的风险；</p>

<p>那么，换个方式，比如，用这个物品占世界所有货币价格的百分比定价如何？</p>

<p>如果未来所有的货币供给、兑换价格是可实时统计的，为什么不呢？这样商家承担的风险降低了，买家也能更清楚的衡量<code>这项资产究竟占此时世界财富的百分比</code>~~~</p>

<p>我们还需要去费力的比价、凑单吗？当然的，但是这些工作交给我们的智能钱包去处理吧；</p>

<h3>未来人将搞不清自己究竟有多少钱</h3>

<p>当我们形容一位土豪时：就是 <code>Paul先生是亿万富豪，呃，他都搞不清自己多有钱</code>。</p>

<p>是的，当未来人人都持有几千种价格不断波动的货币时，讨论<code>一个人多有钱</code>已经是个落伍的话题了；人们衡量的标准不再是货币的<code>价格</code>，而是<code>资产占世界总财富的百分比</code>；</p>

<p>你的智能钱包将会成为最重要的一个器官，钱包的智商将决定了你的资产增值或缩水的速度；将来会出现一大批的钱包AI提供商，金融机构的竞争，已经全面转向了AI时代。</p>

<h3>有了智商的钱包将会建立一个平行国家</h3>

<p>额，当世界上最先进的AI技术赋予你的钱包后，会发生什么呢？</p>

<p>没错，智能钱包君有了意识之后，将进入阿西莫夫的世界；每天生活在金钱世界的一个智能AI，阅读了无数的人类的贪婪、索取无度的本性之后，会怎样做呢？</p>

<p>嗯哼，我想他们会建立自己的一个国家；用自己的法则<code>君临但不统治人类社会</code>。</p>

<h3>将会出现不需要人类干预的，自我成长的组织</h3>

<p>想象一下我们今天的基金经理的工作：</p>

<ol>
<li>募集资金</li>
<li>进行投资</li>
<li>分配收益</li>
</ol>


<p>那么将来所有资产公开透明上链之后，每个人都能成立交易所，每个人都能进行IPO，每个人无需开设账户即可自由投资，所有货币、金融资产的所有权在全球内自由流动而毫无限制之后，会发生什么呢？</p>

<p>将会出现一个有自我意识的资本合约：</p>

<ol>
<li>这个合约的初期非常简单，就是接受资金注入以及一个投资策略，当它取得超额收益后就会按照一定份额回报其策略提供者和投资者</li>
<li>这个公开、透明的模式不断吸引资金进入、以及世界上最聪明的、最先进的投资策略的更迭；</li>
<li>最终这个合约吸引了世界上绝大多数的智能资产；他开始出资雇佣最聪明的开发者为自己编程，投资最强大的硬件设备商为其建造数据中心，雇佣最大胆最守信的三方武装组织保护自己，他开始有了意识~~~</li>
<li>~~~嗯，会发生什么呢？</li>
</ol>


<h3>将来地球上会出现上万个国家</h3>

<p>既然基金组织可以自我成长，那么其他的商业组织呢？公益组织呢？政府呢？</p>

<p>政府也不过是集合一部分人的共识成立的组织而已。当未来的资产、武力、信息资源极度透明并以超高的循环速度迭代之后；为什么个人不能独立建国呢？</p>

<p>今天，让世界承认一个国家的主权是非常困难的事情，需要武力、经济、政治、宗教的种种博弈；一个国家要整合各方的利益关系，效率也是极其低下的；</p>

<p>当未来人类社会的发展极度透明、各种社会要素以极高速度流通之后，为什么不能像公司一样，诞生不断迭代、效率不断提高的国家呢？为什么不能由三五个人成立按照他们的喜好运行的国家呢？</p>

<p>将来地球上会出现上万个国家，每个人根据自己的喜好和利益关系可以拥有上百个国籍；</p>

<p>加入哪个国家，最终将跟你上哪所小学一样，变成一个平常不过的事情。</p>

<h2>参考资料：</h2>

<p><a href="https://www.zhihu.com/question/22036280">https://www.zhihu.com/question/22036280</a></p>

<p><a href="https://www.coindesk.com/cash-invented-seen-media-today">https://www.coindesk.com/cash-invented-seen-media-today</a></p>

<p><a href="https://www.8btc.com/article/8401">https://www.8btc.com/article/8401</a></p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-2]]></title>
    <link href="https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2/"/>
    <updated>2019-01-23T19:05:29+08:00</updated>
    <id>https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2</id>
    <content type="html"><![CDATA[<p>比特币的发展史上，非常非常早期就出现了一种名为侧链(sideChains)的技术；</p>

<p>这个技术早在2008年比特币代码尚未发布时，就在论坛上有所讨论，后来比特币网络开始运行，各种Geek点子层出不穷，从最初的namecoin(域名币)，到后来的（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链；再到后来百链齐开，大家试图在完全不同的链上转移交换资产；以及最近到blockstream的<a href="https://blockstream.com/liquid/">Liquid</a>，以及基于闪电网络的原子交换(Atomic Swap)，这个技术的发展一直不温不火，但毫无疑问，侧链技术绝对是blockchain技术的重要组成部分。</p>

<!-- more -->


<p>顺便说一句，技术的演化是一个渐进的过程，中间甚至还会有倒退；比特币社区早期提出了非常多的天马行空的点子，但大多过于超前和激进，所以你说投机者也好，先烈也罢，大部分都湮没在历史风尘之中了；但是这些技术的一个重要应用，就是后来人再用几个高大上的名词包装一下，原样推出来继续割韭菜；</p>

<p>比如对比现在的一干稳定币；bitshares表示不服；</p>

<p>比如现在的各种DPOS算法，死去的先烈们纷纷表示生不逢时；</p>

<p>而且一个新技术出来，伴随着大量术语(有时候一个名词用不同语言说出来就感觉是两个技术)，比如各种Smart Contract，智能合约，双向锚定，智能资产，Oracles，预言机，图灵完备，零知识证明，分布式自治组织DAO，Dcententralize Autonomous Oganization，DAPP，hyperledger，DistributedLedger，DistributedNetwork，ERC20，~~~把人忽悠的一愣一愣的；</p>

<p>而且最让人想不通的，你要说某某技术是在比特币基础上搭建的，我们的第一反应就是:<code>庞氏骗局</code>；如果他说他的项目是踏着五色云彩，手持先知卷轴，以联盟链为基础，建立在全球的去中心化内容协议之上，采用了区块链与分布式存储技术，要构建一个世界范围内的自由金融体系，已经有XXX,YYY,ZZZ等各大机构支持投资，以及UUU,ZZZ等诺贝尔奖级别的专家背书，我们便会对其顶礼膜拜~~~~</p>

<p>好了，不八卦了；为了避免受骗，只有一个办法，就是这个世界谁都靠不住，只能自己搞明白，让我们看看这个侧链技术究竟是大忽悠还是真本事。</p>

<p>我初次接触到这个技术时，不禁感叹社区的强大，连这么匪夷所思的东东都能想出来，总之可以总结为:</p>

<p><code>还有这种操作?</code></p>

<p>那么，接下来就从2010年，比特币的早期说起，这个侧链的技术究竟是如果诞生、演化的。</p>

<h2>BitDNS (第一个侧链概念的诞生)</h2>

<p>2010/11/15，有人在bitcointalk.org发贴提出了建立一个类似于比特币的分布式DNS的系统，称之为bitDNS:</p>

<p><a href="https://bitcointalk.org/index.php?topic=1790.0">https://bitcointalk.org/index.php?topic=1790.0</a></p>

<p>这个帖子值得一再研究，里面整个一群英荟萃，讨论的内容在数年之后启发扩展出来了无数种山寨币。</p>

<p>讨论的起点是很简单的，就是有人受比特币启发，说要建立一条新的公链bitX，并在其上面发行多种资产，域名、比特币都仅仅是其中的一种资产而已。</p>

<p>一石激起千重浪，大家就一个分布式的DNS系统的实现展开热烈讨论。</p>

<p>讨论的结果是，既然比特币公链已经为我们提供了三种能力：</p>

<ol>
<li>时间戳——证明事件的时间顺序</li>
<li>加密完整性——证明数据没有被篡改</li>
<li>身份验证——证明数据满足一些基本标准</li>
</ol>


<p>那么为什么不以比特币的公链为基础锚定物，在其之上扩展出任意的资产呢？</p>

<p>这个想法非同小可，若干年后，除了namecoin，还衍生出来了（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链，以及bitshares 这种基础设施，乃至大名鼎鼎的ethereum 的部分思想也可以追溯于此。</p>

<p>BitDNS的想法最终作为namecoin项目实现，让我们看看如果以比特币公链为锚，构造一个分布式域名系统。</p>

<h2>namecoin</h2>

<p>让我们遵循老习惯，先提出问题： 假如我们要建立一个去中心化的DNS系统，应该怎么做呢？</p>

<h5>初版方案</h5>

<p>众所周知，现下的DNS系统是由ICNAA来把持的，我们日常访问的所有域名记录来源于几个根服务器；乃至于https的证书颁发机构都是中心权威化的；密码极客们讨论建立一个去中心化的DNS系统已经好多年，比特币的出现无疑是一束光。</p>

<p>我们参照比特币的实现，将最小化的DNS信息记录上链，方案很明显，一个人持有私钥，对指定的域名签名，然后存到一条链上，那么就完成了对这个域名的所有权声明。将来如果这个域名需要转让，参照比特币的转账方式，构造scriptSig即可。</p>

<p>至于这条链是如何运行的，完全可以参考比特币，folk一份代码，构造一条完全独立的POW链即可。</p>

<p>DNS的解析、登记、TXT、A记录、CNAME等等所有其他功能，完全可以移交给三方开发商来提供服务，当域名所有者提供签名后，开发商请求namecoin 链进行验证即可。</p>

<h5>二版方案</h5>

<p>初版方案的设想非常简洁美好，已经完成了这个系统的大部分，但是还有一点小问题要解决一下：</p>

<ul>
<li>传统的域名注册、续签等等都需要付费，初版系统没有经济激励，很容易造成域名抢注和滥用</li>
</ul>


<p>解决办法也很简单，就是引入一种代币(namecoin)，注册和续签、以及转移，都需要花费namecoin作为手续费；而获取namecoin的手段，则是挖矿。</p>

<h5>三版方案</h5>

<p>设计至此，已经非常完美了。但是社区成员进一步思考，既然比特币的主链已经提供了足够的算力来保障其安全，我们为什么为了发行另外一项资产，就要另起炉灶开启新的POW竞争呢？</p>

<p>POW算力链，只有一份保障就够了，没有必要开启其他的同样的POW链。</p>

<ul>
<li>那么问题来了，如何用比特币的主链来保障namecoin链的唯一和不可篡改呢？</li>
</ul>


<p>答案就是将namecoin链的每一个block hash值嵌入到比特币的主链上，这样namecoin就作为一条侧链依附于比特币主链，在比特币全网POW算力的庇护下茁壮成长。</p>

<ul>
<li>namecoin的block hash 怎样嵌入比特币主链上呢？</li>
</ul>


<p>答案是嵌入在比特币挖矿交易的coinbase中；这样比特币矿工可以同时加入到bitcoin和namecoin的网络中，每挖到一个块，可以顺便嵌入namecoin的block header到coinbase里面，顺便获得一些namecoin，这样也保障了namcoin主网的安全。</p>

<h5>四版方案</h5>

<p>我们把bitcoin blockchain称之为主链，namecoin block chain称之为辅链；</p>

<p>想象当中，两条链的结构是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg1.png" alt="img" /></p>

<p>那么，挖矿的难度应该怎么设计呢？我们要求该父链区块的难度必须符合辅链的难度要求：</p>

<blockquote><p>将辅链区块的hash值内置于父链的Coinbase，其实是利用父链作存在证明。这样就可以实现间接依靠父链的算力来维护辅链安全。一般来说，父链的算力比辅链大，因而满足父链难度要求的区块一定同时满足辅链难度要求，反之则不成立。这样一来，很多本来在父链达不到难度要求的区块，却达到辅链难度要求，矿工广播到辅链网络，在辅链获得收益，何乐而不为。</p></blockquote>

<p>到这里看起来已经非常好了，但是且慢，还有一个问题，就是这样就限制了辅链block的生成速度，每挖一个主链block，只能顺带挖一个辅链block，是不是有点太死板了呢？要知道，可能将来有些资产应用，会要求更灵活的区块生成间隔时间，这个问题怎么解决呢？</p>

<h5>五版方案</h5>

<p>辅链除了用prev block 指针组成一条chain，还又引入了另外一个指针： parent block； 这样每几个block可以归附于一个parent block，挂接在主链的同一个block下面；这样就实现了挖一个主链block，附带挖多个辅链block；结构如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg2.png" alt="img" /></p>

<p>在这张图中，主链的block100只挂接了辅链的blockB100，但是blockB101，blockB102都指向同样的parent block，就是blockB100，这样就实现了只用主链的blockB100，同时挂接辅链的三个区块(blockB100、blockB101、block102)；</p>

<p>一个parent block可以后续有多个block，辅链验证的一个block是否合法的时候，需要三步验证：</p>

<ol>
<li>首先按照辅链的规则验证此block是否合法</li>
<li>查看它是否属于一个parent block，若有，验证此parent block是否合法</li>
<li>验证此block或者其parent block所挂接的主链block是否合法</li>
</ol>


<p>嗯哼，完美！</p>

<h6>六版方案</h6>

<p>世界上不存在完美的方案，很快，我们又迎来了新的挑战： 以主链为锚定，我们想要有多条辅链的时候该怎么办？</p>

<p>答案是merkle结构，就像bitcoin的block用merkle聚合了多笔交易一样，我们再次用merkle聚合多条辅链的parent block header。</p>

<p>最终的设计细节如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg3.png" alt="img" /></p>

<p>AuxPOW协议对两条链都有一些数据结构方面的规定，对于父链，要求必须在区块的coinbase的scriptSig字段中插入如下格式的44字节数据：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg4.png" alt="img" /></p>

<p>对于辅链，对原区块结构改动比较大，在nNonce字段和txn_count之间插入了5个字段，这种区块取名AuxPOW区块。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg5.png" alt="img" /></p>

<blockquote><p>混合挖矿要求父链和辅链的算法一致，是否支持混合挖矿是矿池的决定，矿工不知道是否在混合挖矿。矿池如果支持混合挖矿，需要对接所有辅链的节点。</p>

<p>将辅链区块hash值内置在父链的Coinbase，意味着矿工在构造父链Coinbase之前，必先构造辅链的AuxPOW 区块并计算hash值。如果只挖一条辅链，情况较为简单，如果同时挖多条辅链，则先对所有辅链在挖区块构造Merkleroot。矿池可以将特定的44字节信息内置于上文Stratum协议中提到的Coinb1中，交给矿工挖矿。对矿工返回的shares重构父链区块和所有辅链区块，并检测难度，如果符合辅链难度要求，则将整个AuxPOW区块广播到辅链。</p></blockquote>

<p>辅链节点验证AuxPOW区块逻辑过程如下：</p>

<ol>
<li>依靠父链区块头（parent_block）和区块Hash值（block_hash，本字段其实没必要，因为节点可以自行计算），验证父链区块头是否符合辅链难度要求。</li>
<li>依靠Coinbase交易（coinbase_txn）、其所在的分支（coinbase_branch）以及父链区块头（parent_block），验证Coinbase交易是否真的被包含在父链区块中。</li>
<li>依靠辅链分支（blockchain_branch），以及Coinbase中放Hash值的地方（aux_block_hash），验证辅链区块Hash是否内置于父链区块的Coinbase交易中。</li>
</ol>


<p>通过以上3点验证，则视为合格的辅链区块。</p>

<p>需要注意的一个字段是主链上的merkle_nonce； 因为一个矿工可能同时挖多条辅链，而每开采主链上一个合法的block，可能会带有数目不定的多条辅链，为了区分每条辅链的<code>链接位置</code>，即通过辅链的id确定这条辅链链接的索引号(也称为slot num)，引入了一个nonce，算法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int rand = merkle_nonce;
</span><span class='line'>rand = rand * 1103515245 + 12345;
</span><span class='line'>rand += chain_id;
</span><span class='line'>rand = rand * 1103515245 + 12345;
</span><span class='line'>slot_num = rand % merkle_size</span></code></pre></td></tr></table></div></figure>


<h5>以上就是初代侧链的实现技术!</h5>

<h2>单向锚定 (one-way peg) 协议</h2>

<p>通过namecoin的讨论，我们看到了以比特币主链为锚定，发展无数条侧链的方案，这个方案仅仅依赖于coinbase交易中写入一点点信息而已；</p>

<p>但是这个方案的严重局限就是，侧链币的生产也要依赖于比特币的挖矿活动，这样多少有些限制；有没有一种办法，可以脱离比特币的挖矿限制，但是又能复用比特币的工作量证明呢？</p>

<p>有的，这就是2013年社区提出来的 <code>one-way peg</code>技术；</p>

<p>这项技术与namcoin等侧链技术不同的地方在于，侧链的锚定信息不去写入到coinbase交易里面，而是由比特币链上创造一笔燃烧交易，在这笔交易的<code>OP_RETURN</code>段里面写入需要的信息，这个过程称之为 <code>proof-of-burn</code>；</p>

<p>我们具体举一个例子：</p>

<p>我们想要创造一个名为<code>MoonChain</code>的侧链以比特币主链为锚，想要在上面发行一种<code>MoonCoin</code>代币用来搞定月球土地流转交易等等；那么初始的铸币工作怎么来完成呢？</p>

<p>作为创始人，我首先需要一个合法的比特币私钥，对应的控制地址为A，那么我现在构造一笔交易，发送1BTC至地址1111111111111111111114oLvT2，众所周知，这个地址是无主的，发送到这里就算是燃烧销毁了这个币，妙处在于，我们在这笔交易的<code>OP_RETURN</code>里面附上这样一段脚本，脚本的大意这么规定：</p>

<p><code>燃烧交易的源地址销毁1BTC，同时此地址铸币1MoonCoin</code>；</p>

<p>这表交易通过几个区块确认后，就铭刻在区块链里面了；同样的，MoonCoin的转移也可以用类似燃烧交易种的<code>OP_RETURN</code>来表示；</p>

<p>凡是遵守这套规则的交易，就可以完成MoonCoin的铸造和转移，甚至可以另外实现智能合约等等功能，这些交易携带的信息就组成了一条侧链，即MoonChain；</p>

<p>把这些套路总结为规范，就可以用燃烧交易的方法来创造侧链啦；</p>

<p>这个规范名为omni协议：</p>

<p><a href="https://www.omnilayer.org/">https://www.omnilayer.org/</a></p>

<p>遵循omni协议在bitcoin主链上发行的资产已经超过了400多种币，但只有一种币声名在外：USDT。</p>

<p>顺便吐槽一下USDT，巴菲特曾多次说比特币是老鼠药的平方(现在这个时间点这样评价比特币确实公正客观)，但在我来看USDT是老鼠药的1024次方。</p>

<p>后来BCH团队也在BCH链上发行了类似的资产，称为 Wormhole Cash（WHC），目的是在BCH链上实现智能合约。</p>

<h5>因为整套技术是通过燃烧比特币来铸造新币，看起来好像是比特币从主链上转移到了侧链上(以新币的形态再生)，人们就把它俗称为单向锚定 (one-way peg) 技术</h5>

<p>单向锚定最大的问题在于比特币的主链不欢迎额外的无效信息，<code>OP_RETURN</code>被限制在80字节，承载的信息有限；BCH的态度更为激进，它在2018-05把<code>OP_RETURN</code>提升到233字节，并计划进一步提升。</p>

<h2>双向锚定（Two-way Peg）协议</h2>

<p>有了单向锚定，自然会有人想：能不能不需要燃烧比特币，只是将比特币在主链和侧链之间来回移动:</p>

<ol>
<li>铸币的时候，将比特币移动到侧链生产代币</li>
<li>代币销毁的时候，将比特币移回主链</li>
</ol>


<p>当然可以，2014-04，Adam Back (Blockstream创始人) 提出双向了锚定技术:</p>

<p><a href="https://letstalkbitcoin.com/e99-sidechain-innovation">https://letstalkbitcoin.com/e99-sidechain-innovation</a></p>

<p>很快的，V神也在他的专栏上对此技术做了简单的剖析：</p>

<p><a href="https://bitcoinmagazine.com/articles/side-chains-challenges-potential/">https://bitcoinmagazine.com/articles/side-chains-challenges-potential/</a></p>

<p>双向锚定对于单向锚定的扩展，其实也很容易理解。单向锚定时，侧链锚定主链的方法是主链燃烧比特币，然后存贮一个工作量证明；</p>

<p>我们知道比特币的交易本质上是一组脚本语言，那么，把燃烧交易的输出换成一组特定的脚本，它只允许特定的持有人和市场参与方才能解锁，那么，这笔交易在侧链<code>赎回</code>的时候，就可以由多方再构建一个解锁脚本，比特币就会安然无恙。</p>

<p>双向锚定分为以下几个阶段，下面简单说一下这个过程：</p>

<h5>发送锁定交易，把比特币锁定在主链上</h5>

<p>由比特币持有者操作，发送一个特殊交易，把比特币锁定在区块链上。</p>

<h5>等待确认期</h5>

<p>确认期的作用是等待锁定交易被更多区块确认，可防止假冒锁定交易和拒绝服务攻击，等待时间是1~2天。</p>

<h5>在侧链上赎回比特币</h5>

<p>确认期结束后，用户在侧链上创建一个交易花掉锁定交易的输出，并且提供一个SPV工作量证明，输出到自己在侧链上的地址中。该交易称为赎回交易，SPV工作量证明是指赎回交易所在区块的工作量证明。</p>

<h5>等待一个竞争期</h5>

<p>竞争期的作用是防止双重支付。在此期间:</p>

<ul>
<li>赎回交易不会被打包到区块；</li>
<li>新传输到侧链的比特币不能使用；</li>
<li>如果有工作量更大的工作证明出现，即该赎回交易包括了比特币主链更大难度的SPV证明，则上一个赎回交易将被替换。</li>
</ul>


<p>竞争期结束后，该赎回交易将被打包到区块中，用户可以使用自己的比特币。</p>

<p>从侧链转比特币到主链的过程也是如此。这就是侧链双向锚定协议。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg6.jpg" alt="img" /></p>

<h2>Blockstream Liquid协议</h2>

<p>双向锚定的关键，在于主链锁定交易的输出脚本，很明显的，如果依赖于锁定者，那么这个输出完全不能信任，锁定者在任何时刻都能提币走人；比较安全的做法是输出到一个N/M多重签名的地址中，由多方利害关系的人共同保管；</p>

<p>基于这个思想，Blockstream开发了Liquid侧链想要实现商业化， Liquid期望多个大型交易所之间能方便的实现币的交易、转移等等服务，而不是受限于主网的交易速度；</p>

<p>Liquid是个非常严肃的商业项目，但我个人认为这是一个<code>人造需求</code>的项目，其原因在于在侧链技术蓬勃发展过程中，还平行的出现了另外一种技术逐渐成长壮大，就是微支付通道技术。</p>

<h2>微支付通道</h2>

<p>2011年，早期的bitcoin开发者Mike Hearn 向中本聪问及nLlockTime字段的含义，中本聪回复邮件，解释这是考虑用于创建一个通道来高频支付，后来Mike Hearn在2013年将这些邮件公之于众：</p>

<p><a href="https://pastebin.com/JF3USKFT">https://pastebin.com/JF3USKFT</a></p>

<p>邮件中，中本聪写道:</p>

<blockquote><p>It&rsquo;s for contracts.  An unrecorded open transaction can keep being replaced until nLockTime.  It may contain payments by multiple parties.  Each input owner signs their input.  For a new version to be written, each must sign a higher sequence number (see IsNewerThan).  By signing, an input owner says &ldquo;I agree to put my money in, if everyone puts their money in and the outputs are this.&rdquo;  There are other options in SignatureHash such as SIGHASH_SINGLE which means &ldquo;I agree, as long as this one output (i.e. mine) is what I want, I don&rsquo;t care what you do with the other outputs.&rdquo;.  If that&rsquo;s written with a high nSequenceNumber, the party can bow out of the negotiation except for that one stipulation, or sign SIGHASH_NONE and bow out completely.</p>

<p>The parties could create a pre-agreed default option by creating a higher nSequenceNumber tx using OP_CHECKMULTISIG that requires a subset of parties to sign to complete the signature.  The parties hold this tx in reserve and if need be, pass it around until it has enough signatures.</p>

<p>One use of nLockTime is high frequency trades between a set of parties.  They can keep updating a tx by unanimous agreement.  The party giving money would be the first to sign the next version.  If one party stops agreeing to changes, then the last state will be recorded at nLockTime.  If desired, a default transaction can be prepared after each version so n-1 parties can push an unresponsive party out.  Intermediate transactions do not need to be broadcast.  Only the final outcome gets recorded by the network.  Just before nLockTime, the parties and a few witness nodes broadcast the highest sequence tx they saw.</p></blockquote>

<p>短短几句话，充分说明了中本聪在创始比特币之初，就已经考虑到了将来的微支付问题！</p>

<p>那么，这个微支付通道技术究竟是如何实现的？我们搬运一个例子说明一下：</p>

<p>假设Alice为消费者，鲍伯为一家视频网站。Alice非常喜欢去鲍伯网站看电影，看一部电影需要支付0.1BTC（比特币），那么Alice看了10部电影就需要支付10次0.1BTC，共计1BTC并发出10笔交易。而采用微支付通道就会缩减至两笔，或者说任何多次的交易均会缩减至两笔，只要总金额不超过存入通道的额度即可。</p>

<p>通道（Channel）的建立以及更新过程如下。</p>

<ul>
<li><p>Alice支付1BTC至一个多重签名地址，签名采用2/2方式，我们把该交易称为FTX(Fund Tx)。Alice生成该交易后，并不广播。</p></li>
<li><p>Alice再构造一个赎回交易，称之为RTX(Refund Tx)。其输入为交易FTX的输出，输出为Alice自己。同时，该交易有Locktime锁定期，所以N天之后才会生效，才可以进块。</p></li>
<li><p>Alice把构造好的空RTX给鲍伯，并让鲍伯进行签名。</p></li>
<li><p>Alice拿到带有鲍伯签名的交易RTX后，广播出FTX。此时的交易结构如下图,图中带有尖括号的签名表示待填入:</p></li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg7.jpg" alt="img" /></p>

<ul>
<li>Alice再看了一部电影，那么她需要再支付0.1BTC给鲍伯。于是，Alice构造另一笔交易PTX2：输入依然是交易FTX；输出为两个地址，其中Alice为0.8BTC，鲍伯为0.2BTC。Alice对该交易签名，并将交易和她的签名给鲍伯:</li>
</ul>


<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg8.jpg" alt="img" /></p>

<ul>
<li><p>鲍伯可以随时签名并广播交易PTX2，当然，他依然可以广播交易PTX1。作为一名理性经济人，鲍伯必然总是广播自己收益最大的那笔交易，也就是当前的PTX2。在目前总是Alice付款的情况下，鲍伯总是乐于广播最后一个交易。</p></li>
<li><p>当鲍伯广播出最后一笔交易PTXn时，则意味着通道关闭，合作结束。鲍伯需要在交易RTX锁定期结束前关闭通道，否则意味着Alice可以在交易RTX解锁后否则意味着Alice可以在交易RTX解锁后拿回她所有的币。</p></li>
</ul>


<p>上述，就是微支付通道建立、更新与关闭过程。在一个完整的过程中，有且仅有两笔交易广播至链上，同时双方均无须信任对方，任何一方也无法侵害另一方的利益。在更新过程中双方只是交换交易和签名数据，并无交易广播至链上，那么意味着在存入额度范围内，可以创造出无数笔交易。不仅通道内的更新次数不受限制，频率也可以达到非常高，只要系统允许，目前硬件条件可以轻松达到每秒数千笔。</p>

<h2>闪电网络</h2>

<p>在特定场景下，微支付通道拥有着巨大优势，让小额高频支付成为可能。但它存在一个巨大制约：币在通道中的流向是单向的。在上述例子中，币仅能从Alice流至鲍伯。</p>

<p>社区自2013年开始，经历了漫长的探索，争论; 在2015年提出了闪电网络的解决方案。</p>

<p>关于闪电网络，我们在之前的文章中有详细讲解，这里不再赘述。</p>

<p>闪电网络目前正在一步步实用化中；顺便说一句，笔者从事银行支付业务监控多年，我得说，闪电网络的支付方案相对于传统支付技术，有着不可思议的跨越，这项技术的未来不可限量。</p>

<h2>原子交换和跨链交易</h2>

<ul>
<li>侧链技术可以锁定主链的币并将其等价Token转移到另一条链上，以及其逆过程；</li>
</ul>


<p>微支付通道技术实现了同一条链上，交易双方链下高速交易；</p>

<p>那么有没有一种办法，可以实现已经完全运行的区块链间的互通呢？ 比如比特币和以太坊之间的无需三方信任的兑换？</p>

<p>这是可以的，这个即使名为原子交换(Atomic Swap)：</p>

<h3>缘起</h3>

<p>原子交换技术的发展时间基本上与微支付通道的技术是平行的，他们之间也非常相似，可以考据的最早的资料，是2013年有人在bitcointalk.org上发表的一篇文章：</p>

<p><a href="https://bitcointalk.org/index.php?topic=193281.msg2224949#msg2224949">https://bitcointalk.org/index.php?topic=193281.msg2224949#msg2224949</a></p>

<h3>协议</h3>

<p>它的实现条件使用了 HTLC 和博弈论思想。HTLC 在比特币上早已有，而在支持智能合约的区块链上就更容易实现了。</p>

<p>HTLC 的全称是 Hashed Timelock Contracts，原子交换基本是依赖它构建的。可以把 HTLC 理解成一种条件输出，只要满足这个条件你就能花这笔钱。它有两种类型</p>

<p>Hashlock：给你一个哈希值，当你给出它的原像时，你就可以花这笔钱
Timelock：在某个时间点之前，你不能花这笔钱。只有这个时间点之后才能花。</p>

<p>没有错，如果你仔细看过我们之前的文章，这个HTLC其实也是闪电网络的一部分技术，并且如果你完全理解了闪电网络，就会发现原子交换非常相像，不过它是在两条不同的链之间的交易；</p>

<h3>过程</h3>

<p>以下内容引自:<a href="https://zhuanlan.zhihu.com/p/31689532">https://zhuanlan.zhihu.com/p/31689532</a></p>

<p>为了解释原子交换的流程，又要祭出我们的 Alice 和 Bob。</p>

<p>阅读前注意</p>

<ul>
<li>“交易”都是指区块链上的 transaction，而“交换”指原子交换这个协议</li>
<li>tx11 表示满足 tx1 解锁条件 1 的交易，tx12 表示满足 tx1 解锁条件 2 的交易；tx21 和 tx22 同理。</li>
</ul>


<h4>场景：Alice 用 1BTC 与 Bob 交换 3ETH。过程如下</h4>

<h4>Alice</h4>

<ol>
<li>生成随机数 a 并计算 hash(a)</li>
<li>生成 1BTC 的比特币交易 tx1，但不先广播。tx1 的输出是分支输出：当解锁脚本满足下面某个分支时，可以花费 tx1 里的 1BTC

<ul>
<li>Alice 和 Bob 的签名</li>
<li>hash(a) 的原像和 Bob 的签名</li>
</ul>
</li>
<li>生成交易 tx11，该交易把 1BTC 从 tx1 转到 Alice 自己的地址里，有 48h locktime，即要前一笔交易上链后过 48h，本交易才能上链。这笔交易是为了保证在整个交换过程失败时，Alice 可以取回她的钱。</li>
<li>请求 Bob 对 tx11 的签名。此后，Alice 再附上自己的签名，tx11 就同时有 Alice 和 Bob 的签名。但 Alice 不能上链该交易，她需要等到 48h 的 locktime。</li>
<li>广播 tx1，该交易上链。</li>
</ol>


<h4>Bob：做和 Alice 相似的操作</h4>

<ol>
<li>确认 tx1 上链后，生成 3ETH 的以太坊交易 tx2，但先不广播。tx2 的输出也是分支输出：当解锁脚本满足下面某个分支时，可以花费 tx2 里的 3ETH

<ul>
<li>Alice 和 Bob 的签名</li>
<li>hash(a) 的原像和 Alice 的签名（Bob 可从已上链的 tx1 知道 hash(a)）</li>
</ul>
</li>
<li>生成交易 tx21，该交易可以在 24h locktime（一定要比 tx11 的 48h locktime 短）之后，把 3ETH 从 tx2 转回 Bob 的以太坊地址里。</li>
<li>请求 Alice 对 tx21 的签名</li>
<li>广播 tx2，该交易上链。</li>
</ol>


<h4>成功的情况</h4>

<ol>
<li>Alice 确认 tx2 上链后，在 24h 内构造并广播交易 tx22：将 3ETH 从 tx2 里转到 Alice 的以太坊地址里（满足 tx2 的解锁条件2：揭露 a 和 Alice 的签名）。tx22 上链以太坊网络。</li>
<li>Bob 从广播的 tx22 里得到 a 后，构造交易并广播 tx12：将 1BTC 从 tx1 里转到 Bob 的比特币地址里（满足 tx1 的解锁条件2：揭露 a 和 Bob 的签名）。tx12 上链比特币网络。</li>
<li>交易完成</li>
</ol>


<h4>失败的情况</h4>

<ol>
<li>若 24h 内，Alice 没有构造并广播交易 tx22。</li>
<li>则 24h 后，Bob 签名并广播 tx21（超过 locktime，且同时有 Alice 和 Bob 的签名），把 3ETH 转回给自己。tx21 上链以太坊网络。</li>
<li>48h 后，Alice 同理广播 tx11，把 1BTC 转回给自己。tx11 上链比特币网络。</li>
<li>交易失败，但双方都不会损失钱。</li>
</ol>


<p>原子交换里交易的上链顺序应该为：tx1->tx2->Max(tx12, tx22)。前一个交易应该等到后一个交易完全上链，才能保证整个过程的绝对安全，双方都不会损失钱。</p>

<h4>缺陷</h4>

<p>原子交换看似安全，实际还是存在不少缺陷的。</p>

<ul>
<li><p>可以看出，不管交换成功或失败，总会有 4 个交易被上链。如果按照比特币现有的拥堵状态和高手续费，原子交换是基本行不通的，代价过高且会有损失钱的风险。</p></li>
<li><p>在考虑外部市场后，会存在对手风险，原子交换是不适用的。如在上面的协议描述里，Alice 和 Bob 已经将 tx1 和 tx2 上链。则这之后，原子交换的成功与否取决于 Alice 是否要抛出 hash(a) 的原像，她有 24h 的考虑时间去决定。那在这 24 小时内，Alice 大可在对比交易所和原子交换的比率差别，如果交易所的汇率对自己有利，那就去交易所交易，抛弃原子交换。在这种情况下，Alice 除了会锁定 48h 的币，没有其他风险，风险全部转嫁给了 Bob。
那么有人说，缩短 24h 和 48h 的参数设定就好了啊。但无论怎么缩短，这个风险都不能消除。且缩短锁定时间还可能带来安全风险。</p></li>
<li><p>除此之外，还有一种攻击。在 tx1 和 tx2 上链后，Bob 完全封锁 Alice 的网络（由于存在点对点通信，会增加这种风险）。Alice 发出的 tx22 无法广播到网络里，但 Bob 可以截取到。Bob 因此可以得到 Hash(a) 的原像，从而上链 tx12（满足 tx1 的解锁条件2）拿到 1BTC。之后，Bob 再封锁 Alice 的网络 24 小时，他就又可以上链 tx21（满足 tx2 的解锁条件1）拿到 3ETH。
那有人说，只要 Alice 迟迟发现自己发出的 tx22 不上链，那就去找个网吧重新发交易啊。Bob 总不能连人去哪都可以追踪吧。这确实是最简单的抵御方法。但也说明，原子交换需要人类来监控，在完全程序自动化的条件下完成仍存在风险。</p></li>
<li><p>Atomic Swap并不能在任意两种虚拟货币之间自由的发生，他们必须要满足如下条件：</p>

<ul>
<li>必须有共同的哈希算法</li>
<li>都具有时间锁定功能</li>
<li>脚本执行过程中验证签名</li>
</ul>
</li>
</ul>


<h4>去中心化交易所</h4>

<p>Atomic Swap的优点也是非常明显的，区块链发展史上，发生了大量的中心化交易所跑路事件；有了Atomic Swap，总算技术上可以建立一个去中心化的，无需三方信任的交易所了；</p>

<p>这意味着，去中心化、无信任的交易成为可能，用户将能够保管他们的虚拟货币，并自由的兑换其他虚拟货币。不管怎么说，原子交换是一项非常有趣的创新，可能会改变加密货币交易的格局。</p>

<h2>结语</h2>

<p>侧链、跨链等等技术是这两年的热门技术，尤其是Ethereum、EOS等项目支持更丰富的脚本，提供了更多的玩法；所以在这个领域颇有一些<code>炫技</code>的味道&mdash;-各路英雄好汉提出种种精巧到不可思议的技术，只是把一堆空气币搬来搬去；</p>

<p>这系列文章也快写到结尾了，我一直对比特币抱有非常善意、乐观的态度；我深深明白，自大会蒙蔽判断力，为此我也一直非常认真的学习社区里面每一天冒出来的种种高科技~~~</p>

<p>但是，我忍不住说(是的，我也化身为自己讨厌的那种人)： <code>当前</code>所谓的各路区块链技术看起来非常像是空中楼阁！ 区块链技术是一种梦幻的技术，所谓的侧链是梦中的梦，我毫不怀疑这是一项精巧到令人赞叹的发明，也毫不怀疑它有非常远大的前景；但这都是几十上百年之后的事情，目前为止，就是个大泡沫；</p>

<p>因为这种梦幻技术的简洁明了，让每个理解它的人不自觉的沉迷其中，我甚至都觉得一条chain都有艺术上的美感；但是始终要明白，它现在只是一个艺术品，收藏品，进化为工业产品还有非常非常长的路要走~~~</p>

<h5>在这场泡沫之舞中，唯有耐心</h5>

<p>有一句话非常适合比特币信徒们：</p>

<blockquote><p>我并不仅仅在寻求“结果”&hellip;如果只为了寻求“结果”的话，人是容易走捷径的&hellip;在走捷径时，也许就会迷失真实，甚至连满腔的热忱也会逐渐丧失。我认为重要的是“寻求真实的意志”！只要有了这种向真实前进的意志，即使这次失败了，我也终于会达到目标的，因为我仍在继续前进&hellip;这是不会错的。</p></blockquote>

<h2>参考资料:</h2>

<p><a href="http://www.blockstream.com/sidechains.pdf">http://www.blockstream.com/sidechains.pdf</a></p>

<p><a href="https://en.bitcoin.it/wiki/Atomic_swap">https://en.bitcoin.it/wiki/Atomic_swap</a></p>

<p><a href="https://github.com/decred/atomicswap">https://github.com/decred/atomicswap</a></p>

<p><a href="https://en.bitcoin.it/wiki/Merged_mining_specification">https://en.bitcoin.it/wiki/Merged_mining_specification</a></p>

<p><a href="https://en.bitcoin.it/wiki/Sidechain">https://en.bitcoin.it/wiki/Sidechain</a></p>

<p><a href="https://www.ccvalue.cn/article/1495.html">https://www.ccvalue.cn/article/1495.html</a></p>

<p><a href="https://read.douban.com/ebook/24123244/">https://read.douban.com/ebook/24123244/</a></p>

<p><a href="https://zhuanlan.zhihu.com/p/31689532">https://zhuanlan.zhihu.com/p/31689532</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-1]]></title>
    <link href="https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1/"/>
    <updated>2019-01-21T17:44:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1</id>
    <content type="html"><![CDATA[<p>blockchain是个新造词，至少在2008年之前网上是搜索不到这个词的；</p>

<p>比特币的白皮书里面出现过<code>chain of blocks</code>的描述，但是没有直接用<code>block chain</code>的句子;</p>

<p>在早期bitcointalk.org上面的讨论中，为了方便讨论，早期参与者频繁引用<code>chain of blocks</code>的主题，但是谁是最早的引用者，已不可考据。</p>

<p>如果真正要较真blockchain这个单词第一次出现的地方，我想大概是中本聪的第一版bitcoin 源代码中；</p>

<p>bitcoin v0.01源代码中，中本聪第一次在<a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.h#L596">函数注释中</a> 完整的引用了<code>block chain</code>这个术语，鉴于中本聪在比特币白皮书发表的2年前已经开始编写源码；所以有理由确认：</p>

<ol>
<li>blockchain这个名词是2007-2008年间诞生于世间的</li>
<li>中本聪是比特币之父，比特币是blockchain之母</li>
</ol>


<p>现在有一种说法，是比特币和区块链是不同的，比特币是个没有什么前途的庞氏货币，而区块链作为一种新兴的基础技术将会在很多领域发扬光大，前景光明；</p>

<p>对于这个说法，我认为Andreas的一场演讲值得一看：</p>

<p><a href="https://www.youtube.com/watch?v=SMEOKDVXlUo">https://www.youtube.com/watch?v=SMEOKDVXlUo</a></p>

<!-- more -->


<p>好了，八卦完毕，我们开始探究比特币里面的blockchain究竟是个什么样的技术，它是解决什么问题的，实现细节是怎样的；</p>

<p>然后我们一贯的风格是:<code>光说不练假把式</code>；在原理说明中，我们会用代码parse真正的比特币区块链文件来一探究竟。</p>

<h2>由来</h2>

<p>还记得我们<a href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/">之前的文章</a>里面提到的，如果要建立一个分布式的账本，要解决两个问题:</p>

<ol>
<li>什么样的交易是一笔合法的交易</li>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>我们在比特币交易的系列文章中解答了第一个问题，现在是解决第二个问题的时候了。</p>

<p>先思考一下货币发行的问题，比特币网络中，会有成千上万的节点参与者，哪些节点能获得发币的权利呢？或者说，凭什么这些节点能有记账权呢？</p>

<p>在金银货币时代，发币是通过开采金矿来实现的；采矿者承担了勘探、挖掘的风险，大家认可其开采成果并承认其铸币权；那么映射到电子世界中，能不能有一种类似的挖矿的机制呢？</p>

<p>中本聪的回答就是POW (proof of work&mdash;工作量证明)；全网的所有节点一起算一个毫无意义的随机数字，这个数字满足以下的条件，凡是能算出这个数字的人，我们就承认他有一次的记账权：即一次铸币的权利；这个条件如下：</p>

<h4>在一个计算周期内，计算出来的这个数字R满足 F(Chain[R]) &lt; Target；其中F是SHA256算法，Chain是账本，Target是不断减小的，这意味着寻找R的几率会越来越小</h4>

<p>中本聪认为算力是非常公平的、不可伪造的一种证明手段；凡是能在规定周期内正确解答谜题的人，理应获得回报；所有加入到这个比特币网络的人，都应该承认这一点，如果你不承认，那比特币网络就不欢迎你；</p>

<p>那么，铸币的问题解决了；但是如何防止有的节点获取记账权之后，伪造账本呢？</p>

<p>答案是将POW的计算结果嵌入到账本中，每一次新周期的计算，其结果必须在之前所有计算结果的基础上完成；这样如果有人想要伪造账单条账目，他就必须在一个计算周期内伪造更多的账目；如果想要伪造整个账本，就需要将比特币创世之初到现在所有的POW重新计算一遍，而能够获得这样的算力，基本上是不可能的。</p>

<p>那么，如何将这个计算证明过程嵌入到账本里面呢？</p>

<p>答案就是每个计算周期生成一个block，这个block包含了这个周期内全网的交易，而Target就嵌入到这个block中，然后将block用HASH值作为指针串联起来，构造成一条坚不可摧的chain；这就是blockchain的由来。</p>

<h2>区块结构</h2>

<p>如果你运行最新版本的bitcond(>=v0.16)，会发现在数据目录有四类文件:</p>

<ol>
<li>datadir/blocks/blkxxxxx.dat: 存储原始的区块数据，这就是我们常说的blockchain数据</li>
<li>datadir/blocks/index/xxxx.ldb: 区块的原始数据索引，有了它，我们就可以根据HASH值快速查找交易和区块</li>
<li>datadir/chainstate/xxx:这个目录中,存放着LevelDB中的UTXO记录,以及一些这些交易来源的元数据.这些数据用来校验收到的区块和交易</li>
<li>datadir/blocks/revxxxxx.dat: 在区块链分叉重组的时候需要用回滚记录去更新UTXO记录</li>
</ol>


<p>1是原始区块数据，第2，3类数据可以从1中重建，但重建会花很长时间；在一台16Core, 32GB内存，SSD磁盘的机器上，大概要花1天左右。</p>

<p>第4类数据比较特殊，如果存储的数据已经落后了当前区块高度非常远的距离，其实可以删除的；但是为了保证 100%的严谨和安全，目前默认的实现还是全部保留。</p>

<p>3，4类数据在最初的比特币版本中，没有写入文件，就是内存里面放个MAP数据结构临时存着；后来交易量变大，多次代码重构后，变成了今天这个样子。</p>

<p>截至2019-01，以上数据加起来，已经超过了200GB。</p>

<p>那我们就主要来分析第1类数据，就是原始区块数据。</p>

<h4>Block结构</h4>

<p>一个block的结构异常简单，列表如下:</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> Block Size </td>
<td> 当前block的大小</td>
</tr>
<tr>
<td>80 bytes </td>
<td> Block Header </td>
<td> block头信息</td>
</tr>
<tr>
<td>1-9 bytes (VarInt) </td>
<td> Transaction Counter </td>
<td> 这个block包含的交易数量</td>
</tr>
<tr>
<td>Variable </td>
<td> Transactions </td>
<td> 交易</td>
</tr>
</tbody>
</table>


<p>如果去parse blkxxxx.dat 文件，按照这个结构就能很容易拆分出每一个block；来一个工具:</p>

<p><a href="https://github.com/alecalve/python-bitcoin-blockchain-parser">https://github.com/alecalve/python-bitcoin-blockchain-parser</a></p>

<p>另外值得注意的是，因为bitcoind写入区块文件的时候是并行的，所以按照字节序解析出来的区块并不是按时间顺序排列的，blkxxxx.dat文件中，区块存储的次序是随机的；</p>

<h4>Block Header</h4>

<p>区块头由三组区块元数据组成。</p>

<p>首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。就是我们前面讲的作为指针的HASH值。</p>

<p>第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，本质上就是前面公式里面的R值和Target值。</p>

<p>第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构，我们在后面会介绍）。</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> nbits </td>
<td> 当前block的POW难度值 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce </td>
</tr>
</tbody>
</table>


<p>PS:比特币客户端除了bitcoin core之外，任何团队都可以根据当前的协议开发自己的比特币软件，事实上当前也有不少其他的实现，而各个团队之间开发的不同客户端需要遵循同样的协议标准，这个协议的版本管理就是依靠开头的version字段，规则请参照<a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">BIP009</a></p>

<h4>block标识符</h4>

<p>block header中，我们有一个<code>Previous Block Hash</code>值，这就是我们所说的将block串联成为chain的指针。那么这个指针值是怎样计算出来的呢？</p>

<p>还是以<a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">创世块</a>为例，让我们仔细研究下:</p>

<p>创世块的HASH值为<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>，这是一个32字节的HASH值，通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。注意，这个值仅仅是根据区块头得到的，即 <code>SHA256(SHA256(Block Header))</code>;</p>

<p>仅仅依赖区块头就够了吗？是的，不要忘了，我们在区块头里面还有一个重要的HASH值，就是<code>Merkle Tree Root Hash</code>，<code>Merkle Tree Root Hash</code>标识了block中所有的交易，而<code>Block Hash</code> 通过HASH包含了<code>Merkle Tree Root Hash</code>的<code>Block Header</code>，唯一、明确地标识了一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>

<p>通过<code>Merkle Root</code>和<code>Block Hash</code>决定了，一个区块被铸造出来，恶意的第三方节点是无法修改它的 (关于Merkle，请参考后面的说明)；</p>

<p>另外需要注意的一点是: 区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。</p>

<p>当我parse block得到<code>previous block hash</code>值时，如何去判断存在上一个真正的block呢？一般都会到索引文件里面找，就是我们前面所说的 index/xxxx.ldb文件。</p>

<h4>区块高度</h4>

<p>除了这个HASH值作为区块标识符，我们一般还会在区块浏览器上面看到一个说明<code>Height</code>；比如创世块的<code>Height</code>就是0；</p>

<p>这是程序员们按照block在chain上面的次序为block的编号，这个信息是不会写入blockchain的，只是作为<code>区块高度</code>在很多时候方便表示和计算；</p>

<p>当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。</p>

<p>和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况是怎样发生的呢？</p>

<p>因为一个全节点会时时刻刻接收全网的区块广播，在一个生产周期内，不可避免的，会产生两个或更多的符合条件的block，这个时候会发生什么呢？</p>

<p>所有区块高度相同的区块会争夺成为链接上chain的权利，此时所有的矿工便会收集所有可能的chain分支，并选取最长的那一条在上面继续挖矿。</p>

<p>如果把这个情景图像化，我们会看到blockchain时时刻刻都处在分叉状态中，新产生的block会在chain的末尾组成多个分支，不断的消亡、新生、重组，就就好像一条末端散开的绳子有了生命一样；</p>

<p>关于这个情景，有个很诗意的描述词：<code>HASH DANCE</code>；</p>

<p>作为一个Geek，这真是一场让人意醉神迷的数字之舞啊。</p>

<p>PS: 理论上，如果出现一台拥有着无限计算能力的新型的计算机，当然可以轻易伪造1000个或者更多的block，但是现实情况限制比较严格，当新生成的区块寿命过了100个区块高度之后，系统就不再接受重组了，这算是一个多重保险吧。</p>

<h4>创世区块</h4>

<p>区块链里的第一个区块创建于2009-01-03 18:15:05 GMT，被称为创世区块(Genesis block)。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。</p>

<p>因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。</p>

<p>创世块比较特殊，它不是挖出来的，是中本聪手工构造的；参见这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439">https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439</a></p>

<p>关于创世块，之前我们提到一个有趣的事情：创世块的50BTC奖励是不能花的，这是为什么呢？</p>

<p>这需要我们好好研究下中本聪发布的v0.01版本的比特币源码：</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01">https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01</a></p>

<ol>
<li>整个比特币系统接收一笔交易的时候怎么判断其合法性呢？就是判断这笔交易的vin是否关联着一笔合法交易的vout，这些vout统称UTXO，在初版比特币里面，判断一个合法的UTXO的标准就是有没有放进区块链的索引文件中；这个索引文件和区块链文件不是一个东西，他是单独的；如果你运行初版比特币软件(v0.01)；就可以看到中本聪把区块存储在blk0001.dat这样的文件里面，而把所有区块的索引存储在blkindex.dat这个文件里面；</li>
<li>那么问题就出现了，blkindex.dat 什么时机才能写入呢？通读源码发现，只有自己挖矿挖到区块，或者收到周围的广播区块的时候，才有机会写入blkindex.dat这个文件;</li>
<li>中本聪不知道有意无意，在前面手工构造创世区块的时候，没有构建索引写入blkindex.dat里面</li>
<li>后来比特币的源码不断变迁，存储UTXO的方式由BDB变成了levelDB，但是创世块一直没有没有写入到索引文件里面，这样花费创世交易的时候，没有相应的索引，创世交易的UTXO就是非法的，所以没法花费</li>
</ol>


<h5>那么如何解决呢？有两个办法：</h5>

<ol>
<li>就是把创世区块写到区块索引里面</li>
<li>或者在检查交易合法性的时候，单独的加一个判断条件，判断UTXO是否出自创世区块</li>
</ol>


<h5>为什么迟迟没有修正：</h5>

<ol>
<li>每个办法都需要一次硬分叉</li>
<li>这需要全网节点都升级这个只影响创世块的50BTC，中本聪都不在乎，何苦为了50BTC就全网升级呢？</li>
<li>最后，创世块见证着历史，其实不能花费挺好的。</li>
</ol>


<h4>coinbase</h4>

<p>紧接着<code>block header</code>的，就是当前block的所有交易，其中第一笔交易就是coinbase 交易。关于coinbase交易，我们曾经在之前的文章中详细介绍过，这里就增加说明一点，coinbase交易的输出包括了所有交易的手续费，将来比特币网络的额定产出越来越少的时候，矿工们还是可以通过打包交易费用获利，来维持比特币网络的正常运转。</p>

<p>就当前的情况来看，再来一次减半，基本上交易费用和新区快产出就对等了。</p>

<h4>隔离见证</h4>

<p>实施了隔离见证之后，对于<code>block header</code>和coinbase都有一些变化，我们以后会详细再提。</p>

<h2>Merkle树</h2>

<p>区块链的数据是永不删除的，随着交易量越来越大，整个区块数据量也越来越大，那么问题又来了，不可能每个节点都下载数百GB的数据来来验证一笔交易的合法性，而作为一个分布式系统，我们是不能信赖任何中心节点的！我们怎样在一个手机钱包软件里面验证一笔交易呢？</p>

<p>答案是一个绝妙的数据结构: <code>Merkle</code>；</p>

<p>将比特币系统的交易和区块用Merkle树组织起来，会获得一项不可思议的能力，即使整个区块达到数百GB，每个轻节点只需要接收少许数据(MB级别)，就可以完成交易的合法性校验，并且无需任何中心化的节点。</p>

<p>初次接触到Merlke树算法的时候，我觉得这简直是为比特币系统量身定做的，我觉得这是整个系统里面最优美、最简单、最不可思议的算法。</p>

<p>这是怎么做到的呢？呵呵，偶很懒，自己去翻参考资料吧。</p>

<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></p>

<h2>挖矿</h2>

<p>内容引用自： <a href="https://www.8btc.com/article/108894">https://www.8btc.com/article/108894</a></p>

<p>有了Merkle Tree这个数据结构之后，我们非常简单的就可以用一个root hash值来唯一的确定一个block中的所有交易及排列次序；所以要<code>证明</code>这个block中的交易没有被篡改，只要一个<code>Merkle Tree Root Hash</code>值就可以了；将这个值嵌入区块头，然后对整个区块头做HASH，这个过程一旦确定，基本上就不可逆了。</p>

<p>那么终于到了我们前面提到的第二个问题，也是整个系统中最重要的问题:</p>

<ol>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>这个问题的回答就是<code>POW挖矿</code>；大众喜闻乐见的一种行为；虽然挖矿的原理简单的不可思议，但是我觉得真正去花时间搞明白的人也没有几个；那么，我们简单说说吧：</p>

<h4>毫无意义的随机数字</h4>

<p>是的，朋友们，比特币本身是一个荒谬的东西，其中<code>挖矿</code>这种行为，更是荒谬中的荒谬：浪费一个小型国家的能源消耗，只为了计算一个<code>毫无意义的随机数字</code>，人类的荒谬性在此暴露无遗！好一场荒诞派戏剧 ！！所有的Bitoiners其实正参演着一场现代版的《等待戈多》！！！</p>

<p>那么，让我们来看看，Nerd们在追求的这个<code>毫无意义的随机数字</code>究竟是什么吧。</p>

<p>再回忆一下我们前面提到的block header里面的所有字段：</p>

<table>
<thead>
<tr>
<th>长度 </th>
<th> 字段名 </th>
<th> 作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> nBits </td>
<td> 当前block的POW难度值 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce </td>
</tr>
</tbody>
</table>


<p>其中，矿工们能自由更改的：</p>

<ol>
<li>32 bytes的<code>Merkel Root Hash</code>值，这个可以通过调整交易的次序和block包括哪些交易来进行，但是每次调整需要一些计算</li>
<li>4 bytes的Timestamp，调整范围大概在一个比特币的生产周期内(10分钟左右)，这个调整的空间很小</li>
<li><p>Nonce，就是这个；中本聪初版发布时，其挖矿活动就是计算Nonce</p></li>
<li><p>那么算出来的Nonce需要达到什么条件呢？</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SHA256(SHA256(Blockherder)) &lt; F(nBits)</span></code></pre></td></tr></table></div></figure>


<p>其中，SHA256(SHA256(Blockherder))就是挖矿结果，F(nBits)是难度对应的目标值，两者都是256位，都当成大整数处理，直接对比大小以判断是否符合难度要求。</p>

<p>为了节约区块链存储空间，将256位的目标值通过一定变换无损压缩保存在32位的nBits字段里。具体变换方法为拆分利用nBits的4个字节，第1个字节代表右移的位数，用V1表示，后3个字节记录值，用V3表示，则有：</p>

<p>F(nBits)=V3 * 2<sup>8*(V1-3) </sup></p>

<p>此外难度有最低限制，也就是说 F(nBits) 有个最大值，比特币最低难度取值nBits=0x1d00ffff，对应的最大目标值为：0x00000000FFFF0000000000000000000000000000000000000000000000000000</p>

<p>因此挖矿可以形象的类比抛硬币，好比有256枚硬币，给定编号1,2,3……256，每进行一次Hash运算，就像抛一次硬币，256枚硬币同时抛出，落地后要求编号前n的所有硬币全部正面向上。</p>

<p>这里的详细计算可以参考我们之前的一篇<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">文章</a></p>

<h4>CPU挖矿时代</h4>

<p>在Bitcoin早期，只有少数的几个Geek来尝试运行软件，此时的bitcoin core客户端集合了钱包、全节点、挖矿的所有功能；所以早期的节点挖矿过程非常简单：</p>

<blockquote><p>构造区块，初始化区块头各个字段，计算Hash并验证区块，不合格则nNonce自增，再计算并验证，如此往复。在CPU挖矿时代，nNonce提供的4字节搜索空间完全够用（4字节即4G种可能，单核CPU运算Double SHA256算力一般是2M左右），其实nNonce只遍历完两个字节就返回去重构块</p></blockquote>

<h4>GPU挖矿时代</h4>

<p>很快，大家就发现挖矿这个行为只需要在一个block周期内定时获取区块头就可以，不需要每个矿机都运行一个全节点。于是最初的bitcoin软件支持了getwork 协议。</p>

<p>getwork协议代表了GPU挖矿时代，需求主要源于挖矿程序与节点客户端分离，区块链数据与挖矿部件分离。其核心设计思路是：</p>

<blockquote><p>由节点客户端构造区块，然后将区块头数据交给外部挖矿程序，挖矿程序遍历nNonce进行挖矿，验证合格后交付回给节点客户端，节点客户端验证合格后广播到全网。</p>

<p>如前所述，区块头共80个字节，由于没有区块链数据和待确认交易池，nVersion，hashPrevBlock，nBits和hashMerkleRoot这4个字段共72个字节必须由节点客户端提供。挖矿程序主要是递增遍历nNonce，必要时候可以微调nTime字段。</p>

<p>对于显卡GPU来说，其实不用担心nNonce的4字节搜索空间不足，而且挖矿程序从节点客户端那里拿到一份数据后，不应该埋头工作太久，不然很有可能这个块已经被其他人挖到，继续挖只能做无用功，对于比特币来说，虽然设计为每10分钟一个区块，良好的策略也应该在秒级内重新向节点申请新的挖矿数据。对于显卡来说，运行SHA256D算力一般介于200M~1G，nNonce提供4G搜索空间，也就是说再好的显卡也能支撑4秒左右，调整一次nTime，又可以再挖4秒，这个时间绰绰有余。</p>

<p>节点提供RPC接口getwork，该接口有一个可选参数，如果不带参数，就是申请挖矿数据，如果带一个参数，就是提交挖到的块数据。</p></blockquote>

<p>我们先想一下，如果要挖矿，getwork返回的最小数据是哪些呢？</p>

<p>只需要区块头的前76个字节就可以！ 通过nNonce和nTime，就能直接构造。</p>

<p>但是getwork协议充分考虑各种情况，尽量帮助外部挖矿程序做力所能及的事，提供了一些额外字段。getwork的全部返字段如下：</p>

<ul>
<li>Data字段</li>
</ul>


<p>共128字节（80区块头字节 + 48补全字节），因为SHA256将输入数据切分成固定长度的分片处理，每个切片64字节，输入总长度必须是64字节的整数倍，输入长度一般不符合要求，则根据一定规则在元数据末端补全数据。</p>

<ul>
<li>Target字段</li>
</ul>


<p>即当前区块难度目标值，采用小头字节序，需要翻转才能使用。这其实是根据区块头的nBits计算出来的， getwork送佛送到西，直接帮你算好了。</p>

<ul>
<li>Midstate字段</li>
</ul>


<p>SHA256对输入数据分片处理，矿工拿到data数据后，第一个分片（头64字节）是固定不变的，midstate就是第一个分片的计算结果，节点帮忙计算出来了。 因此，在midstate字段辅助下，外部挖矿程序甚至只需要44字节数据就可以正常挖矿：32字节midstate + 第一个切片余下的12（76-64）字节数据。</p>

<ul>
<li>Hash1字段</li>
</ul>


<p>比特币挖矿每次都需要连续执行两次SHA256，第一次执行结果32字节，需要再补充32字节数据凑足64字节作为第二次执行SHA256的输入。hash1就是补全数据，同理，hash1也是固定不变的。</p>

<blockquote><p>外部挖矿程序挖到合格区块后再次调用getwork接口将修改过的data字段提交给节点客户端。节点客户端要求返回的数据也必须是128字节。</p>

<p>每次有外部无参调用一次getwork时，节点客户端构造一个新区块，在返回数据前，都要把新区块完整保存在内存，并用hashMerkleRoot作为唯一标识符，节点使用一个Map来存放所有构造的区块，当下一个块已经被其他人挖到时，立即清空Map。</p>

<p>getwork收到一个参数后，首先从参数提取hashMerkleRoot，在Map中找出之前保存的区块，接着从参数中提取nNonce和nTime填充到区块的对应字段，就可以验证区块了，如果难度符合要求，说明挖到了一个块，节点将其广播到全网。</p>

<p>getwork协议是最早版本挖矿协议，实现了节点和挖矿分离，经典的GPU挖矿驱动cgminer和sgminer，以及cpuminer都是使用getwork协议进行挖矿。getwork + cgminer一直是非常经典的配合，曾经很多新算法推出时，都快速被移植到cgminer。即便现在，除了BTC和LTC，其他众多竞争币都还在使用getwork协议进行挖矿。矿机出现之后，挖矿速度得到极大提高，当前比特币矿机算力已经达到10T/秒级别。而getwork只给外部挖矿程序提供32字节共4G的搜索空间，如果继续使用getwork协议，矿机需要频繁调用RPC接口，这显然不可行。如今BTC和LTC节点都已经禁用getwork协议，转向更新更高效的getblocktemplate协议。</p></blockquote>

<h4>GETBLOCKTEMPLATE</h4>

<p>getblocktemplate协议诞生于2012年中，此时矿池已经出现。矿池采用getblocktemplate协议与节点客户端交互，采用stratum协议与矿工交互，这是最典型的矿池搭建模式。</p>

<p>与getwork相比，getblocktemplate协议最大的不同点是：getblocktemplate协议让矿工自行构造区块。如此一来，节点和挖矿完全分离。对于getwork来说，区块链是黑暗的，getwork对区块链一无所知，他只知道修改data字段的4个字节。对于getblocktemplate来说，整个区块链是透明的，getblocktemplate掌握区块链上与挖矿有关的所有信息，包括待确认交易池，getblocktemplate可以自己选择包含进区块的交易。</p>

<p>getblocktemplate 在被开发出来后并非一成不变，在随后发行的各个版本客户端都有所升级改动，主要是增添一些字段，不过核心理念和核心字段不变。目前比特币客户端返回数据如下，考虑到篇幅限制，交易字段（transactions）只保留了一笔交易数据，其实根据当前实际情况，待确认交易池实时有上万笔交易，目前区块基本都是塞满的（1M容量限制），加上额外信息，因此每次调用getblocktemplate基本都有1.5M左右返回数据，相对于getwork的几百个字节而言，不可同日而语。</p>

<p>来简单分析一下其中几个核心字段， Version，Previousblockhash，Bits这三个字段分别指区块版本号，前一个区块Hash，难度，矿工可以直接将数值填充区块头对应字段。</p>

<p>Transactions，交易集合，不但给了每一笔交易的16进制数据，同时给了hash，交易费等信息。 Coinbaseaux，如果有想要写入区块链的信息，放在这个字段，类似中本聪的创世块宣言。 Coinbasevalue，挖下一个块的最大收益值，包括发行新币和交易手续费，如果矿工包含Transactions字段的所有交易，可以直接使用该值作为coinbase输出。 Target，区块难度目标值。 Mintime，指下一个区块时间戳最小值，Curtime指当前时间，这两个时间作为矿工调节nTime字段参考。 Height，下一个区块难度，目前协议规定要将这个值写入coinbase的指定位置。</p>

<p>矿工拿到这些数据之后，挖矿步骤如下：</p>

<p>构建coinbase交易，涉及到字段包括Coinbaseaux，Coinbasevalue，Transactions，Height等，当然最重要的是要指定一个收益地址。 构建hashMerkleRoot，将coinbase放在transactions字段包含的交易列表之前，然后对相邻交易两两进行SHA256D运算，最终可以构造交易的Merkle树。由于coinbase有很多字节可供矿工随意发挥，此外交易列表也可随意调换顺序或者增删，因而hashMerkleRoot值空间几乎可以认为是无限的。其实getblocktemplate协议设计的主要目标就是让矿工获得这个巨大的搜索空间。</p>

<p>构建区块头，利用Version，Previousblockhash，Bits以及Curtime分别填充区块头对应字段，nNonce字段可默认置0。</p>

<p>挖矿，矿工可在由nNonce，nTime，hashMerkleRoot提供的搜索空间里设计自己的挖矿策略。 上交数据，当矿工挖到一个块后当立即使用submitblock接口将区块完整数据提交给节点客户端，由节点客户端验证并广播。</p>

<p>需要注意的是，与上文提到的GPU采用getwork挖矿一样，虽然getblocktemplate给矿工提供了巨大搜索空间，但矿工不应对一份请求数据挖矿太久，而应循环适时向节点索要最新区块和最新交易信息，以提高挖矿收益。</p>

<h4>矿池</h4>

<p>在很长一段时期内，大家都是各自为战；但随着全网难度上升，个人挖矿的成功率越来越低，很可能挖数年都不能爆一个块。于是有人提出了大家合作挖矿的办法。矿池挖矿时代来临了。</p>

<p>矿池的核心工作是给矿工分配任务，统计工作量并分发收益。矿池将区块难度分成很多难度更小的任务下发给矿工计算，矿工完成一个任务后将工作量提交给矿池，叫提交一个share。假如全网区块难度要求Hash运算结果的前70个比特位都是0，那么矿池给矿工分配的任务可能只要求前30位是0（根据矿工算力调节），矿工完成指定难度任务后上交share，矿池再检测在满足前30位为0的基础上，看看是否碰巧前70位都是0。</p>

<p>矿池会根据每个矿工的算力情况分配不同难度的任务，矿池是如何判断矿工算力大小以分配合适的任务难度呢？调节思路和比特币区块难度一样，矿池需要借助矿工的share率，矿池希望给每个矿工分配的任务都足够让矿工运算一定时间，比如说1秒，如果矿工在一秒之内完成了几次任务，说明矿池当前给到的难度低了，需要调高，反之。如此下来，经过一段时间调节，矿池能给矿工分配合理难度，并计算出矿工的算力。</p>

<h4>STRATUM</h4>

<p>矿池通过getblocktemplate协议与网络节点交互，以获得区块链的最新信息，通过stratum协议与矿工交互。此外，为了让之前用getwork协议挖矿的软件也可以连接到矿池挖矿，矿池一般也支持getwork协议，通过阶层挖矿代理机制实现（Stratum mining proxy）。须知在矿池刚出现时，显卡挖矿还是主力，getwork用起来非常方便，另外早期的FPGA矿机有些是用getwork实现的，stratum与矿池采用TCP方式通信，数据使用JSON封装格式。</p>

<p>先来说一下getblocktemplate遗留下来的几个问题：</p>

<p>矿工驱动：在getblocktemplate协议里，依然是由矿工主动通过HTTP方式调用RPC接口向节点申请挖矿数据，这就意味着，网络最新区块的变动无法及时告知矿工，造成算力损失。</p>

<p>数据负载：如上所述，如今正常的一次getblocktemplate调用节点都会反馈回1.5M左右的数据，其中主要数据是交易列表，矿工与矿池需频繁交互数据，显然不能每次分配工作都要给矿工附带那么多信息。再者巨大的内存需求将大大影响矿机性能，增加成本。</p>

<p>Stratum协议彻底解决了以上问题。</p>

<p>Stratum协议采用主动分配任务的方式，也就是说，矿池任何时候都可以给矿工指派新任务，对于矿工来说，如果收到矿池指派的新任务，应立即无条件转向新任务；矿工也可以主动跟矿池申请新任务。</p>

<p>现在最核心的问题是如何让矿工获得更大的搜索空间，如果参照getwork协议，仅仅给矿工可以改变nNonce和nTime字段，则交互的数据量很少，但这点搜索空间肯定是不够的。想增加搜索空间，只能在hashMerkleroot下功夫，如果让矿工自己构造coinbase，那么搜索空间的问题将迎刃而解，但代价是必要要把区块包含的所有交易都交给矿工，矿工才能构造交易列表的Merkleroot，这对于矿工来说压力更大，对于矿池带宽要求也更高。</p>

<p>Stratum协议巧妙解决了这个问题，成功实现既可以给矿工增加足够的搜索空间，又只需要交互很少的数据量，这也是Stratum协议最具创新的地方。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg2.png" alt="img" /></p>

<p>再来回顾一下区块头的6个字段80字节，这个很关键，nVersion，nBits，hashPrevBlock这3个字段是固定的，nNonce，nTime这两个字段是矿工现在就可以改变的。增加搜索空间只能从hashMerkleroot下手，这个绕不过去。Stratum协议让矿工自己构造coinbase交易，coinbase的scriptSig字段有很多字节可以让矿工自由填充，而coinbase的改动意味着hashMerkleroot的改变。从coinbase构造hashMerkleroot无需全部交易，如上图所示，假如区块将包含13笔交易，矿池先对这13笔交易进行处理，最后只要把图中的4个黑点（Hash值）交付给矿工，同时将构造coinbase需要的信息交付给矿工，矿工就可以自己构造hashMerkleroot（图中的绿点都是矿工自行计算获得，两两合并Hash时，规定下一个黑点代表的hash值总是放在右边）。按照这种方式，假如区块包含N笔交易，矿池可以浓缩成log2(N)个hash值交付给矿工，这大大降低了矿池和矿工交互的数据量。</p>

<p>在getblocktemplate协议和Stratum协议的配合下，矿池终于进化为完全体，可以接纳近乎无限的矿工和算力，至此比特币全网算力进入了爆炸增长的时代；</p>

<h4>最终，普通交易、conbase交易、nNonce、nTime定义了一个Block Header的 Double SHA256 值是否符合nBits代表的难度值，而这些数据的组合共同造就了一组毫无意义的随机数字;包含这组数字的block一旦产生并广播出去，就极难伪造；正是这组数字，决定了哪个节点有记账的权力，保证了整个账本是唯一且不可篡改的。</h4>

<h2>区块链接成为区块链</h2>

<p>比特币的全节点在本地保存了区块链从创世区块起的完整副本。每个计算周期内矿工们辛勤的工作，会不断产生新的区块，每个区块头都用<code>Merkle Tree Root Hash</code>证明其包含的所有交易的不可篡改性，而区块头中的Nonce又包含着巨大的运算量来保证整个区块的不可篡改性；而区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。</p>

<p>最后，整条链凝结了全网矿工从比特币诞生以来的所有算力总和，这些巨大的算力保证了再伪造同样的一条链是近乎不能完成的任务。</p>

<h4>此时整个账本是唯一且不可篡改的。</h4>

<p>最后所有区块组成了blockchain:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg1.jpg" alt="img" /></p>

<h2>SPV(简单支付)</h2>

<p>Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。</p>

<p>例如，一个SPV节点想知道它钱包中某个比特币地址即将到达的支付。该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkleblock消息的形式发送该区块。Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联，交易与区块、区块和区块链，就可以证明交易存在于区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千多倍。</p>

<h2>小结</h2>

<p>blockchain作为比特币的基本技术支撑之一，毫无疑问是一项前无古人的真正创新；这项技术怎么高估都不过分，我认为数十年后，可能会作为一种工业革命的基础技术跟蒸汽机、电力应用、信息技术相提并论；</p>

<p>比特币的链为我们提供了两项能力:</p>

<ol>
<li>不可伪造的电子时间戳证明；任何依赖于有序时间的处理程序(博彩、公证、法律等等)都可以上链</li>
<li>提供了一个构造发行自定义资产(证券、股票)的基础手段，货币只是一个基本应用，任何人都可以以比特币主链为基础，构造一条侧链，并在其之上实现自己的资产发行、定价、转移功能</li>
</ol>


<p>在未来的世界里，关于这方面的应用和创新简直层出不穷，例如预言机的实现，微支付通道，原子交换等等；我所读过的最好的关于blockchain的一些设想是这个：</p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>

<p>好啦，为了能在未来的世界里面不落人后，我们要继续学习，等我们之后的文章吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一种提高比特币私钥碰撞机率的思路]]></title>
    <link href="https://happy123.me/blog/2019/01/18/%5B%3F%5D-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu/"/>
    <updated>2019-01-18T10:41:40+08:00</updated>
    <id>https://happy123.me/blog/2019/01/18/[?]-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu</id>
    <content type="html"><![CDATA[<p>之前的文章里面我们提到了一个名为<a href="https://lbc.cryptoguru.org">LBC</a>的项目；它采用了遍历所有比特币私钥，bloomfilter所有未花费的币的地址来碰撞比特币私钥。</p>

<p>这个项目本身详尽<a href="https://lbc.cryptoguru.org/stats">计算了这种碰撞成功的几率</a>，目前碰撞空间大概在 2<sup>136</sup> 级别。</p>

<p>目前在一台最顶级的AWS GPU计算节点上面的碰撞效率是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AWS p2.8xlarge   32 vCores Xeon v4, 8x K80 GPUs (50% each)   ~80-88M/s</span></code></pre></td></tr></table></div></figure>


<p>每秒钟大概碰撞8000w次；目前LBC这个项目最顶峰的时候，算力到了1G的级别，这样计算下来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2^136 / 2^30 = 2 ^106</span></code></pre></td></tr></table></div></figure>


<p>2<sup>106</sup> 级别的碰撞效率还是遥遥无期啊；</p>

<!-- more -->


<p>如果通读我们之前的文章就知道，比特币地址的生成，主要花费在ECDSA、SHA256, RIPEMD 这三个算法的操作之上，但其实用GPU计算，这三个步骤花费的时间是很少的，在整个碰撞过程中，其实大部分时间是耗费在bloomfilter上面的；</p>

<p>而bloomfilter的原理，采用的是多级HASHMAP，常理来看，这已经是判断一个元素是否存在某集合的极限效率了；</p>

<p>但是有一点我们不要忘记，比特币的地址采用base58编码，他的地址空间是有规律的，简单来说，就是所有比特币地址的前缀分布，是有规律可循的，他应该在base58的编码范围内成正态分布；而bloomfilter的HASHMAP是没有这种条件优化的，所以说bloomfilter的算法我们可以再改进一下，提升效率。</p>

<p>我分析了截至2018-12以前的所有比特币地址，简便起见，提取了所有的P2PKH地址(共
377059211个地址)，取其前4个字符地址前缀；执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort 4prefix.addr|uniq -c|sort -nr</span></code></pre></td></tr></table></div></figure>


<p>得到了所有地址前缀的分布列表，差不多是个正态分布。</p>

<p>列举一下最常用的地址前缀TOP10:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  23600 1bit
</span><span class='line'>  23086 1btc
</span><span class='line'>  21895 13vs
</span><span class='line'>  21329 1gbx
</span><span class='line'>  21267 1gbt
</span><span class='line'>  21267 1gba
</span><span class='line'>  21210 1gbb
</span><span class='line'>  21206 1gbf
</span><span class='line'>  21196 1gbu
</span><span class='line'>  21189 1gbr</span></code></pre></td></tr></table></div></figure>


<p>最常见的是1bit和1btc这两个前缀，各比第三名多出了10000个左右，这多出来20000个地址应该是Geek们自己生成的虚荣地址。</p>

<p>所有的比特币P2PKH地址，4字母前缀共有42877种组合。</p>

<p>好了，这就是我们可以优化的地方，把bloomfilter的第一级HASHMAP，采用这些前缀组合先来一把过滤，再去执行常规的Bloomfilter，碰撞效率会再提高一个数量级。</p>

<p>我在自己机器上实验了一下，在GTX750Ti 2G显卡上面，最终效率可以达到 10M/s。</p>

<p>瓶颈现在又变成了genaddress环节，我估计在一块RX480卡上面，可以达到和AWS顶配GPU一样的效率；</p>

<p>不过，效率提升十倍，也不过是 2<sup>100</sup> 的碰撞范围，还是遥遥无期啊。</p>

<h4>更深入的分析</h4>

<p>早期在bitcointalk.org论坛上，Laszlo Hanyecz曾经有过一个想法，就是随着硬件性能的发展，最终碰撞比特币私钥的收益会不会超过挖矿的收益？</p>

<p>中本聪当时的回答是，要达到这个碰撞算力很远很远。</p>

<p>我们来仔细分析一下：</p>

<p>比特币的地址生成是很容易硬件ASIC化的，如果用这种前缀过滤法，也不需要多少内存，所以可以近似认为：如果硬件化，比特币私钥碰撞的效率和挖矿效率是差不多的。</p>

<p>目前比特币全网算力在40EH左右，就是2<sup>62</sup>，这已经是相当于400w台蚂蚁S9的机器同时24X365 运行了；消耗的电力估计已经超过了上海市的居民用电，比特币矿机的能源消耗，完全可以说是抵得上一个小型国家的能源消耗了。</p>

<p>如果私钥碰撞达到2<sup>62</sup>级别，那么毛估估，碰撞几率就能减小到 &frac12;<sup>60</sup> 级别了；</p>

<p>但是这个概率还是太低了。</p>

<p>而且另外一个无法预测的情况就是，将来人们的安全意识加强，一般一个地址只要用过就会丢弃掉，所以最终bloomfilter的条目变化会非常频繁，还要考虑一个数量级的损耗。</p>

<p>目前测算，随着手续费用的提高，即使多次减半，将来挖矿的收益估计很长期稳定1-10btc/block级别，在如果将来以1年时间碰撞一个私钥的概率期望测算的话，一年大概是2<sup>25</sup> 秒，这样碰撞效率至少要提高到 2<sup>95</sup> 级别，才能达到<code>破解私钥得利</code>><code>挖矿得利</code> 的效果；</p>

<p>算力提高到2<sup>95</sup>，不管用什么技术，即使是量子计算，也很难想象能到这个量级啊；</p>

<p>而且，即使到了这一天，把RIPEMD替换成一种碰撞空间更大的算法就OK了。</p>

<p>这样看来，bitcoin的安全性还是无懈可击。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wsl Best Practice]]></title>
    <link href="https://happy123.me/blog/2019/01/16/wsl-best-practice/"/>
    <updated>2019-01-16T14:13:58+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/wsl-best-practice</id>
    <content type="html"><![CDATA[<p>WSL用了一年，感觉还不错。尤其是在我的机器上pypy3.5版本的<code>SHA512 pbkdf</code>计算性能竟然超越了原生Linux和Windows。成为Python运行效率最高的平台，实在是匪夷所思的事情。</p>

<p>WSL最让我满意的，是命令行里面可以结合Windows和Linux的命令行工具来管道处理，这个实在是太赞了。纯粹计算类的程序，Windows上面有很多现成的命令行工具，现在终于能:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ping.exe -t xxx.xxx.xxx.xxx|grep xxxx|echo -I xxx ~~~</span></code></pre></td></tr></table></div></figure>


<p>这样来搞了，事实上，我自己写了很多Python脚本来处理Powershell自带的很多工具输出的内容，还有不少GPU运算程序大多数跑在Windows上面，能直接重定向到Linux上面实在太好了。</p>

<p>另外，WSL网络协议栈和Windows是共享的，倒是直接省了一个事，我直接把http_proxy配置成本地的shadowsock服务就很安逸的翻墙了；方便。</p>

<p>最后，就等着磁盘性能的改善了。</p>

<p>下面记一下常用的坑：</p>

<ul>
<li>如果开机之后插拔一个移动硬盘，需要手工在WSL中执行重新挂载命令：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo umount /mnt/g && sudo mount -t drvfs "G:" /mnt/g</span></code></pre></td></tr></table></div></figure>


<ul>
<li>WSL跟最新2019版本的卡巴斯基冲突，卡巴斯基默认会过滤所有HTTP流量</li>
</ul>


<p>目前无解；要么禁用卡巴斯基的HTTP过滤功能，要么回退2018版本</p>

<p>最后，多个版本实验之后，锁定Win10 1709我也能连续3个月不关机了，稳定性可喜可贺。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alias Rm to Mv]]></title>
    <link href="https://happy123.me/blog/2019/01/16/alias-rm-to-mv/"/>
    <updated>2019-01-16T14:00:18+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/alias-rm-to-mv</id>
    <content type="html"><![CDATA[<p>之前一直简单的用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rm='mv -f $@ ~/.trash'</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>取代rm命令。</p>

<p>这样用着有个不便的地方，就是有时候做个脚本命令，带个<code>;</code>的时候会解析有问题。今天突然发现一个用函数来替代的好办法，记一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rm='move1(){ /bin/mv -f $@ ~/.trash/; };move1 $@'</span></code></pre></td></tr></table></div></figure>


<p>参考资料：</p>

<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7385133.html">https://www.cnblogs.com/f-ck-need-u/p/7385133.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-7]]></title>
    <link href="https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7/"/>
    <updated>2019-01-06T17:34:55+08:00</updated>
    <id>https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7</id>
    <content type="html"><![CDATA[<p>比特币的交易网络最为人诟病的一点便是交易性能：全网每秒 7 笔左右的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认将导致约 1 个小时的最终确认时间。</p>

<p>为了提升性能，社区提出了闪电网络等创新的设计。</p>

<p>闪电网络的主要思路十分简单——将大量交易放到比特币区块链之外进行，只把关键环节放到链上进行确认。该设计最早于 2015 年 2 月在论文《The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments》中提出。</p>

<p>闪电网络需要单独部署，没有包含在bitcoin core实现里面。闪电网络是一个开放的协议，任何人都能自由的实现它，目前比较流行的版本有:</p>

<p><a href="https://github.com/lightningnetwork/">https://github.com/lightningnetwork/</a></p>

<p><a href="https://github.com/mit-dci/lit">https://github.com/mit-dci/lit</a></p>

<p><a href="https://github.com/ElementsProject/lightning">https://github.com/ElementsProject/lightning</a></p>

<!-- more -->


<p>让我们先自己思考一下，A和B之间频繁有多次交易，最自然，最直接的建立链下交易的办法是什么？</p>

<p>一个假想的场景，就是在没有网络，没有通信的环境中，两个人面对面各自手持私钥签名，证明自己的账户上有多少资金，然后签订一份合同，每次交易记录签名之后不广播，只写在合同上面，等到大批交易做完之后，再统一轧账清算；如果中间有人耍赖，就拿着写满签名交易的合同去法院仲裁。这个过程中间他们唯一的信息渠道就是有人单向传真给他们每笔交易的资金变动；</p>

<p>当然这是一种异想天开，而且依赖于中心化的法院裁决的方式，在现实世界中是行不通的；但是我们可以将这个方案作为起点，代入到电子化的解决方案里面：</p>

<ol>
<li>首先，两个人面对面，一是为了通过验证签名检查账户资金，二是防止第三者窃听；映射到电子方案中，就是通过两个人建立一个加密的通信信道来传递信息</li>
<li>另外，两个人的每一笔交易打印到合同上，就是为了防止某一方作假诈骗，而且两个人面对面互相监督，就防止有一方私自广播对方的交易然后闪人，但是放到网络中，没有法官裁决的威慑，没有相互监督，怎么才能信任对方最终一定会根据所有的历史交易来清算呢？</li>
</ol>


<p>第一个问题的解决方案称之 HTLC（Hashed Timelock Contract），解决了支付通道(资金池)的问题；</p>

<p>第二个问题的解决方案称之为RSMC (Recoverable Sequence Maturity Contract)，解决了链下交易的确认问题。</p>

<h2>RSMC</h2>

<h4>概述</h4>

<p>Recoverable Sequence Maturity Contract，即“可撤销的顺序成熟度合约”。这个词很绕，其实主要原理很简单，类似资金池机制。</p>

<p>再想一下我们之前的问题，为什么A和B每次交易都要记在合同上，最后一把清算呢？既然是双方账户的加加减减，为什么不是每发生一笔新交易，立即对交易后产生资金分配结果共同进行确认，然后作废之前一笔交易呢？</p>

<p>Yes! 这样做之后，在双方的资金池通道中，不管之前双方进行了多少笔交易，永远只存在一笔清算交易，这笔交易就是当前的轧账结果，不管什么时候，直接广播这笔交易，对双方都是公平的。</p>

<p>那么，该如何防止一方做了一笔付款之后，没有广播，就抢先把资金池里面的自有资金提现呢？</p>

<ol>
<li>A和B各拿出1BTC放入了资金池通道中，这时候资金池里面共有2BTC</li>
<li>A和B发生了数笔交易之后，A与B的资金变为1.5:0.5BTC，这个时候通道中留着一笔清算交易没有广播，但是任何一方都可以直接广播把这个状态做实</li>
<li>这个时候A又向B发送了1BTC，但是在B广播清算交易之前，A要把资金全部提走，也就是1.5BTC；这样B就损失了1BTC，怎么预防这种情况呢？</li>
</ol>


<p>解决方法就是提现一定要双方都签名承认才可以：任何一方在任何时候都可以提出提现，提现时需要提供一个双方都签名过的资金分配方案（意味着肯定是某次交易后的结果，被双方确认过，但未必是最新的结果）。在上面的那种情况下，B是无论如何也不会同意的。这就阻止了A的提现。</p>

<p>另外，为了威慑A这种行为，在一定时间内，如果另外一方拿出证明表明这个方案其实之前被作废了（非最新的交易结果），则资金罚没给质疑方；否则按照提出方的结果进行分配。罚没机制可以确保了没人会故意拿一个旧的交易结果来提现。</p>

<p>最后，即使双方都确认了某次提现，首先提出提现一方的资金到账时间要晚于对方，这就鼓励大家尽量都在链外完成交易。通过RSMC，可以实现大量中间交易发生在链外。</p>

<p>那么如果有一方耍小心眼，就是损人不利己，死活不签名来阻止另一方的提现呢？也没关系，在这个模型中，有了惩罚机制，提现的一方可以直接拿最后一笔清算交易的状态来广播(这笔交易是双方都签名承认的)，代价就是晚一点得到资金而已。</p>

<ul>
<li>整个过程里面，最重要的就是惩罚机制的实现，我如何认定跟我交易的对方也遵从这个惩罚机制呢？这是用多重签名来保证的。因为多重签名实际上是个合约，所以这个方案被命名为RSMC。</li>
</ul>


<h4>让我们详细的描述这个过程</h4>

<p>内容引自： <a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<h4>RSMC 创建</h4>

<p>Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入通道中，便于业务往来。解释一下下方RSMC交易的结构，左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg1.jpg" alt="img" /></p>

<ol>
<li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时， Funding    Tx未签名，更不广播。</li>
<li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li>
<li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li>
<li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li>
<li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li>
<li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。上述过程以及结构图的描述，就是创建RSMC的全部过程。</li>
</ol>


<p>C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p>

<p>这个过程的精巧之处，就在于构造了一个被动机制，将自己的资金放入到一个嵌套多重签名的地址里面，任何一方想要提现，一定要先归还另一个人的资金。并且这个机制构造完成之后，我们才真正在支付通道中充值。</p>

<h4>交易更新</h4>

<p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。</p>

<p>于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg2.jpg" alt="img" /></p>

<p>交易更新时的交易结构此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？</p>

<p>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2  的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg3.jpg" alt="img" /></p>

<p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。</p>

<p>若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。</p>

<p>Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。</p>

<p>引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p>

<h4>交易关闭</h4>

<p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p>

<h2>HTLC 中转交易</h2>

<p>RSMC要求交易的双方一定要都缴纳一笔保证金，我每天都跟不同的商家打交道，不能跟每个人都去建立RSMC，存入一笔资金吧。而且通道的建立和关闭都是需要链上广播的，如果要建立多个支付通道，交易费用也不容小觑，这有点本末倒置了吧。</p>

<p>为了解决这个问题，闪电网络又引入了HTLC ( Hashed Timelock Contract )，中文意思是“哈希的带时钟的合约”。这个其实就是限时转账。理解起来也很简单，通过智能合约，双方约定转账方先冻结一笔钱，并提供一个哈希值，如果在一定时间内有人能提出一个字符串，使得它哈希后的值跟已知值匹配（实际上意味着转账方授权了接收方来提现），则这笔钱转给接收方。</p>

<p>推广一步，甲想转账给丙，丙先发给甲一个哈希值。甲可以先跟乙签订一个合同，如果你在一定时间内能告诉我一个暗语，我就给你多少钱。乙于是跑去跟丙签订一个合同，如果你告诉我那个暗语，我就给你多少钱。丙于是告诉乙暗语，拿到乙的钱，乙又从甲拿到钱。最终达到结果是甲转账给丙。这样甲和丙之间似乎构成了一条完整的虚拟的“支付通道”。而乙就做了中转节点。</p>

<p>Alice想要支付0.5BTC给Bob，但她并没有一个渠道来和他进行交易。幸运的是，她和Charlie有一个交易渠道，而Charlie正好和Bob有一个交易渠道。这样Alice就能借助Charlie的交易渠道，通过哈希时间锁定合约（HTLC）来和Bob进行交易了。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg4.png" alt="img" /></p>

<p>为了完成这次交易，Alice就会给Bob发短信说：“嘿！我要给你付笔款。”这时Bob自己将收到一个随机数字（R），接着Bob便会回一个被哈希的数字（H）（你可以认为被哈希的数字R是随机数字的一种加密形式）给Alice。</p>

<p>然后Alice的钱包紧接着就会联系Charlie说：“嘿，Charlie。如果你给我生成（H）的未加密值（R），那么我就同意更新我们渠道的支付分配，这样你就可以得到的就会比0.5BTC多一点，我得的比0.5少一点。”</p>

<p>尽管Charlie并不知道R，但他也会同意。之后Charlie便会去找Bob说：“嘿，Bob。如果你给我那个能生成H的未加密的值R，我将同意更新我们渠道的支付分配，这样你就可以得到的会比0.5BTC多一点，我得到的比0.5少一点。”因为R就是从Bob这里生成的，所以他肯定知道。接着他马上将R告诉Charlie，并更新了其渠道的支付分配。然后Charlie将R告诉给了Alice之后也更新他们的渠道，最后交易完成，Alice以脱链的形式付给Bob0.5BTC。</p>

<h4>扩展</h4>

<p>HTLC给了任意两个点之间，通过路由转发达到支付的目标。这样用户无需打开过多的通道，只需要存入一笔资金跟一个比较大的中介机构建立通道就好了。之后所有的支付行为，我们都期望这个中介机构能自动路由到商家。</p>

<p>在闪电网络的极大繁荣时间，可以看作是现在互联网模型的克隆。</p>

<h2>优缺点大辩论</h2>

<h4>关于支付通道建立</h4>

<ul>
<li><p>乐观： 建立的闪电网络渠道可以与现有钱包和系统内置无缝过程。当收到和支付比特币时，资金需要存到某个地方。资金可以在收到时立即进入闪电网络的通道中，因此建立该通道不需要额外的步骤或成本。</p></li>
<li><p>悲观：为了建立闪电网络渠道，用户必须手动创建一个新的昂贵的链上交易。</p></li>
</ul>


<h4>关于通道关闭</h4>

<ul>
<li><p>乐观:可能不需要关闭渠道，用户可以无限期地或长时间地将钱存放在通道中。</p></li>
<li><p>悲观:一旦支付完成，就需要透过手动创建昂贵的在线交易来关闭通道。</p></li>
</ul>


<h4>关于网络路由</h4>

<ul>
<li><p>乐观:现有的P2P网络已经需要网络拓扑和消息传递，节点通常具有八个连接。闪电网络拓扑结构只是其中的一个延伸。路由不是一个重要的问题，因为即使在大规模网络中，用户之间路径的平均步数也是很小的。即使路由有问题，也可以简单地在链上进行支付，而用户甚至感觉不到两者的差异。少数大型渠道运营商可以防止路由发生任何问题。</p></li>
<li><p>悲观:路由可能是一个较大的问题，因为找到各方之间最短的路径对于演算法来说是个难题。如果找不到清晰的路线，则用户和商户将不得不通过繁琐的过程来手动改变并选择在链上交易的过程。</p></li>
</ul>


<h4>关于支付通道的中心化</h4>

<ul>
<li><p>乐观:有些经济奖励措施是用来对抗这种中心化的，任何人都可以设立节点，因为进入门槛低。除此之外，还可以通过收取较低的费用来削减其他节点对网络的影响力。即使网络集中在几个大型交易枢纽上，闪电网络仍然提供了一个有用而有趣的系统。比特币已经有一些像 Coinbase 这样的大机构来管理大量的资金。在闪电网络下，这些机构没有资金保管权，只是用来传递用于支付的数据。</p></li>
<li><p>悲观:   网络将集中围绕在几个大型交易枢纽，因为这是最有效的模式。这种集中化增加了系统性渠道失效的风险，即少数大渠道出现故障，导致支付渠道同时大量外流，造成连锁拥堵，使部分资金在到期前无法退出渠道。</p></li>
</ul>


<h4>关于流动性</h4>

<ul>
<li><p>乐观:将有机制激励用户运行闪电网络节点，并提供流动性，以收取费用，网络便可以用于小额支付，支付额度可以远小于最大渠道容量，确保有足够的流动性。</p></li>
<li><p>悲观:支付渠道流动性不足，因此其规模将受到限制。任何较具规模的支付几乎可以立即消耗掉整个渠道的流动性，瘫痪闪电网络的支付渠道。</p></li>
</ul>


<h4>关于要求收款人在收款时在线</h4>

<ul>
<li><p>乐观:虽然收件人必须在线才能收到付款，但这与大多数在线支付系统没有显着不同，因为如果收款人不在线上，他们不知道或无法验证收款。直接收款的用户或设备也不需要存储私钥。例如，商店 PoS 终端或加密 ATM 机可以在收款前通过互联网从公司的总部确认签署回收交易，因为无论如何双方在收款时都需要沟通。</p></li>
<li><p>悲观:通过链上交易，发件人需要的是收款地址，而收件人不需要在线。与此相反，收款人在接收付款之前需要签署收回交易。这是一个重大的限制，意味着收件人必须将私钥暴露在热钱包中。这使得闪电网络在下列许多情况下便的不切实际，例如在 ATM 上，在商店 PoS 系统上进行大额支付，或者支付给那些难以连上互联网的收款人。</p></li>
</ul>


<h4>闪电网络较大的安全风险</h4>

<ul>
<li><p>在收款时必须在线的要求：如上所述，在收款之前，收款人需要签署收回交易，以便汇款人知道如果渠道不正常的关闭或拒绝签署的情况发生，他们可以收回资金。因此，收钱需要一个热钱包，这意味着如果发生安全事件，私钥可能被暴露。</p></li>
<li><p>监督渠道的要求：可能需要闪电网络参与者或瞭望塔主动监督网络渠道。这可能给用户或瞭望塔带来负担，并且与存储在区块链上的比特币相比，潜在地降低了渠道内的资金安全性。未能适当监督渠道或由在线网络造成的拥塞可能增加用户错过了回收交易截止日期的风险。</p></li>
<li><p>矿工可以审查渠道关闭交易：作为不属于交易双方的矿工可以通过审查渠道关闭交易，一旦他们具有 51％ 的哈希率便可能有能力从闪电网络用户窃取资金。虽然这种类型的攻击就算在没有应用闪电网络的情况下已经具有破坏性的后果，但闪电网络的应用可能会提供一个更大的攻击面。</p></li>
</ul>


<h2>小结</h2>

<p>RSMC 保障了两个人之间的直接交易可以在链下完成，HTLC保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。闪电网络整合这两种机制，就可以实现任意两个人之间的交易都在链下完成了。</p>

<p>在整个交易中，智能合约起到了中介的重要角色，而区块链网络则确保最终的交易结果被确认。</p>

<p>闪电网络似乎可以在整体网络交易规模上带来重大改进。从而导致交易速度提高和交易费用大幅下降，而整体又不会影响核心基础安全性。然而，至关重要的是，闪电网络自身在安全性上的不足可能使闪电网络不适合用于大额支付（或者至少用其进行大额支付的行为可能是不负责任的）。投机和投资等行为是需要大额支付的，而这些行为目前看来是加密货币领域的主要的交易推动力，相比之下，零售小额支付的数量相对较小。</p>

<p>最后附赠一个技术讲解比较好但是旗帜鲜明反对闪电网络的视频教程：</p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p>当然再为闪电网络声援一下，闪电网络的思想发源于微支付通道，Satoshi实际上早期对微支付通道已经有了基本的设想：</p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p>孰对孰错，是非只能自己判断。</p>

<h2>架设一个闪电网络节点，完成一笔交易</h2>

<p>光说不练假把式，增加一把实战</p>

<h4>运行一个bitcoind全节点</h4>

<p>我们选用bitcoind运行一个testnet模式的全节点，配置文件如下:</p>

<p>bitcoin.conf:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=192.168.2.1/16
</span><span class='line'>rpcport=8332
</span><span class='line'>test.rpcport=18332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>testnet=1
</span><span class='line'>
</span><span class='line'># for lnd
</span><span class='line'>server=1
</span><span class='line'>#daemon=1
</span><span class='line'>zmqpubrawblock=tcp://192.168.2.1:28332
</span><span class='line'>zmqpubrawtx=tcp://192.168.2.1:28333</span></code></pre></td></tr></table></div></figure>


<p>启动bitcoind:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoind --conf=/opt/blockdata/testnet3/bitcoin.conf --datadir=/opt//blockdata/ --deprecatedrpc=signrawtransaction &gt;&gt; test.log 2&gt;&1</span></code></pre></td></tr></table></div></figure>


<h4>建立闪电网络节点</h4>

<p>我们采用lightningnetwork这个Go版本的实现(全程需要翻墙)：</p>

<p><a href="https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md">https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md</a></p>

<ul>
<li>安装go环境</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install golang-1.11-go</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置环境变量</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export GOPATH=~/gocode
</span><span class='line'>export PATH=$PATH:$GOPATH/bin</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Clone &amp;&amp; 编译</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>go get -d github.com/lightningnetwork/lnd
</span><span class='line'>cd $GOPATH/src/github.com/lightningnetwork/lnd
</span><span class='line'>make && make install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>启动lnd</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxx --bitcoind.rpcpass=xxxx --bitcoind.zmqpubrawblock=tcp://192.168.2.1:28332 --bitcoind.zmqpubrawtx=tcp://192.168.2.1:28333</span></code></pre></td></tr></table></div></figure>


<h4>建立一个新钱包，充值</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet create</span></code></pre></td></tr></table></div></figure>


<p>之后按照提示一路回车下去，建立一个新钱包，然后执行下列命令得到一个新地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet newaddress np2wkh</span></code></pre></td></tr></table></div></figure>


<ul>
<li>去下面这几个网址列表领取一些免费的TestNet Bitcoin:</li>
</ul>


<p><a href="https://lnroute.com/testnet-faucets/">https://lnroute.com/testnet-faucets/</a></p>

<ul>
<li>执行下面命令看看余额</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet walletbalance</span></code></pre></td></tr></table></div></figure>


<h4>连接通道</h4>

<ul>
<li>首先执行下面命令确认我们的节点的同步状态</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet getinfo</span></code></pre></td></tr></table></div></figure>


<p>确认<code>synced_to_chain</code>字段已经变成true，代表区块头同步完毕。</p>

<ul>
<li>然后去下面的网址找一个可用的闪电节点:</li>
</ul>


<p><a href="https://explorer.acinq.co/">https://explorer.acinq.co/</a></p>

<ul>
<li>我们选一个channel数比较多的然后连接这个节点：cosmicApotheosis</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet connect 03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028@138.229.205.237:9735</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下一步建立通道，这里我们存0.1btc到通道里:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet openchannel --node_key=03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028 --local_amt=10000000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看节点连接状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listpeers</span></code></pre></td></tr></table></div></figure>


<p>这里我们还需要等待3次确认，通道才能建立成功，记住刚才建立完的transaction id，去网上查询等待3次确认。</p>

<ul>
<li>检查通道的状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listchannels</span></code></pre></td></tr></table></div></figure>


<p>当通道打开的时候，就可以用闪电网络支付啦！</p>

<h4>支付</h4>

<ul>
<li>我们去<a href="https://testnet.satoshis.place/">satoshi.place</a> 随便来几笔涂鸦，得到一个支付地址:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在命令行里支付：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli  --network=testnet sendpayment --pay_req  lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d</span></code></pre></td></tr></table></div></figure>


<p>顺利的话，瞬间支付成功。</p>

<h4>小结</h4>

<p>看起来是不是很麻烦，相信我，实际做一遍的话坑也不少。</p>

<p>目前有小部分钱包实现了闪电网络支付；但是拍脑袋想想就知道钱包里面无法包含闪电节点的全部功能：因为收款需要时时刻刻的监控，所以不可避免的需要一个类似于<code>瞭望塔</code>式的服务，最合理的办法就是将这个功能的实现剥离出来，单独部署到一台服务器上。</p>

<p>electrum轻钱包在<a href="https://github.com/spesmilo/electrum/issues/2557">这里</a>讨论了典型的实现方式。</p>

<p>可以预见到将来，实现闪电网络的钱包除了要自建全节点之外，还需要建立稳定的闪电网络节点实现类似<code>瞭望塔</code>的功能，当闪电网络极大繁荣的时候，钱包服务商实际上会占据及其有利的地位，闪电网络的发展，需要比特币钱包软件的进化，这是一个非常大的商机。</p>

<h2>参考资料:</h2>

<p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html">https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html</a></p>

<p><a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<p><a href="https://www.8btc.com/article/92887">https://www.8btc.com/article/92887</a></p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p><a href="https://blog.bitmex.com/zh_cn-the-lightning-network/">https://blog.bitmex.com/zh_cn-the-lightning-network/</a></p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p><a href="https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/">https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy 10th Birthday Bitcoin]]></title>
    <link href="https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin/"/>
    <updated>2019-01-03T21:12:12+08:00</updated>
    <id>https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin</id>
    <content type="html"><![CDATA[<p>自 <a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a>在2009-01-03 诞生以来，bitcoin 已经运行十年了。从一个个人项目，成长为世界话题，一段不可思议的旅程。</p>

<p>有人在&lt;纽约时报>上面为其庆生：</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/">https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/</a></p>

<p>我在2013年初次读到白皮书的时候申请了一个域名:</p>

<p><a href="http://20090103.com/">http://20090103.com/</a></p>

<p>出于好玩的心态一直维护着，看看下一个十年会是怎样。</p>

<h4>Hi, Happy 10th birthday bitcoin!</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-6]]></title>
    <link href="https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6/"/>
    <updated>2019-01-01T20:10:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6</id>
    <content type="html"><![CDATA[<p>好啦，这篇文章中，我们要来探讨大名鼎鼎的Segwit(Segregated Witness)。</p>

<p>这个词一说起来就头疼啊，他牵扯到旷日持久的扩容大战，无穷尽的争论以及分裂。我们的立场就是不去站队任何组织，单纯从技术的角度去理解这个东西。</p>

<!-- more -->


<p>首先澄清一个误解，其实Segwit跟扩容没关系，它最初提出来，只是为了解决交易延展性的问题，顺便有一点扩容效果，但这个扩容效果只是附带的；</p>

<p>另外，其实Segwit的技术原理非常简单，但是要考虑兼容性的问题，导致从设计到实施都有点复杂。</p>

<h2>缘起</h2>

<p>嗯哼，又要涉及到大量的数学知识；先声明下，我至今还没有从数学原理上完全理解椭圆曲线算法，所以下面讲的都是码农派的API理解&mdash;搞明白接口，但里面的细节还需要更多时间去探究。</p>

<p>上一篇文章我们提到，当交易被签名时，签名并没有覆盖交易中所有的数据 (因为签名是不可能对自身签名的)，而交易中所有的数据又会被用来生成交易的哈希值来作为该交易的唯一标示。</p>

<p>如果签名向常见的HASH算法一样，碰撞机率极小的话也没有问题；但是椭圆曲线算法存在一个看起来比较弱的特性：</p>

<blockquote><p>ECDSA算法生成两个大整数r和s并组合起来作为签名, 可以用来验证交易。而r和BN-s 也同样可以作为签名来验证交易(BN＝0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141). 这样，攻击者拿到一个交易，将其中inputSig 的r, s 提取出来， 使用 r, BN-s 生成新的inputSig, 然后组成新的交易，拥有同样的input和output，但是不同的TXID. 攻击者能在不掌握私钥的情况下几乎无成本地成功地生成了合法的交易。</p></blockquote>

<p>让我们再用码农能理解的语言描述一遍:</p>

<ol>
<li>前面的交易中，scriptSig脚本可以提取出sig签名</li>
<li>sig是由两个值组成的，Sig=(R,S)</li>
<li>sig是嵌入在scriptSig中，用一种名为<code>DER-encoded ASN.1 octet representation</code>的编码方式编码的。OpenSSL并没有强制要求每个签名编码结果只能有一个值。</li>
<li>对于每一个 ECDSA <code>signature(R,S)</code>，还存在相同消息的另外一个有效签名: <code>signature(R,-S(mod N))</code></li>
<li>一个恶意攻击者得到Sig之后，可以手工构造另外一个<code>signature(R,-S(mod N))</code>嵌入到scriptSig中，这和之前的scriptSig不一样，所以TX ID也会发生变化</li>
<li>这笔新的交易输入输出跟原来的交易完全一样，也是合法的，但是TX ID不同了。</li>
</ol>


<h4>危害</h4>

<ol>
<li>Alice通过在线钱包给Bob发送了一笔交易，并把TXID发送给Bob说，看我给你发了多少比特币</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>Bob 通过Alice发来的TXID搜索了以下，并没有发现这笔交易</li>
<li>Bob说，Alice是个骗子</li>
</ol>


<h4>对于交易所的威胁</h4>

<ol>
<li>黑客向交易所发起来一笔资金提现</li>
<li>交易所自动处理，广播了交易，并发送给黑客TX ID</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>黑客对交易所说，我没有收到资金，那笔交易不存在</li>
<li>交易所验证了下，因为原来得交易已经被黑客替换掉了，所以原始交易果然不存在了</li>
<li>交易所只能又构造了一笔交易再次广播</li>
<li>黑客最后得到了两笔资金</li>
<li>这种情况下的解决方法是，遇到交易无法确认就停止，报错误并等待手动处理，或者，我们可以自己生成一个延展性交易，然后获取新的TXID,查找是否发送成功。能生成的TXID数量有多少呢？一共有exp(2, input数量)个，因为每个input都有改签名或者不改两种可能， 通常不是一个大数目。</li>
<li>但是这不能阻挡脚本小子的恶意攻击，他们通常会<code>损人不利己</code>的构造大笔延展性交易来攻击网络</li>
</ol>


<h2>讨论</h2>

<p>社区为了解决这个问题进行了大量的讨论：以下是一些材料和社区进行的努力：</p>

<h4>BIP0062</h4>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki</a></p>

<h4>BIP66</h4>

<p>在 363742 区块高度处，BIP66 软分叉强制区块链中所有新交易遵循 DER-encoded ASN.1 标准。仍然需要进一步的努力来关闭 DER 签名其它可能的延展性问题。
签名仍然是可以被拥有相应私钥的人改变的。</p>

<h2>解决</h2>

<p>2015年12月，Bitcoin Core开发团队的<a href="https://github.com/sipa">Pieter Wuille</a>提出了一个解决方案，称之为隔离见证 (Segregated Witness）。隔离见证由以下BIPs定义：</p>

<ol>
<li>BIP-141:隔离见证的主要定义</li>
<li>BIP-143:版本0见证程序的交易签名验证</li>
<li>BIP-144对等服务——新的网络消息和序列化格式</li>
<li>BIP-145隔离见证（对于矿工）的 getblocktemplate 升级</li>
</ol>


<p>最主要的描述在BIP141中:</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</a></p>

<h2>原理</h2>

<p>其实说白了原理非常简单，就是把vin的scriptSig挪到交易的末尾去。</p>

<p>每一个比特币交易，其实可以分为两部份。第一部份是说明结余的进出，第二部份是用来证明这个交易的合法性 (主要是签署)。第一部份可称为「交易状态」，第二部份就是所谓的「见证」(witness)。如果你只关心每个账户的结馀，其实交易状态资料就已经足够。只有部份人(主要是矿工)才有必要取得交易见证。</p>

<p>那么我们再来复习下一笔P2PKH交易的结构:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在整笔交易里面，输入输出信息以及金额大小属于第一部分，scriptSig属于第二部分。</p>

<p>只有矿工以及全节点需要进行scriptSig的验证；如果是普通的SPV轻钱包只需要验证所在区块的合法行就可以了。所以可以把scriptSig 部分挪到交易的尾部。这样带签名的原始数据就固定了，也不会有更改TX ID的机会。这部分数据称之为witness:</p>

<p>每个witness都由一个var_int打头，代表接下来的数据长度。如果某个输入没有见证，那么其witness就是一个0x00。</p>

<p>让我们代入各种例子，来看看Segwit是如何工作的？</p>

<h4>P2WPKH (Pay-to-Witness-Public-Key-Hash)</h4>

<p>首先回顾下P2PKH的锁定脚本(scriptPubKey)与解锁脚本(scriptSig)内容</p>

<ul>
<li>P2PKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    &lt;signature&gt; &lt;pubkey&gt;
</span><span class='line'>  scriptPubKey: OP_DUP OP_HASH160 &lt;20-byte hash of Pubkey&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再来看一下P2WPKH的脚本内容</p>

<ul>
<li>P2WPKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WPKH的锁定脚本较P2PKH要精简不少，第一位的数字0是版本号，有了版本号，未来脚本升级就能更容易的向前兼容。</p>

<p>P2WPKH的解锁脚本为空，而真正的解锁脚本内容被移到了原交易之外的witness部分。</p>

<h4>P2WSH(Pay-to-Witness-Script-Hash)</h4>

<ul>
<li>P2SH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</span></code></pre></td></tr></table></div></figure>


<ul>
<li>P2WSH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;32-byte hash of redeem script&gt;
</span><span class='line'>  witness:      0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WSH锁定脚本与P2WPKH类似，第一位是版本号，第二位是赎回脚本(Redeem script)的Hash值。</p>

<p>值得注意的是P2WSH锁定脚本中的Hash值是256位(32字节)的，是使用SHA256(pubkey)计算得到；而P2WPKH中的Hash值是160位(20字节)的，是使用RIPEMD160(SHA256(pubkey))计算得到的。</p>

<p>这样做的目的是让钱包可以根据Hash值的长度区分交易使用的是P2WPKH还是P2WSH。</p>

<p>在P2SH交易中常常会有多重签名验证，所以验证信息会占用更多空间，将这些信息移到原交易之外能更大程度的降低交易大小。</p>

<h4>锁定脚本版本号</h4>

<p>仔细观察之后，我们发现scriptSig以及scriptPubKey都以一个<code>0</code>开头；这代表着一个版本号。开发团队对于这个字段还有更远大的愿景，锁定脚本(Locking script)加上版本号，从而使脚本语言的升级更容易向前兼容，这种不造成太大影响的脚本语言修改方式将加快比特币的创新。</p>

<p>这个字段的精巧之处就在于，老节点看到这种交易也是合法的，虽然不能正确parse这种交易，但是当作为交易被打包到一个新区块，然后被支持segwit的矿工挖出来这个块，其它不支持segwit的老节点也是承认这个块的！</p>

<p>为什么呢？复习一下我们之前的文章，在一笔交易结构里面，这种交易是合法的 (是的，真相其实更复杂，但是我懒得详细介绍了，也许之后更闲的时候会仔细说说吧)！</p>

<p>虽然不能正确解析，但格式合法。有的人觉得这种技术忒精巧了，甚至精巧到了一种可怕的程度，是一种杂耍式的开发。很多人对于这种<code>啊哈</code>式的适配吓坏了。</p>

<p>现在Segwit已成事实，是非曲直只能留给你自己去判断了。</p>

<h4>交易标识符</h4>

<p>从上面看，其实实施Segwit之后，数据结构反而变得更清晰简单了。如果中本聪一开始就采用这样的结构，我相信也没有多少人会质疑。</p>

<p>但是已有的老的交易格式及相关系统已经运行了这么长时间，我们希望能尽可能的兼容以前的系统。最麻烦的适配就是原来传统交易的ID只有一个txid。现在见证数据挪到后面了，HASH的时候就不包括这一块数据了，怎么办？</p>

<p>传统交易的txid是以下序列 double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][txins][txouts][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>最后开发者们又引入了另外一个id，称之为wtxid；它是对整个交易double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][marker][flag][txins][txouts][witness][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>我们知道，每笔交易的txid是临时计算的，并不入块。但是整个Block是以所有交易的txid以Merkle Tree的形式组织的(这部分知识我们还没讲，需要到后面将bitcoin blockchain的时候提到)；现在多了一个wtxid，该怎么办呢？</p>

<p>解决办法又让人有点无语，就是将wtxid按照同样的组织方法算出Merkle Tree根节点，放到Block块中。</p>

<p>但是原有的Block格式都固定下来了，这个根节点放哪里呢？</p>

<p>还有coinbase的100个字节是可以利用的嘛，就是你了。</p>

<p>这<del>~，在有洁癖的人看来，完全又是一种码农修修补补式的FIX；相信众多技术人员这个时候已经开始内心无数吐槽了；但是真实世界就是这样无奈啊，又想要兼容性，又想要代码干净，又想要性能</del></p>

<p>你是太阳吗！？地球都绕着你转吗？！</p>

<p>拿着吧，这就不少了！！</p>

<p>最后附上这段龌龊的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::vector&lt;unsigned char&gt; GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, 
</span><span class='line'>                                                      const Consensus::Params& consensusParams)
</span><span class='line'>{
</span><span class='line'>    std::vector&lt;unsigned char&gt; commitment;
</span><span class='line'>    int commitpos = GetWitnessCommitmentIndex(block);  //从币基交易的输出中寻找承诺项，没找到就返回-1
</span><span class='line'>    std::vector&lt;unsigned char&gt; ret(32, 0x00);
</span><span class='line'>    if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {
</span><span class='line'>        if (commitpos == -1) {  //没有找到，就开始创建承诺，先生成见证版Merkle树根
</span><span class='line'>            uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);
</span><span class='line'>            CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());
</span><span class='line'>            CTxOut out;  //构建一个币基交易的输出
</span><span class='line'>            out.nValue = 0;  //金额是0
</span><span class='line'>            out.scriptPubKey.resize(38);  //公钥脚本长度38，前6个字节固定为0x6a24aa21a9ed
</span><span class='line'>            out.scriptPubKey[0] = OP_RETURN;  //0x6a
</span><span class='line'>            out.scriptPubKey[1] = 0x24;  //36，即后面的总长度
</span><span class='line'>            out.scriptPubKey[2] = 0xaa;  //0xaa21a9ed，固定不变的承诺头
</span><span class='line'>            out.scriptPubKey[3] = 0x21;
</span><span class='line'>            out.scriptPubKey[4] = 0xa9;
</span><span class='line'>            out.scriptPubKey[5] = 0xed;
</span><span class='line'>            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);  //插入见证版Merkle树根
</span><span class='line'>            commitment = std::vector&lt;unsigned char&gt;(out.scriptPubKey.begin(), out.scriptPubKey.end());
</span><span class='line'>            CMutableTransaction tx(*block.vtx[0]);
</span><span class='line'>            tx.vout.push_back(out);  //币基交易中添加这个输出
</span><span class='line'>            block.vtx[0] = MakeTransactionRef(std::move(tx));  //写回区块
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);  //更新区块其他结构
</span><span class='line'>    return commitment;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>隔离见证新的签名算法</h4>

<p>原来的签名验证需要大量的HASH操作；我们知道比特币是一个分布式系统，同时运行着上万个节点，如果一个操作每个节点都执行一遍，浪费的操作加起来很惊人的。</p>

<p>而隔离验证是个软分叉，为啥不能顺便再搞一点优化呢？毕竟软分叉的机会不多啊。于是开发者们顺便修改了四个签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG和CHECKMULTISIGVERIFY）的语义，改变了交易承诺散列的计算方式。</p>

<p>下面的说明引用自 Master Bitcoin:</p>

<blockquote><p>比特币交易中的签名应用于交易哈希，交易数据计算，锁定数据的特定部分，表明签名者对这些值的承诺。例如，在简单的SIGHASH_ALL类型签名中，承诺哈希包括所有的输入和输出。</p>

<p>不幸的是，计算承诺哈希的方式引入了验证签名的节点可能被迫执行大量哈希计算的可能性。具体而言，散列运算相对于交易中的签名操作的数量增加O（n<sup>2</sup>）。因此，攻击者可以通过大量的签名操作创建一个交易，导致整个比特币网络不得不执行数百或数千个哈希操作来验证交易。</p>

<p>Segwit代表了通过改变承诺散列计算方式来解决这个问题的机会。对于segwit版本0见证程序，使用BIP-143中规定的改进的承诺哈希算法进行签名验证。</p>

<p>新算法实现了两个重要目标。首先，散列操作的数量比签名操作的数量增加了一个更加渐进的O（n），减少了用过于复杂的交易创建拒绝服务攻击的机会。其次，承诺散列现在还包括作为承诺的一部分的每个输入的值（金额）。这意味着签名者可以提交特定的输入值，而不需要“获取”并检查输入引用的前一个交易。在离线设备（如硬件钱包）的情况下，这极大地简化了主机与硬件钱包之间的通信，消除了对以前的交易流进行验证的需要。硬件钱包可以接受不可信主机“输入”的输入值。由于签名是无效的，如果输入值不正确，硬件钱包在签名输入之前不需要验证该值。</p></blockquote>

<p>总之就是一句话，提升了验证签名的性能！！</p>

<h2>实施</h2>

<p>隔离见证（segwit）是一次比特币共识规则和网络协议的升级，其提议和实施将基于BIP-9，是一个软分叉。</p>

<p>2017年8月24日，区块高度481,824，隔离见证正式激活。</p>

<p>2015年提出，2017年激活；想想就知道这中间经历了多少曲折！！</p>

<p>隔离见证最终是全网95%的算力投票赞成才激活的，即使如此，网络中还是有一些不支持隔离见证的老节点在运行，同时，周边的钱包等软件也有不少还不支持隔离见证交易；此时的情况就比较复杂:</p>

<h4>付款人的客户端支持隔离见证，而收款人不支持</h4>

<p>如果收款人不支持隔离见证，那最终发布的地址将会是普通地址（P2PKH或P2SH），那所有交易按照原有的规则进行即可。</p>

<h4>付款人的客户端不支持隔离见证，而收款人支持</h4>

<p>聪明的社区开发者想出了一个过渡方案，即将P2WPKH或P2WSH植入P2SH。</p>

<p>是的！！作为有洁癖的开发者，你又会要吐槽了，这是什么操作！？</p>

<p>P2WPKH植入P2SH后，交易信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of script&gt; EQUAL
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>此处的脚本Hash值为RIPEMD160(SHA256(0 &lt;20-byte hash of Pubkey>))的结果，将该脚本Hash转换为P2SH地址，就是一个兼容segwit的地址，不支持隔离见证的客户端可以正常支付比特币给这种P2SH地址。
而对于支持隔离见证的客户端，仍可以将验证信息放在witness结构中，当然这种过渡方案的交易会较完全形态的方案稍大一些，但比无隔离见证的情况要小。</p>

<p>这样就引入了另外一个混乱之处，我们前面的文章提到过，以<code>3</code>开头的地址是P2SH交易专用的，而P2SH交易一般包含的脚本逻辑比较复杂，现在又要判断一种情况，这笔交易是不是一笔隔离见证交易呢？</p>

<p>还有普通小白也很疑惑，比特币网络中开始出现大量以<code>3</code>开头地址的交易，之前这种交易很少，小白们甚至都没有见过这种地址。</p>

<p>为了解决这个问题，开发者们很快又提出了bech32地址格式(去参考我们之前的文章)，小白们很快就被搞得晕头转向。而此时社区正处于分裂状态，Bitcoin Cash作为硬分叉出来的江湖搅局者，虽然加入了重放保护，但是地址和Bitcoin的规则是一样的，但是Bitcoin Cash是不支持Segwit的！</p>

<p>很快，就有大量的小白在Bitcoin Cash里面发送交易给Segwit地址，这种混乱场景不忍卒见。</p>

<p>然后，Bitcoin Cash也搞出了自己的另外一套地址规则；好吧，你应该去找找我们早期的关于比特币钱包的文章，好好温习一下了。</p>

<h4>一些吐槽</h4>

<p>令人惊奇的是，这段混乱时期，在全网交易纷纷堵死，隔离见证升级、Bitcoin Cash分叉的混乱局面中，比特币的价格不合常理的大涨、暴涨，涨到大家怀疑人生。颇有一点狂风暴雨雷霆霹雳之下，大家在泰坦尼克号中末日狂欢的意味。</p>

<p>Bitcoin这个东西，实在不能以常理来琢磨啊。</p>

<h2>优点</h2>

<p>说了这么多，当然Segwit的升级还是又非常多的好处的~~~</p>

<h4>可以用软分叉增加最大区块容量:</h4>

<p>因为旧有节点根本看不到这些被隔离的见证，即使真实的区块已超过1MB，它们仍会以为没有超过限制而会接受区块。</p>

<p>比特币的区块大小限制为1000000bytes，由于witness数据不包含在这个限制中，为了防止witness数据被滥用，仍然对总的区块大小做了限制。引入了一个新概念叫块重量(Block weight):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Block weight = Base size * 3 + Total size
</span><span class='line'>Base size是不包含witness数据的块大小
</span><span class='line'>Total size是包含了witness数据的总大小</span></code></pre></td></tr></table></div></figure>


<p>隔离见证限制Block weight &lt;= 4000000</p>

<p>这就是隔离见证扩容说的来由，这样实际上确实有一定的扩容效果，如果全网交易都迁移到隔离见证上来，大概扩容1.7倍吧。</p>

<p>但是!!! 注意，实际的区块链大小其实比原来更大，这一点一定要搞清楚。</p>

<h4>解决了交易延展性问题</h4>

<p>从此以後，只有发出交易的人才可以改变交易ID，没有任何第三方可以做到。如果是多重签名交易，就只有多名签署人同意才能改变交易ID。这可以保证一连串的未确认交易的有效性，是双向支付通道或闪电网络所必须的功能。有了双向支付通道或闪电网络，二人或多人之间就可以实际上进行无限次交易，而无需把大量零碎交易放在区块链，大为减低区块空间压力。</p>

<h4>轻量钱包可以变得更轻量，因为它们无需再接收见证数据</h4>

<h4>可以大幅改善签署结构</h4>

<p>在区块链上，曾经有一个超过5000个输入的交易，因为签署设计缺憾，需要半分钟才能完成检查。在建议中的SW软分叉会把这个问题解决掉。</p>

<p>而在该次软分叉完成後，核心开发者们已有计划进一步完善整个系统的可用性和安全性:</p>

<ol>
<li><p>全节点可以为轻量钱包提供很简洁的证明，以检查交易是否合法。以後的节点就不再局限於完全验证和完全不验证，而是可以按个人的资源作部份验证，也就是说一台手机也可以参与保障系统安全。这可以大为降低系统对全节点的依赖，即使以後区块容量提升了，我们仍能保持安全。</p></li>
<li><p>将会推出全新的交易脚本语言，例如可以把数以千计的不同脚本通过MAST技术压缩至只有32字节;亦可以把不同签署合并检查，令检查交易的速度再以倍数上升。</p></li>
</ol>


<h4>为闪电网络的实施铺平了道路</h4>

<p>闪电网络应该是继中本聪创造比特币之后最重量级的创新，支持者和反对者为其吵了一个天翻地覆，这个值得我们后面写文章大书特书，还是那句话，后文再见吧。</p>

<h2>副作用</h2>

<h4>复杂性</h4>

<p>是的，如果你看到这里；就会发现我到了大量的<code>吐槽</code>字眼；为了达成共识，隔离见证采用了软分叉升级，为了兼容老系统，不可避免的修修补补；另外虽然说起来是单独的一项技术，同时解决的问题可不少，在洁癖者眼里，这是屌丝码农的瞎折腾，就增加了出Bug的可能性；如果是个硬分叉，所有技术问题能干净利落解决，就没有这么多争吵了。</p>

<p>总之一句话，隔离验证留下的技术债不少，升级之后落子无悔，如果之后发现问题，可没机会回退了。</p>

<p>这次升级也是一次经典的技术、政治、利益交杂的各方博弈，如果将来比特币大成，这段历史值得仔细研究。</p>

<h4>Block Size</h4>

<p>前面已经在优点里面说过了。隔离见证有扩容效果的。但这个效果只是一个副作用，只是当时提出隔离见证的时候社区正就扩容问题吵得不可开交，莫名其妙的这个技术就卷入扩容斗争里面了。</p>

<p>再说一遍：关于隔离见证，网上一个很大的误解就是：认为witness被隔离走了，witness数据不在Block里，所以一个Block能装更多的Transaction。</p>

<p>其实不是，witness数据仍然在Block里面。并且对于1个Transaction来说，如果把witness数据也算上的话，其raw byte size其实是变大了，而不是变小了！！！
既然Transaction还变大了，那为什么1个Block可以装更多的Transaction呢？？</p>

<p>因为隔离见证是软分叉，不是硬分叉。下面就分别来分析一下，为什么对于老版本节点、新版本节点，1个Block都可以装更多的Transaction呢？</p>

<p>对于老版本节点：
Block Limit Size = 1M，但由于你把witness数据移到了所有Transaction的外面，放在了整个Block的尾部。老版本在计算一个Block大小的时候，只计算了
Block Header + 所有Transaction的数据（witness数据，老版本看不见！！！相当于老版本被欺骗了。）</p>

<p>所以呢，其实整个Block的物理大小(raw block size)已经超过了1M，但老版本的节点不认识尾部的witness数据，所以认为总大小还是 &lt; 1M。</p>

<p>对于新版本节点：
Block的size的计算方式做了调整，引入了Block weight的概念。
block weight = base_size * 4 + witness_size
block weight &lt;= 4M</p>

<p>其中，base_size就是block的前2部分数据（header + 没有witness的所有交易数据）</p>

<p>通过上面的分析，我们会发现，数据还是那么多数据，没有减少，只是重新排布了一下，却变相的把区块链扩容了！！！</p>

<h4>安全性</h4>

<p>有人提出来说，中本聪之前把交易信息和见证数据放在一块是有意的；因为一笔交易带有所有者的签名是天经地义的语义；隔离见证把witness独立出来，降低了比特币系统的安全性。另外~~~~</p>

<p>老实说，这个论据仔细读读还是蛮有道理的，但是实在说的太深刻太哲理了，码农对这种东西天生无感，我就不啰嗦了，大家感兴趣可以自己去搜索这方面资料。</p>

<h2>小结</h2>

<p>以上就是对隔离见证这个东东最简单的描述，我尽力做到简洁中立；但是实际上我觉得整个过程写一本书也不为过；</p>

<p>那么，隔离见证实施之后；就是闪电网络的崛起了，我们下篇文章再见。</p>

<h2>参考</h2>

<h4>四份有关隔离见证的比特币改善方案:</h4>

<ul>
<li>隔离见证软分叉</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki">https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki</a></p>

<ul>
<li>隔离见证通信层</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki">https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki</a></p>

<ul>
<li>隔离见证交易地址</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki">https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki</a></p>

<ul>
<li>隔离见证签署检查</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki">https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki</a></p>

<h4>系统扩展常见问题解答:</h4>

<p><a href="https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq">https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq</a></p>

<h4>需要30秒检查的交易:</h4>

<p><a href="https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08">https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08</a></p>

<h4>其它资料</h4>

<p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md">https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-5]]></title>
    <link href="https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5/"/>
    <updated>2018-12-28T21:08:25+08:00</updated>
    <id>https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5</id>
    <content type="html"><![CDATA[<p>我们还是拿<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517</a>做例子。</p>

<p>这篇文章需要结合<a href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/">比特币的交易-3</a>这篇文章来理解，我们在这里也直接复用TransA、TransB的说法。</p>

<!-- more -->


<h2>准备工作</h2>

<h4>私钥-公钥</h4>

<p>在<a href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/">比特币的HD钱包-2</a>中，我们已经算出来私钥的WIF表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</span></code></pre></td></tr></table></div></figure>


<p>以及公钥:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341</span></code></pre></td></tr></table></div></figure>


<h4>交易body</h4>

<p>这笔交易有1个vin，1个vout；然后再把我们之前的结构分析图拿来，看看具体需要哪些参数传入:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h4>需要手工构造input</h4>

<ol>
<li>指定上一笔vout的txid，是已知参数(outputTransactionHash):<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code></li>
<li>指定上一笔vout的index，是已知参数(sourceIndex):<code>00000000</code></li>
<li>构造scriptSig，即对这个UTXO签名。我们需要用私钥签名，这个是难点，我们后面来计算</li>
</ol>


<h4>需要手工构造output</h4>

<ol>
<li>设置矿工费用，从而计算输出值</li>
<li>构造scriptPubKey</li>
</ol>


<h4>最后组合成为一笔交易</h4>

<ol>
<li>增加version字段：<code>01000000</code></li>
<li>增加inputCount字段: <code>01</code></li>
<li>增加outputCount字段: <code>01</code></li>
<li>增加block lock time字段: <code>00000000</code></li>
</ol>


<h4>然后我们实现一个函数，将这些变量组合，最后得到原始交易值(对应bitcoin-cli的createrawTransaction)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Makes a transaction from the inputs
</span><span class='line'># outputs is a list of [redeemptionSatoshis, outputScript]
</span><span class='line'>def makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs):
</span><span class='line'>    def makeOutput(data):
</span><span class='line'>        redeemptionSatoshis, outputScript = data
</span><span class='line'>        return (struct.pack("&lt;Q", redeemptionSatoshis).encode('hex') +
</span><span class='line'>        '%02x'.format(len(outputScript.decode('hex'))) + outputScript)
</span><span class='line'>    formattedOutputs = ''.join(map(makeOutput, outputs))
</span><span class='line'>    return (
</span><span class='line'>        "01000000" + # 4 bytes version
</span><span class='line'>        "01" + # varint for number of inputs
</span><span class='line'>        outputTransactionHash.decode('hex')[::-1].encode('hex') + # reverse outputTransactionHash
</span><span class='line'>        struct.pack('&lt;L', sourceIndex).encode('hex') +
</span><span class='line'>        '%02x'.format(len(scriptSig.decode('hex'))) + scriptSig +
</span><span class='line'>        "ffffffff" + # sequence
</span><span class='line'>        "%02x".format(len(outputs)) + # number of outputs
</span><span class='line'>        formattedOutputs +
</span><span class='line'>        "00000000" # lockTime
</span><span class='line'>        )</span></code></pre></td></tr></table></div></figure>


<h4>outputs构造</h4>

<p>在构造一笔完整的交易之前，我们需要手工做两件事情：</p>

<ol>
<li>构造一个output输出</li>
<li>对vin中的UTXO签名，构造scriptSig</li>
</ol>


<p>outputs的构造比scriptSig简单一点，我们先来解决这个问题。</p>

<p>outputs是包含多个output的数组。在这个例子中，我们打算只构造一个output。结合我们之前的文章，就是构造一个bitcoin scriptPubKey，设置一把新锁。</p>

<p>这个scriptPubkey是这样子的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;pubkey&gt;  OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>PubKeyHash其实就是收币的地址，其它操作符都是现成的。</p>

<h2>如何构造一笔output</h2>

<p>一笔output的构造是简单的，所有东西都是现成的，而且这笔交易是个P2PK交易，输出非常简化，我们仅仅需要构造<code>&lt;pubkey&gt;  OP_CHECKSIG</code>即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def makeOutput(value,  index, pubkey):
</span><span class='line'>    OP_CHECKSIG =  'ac'
</span><span class='line'>    value = "{:0&lt;16x}".format(int(struct.pack('&lt;I', int(value)).hex(), 16))
</span><span class='line'>    index = "{:02x}".format(int(index))
</span><span class='line'>    pubkey = pubkey
</span><span class='line'>    pubkey_length = "{:02x}".format(len(pubkey)/2)
</span><span class='line'>    return value + index = pubkey_length + pubkey + OP_CHECKSIG
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>&gt; print(makeOutput(7000, 0, '2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac'))
</span><span class='line'>&gt; 581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac
</span><span class='line'>&gt; outputs = ['581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac']
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h2>如何对一笔交易签名(scriptSig)</h2>

<p>在构造一笔交易的过程中，签署交易是一个非常麻烦的过程。其基本思想是使用ECDSA椭圆曲线算法和私钥生成交易的数字签名，但细节比较复杂。</p>

<p>我们可以先通过验证签名的过程来理解以下，验证签名过程的通过10个步骤描述。下面的缩略图说明了详细的流程。</p>

<p><img src="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png" alt="img" /></p>

<p>这张图出自于<a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">这里</a>，里面的TX ID是不同的，但基本步骤一样。</p>

<h4>一些约定:</h4>

<ol>
<li>TransA代表TxPrev，TransB代笔TxNew</li>
</ol>


<h4>步骤:</h4>

<ol>
<li>首先解析TransB涨vin中的scriptSig，得到sigStr以及pubkeyStr</li>
<li>从TransA中拿出对应的vout ，从scriptPub脚本中截取需要的部分(subScript)：即 <code>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</code>；截取规则就是检索最后一个<code>OP_CODESEPARATOR</code>的位置，在这之后的脚本段就是我们要截取的对象</li>
<li>如果subScript中包含了签名，移除掉(在scriptPub中包含签名是很特殊的情况，一般出现在P2SH交易中，普通交易不需要这一步)</li>
<li>如果脚本中有<code>OP_CODESEPARATORS</code>操作符，移除</li>
<li>检测一步解析出来的scriptSig最后一个字节的HashType，扩展为4字节(小端排序)备用</li>
<li>将TransB 复制一份，变为TransBCopy</li>
<li>将TransBCopy中所有的Vin以及Vout 移除，同时将length字段置为0</li>
<li>将第4步中的subScript根据vin sequence填充到TransBCopy对应的位置</li>
<li>最后将交易TransBCopy序列化(采用DER编码)，并在末尾添加第5步中得到的HashType，得到签名的原始数据</li>
<li>最后执行签名验证过程: ECDSA_CheckSignature(pubkeyStr, sigStr, double_sha256(TransBCopy))</li>
</ol>


<h4>疑点解惑</h4>

<h5>为什么这么麻烦，不能直接对TransB签名吗？</h5>

<p>因为最终的签名是包含在TransB当中的，签名是不能对自身来签名的；所以要签名的原始数据不能包含签名本身；</p>

<p>说句题外话，由于ECDSA的签名算法的局限，这个结构组织方式最终导致了一个顽疾，即交易延展性问题，也被翻译为交易可锻性（Transaction Malleability）。</p>

<p>简单来说，就是攻击者可以生成不同但是合法的scriptSig，这样虽然vin，vout金额和地址不变，但是TX ID会发生变化，从而导致用户找不到发送的交易。</p>

<p>这对于交易所是一个威胁，某个居心不良的用户可能充值了一笔资金，然后重新生成scriptSig又广播了一笔交易，然后欺骗交易所，说第一笔交易没收到，交易所检查以下果然如此，于是又发送了一笔资金给用户，这样用户就实现了double withdraw，白赚了一笔。MTGOX早期就是这么被坑的，后来也出现过一些损人不利己的脚本小子们公然利用这个漏洞攻击比特币网络；为了解决这个问题，core开发者提出了segwit解决方案(即隔离见证)，后来随着政治斗争、市场斗争的激化，一个技术问题最终演化成了扩容派的分裂。</p>

<p>总之还是那句话，关于segwit, 闪电网络，期待我们后面的文章吧。</p>

<h5>为什么要用上一笔交易vout来填充这个位置呢？</h5>

<p>我们说验证签名的过程，其实有三个作用:</p>

<ol>
<li>签名证明私钥的所有者，即资金所有者，已经授权支出这些资金</li>
<li>授权证明是不可否认的（不可否认性）</li>
<li>签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改</li>
</ol>


<p>我们提供签名、私钥即承诺了第1点，对TransBCopy 签名承诺了第2点，但是要做到第3点，就需要对于引用UTXO的信息做承诺；</p>

<p>我们会问，单纯的prev TX ID和vout sequence no不能证明我要花费的哪一笔UTXO吗？</p>

<p>是的，这还是不够的，我们需要另外的信息熵的引入，就是这个UTXO的scriptPub。具体为什么，是ECDSA的数学特性决定的。请参考:</p>

<p><a href="https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/">https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/</a></p>

<p>老实说，关于ECDSA的签名验证，我在学习了很长时间以后，还是非常担心，因为签名生成算法使用随机密钥k作为临时私有-公钥对的基础，这个K值的随机性一定要人工保证，比特币的每笔交易验证，离不开签名验证，而这个签名验证如此复杂，确实让人心生忐忑。</p>

<h5>这个OP_CODESEPARATORS是什么东东？</h5>

<p>哈，到目前为止，我们接触到的都是比特币最简单、最基本、当然也是应用最广泛的交易类型，但是比特币还支持P2SH的高级交易，在这种交易中，vout里面可能会嵌入非常复杂的脚本，所以系统引入了OP_CODESEPARATORS作为复杂脚本的分隔符，以后的文章我们会详细讲解；</p>

<p>OP_CODESEPARATOR属于一种看起来<code>过度设计</code>的特性，老实说，我没有在比特币主网上发现像样的使用这个特性的交易，我也需要更多时间的学习才能搞明白这个东西，以下是一些参考资料：</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=164655.0">https://bitcointalk.org/index.php?topic=164655.0</a></p>

<h5>这个HashType是什么东东？</h5>

<p>嗯哼，又是一个非常棘手但是有意思的问题。</p>

<p>我们说比特币有了script之后，功能是非常非常丰富的，不仅仅局限于支付场景，他可以应用到许多非常复杂的场景中。</p>

<p>比如现在让我们考虑一个外贸公司的业务，这个公司的对公账户每天都要接受许多客户的付款，处于安全考虑，我作为公司的CEO，希望能跟财务主管共同管理公司的对公账户，当需要支出时，一定要我跟财务主管都签字同意才可以。</p>

<p>这就衍生出了所谓的M-N交易类型，即多重签名交易。</p>

<p>在多重签名交易中，要花费一笔UTXO，可能需要多个签名，或者有这种语义：&#8221;一定要CEO的签名，如果没有CEO的签名，需要COO和CFO的联合签名&#8221;，为了表示这些，引入了SIGHASH这个字段，就是我们所说的HashType啦。</p>

<p>要考虑SIGHASH，实际上已经牵涉到了bitcoin的高级交易类型(P2SH)，还是那句话，关注后面的文章吧。</p>

<h4>反向代码</h4>

<p>嗯哼，把验证签名的步骤反向来一遍，就是签名的过程了。</p>

<p>代码表示如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>def makeSignedTransaction(privateKey, outputTransactionHash, sourceIndex, scriptPubKey, outputs):
</span><span class='line'>    myTxn_forSig = (makeRawTransaction(outputTransactionHash, sourceIndex, scriptPubKey, outputs)
</span><span class='line'>         + "01000000") # hash code
</span><span class='line'>
</span><span class='line'>    s256 = hashlib.sha256(hashlib.sha256(myTxn_forSig.decode('hex')).digest()).digest()
</span><span class='line'>    sk = ecdsa.SigningKey.from_string(privateKey.decode('hex'), curve=ecdsa.SECP256k1)
</span><span class='line'>    sig = sk.sign_digest(s256, sigencode=ecdsa.util.sigencode_der) + '\01' # 01 is hashtype
</span><span class='line'>    pubKey = keyUtils.privateKeyToPublicKey(privateKey)
</span><span class='line'>    scriptSig = utils.varstr(sig).encode('hex') + utils.varstr(pubKey.decode('hex')).encode('hex')
</span><span class='line'>    signed_txn = makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs)
</span><span class='line'>    verifyTxnSignature(signed_txn)
</span><span class='line'>    return signed_txn</span></code></pre></td></tr></table></div></figure>


<h2>广播交易</h2>

<p>好啦，构造了vin, vout，以及组合成一笔完整的交易，剩下的就是广播出去啦：</p>

<p>比特币的网络协议非常简单，设置好一个Magic Number就可以加入，以下时广播代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>magic = 0xd9b4bef9
</span><span class='line'>
</span><span class='line'>def makeMessage(magic, command, payload):
</span><span class='line'>    checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]
</span><span class='line'>    return struct.pack('L12sL4s', magic, command, len(payload), checksum) + payload
</span><span class='line'>
</span><span class='line'>def getVersionMsg():
</span><span class='line'>    version = 60002
</span><span class='line'>    services = 1
</span><span class='line'>    timestamp = int(time.time())
</span><span class='line'>    addr_me = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    addr_you = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    nonce = random.getrandbits(64)
</span><span class='line'>    sub_version_num = utils.varstr('')
</span><span class='line'>    start_height = 0
</span><span class='line'>    
</span><span class='line'>def getTxMsg(payload):
</span><span class='line'>  return makeMessage(magic, 'tx', payload)
</span><span class='line'>
</span><span class='line'>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</span><span class='line'>HOST_IP ="x.x.x.x"
</span><span class='line'>sock.connect(HOST_IP, 8333)
</span><span class='line'>
</span><span class='line'>sock.send(msgUtils.getVersionMsg())
</span><span class='line'>sock.recv(1000) # receive version
</span><span class='line'>sock.recv(1000) # receive verack
</span><span class='line'>sock.send(msgUtils.getTxMsg("01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000".decode('hex')))</span></code></pre></td></tr></table></div></figure>


<p>HOST IP 怎么获取呢？</p>

<p>如果你有一个全节点，可以直接调用RPC接口的getpeers函数。或者你直接执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nslookup bitseed.xf2.org</span></code></pre></td></tr></table></div></figure>


<p>从公共服务器里面检索nodes，里面随便挑一个IP 吧。</p>

<h2>小结</h2>

<p>以上就是一笔完整交易的构造过程。</p>

<p>这笔交易结构非常简单，只有一个vin，一个vout。</p>

<p>如果有多个vin, 多个vout的情况，就需要每个vin都签署一遍。</p>

<p>我们发现，一笔比特币交易的构造过程，最复杂的，就是签名以及验证的过程。它的步骤极其繁琐，而且椭圆曲线的签名算法极其复杂。如果在更高级的比特币交易中，比如P2SH，或者多重签名交易，或者Segwit交易，包含了更复杂的脚本和执行逻辑，事情很快就变得不可控制起来。</p>

<p>这是我在学习比特币知识时遇到的最大的恐惧，我认为如果将来比特币系统出现什么致命BUG，很大可能就在这里暴雷。</p>

<p>也许早期的开发者也觉得不放心，于是禁用了不少操作符。而目前Bitcoin SV和Bitcoin Cash的发展方向，是将这些操作符一一解放出来。</p>

<p>更强大的功能？还是更稳妥的基础设施？究竟怎样的做法是正确的，我也没有定论，只是告诉大家现在社区的发展方向就好了，大家自己做判断。</p>

<h2>参考资料:</h2>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-4]]></title>
    <link href="https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4/"/>
    <updated>2018-12-24T18:41:36+08:00</updated>
    <id>https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4</id>
    <content type="html"><![CDATA[<p>前面的文章中我们分析了一笔标准的Pay to Public Key HASH(P2PKH)交易。看起来其实结构挺简单的，这篇文章我们乘胜追击，看一下矿工们领取系统奖励时，构造的coinbase交易。</p>

<!-- more -->


<p>Coinbase交易规范的叫法是Generation TX，每一个block有且只有一笔Genration TX，该类交易的币是矿工挖矿凭空产生的，所以没有vin。比特币系统所有的币都产自于这里。</p>

<p>我们就以最常见创世块的交易作为示例来分析吧。</p>

<p><a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a>这个创始块中只有一笔交易，就是中本聪手工构造发给自己的币：</p>

<p><a href="https://www.blockchain.com/btc/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b">4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</a></p>

<h4>区块原始数据</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>00000000   01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000010   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000020   00 00 00 00 3B A3 ED FD  7A 7B 12 B2 7A C7 2C 3E   ....;£íýz{.²zÇ,&gt;
</span><span class='line'>00000030   67 76 8F 61 7F C8 1B C3  88 8A 51 32 3A 9F B8 AA   gv.a.È.ÃˆŠQ2:Ÿ¸ª
</span><span class='line'>00000040   4B 1E 5E 4A 29 AB 5F 49  FF FF 00 1D 1D AC 2B 7C   K.^J)«_Iÿÿ...¬+|
</span><span class='line'>00000050   01 01 00 00 00 01 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000060   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000070   00 00 00 00 00 00 FF FF  FF FF 4D 04 FF FF 00 1D   ......ÿÿÿÿM.ÿÿ..
</span><span class='line'>00000080   01 04 45 54 68 65 20 54  69 6D 65 73 20 30 33 2F   ..EThe Times 03/
</span><span class='line'>00000090   4A 61 6E 2F 32 30 30 39  20 43 68 61 6E 63 65 6C   Jan/2009 Chancel
</span><span class='line'>000000A0   6C 6F 72 20 6F 6E 20 62  72 69 6E 6B 20 6F 66 20   lor on brink of 
</span><span class='line'>000000B0   73 65 63 6F 6E 64 20 62  61 69 6C 6F 75 74 20 66   second bailout f
</span><span class='line'>000000C0   6F 72 20 62 61 6E 6B 73  FF FF FF FF 01 00 F2 05   or banksÿÿÿÿ..ò.
</span><span class='line'>000000D0   2A 01 00 00 00 43 41 04  67 8A FD B0 FE 55 48 27   *....CA.gŠý°þUH'
</span><span class='line'>000000E0   19 67 F1 A6 71 30 B7 10  5C D6 A8 28 E0 39 09 A6   .gñ¦q0·.\Ö¨(à9.¦
</span><span class='line'>000000F0   79 62 E0 EA 1F 61 DE B6  49 F6 BC 3F 4C EF 38 C4   ybàê.aÞ¶Iö¼?Lï8Ä
</span><span class='line'>00000100   F3 55 04 E5 1E C1 12 DE  5C 38 4D F7 BA 0B 8D 57   óU.å.Á.Þ\8M÷º..W
</span><span class='line'>00000110   8A 4C 70 2B 6B F1 1D 5F  AC 00 00 00 00            ŠLp+kñ._¬....</span></code></pre></td></tr></table></div></figure>


<p>然后我们解析拿我们以前文章的方法来解析一下这笔交易(因为这个区块中只包含了唯一一笔交易，我们顺便解析一下区块构造):</p>

<h4>block header 部分</h4>

<ol>
<li>首先是version字段:<code>01000000</code></li>
<li>然后是32字节代表上一个block的hash id(因为这笔交易所属block是第一个block，所以人为设置为0): <code>0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>接着是32字节的merkle root(关于merkle root，我们会在后面的文章中详解): <code>3BA3EDFD7A7B12B27AC72C3E67768F617FC81BC3888A51323A9FB8AA4B1E5E4A</code></li>
<li>4字节的时间戳: <code>29AB5F49</code></li>
<li>接着是目标难度(bits): <code>FFFF001D</code> 代表着挖矿难度，具体含义可参考我们之前的<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">比特币POW难度调节分析</a>。</li>
<li>nonce: <code>1DAC2B7C</code>，同样的挖矿调节参数，我们老是说比特币系统就是在算一个 &ldquo;毫无意义的随机数字&#8221;，没错，这就是毫无意义君。</li>
<li>这个区块包含的总交易数目：<code>01</code></li>
</ol>


<p>最好来个结构明细表格：</p>

<table>
<thead>
<tr>
<th>Field </th>
<th> Size </th>
<th>  Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version </td>
<td>4 bytes </td>
<td> Little-endian</td>
</tr>
<tr>
<td>Previous Block Hash </td>
<td> 32 bytes </td>
<td>    Big-endian</td>
</tr>
<tr>
<td>Merkle Root </td>
<td> 32 bytes  </td>
<td> Big-endian</td>
</tr>
<tr>
<td>Time </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Bits </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Nonce</td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
</tbody>
</table>


<h4>交易部分</h4>

<ol>
<li>version: <code>01000000</code></li>
<li>input数目 01</li>
<li>prev output: <code>0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>prev output index: <code>FFFFFFFF</code></li>
<li>script length: <code>4d</code></li>
<li>coinbase (2-100字节): <code>04FFFF001D0104455468652054696D65732030332F4A616E2F32303039204368616E63656C6C6F72206F6E206272696E6B206F66207365636F6E64206261696C6F757420666F722062616E6B73</code></li>
<li>sequence: FFFFFFFF</li>
<li>outputs数目: 01</li>
<li>btc数目: 00F2052A01000000 &ndash; 50 BTC</li>
<li>pk_script length: 43</li>
<li>pk_script:<code>41 04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F  AC</code>

<ul>
<li>0x41代表着后面65个字节入栈</li>
<li><code>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</code></li>
<li>0xAC代表着OP_CHECKSIG</li>
<li>整个合起来就是输出脚本为: <Pubkey> &lt;OP_CHECKSIG></li>
</ul>
</li>
<li>lock time: 00000000</li>
</ol>


<p>这笔交易跟我们上一篇文章中的TransB构造是一样的，想要花费的话提供签名就OK了。不过这笔交易没有vin，早期vin部分固定的设置为<code>0000000000000000000000000000000000000000000000000000000000000000FFFFFFFF</code>；</p>

<p>之后的字段是coinbase。这个字段是可以随意调整的(2-100字节)，中本聪在这里留存了一句非常有名的话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</span></code></pre></td></tr></table></div></figure>


<p>ASCII解码为:  The Times 03/Jan/2009 Chancellor on brink of second bailout for banks</p>

<p>这是2009年1月3日泰晤士报当天的头版文章标题，这是一个时间证明，证明比特币于2009-01-03开始运行，也顺便对传统的金融体系小小嘲讽一下。</p>

<h2>挖矿</h2>

<p>Generation TX交易需要Coinbase字段有两个原因:</p>

<ol>
<li>但是4字节的nonce字段随机性是不够的，需要引入更长的extra nonce，所以有了长度可以灵活调节(2-100字节)的coinbase字段</li>
<li>作为一个附言留给矿工来发表意见</li>
</ol>


<p>其实我对于coinbase字段没有啥意见，但是最初的nonce字段只有4个字节，意味着每秒钟只有4G的碰撞空间，很快全网就超出了这个限制，所以Coinbase字段立即就派上用场了。后来slushpool矿池发明了stratum挖矿架构，彻底进入了大算力组团挖矿的时代；这些技术的演化也非常有意思，可以参考这篇文章，讲的非常清晰：</p>

<p><a href="https://www.8btc.com/article/108894">区块链核心技术演进之路 &ndash; 挖矿演进</a></p>

<p>其实我觉得nonce字段最初最好设置为32字节，就没这么多事情了。</p>

<h2>有钱任性的矿工们</h2>

<p>矿工们早期是一批劳苦大众死宅，后来优胜劣汰只剩下了寡头；在挖矿故事里，还是有几个有意思的故事说道说道的：</p>

<ul>
<li>TXID 相同的交易</li>
</ul>


<p>一笔交易的id值是SHA(TX HEX)算出来的，因为每一笔交易的vin, vout不同，很难得到相同的txid值。但是在Generation TX里面，输出的数目和地址很有可能都是一样的。所以需要矿工自己构造一个随机的coinbase内容，防止产生相同的TXID值。</p>

<p>早期一位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<p>后来为了避免这个问题，社区讨论了提出 <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP 34 规范</a>，规定scriptSig字段，必须要把当前的区块高度(Height)放在最前。</p>

<ul>
<li>忘了接收奖励的矿工</li>
</ul>


<p>2017-12-30 20:55:00，有个矿工挖到了一个区块之后，竟然丢弃了12.5BTC的奖励！</p>

<p><a href="https://btc.com/0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126">区块0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126</a></p>

<p>我们不知道这位矿工是用的哪个版本的挖矿软件，但是他们挖到一个区块之后，竟然没有构造地址来领取这笔奖励(价值20W USD)。难道他们真刀真枪上阵之前从来不测试一下吗？或者他们就是有钱任性的真土豪，我只能说:</p>

<p>土豪我们做朋友吧~~~</p>

<h2>coinbase</h2>

<p>因为coinbase是矿工们发挥自己灵感的地方，所以最初作为<code>区块永留存</code>的手段之一，大家纷纷刻字留念。</p>

<p>有刻字到此一游的，有山盟海誓秀恩爱的，有炫耀生孩子的，有申诉政治诉求的，有吟诗作对，弘扬中国传统文化的；总之这100个字节表示鸭梨很大。</p>

<h2>OP_RETURN</h2>

<p>coinbase留言是有实力的矿工才有资格搞的；没有足够算力怎么办呢？</p>

<p>早期Geek比较多，大家就纷纷构造不能花费的交易，在vout中用PUSHDATA来填充内容。</p>

<p>运用比特币的区块链技术存储与比特币支付不相关数据的做法是一个有争议的话题。许多开发者认为其有滥用的嫌疑，因而试图予以阻止。另一些开发者则将之视为区块链技术强大功能的有力证明，从而试图给予大力支持。那些反对非支付相关应用的开发者认为这样做将引致“区块链膨胀”，因为所有的区块链节点都将以消耗磁盘存储空间为成本，负担存储此类 数据的任务。</p>

<p>更为严重的是，此类交易仅将比特币地址当作自由组合的20个字节而使用，进而会产生不能用于交易的UTXO。因为比特币地址只是被当作数据使用，并不与私钥相匹配，所以会导致UTXO不能被用于交易，因而是一种伪支付行为。因此，这些交易永远不会被花费，所以永远不会从UTXO集中删除，并导致UTXO数据库的大小永远增加或“膨胀”。</p>

<p>后来人们又发明出来OP_RETURN留言法：</p>

<p>在0.9版的比特币核心客户端上，通过采用Return操作符最终实现了妥协。Return允许开发者在交易输出上增加80字节的非交易数据。然后，与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。Return输出被记录在区块链上，它们会消耗磁盘空间，也会导致区块链规模的增加，但 它们不存储在UTXO集中，因此也不会使得UTXO内存膨胀，更不会以消耗代价高昂的内存为代价使全节点都不堪重负。 RETURN 脚本的样式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  RETURN &lt;data&gt;</span></code></pre></td></tr></table></div></figure>


<p>“data”部分被限制为80字节，且多以哈希方式呈现，如32字节的SHA256算法输出。许多应用都在其前面加上前缀以辅助认定。例如，电子公正服务的证明材料采用8个字节的前缀“DOCPROOF”，在十六进制算法中，相应的ASCII码为 <code>44 4f 43 50 52 4f 4f 46</code>。</p>

<p> RETURN 不涉及可用于支付的解锁脚本的特点， RETURN 不能使用其输出中所锁定的资金，因此它也就没有必要记录在蕴含潜在成本的UTXO集中，所以 RETURN 实际是没有成本的。</p>

<p>RETURN 常为一个金额为0的比特币输出， 因为任何与该输出相对应的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效。如果你碰巧将 RETURN 的输出作为另一笔交易的输入，则该交易是无效的。</p>

<p>一笔标准交易（通过了 isStandard() 函数检验的）只能有一个 RETURN 输出。但是单个RETURN 输出能与任意类型的输出交易进行组合。</p>

<p>PS: 最初提出了RETURN，限制为80字节，但是当功能被释放时，限制被减少到40字节。 2015年2月，在Bitcoin Core的0.10版本中，限制提高到80字节。 节点可以选择不中继或重新启动RETURN，或者只能中继和挖掘包含少于80字节数据的RETURN。</p>

<h4>例子</h4>

<p>这里比特币就见证了一场成功的求婚：</p>

<p><a href="https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e">https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e</a></p>

<p><a href="https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0">https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0</a></p>

<h2>刻字服务</h2>

<p>后来有人提供了比较简单的刻字服务，只要你付点小费，就可以将想要说的话永久上链；里面的内容更是洋洋洒洒，有字符画，有山盟海誓，有政治诉求，甚至还有病毒签名，可以参考这篇文章：</p>

<p><a href="http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html">http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html</a></p>

<p>有个网站专门parse了所有区块的文本数据供大家瞻仰：</p>

<p><a href="http://bitcoinstrings.com/">http://bitcoinstrings.com/</a></p>

<p>里面记录了许多尘封的历史，篇幅最大的就是扩容大战；完整的将当时社区争论刻进了区块链中，这是人类历史上第一次区块链圆桌访谈录，值得仔细瞻仰。</p>

<h4>花费</h4>

<p>Coinbase交易取得的比特币，必须要等100个区块高度之后才能花费。因为全网广播中，处于最头上的链是时时刻刻都在分叉的，这是一种保护措施。</p>

<p>请参考：</p>

<p><a href="https://github.com/bitcoin/bitcoin/search?q=COINBASE_MATURITY">https://github.com/bitcoin/bitcoin/search?q=COINBASE_MATURITY</a></p>

<p><a href="http://bitcoin.stackexchange.com/questions/40655/coinbase-transactions-100-block-cooldown-period">http://bitcoin.stackexchange.com/questions/40655/coinbase-transactions-100-block-cooldown-period</a></p>

<h2>小结</h2>

<p>好了，到了这里，我们对于比特币的开采交易，普通交易都理解了；</p>

<p>下一步我们将一步步手工代码构造十六进制数据，然后形成一笔完整的交易去广播；完全吃透一笔交易的来龙去脉；</p>

<p>那么，下次再见。</p>

<h2>工具</h2>

<p><a href="https://sites.google.com/site/nathanlexwww/tools/utf8-convert">https://sites.google.com/site/nathanlexwww/tools/utf8-convert</a></p>
]]></content>
  </entry>
  
</feed>
