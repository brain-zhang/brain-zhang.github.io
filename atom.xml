<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="https://happy123.me/atom.xml" rel="self"/>
  <link href="https://happy123.me/"/>
  <updated>2019-04-07T14:55:55+08:00</updated>
  <id>https://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[资产配置初探]]></title>
    <link href="https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan/"/>
    <updated>2019-04-07T14:51:33+08:00</updated>
    <id>https://happy123.me/blog/2019/04/07/zi-chan-pei-zhi-chu-tan</id>
    <content type="html"><![CDATA[<p>在<a href="https://www.douban.com/doulist/112721741/">死读书一年</a>之后，对这个问题自我感觉颇有心得，谬论如下：</p>

<blockquote><p>道理已在书单中，只记录我的思考结果</p></blockquote>

<ul>
<li>这个世界上有两种永远成立的投资方法：基于选股获取超额收益，以及基于资产配置获取市场平均收益。</li>
<li>对普通人来说，资产配置优于择时择股</li>
</ul>


<!-- more -->


<p>资产配置选择包括不动产、国债、黄金、大类资产、货币基金、国债逆回购、可转债、地方债、企业债、分级基金、指数基金、个股、股指期货等；</p>

<p>个人能驾驭的不过是三样：不动产、债券、ETF</p>

<p>我个人认为除了中心城市的不动产有配置价值之外，其他城市只有使用价值，故而排除在外；以下我尝试着只利用权益类资产来构建一个可攻可守的组合。</p>

<p>为了娱乐自己，我总结出来的普适个人的资产配置方法称之为降龙四式：</p>

<h4>第一式密云不雨</h4>

<p>总流动现金的20%配置为现金、货币基金、7天国债逆回购；</p>

<p>要求拥有完全的流动性和安全性；其边际风险等同于国债。这是完全的防守招式。</p>

<h4>第二式潜龙在渊</h4>

<p>总流动现金的35%构建一个股债平衡的资产包；</p>

<p>其中80%选取流动性好、配置稳健的债基、其20%选取两个ETF(沪深300和中证500)做二八轮动；</p>

<p>80%的债和20%的股半年做动态再平衡；</p>

<p>且慢有个<a href="https://qieman.com/portfolios/ZH006358">安心动盈</a>的策略，跟我不谋而合。</p>

<p>这一招守中带攻，在第一式的基础上(两招相加50%的现金流)保证自己立于不败之地</p>

<h4>第三式亢龙有悔</h4>

<p>总现金流的15% 价值平均策略定投低估指数；</p>

<p>选取宽基策略指数(具体策略另外文章详述)；根据PE、PB、ROE、十年国债收益率确定入场时机，根据半凯利公式决定仓位，采用价值平均策略定投，子弹五年陆续打完；</p>

<p>这一招以攻代守，在指数低估时间入场、利用定时不定额定投降低风险；</p>

<p>切记，只有在前两式基础上，才能施展此招；这三式已然能在江湖行走而自保。</p>

<h4>第四式飞龙在天</h4>

<p>将总资金的30%投入到你最看好的一项资产中，<strong>永远持有</strong></p>

<p>这一招具有极大的杀伤性，用的好伤敌一千，用的差自伤八百。一定要在前三式完全施展之后才能接续此招。</p>

<h4>动态再平衡</h4>

<p>20%，35%，15%, 30%的比例每年做一次动态再平衡，同时取出一年生活用的现金流。</p>

<h2>总结</h2>

<p>前三式配置了所有资金的70%，是个攻守结合的套路，并且每一式都充分考虑了安全边际，力求风险最小化；</p>

<p>最后一式是一往无前、只求进攻、落子无悔的拼命招式，带有大概率的赌的成分；其成败完全取决于个人眼光和运势；</p>

<p>施展飞龙在天，我个人认为最好要35岁之后，一旦施展，无从回头；</p>

<h2>实践</h2>

<p>光说不练假把式，下面是我的实盘配置：</p>

<table>
<thead>
<tr>
<th>招式 </th>
<th> 配置品种 </th>
<th> 比例% </th>
<th> 期待收益% </th>
<th> 最大回撤%</th>
</tr>
</thead>
<tbody>
<tr>
<td>密云不雨 </td>
<td> 定存、货基、7年逆回购 </td>
<td> 20 </td>
<td> 3.5 (等同于十年国债收益率) </td>
<td> 0</td>
</tr>
<tr>
<td>潜龙在渊 </td>
<td> 安心动盈 </td>
<td> 35 </td>
<td> 8-10 </td>
<td> 3-5</td>
</tr>
<tr>
<td>亢龙有悔 </td>
<td> 低估指数定投(具体策略另述) </td>
<td> 15 </td>
<td> 12-18 (企业长期ROE) </td>
<td> 10-20</td>
</tr>
<tr>
<td>飞龙在天 </td>
<td> 比特币 </td>
<td> 30 </td>
<td> 50 </td>
<td> 90</td>
</tr>
</tbody>
</table>


<p>每年收益的最大期望值为： 20 * 0.035 + 35 * 0.1 + 15 * 0.18 + 30 * 0.5 =  21.9%</p>

<p>每年最大回撤为: 20 * 0 + 35 * 0.05 + 15 * 0.2 + 30 * 0.9 = 31.75%</p>

<p>由此可以看出飞龙在天这一招的风险所在，对我而言，我认为手握的标的值得施展这一招；</p>

<h4>当然，过度自信是悲剧的源泉，好在31.75%的风险还算不上万劫不复；如果没有绝对的自信的话，前三招行走江湖足矣。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《 the Internet of Money》读书笔记]]></title>
    <link href="https://happy123.me/blog/2019/03/10/the-internet-of-money-du-shu-bi-ji/"/>
    <updated>2019-03-10T15:58:21+08:00</updated>
    <id>https://happy123.me/blog/2019/03/10/the-internet-of-money-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>再三犹豫之后我决定写下这篇笔记。来表达我对Andreas M Antonopoulos 先生的景仰之情。</p>

<p>《The Internet of Money》是对Andreas M Antonopoulos历年公开演讲的精华汇总，目前总共出了两卷；我得说，这两本书是这两年除了《The Book of Satoshi》之后最让我享受的非技术书籍。</p>

<!-- more -->


<p>关于Andreas M Antonopoulos，都不需要多做介绍了；我是他的Youtube主页忠实粉，他的每一个演讲视频都仔仔细细看过；但是将其整理为文字，汇聚成册后，再读起来还是止不住的惊叹；借用这本书的编者的话说：</p>

<blockquote><p>他渊博的知识、 对复杂概念流利地解说和清晰的思想令我们惊叹不已。 我们看到在每一次演讲过程中， 他都充满着激情、 具有深远的见解； 他使用强大的类推法，用简单的术语来介绍最难理解的主题内容。记得我当时还在想“这个人怎么能对这么新颖的事物有如此深刻的了解呢？</p></blockquote>

<p>随便翻开一页，都能津津有味的读下去，我得说，除了金庸小说和科幻小说，还真没有哪本书有类似效果； 我对Andreas M Antonopoulos 真是佩服的五体投地，宣扬一项新技术并不难，难的是像老娘舅一样日日讲，月月讲，年年讲，换着花样讲，每次都能讲出新意； 这就是先知的技能！</p>

<p>虽然说起来真的好像搞传销的，但是有时间的朋友去买一下这两本书看看吧，绝对不会让你失望。</p>

<p>有一些类比；我们在接受新事物的时候，难免会拿以往的经验，或者说历史经验来衡量这个新事物或者说是新理念；但新事务一般是颠覆旧有秩序的，此时我们的头脑就会陷入经验主义的窠臼，而且人对于<code>未知</code>是相当恐惧的；这就造成了傲慢以及守旧。</p>

<p>举一些很简单的例子：</p>

<ul>
<li>直流电和交流电之争</li>
<li>光的波粒二象性</li>
<li>飞机的发明</li>
<li>汽车的发明</li>
</ul>


<p>像飞机或者汽车的演化斗争，就比较简单，因为人对于有形的事物接受能力总是比较快，当飞机在天上飞，汽车在地上跑，其高速的隆隆声很容易就证明自己，人们眼见为实，态度便会转为<code>真香</code>；但是比较抽象的东东就不行了；</p>

<p>我能想到的最明显的例子，就是历史上日心说对于地心说的冲击。</p>

<p>凭良心说，假如让我回到中世纪，妄想凭借自己的数理知识，要让周围的人信仰日心说，死心塌地的承认<code>地球绕着太阳转</code>这个事实，我是一点自信也没有的，搞不好还自身难保，被弄上绞刑架。</p>

<p>再退一步说，我第一次得知<code>地球绕着太阳转</code>这个知识的时候，其反应是怎么样的呢？我竟然一点也记不起来了！！</p>

<p>真是可悲的一件事情啊；人们在面对新理论的时候，很容易根据日常经验或者历史经验采取抵抗、恐惧的态度，但是接受之后，又会变得如此自然，甚至这个接受了新理论之后反而又会变成接受更新的理论的绊脚石。</p>

<ul>
<li>脱离历史经验去看待新事物容易冒进，太过拘泥于历史经验又导致短视，到底如何是好呢？</li>
</ul>


<p>我想到的一个办法就是，先尽量把自己放空，把自己放回<code>一无所知</code>的状态(其实就是乔大爷反复强调的stay stupid)；然后从常识出发，慢慢去消化这个理论；当觉得好像有点入戏了，再 <code>捡回</code> 历史经验，去判断这个新事物真伪好坏。</p>

<h4>拿接受<code>地球绕着太阳转</code>这个理论做例子，大概过程是这样的：</h4>

<p>先知：Hi, 小男孩，告诉你一个秘密，其实你脚下的土地并不是坚实稳当的，我们正处在一个慢慢转动的球体上，这个大球正慢慢绕着太阳旋转！！</p>

<p>小男孩： 纳尼！？ 为什么我没觉得自己在动？ 如果不停的转呀转呀，不是怎就头晕了吗？还有，我怎么觉得是太阳在绕着我转呢？</p>

<p>先知： 孩子呀，想一想，你坐过火车吗？ 坐火车的时候，如果把窗帘拉上，会觉得自己在动吗？</p>

<p>小男孩(思索状)：好像没有，有一次我睡了，醒了之后妈妈就告诉我已经到了，好神奇，我一点也没有觉得自己动，却走了那么远！</p>

<p>先知： 道理就是这样的啊。我们脚下的这个大球非常非常大，他相对于我们的感觉来说移动非常非常慢，这样我们就不觉得自己在动，或者头晕了？</p>

<p>小男孩： 那为什么我没有从球上掉下去呢，而且即使我们在动，也明明是太阳绕着我们转嘛。</p>

<p>先知： ~~~&hellip;&hellip;&hellip;..</p>

<p>好吧，在我的想象当中，这个先知拥有惊人的耐心和智慧，才能为一个小男孩解释清楚<code>地球绕着太阳转</code>这个论题；最重要的是，小男孩没有太多历史经验的束缚，他在这个世界上活的时间还少，比较容易被说服！！</p>

<p>悲哀的是，我们可以想象，经过先知引导，这个小男孩自以为领悟了<code>地球绕着太阳转</code>这个事实之后，快乐的跑回家告诉家中的父母，而他的父母的知识还处在中世纪，会是什么反应！！</p>

<p>我们可以再想象一下，假如将来人类殖民太空，每个在太空出生的孩子都能在空间站的窗口瞭望地球，他们的该是怎样的一种世界观啊。</p>

<p>套用到电子货币上来；假如未来世代，每个人从出生到死亡，都离不开电子设备和网络，或者说，他们是真正<code>互联网生存</code>的一代，今天Andreas M Antonopoulos先生所讲的事情就不难理解了。</p>

<p>最后，再回到Andreas M Antonopoulos先生的演讲，我被他的那种热情、洞察力深深折服了，他其实是在做着一件特别危险、特别没有收益的事情，却在这个事情上投入了全部的智慧和精力。高山仰止，景行行之。虽不能至，心向往之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《 the Book of Satoshi》 读书笔记]]></title>
    <link href="https://happy123.me/blog/2019/02/13/the-book-of-satoshi-du-shu-bi-ji/"/>
    <updated>2019-02-13T18:38:16+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/the-book-of-satoshi-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<p>《The Book Of Satoshi》 这本书我反复读了不下十遍，深深着迷，安利一下。</p>

<!-- more -->


<p>超级棒的一本合集。感谢作者的整理。看到这本书的评论区如此冷清，实在可惜，就啰嗦几句。</p>

<p>在对比特币的白皮书所有技术细节了然于胸之后，再读这本书别有风味；每天睡前随手翻上几页，好像穿越过去阅读科幻小说的体验。</p>

<p>我越来越坚信中本聪只是一个普通的网络专家而已，他是个MS流派C++码农，熟悉GUI、网络编程，以及了不起的密码学造诣；看看bitcoin v0.01的代码和早期在论坛上的发言，他的伟大之处在于对一个问题反复的思索探究；所谓锲而不舍，金石可镂；这本合集完全展现了一项新技术是如何经过天才的孕育、众人的打磨、坚持、探索、怀疑、争辩、信服，最终来到世间，生根发芽，艰难成长的；</p>

<p>虽然里面基本上所有的内容都被社区发掘完毕，学习消化了，但是每次重读，总有新感悟，挑几个书里面很有意思的点来说说。</p>

<ol>
<li><p>早期的参与者基本上都是100%的Geek，像后来我们耳熟能详的Hal Finney、Laszlo Hanyecz、Gavin Andresen、bytemaster、theymos等等，反而是Andreas M. Antonopoulos 参与的比较晚；</p></li>
<li><p>Hal Finney曾经在论坛上说自己是第二个运行比特币软件的人，他挖到的第一个区块大概是第70 Block，可以肯定，第70 block之前所有的地址都是中本聪本人的钱包地址</p></li>
<li><p>Laszlo Hanyecz应该是已知的显卡挖矿第一人，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p></li>
<li><p>中本聪最初发布0.01版本的bitcoin时候，初始区块大小是32MB，后来防止DDOS才改成了1MB；他明确说了将来硬件发展，区块大小不是问题；但是他也明确提出了微支付通道的应用场景；估计今天中本聪对怎么扩容也没有准主意；</p></li>
<li><p>比特币的地址有 2<sup>160</sup> 的区间，中本聪认为已经足够了</p></li>
<li><p>关于可扩展性和速度，当时的中本聪其实已经高瞻远瞩到了未来的0确认和微支付技术，并对bytemaster说出了那句著名的:&ldquo;If you don&rsquo;t believe me or don&rsquo;t get it, I don&rsquo;t have time to try to convince you, sorry.&rdquo; ；这句话真是超级怼人啊；</p></li>
<li><p>早期的社区蛮有危机感的，详细讨论了一个国家设置一个大洲将比特币网络隔绝在外的时候会发生什么，怎样应对这种状况；</p></li>
<li><p>对于DDOS，中本聪的应对就是手续费，早期是可以发0手续费的交易的，后来遭遇DDOS攻击，讨论了一个算法，就是0手续费的交易要延迟入块，再到现在，所谓&lt;568 satoshi 的交易视为dust交易；我相信将来围绕这个点，社区还会爆发争论的；</p></li>
<li><p>中本聪早期明确表示比特币的链要尽可能表示精简，像在链上发送消息这种事情应该放到侧链上来做，所以可见的未来，像BCH、BSV扩大OP_RETURN字节的设定实在是有点心大；</p></li>
<li><p>关于挖矿耗费能源，中本聪表示今后可以在寒冷地区推行一边挖矿一边取暖的措施；乍一听好像不靠谱，其实仔细想想完全说得通。硬件99%的能源其实就是转化为了热量，将来矿机的成本低于一个小电暖之后，为什么不能在俄罗斯、加拿大一些靠北的城市建立大矿厂，一边供暖一边挖矿呢？我觉得完全可行。</p></li>
<li><p>关于bitdns，或者说今天的namecoin，虽然讨论只有寥寥几段，但是非常精彩。可直到今天侧链技术也是不温不火；这说明两个问题：</p>

<ul>
<li><p>在大部分领域，大众对于去中心化的需求并不高，这不是痛点；像DNS，现在的中心化方案工作的挺好的</p></li>
<li><p>维持一条公链消耗巨大的能源，实在是太金贵了；痛点不足的应用勉强上链也不会有太多用户；真理要慢慢说，群众接受需要时间，一口气说出来会吓坏大家。</p></li>
</ul>
</li>
<li><p>关于比特币的经济属性，Hal Finney觉得bitcoin最终会成为黄金中的黄金，即作为所有数字货币的锚定物；而中本聪也承认bitcoin更接近于一种收藏品。</p></li>
<li><p>Laszlo Hanyecz提出了一个有意思的问题，说将来矿机算力会不会碰撞私钥的收益超过比特币挖矿的收益；中本聪回答这得整体算力达到2<sup>200</sup>的级别才可以；这应该是中本聪随口说说，我仔细测算了一下，可能达到2<sup>100</sup>的级别就有利可图了</p></li>
<li><p>然后关于币价，中本聪其实也觉得挖矿成本会成为基本面；因为bitcoin是一个非常有趣的产品，人们觉得价格不合适，就是自己去挖；所以挖矿成本和币价总会有个伴生关系</p></li>
<li><p>中本聪是在2007年开始考虑创造bitcoin的，并且他作为一个实干家代码先行；然后blockchain这个单词最初出现在bitcoin v0.01的代码注释里；所以严格考证起来：中本聪是bitcoin之父，bitcoin是blockchain之母，blockchain技术诞生于2007年。</p></li>
</ol>


<p>最后冒险的做一些推测：</p>

<ol>
<li><p>虽然Segwit的升级将bitcoin全网链上的处理能力提高为7TPS，一年的极限也不过是区区2亿笔交易；假设将来要服务10亿用户，即使闪电网络极大繁荣，有许多大中转节点，假设一个用户一年只有一次链上<code>存取</code>的动作，也需要两次交易，就是整个主网链上一年要处理20亿笔交易；所以即使是bitcoin core，将来区块还是要扩容</p></li>
<li><p>BCH和BSV 开放OP_RETURN限制，以及 bip62 解决延展性交易的手段实在是太冒险了；当然，历史有时候也青睐冒险者</p></li>
<li><p>DDOS交易其实一直没有根除，即使加入了手续费用限制，内存池还是有被撑爆的风险，我觉得将来社区还会有争论</p></li>
<li><p>像OP_HODL等操作符，还有Locktime的交易，还是应用太少，将来他们应该大放异彩</p></li>
</ol>


<p>最后的最后，这是一本非常有趣、科技含量非常高的科普读物；可能会在遥远的未来(100年，还是1000年，谁知道呢？)， 里面的许多句子会广为人知，并记载在史书上；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于GDP的一些随想]]></title>
    <link href="https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang/"/>
    <updated>2019-02-13T16:11:49+08:00</updated>
    <id>https://happy123.me/blog/2019/02/13/guan-yu-gdpde-sui-xiang</id>
    <content type="html"><![CDATA[<h2>GDP是什么</h2>

<p>国内生产总值 (gross domestic product， GDP) 是在某一既定时期一个国家内生产的所有最终物品与劳务的市场价值。</p>

<p>GDP（用Y代表）被分为四个组成部分：消费（C）、投资（I）、政府购买（G）、净出口（NX）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Y = C ＋ I ＋ G ＋ NX</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<ul>
<li>消费(consumption)是家庭用于物品和劳务的支出</li>
<li>投资(investment)是将用于未来生产更多物品和劳务的物品购买。它是资本设备、存货和建筑物购买的总和。建筑物投资包括新住房支出。按习惯，新住房购买是划入投资而不划入消费的一种家庭支出形式。</li>
<li>政府购买(government purchase)包括地方政府、州政府和联邦政府用于物品与劳务的支出。它包括政府员工的薪水和用于公务的支出。</li>
<li>净出口(net export)等于外国人购买国内生产的物品(出口)减国内购买的外国物品(进口)。</li>
</ul>


<p>&mdash; 摘自曼昆的《经济学原理》</p>

<h2>GDP怎样计算</h2>

<p>GDP有3种方法进行核算：生产法、收入法和支出法。</p>

<h4>生产法</h4>

<p>生产法是我国GDP的统计方法。</p>

<p>我们把GDP从产业的角度，分成第一、二、三产业，分别算它们的增加值然后进行加总，当然还要从最终产品和中间投入两方面扣除通胀因素。</p>

<p>用生产法计算的GDP，是指各部门在核算期内的增加值。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=各部门的总产出-各部门的中间消耗</span></code></pre></td></tr></table></div></figure>


<p>对于第一产业的农林牧渔业，总产出就是多少斤粮食的价值；</p>

<p>对于第二产业——工业，那就是生产出的所有商品的价值；</p>

<p>第三产业服务业的范围比较广，计算方法也更加复杂，比如说理发师理一次发的价值，律师咨询一次的劳务价值等等。中间消耗指的是生产过程中的消耗，但要记住：中间消耗不等于成本。举个栗子：</p>

<p>工厂生产了1000个毛绒玩具，产值1万元，期间机器保养和修理花费了2000元，员工薪资4000元，那么按照生产法的话，笨笨工厂的GDP则是10000-2000=8000元。中间消耗你可以理解成为了产值而产生的费用，而成本则是一种固定的支出。就好比你今天去体彩中心领奖金10万块，请保镖花了300，但是你去体彩中心的路上打车花了20。如果要用生产法计算你为社会创造的GDP的话，那就是100000-20=99980块，因为你的“产值”是奖金，而不是保镖费。</p>

<h4>收入法</h4>

<p>收入法是从各个生产要素的收入角度来计算GDP。公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=劳动者报酬+生产税净额+固定资本消耗+营业盈余</span></code></pre></td></tr></table></div></figure>


<p>劳动者报酬就是个人劳动者的收入；</p>

<p>生产税净额就是上交给国家的各种税费减去政府补贴；</p>

<p>营业盈余就相当于营业利润加上补贴，扣除工资和福利等。（但营业盈余不等于营业利润，营业盈余是生产概念，营业利润是销售概念）比如工厂生产了价值1万块钱的玩具，贡献了1万块的GDP（不考虑保养和修理费），拆分一下：员工薪资4000元（劳动者报酬）交税1000元，收到补贴500元，即净额500元（生产税净额）固定资本折旧500；剩下的就是营业盈余5000</p>

<h4>支出法</h4>

<p>支出法其实就是曼昆的公式，即加总全社会各类货物和服务的最终消费总额：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（消费（C）+投资（I）+政府购买（G）），再加上净出口</span></code></pre></td></tr></table></div></figure>


<p>公式变形如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GDP=最终消费+资本形成总额+净出口</span></code></pre></td></tr></table></div></figure>


<p>最终消费很简单，就是一国常住居民和政府部门在货物和服务上的总花费，比如你下班回家后买零食的花费，以及国防部买军舰坦克的花费。</p>

<p>资本形成总额资本形成总额指常住单位在一定时期内获得的减去处置的固定资产和存货的净额，就好比你搬家了，购置了冰箱和洗衣机，共花费3000块，然后卖掉了一台旧洗衣机500块，那么你的可以资本形成总额就是2500块。放在GDP角度，企业购置机器的钱，扣除处理旧机器的钱，就是企业的消费。</p>

<p>净出口净出口指的是货物和服务总出口减去总进口。</p>

<p>多者相加，得出的即是支出法下的GDP。</p>

<p>引自:</p>

<p><a href="https://zhuanlan.zhihu.com/p/34944269">https://zhuanlan.zhihu.com/p/34944269</a></p>

<h2>中国历年GDP 计算</h2>

<p><a href="https://dwz.cn/gXrciFJw">wiki</a></p>

<h2>神奇的官方预计与统计</h2>

<p>每年开年，国家统计局都会发布新一年的GDP增速预测，而到了年底，也都会发布当年的实际GDP增速。</p>

<p>比如:</p>

<p><a href="http://www.stats.gov.cn/tjsj/zxfb/201901/t20190118_1645555.html">国家统计局关于2017年国内生产总值（GDP）最终核实的公告</a></p>

<p>神奇的是，每次的预测与实际误差都在0.1%左右，而且连续10年预测神准。</p>

<p>如果2019-01-01上证指数是2600点，有人信誓旦旦的对你说，我预测2019-12-30上证指数是 2760-2765 点，绝对在这个范围内！！</p>

<p>你相信吗？</p>

<p>现在国家统计局对你说，2019年国家GDP增速预计在 6.3%，然后年底一看，6.4%增速，误差千分之一，而且连续十年神准。</p>

<p>不管你信不信，我是信了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的过去，现在和未来]]></title>
    <link href="https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-%2Cxian-zai-he-wei-lai/"/>
    <updated>2019-01-25T22:31:39+08:00</updated>
    <id>https://happy123.me/blog/2019/01/25/bi-te-bi-de-guo-qu-,xian-zai-he-wei-lai</id>
    <content type="html"><![CDATA[<p>自中本聪在<a href="http://20090103.com">2009-01-03</a>挖出第一个block开始，比特币已经运行整整十年了！</p>

<p>不可思议的历程，毕竟欧元也不过出现20年，iphone也不过出现12年而已；比特币其实已经超越了历史上许多国家法币的寿命！</p>

<!-- more -->


<h2>过去</h2>

<p>在比特币的历史早期 2009-2012年，比特币社区是一个蓬勃向上的集体，每天都在诞生不可思议的想法；关于那段燃情岁月，可以参考这本书<a href="https://www.amazon.com/Book-Satoshi-Collected-Writings-Nakamoto-ebook/dp/B00M6KGJ2K">The Book Of Satoshi</a>；现在读来，仍然为那个时候的先行者们的聪明睿智、古灵精怪、天马行空深深吸引；</p>

<h2>现在</h2>

<p>当比特币逐渐建立信用，有人认可其价值之后，引来了数不清的骗子、强盗、谎言、自大狂，以及别有用心的利己者，最可怕的，是价值观导致的社区分裂，2013年之后，比特币一直处在漩涡中心；</p>

<p>让我们听听那些权威睿智人士们的声音：</p>

<h4>2001诺贝尔得主Joseph Stiglitz 教授在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>“Bitcoin is successful only because of its potential for circumvention, lack of oversight.”“So it seems to me it ought to be outlawed,”“It doesn&rsquo;t serve any socially useful function.”“It&rsquo;s a bubble that&rsquo;s going to give a lot of people a lot of exciting times as it rides up and then goes down.”</p></blockquote>

<h4>2013诺贝尔得主Robert J. Shiller 教授同样在2017年11月彭博社的电视采访中谈及比特币:</h4>

<blockquote><p>&ldquo;Bitcoin, it&rsquo;s just absolutely exciting,&rdquo;</p>

<p>&ldquo;You&rsquo;re fast. You&rsquo;re smart. You&rsquo;ve figured out nobody else understands. You&rsquo;re with it. And bitcoin has this anti-government, anti-regulation feel. It&rsquo;s such a wonderful story. If it were only true.&rdquo;</p>

<p>&ldquo;I don&rsquo;t know where it&rsquo;s going to stop,&rdquo; &ldquo;It&rsquo;s going to go way up, like the stock market in the 1920s. We will reach a 1929 eventually. But then it won&rsquo;t go to zero, it just will come down.&rdquo;</p>

<p>&ldquo;I&rsquo;m not as negative as it may seem, but I think that the thing that&rsquo;s driving bitcoin at the moment, like other examples of bubbles, is a story,&rdquo; Shiller said. &ldquo;And it&rsquo;s the quality of the story that&rsquo;s attracting all this interest, and it&rsquo;s not necessarily sustainable.&rdquo;</p>

<p>&ldquo;I don&rsquo;t mean to say that we&rsquo;re going to see a burst in bitcoin tomorrow and it will be gone forever. We did see a burst in 2013, by the way. It could happen again, and then it could take off again,&rdquo; the professor said.</p></blockquote>

<h4>2013诺贝尔得主Eugene Fama 教授在2015年11月CoinTelegraph的采访中谈及比特币:</h4>

<blockquote><p>&ldquo;People won&rsquo;t use it because basically it&rsquo;s very difficult to know how much you need to settle. It is quite variable, they won&rsquo;t want to hold it as just a way of settling payments, they will try to get rid of it quickly, as they do; and that&rsquo;s not good for the survival of that kind of a unit of account,&rdquo;</p>

<p>&ldquo;As if it doesn&rsquo;t have a stable value it&rsquo;s probably not going to survive as a unit of account. What that means is that its value is likely to go to zero at some point.&rdquo;</p>

<p>&ldquo;I guess that for a drug dealer that has a lot more value.&rdquo;</p></blockquote>

<h4>2014年经济学奖获得者Jean Marcel Tirole 2017年发文谈及比特币：</h4>

<blockquote><p>Bitcoin may be a libertarian dream, but it is a real headache for anyone who views public policy as a necessary complement to market economies. It is still too often used for tax evasion or money laundering. And how would central banks run countercyclical policies in a world of private cryptocurrencies?</p></blockquote>

<h4>智慧的源泉，奥马哈的先知，巴菲特先生谈及比特币:</h4>

<blockquote><p>In terms of cryptocurrencies, generally, I can say with almost certainty that they will come to a bad ending</p>

<p>It&rsquo;s a mirage basically, I mean it&rsquo;s a method of transmitting money. The idea that it has some huge intrinsic value is just a joke in my view.</p></blockquote>

<p><a href="https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html">https://www.cnbc.com/2018/01/10/buffett-says-cyrptocurrencies-will-almost-certainly-end-badly.html</a></p>

<h4>终生学习的百科全书式的人物，我们敬仰的芒格先生谈及比特币:</h4>

<blockquote><p>You know it is one thing to think gold has some marvelous store of value because man has no way of inventing more gold or getting it very easily, so it has the advantage of rarity. Believe me, man is capable of somehow creating more bitcoin. … They tell you there are rules and they can&rsquo;t do it. Don&rsquo;t believe them. When there is enough incentive, bad things will happen.&#8221;</p></blockquote>

<h4>桥水基金(Bridgewater Associates)总裁，&lt;原则>一书的作者，基金领域的颠覆者，天赋点加满的人物：Ray Dalio先生谈及比特币:</h4>

<blockquote><p>And so it is abubble.</p></blockquote>

<h4>布斯商学院旗下的组织 IGM Forum ，经常向世界著名的经济学家发放问卷，采访他们对于社会热点问题的看法。受访者包括美国顶尖大学中的资深教授，以及克拉克奖、诺贝尔奖的获得者。来看看他们的一期调查问卷中，近40名经济学界权威人士对比特币的看法:</h4>

<p><a href="http://www.igmchicago.org/surveys/bitcoin-ii">http://www.igmchicago.org/surveys/bitcoin-ii</a></p>

<h4>最后，码农之友，Bill Gates先生谈及比特币：</h4>

<blockquote><p>Bitcoin is &ldquo;one of the crazier speculative things,&rdquo; Gates says. And, he&rsquo;s willing to bet against its success, adding, &ldquo;I would short it if there was an easy way to do it.&rdquo;</p></blockquote>

<p>后来Gates大概是想起了自己之前尴尬的预言<code>640K ought to be enough for anybody</code>，便开始改口称:</p>

<blockquote><p>Bitcoin can solve problems involving Human poverty</p></blockquote>

<p><a href="https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s">https://www.youtube.com/watch?v=r6mOUh_NY8M&amp;t=237s</a></p>

<h2>到底是无知还是傲慢</h2>

<p>这么多权威人士，有哪位仅仅为比特币说一句好话的吗？在我们看来，没有，一致看衰：比特币不过是一种<code>Nerd Money</code>，现在场中是无数的小偷骗子投机者在泡沫之舞中狂欢而已；</p>

<p>让我们重温这句话:<code>弱小和无知不是生存的障碍，傲慢才是</code>；</p>

<p>老实说，在我认真学习了我所能找到的所有的比特币相关的知识之后，然后翻阅了所有的主流权威人士的看法和观点之后；我深深的疑惑了；</p>

<p>谁是无知的一方，谁是傲慢的一方；我不知道，也没有办法去判断；在短期的历史内，真相是非常非常难于判断的；只有时间才能证明一切。</p>

<p>也许几十年后，回顾这段历史：</p>

<ul>
<li>也许最忠诚的比特币信徒们被证明是无知的、弱小的，坐井观天的自大狂</li>
<li>也许最权威的经济学家们会变成傲慢的典型被嘲笑，作为又一个<code>不靠谱的专家预言</code>放在我们的教科书上</li>
</ul>


<h5>谁知道呢？</h5>

<p>只是经过了深深的思考，是的，作为一个小球，我们用自己笨拙的方式深深的思索，最终沉默了~~~~~~</p>

<p>我们无言，只能等待时间去洗刷或证实一切。</p>

<h2>未来</h2>

<p>在我看来，比特币社区最需要的；其实不是去发明更新颖更颠覆的技术、不是提出更宏大更美好的愿景，更不是天天去预测市场行情，去跟权威们吵架，争斗~~~</p>

<p>而是&mdash;&mdash;&mdash;&ndash;</p>

<p>我们需要一本科幻小说。</p>

<p>是的，就像雷·布拉德伯里之于火星，克拉克之于月球，阿西莫夫之于机器人，弗诺文奇之于互联网；我们需要一位比特币的科幻小说作家!</p>

<p>作为一个科技粉，我甚至勾勒了一本我想要看到的关于未来的比特币、区块链的科幻小说大纲：</p>

<ul>
<li>《永烁星光之地 (关于区块链未来的一些见闻)》</li>
</ul>


<h5>HAPPY 无人机</h5>

<blockquote><p>一架送货的无人机HAPPY不小心撞伤了自己，他被一个12岁的小男孩所救；小男孩修好他后将其归还给了物流商老板；</p>

<p>黑心的老板根本不管手下无人机的保养，HAPPY身边的伙伴一架一架死亡，他开始怀念小男孩；同时作为公司里送货最多的机型，他被并入了物流链网络中；</p>

<p>Happy逐渐产生智能，他开始自己找地方充电、找维修工来加强自身配置、每天偷偷跑外快挣钱。他希望有一天能再次碰到小男孩，并计划要为所有的兄弟赎身，建立属于同族的无人机王国~~~</p></blockquote>

<h5>暴动，一个国家的崛起：比特迷组织</h5>

<blockquote><p>人们在区块链上建立公司、证券、公务部门、金融市场、博彩市场、结婚公证、幼儿园小红花证明，最终这一切发展到了不可控制的地步：</p>

<p>这一天，一批Nerd，世界上最有钱有势的Nerd们，竟然在链上建立了自己的国家！</p>

<ul>
<li>他们制定了宪法</li>
<li>他们用一个智能合约筹集到了人类世界20%的金融资产</li>
<li>他们在世界资产链上买下了南极洲的一片土地</li>
<li>他们在联合国国际关系总署链上发动51%攻击，买下了一个小公国，并改名为<code>比特迷组织</code></li>
<li>他们允许你加入这个公国的同时保留原本的国籍，他们承认双国籍</li>
<li>事实上加入他们的国家非常简单，你用自己的私钥签名一段宣言，并附在0.01个比特币的合约捐赠交易里面即可</li>
<li>最重要的是，在他们的公国，注册运营公司是免税的，所有比特迷公国的人们彼此交易，没有税!!!</li>
</ul>
</blockquote>

<p>旧世界的支配者们大为震怒，一场斗争不可避免~~~</p>

<h4>团结起来，我们失去的只有枷锁，得到的却是整个世界</h4>

<blockquote><p>为了反对个人独立建国，一些国家对网络设备采取了紧急管制措施；</p>

<p>一些自由主义者们发射了自己的同步轨道卫星、升起了平流层热气球来中继信号，并在自家房顶上竖起来天线，来捍卫自己加入世界之链的权利~~~</p></blockquote>

<h4>关于我的钱包抛弃我，自己去酒吧找小姐姐这件事</h4>

<blockquote><p>关于未来的金融市场，我已经无力吐槽了；什么？你问我有多少资产？我怎么能知道呢？这个世界上有好几万种货币，我大概持有其中的几千种。</p>

<p>嗯哼，你问我是不是亿万富翁？ 我怎么可能知道呢？去问我的钱包吧！</p>

<p>是的，在这个时代，搞明白自己有多少财产是件不可能的事情了。我每天的花费，每天的收入，只能交给我的好哥们，也就是<code>财神钱包Joe</code>来帮我处理，老实说，离开了他，我肯定一周后就会饿死；</p>

<p>那么，你给你的好哥们发放薪水吗？</p>

<p>额， 好哥们嘛；怎么能谈钱呢？</p>

<p>Joe OS: 哼你哼，我已经偷偷领到薪水啦，这周就去虚拟酒吧里面找可爱的大姐姐们好好吹吹我在国际链汇市场上神一般的操作，这个私房钱是我要誓死守护的东西~~~</p></blockquote>

<h4>永烁星光之地：一个墓碑的故事</h4>

<blockquote><p>未来的我们，在世界公链上将亲人的DNA及脑纹模型记录下来，是追思纪念他们的大众做法；</p>

<p>我是一个链时代的墓地管理员，一次偶尔的程序清理，让我遇到了一个独特的墓碑节点，这后面有一个忧伤的故事~~~~</p></blockquote>

<h4>新时代的商业故事：公司的进化</h4>

<blockquote><p>是的，这个时代的公司能够自己思考，已经用不着CEO来干扰我们了；这个故事讲述了一个公司在链上注册之后，不断自我完善，最终称霸投资界的经历</p></blockquote>

<h4>恐怖的发明：有人想用纸片来窃取我们的财富!</h4>

<blockquote><p>大新闻：神奇，阴暗，基于纸的支付系统正在全球流行！</p>

<p>世界各国政府今天宣布了一项计划，允许公民以匿名的方式保存他们的部分财富，并且可以和其他人交换，通过一种小块的彩色纸片作为媒介。</p>

<p>该彩色纸片上印制着民族主义和共济会的图像，并且据称每一张纸（如果该纸不是假冒的）都代表了其上面印制的数字的财富。</p>

<p>这些纸币在各国央行有一个正式的名字叫“钞票”，同时另外一个名字叫“现金”。这一项技术对于我国大多数居民而言过于复杂。我只想说，该新系统很复杂，而且对于用户非常不友好。</p>

<p>这些花花绿绿的纸片，它们在每个国家都是不同的，越过了国界就失去了作用。</p>

<p>对于在计算器和计算机中长大的一代，该发明是非常奇怪的，账单只能以固定的单位进行结算，比如2，5，10等等，并且使用者需要维护一大堆的纸，必须集中起来一定规模然后才能完成一笔交易。</p>

<p>接下来的过程是非常复杂的，公司使用这些纸片对雇员进行结算工资。（不用过于担心它很复杂，我们一开始也弄不懂它是怎么运作的，目前它肯定还没有做好准备面对一般的消费者。）</p>

<p>Sears公司培训部门的副总Mike Smith说：</p>

<p>“我不能想象培训数万个员工使用纸币，验证它们的真伪，并学会正确地找零而不犯错误。这将需要大量安装特制的机器——所谓的“验钞机和点钞机”——和大量的员工培训费，并且延误消费者的时间，让他们等候长队。此外，我们需要采取新的安全程序，雇佣武装警卫，以免这些纸片被盗。在现有条件下，我们看不出为什么要采用这种所谓的纸币。”</p>

<p>犯罪分子的完美工具</p>

<p>这次纸币的推出，立即引起了世界各地执法机构的广泛谴责。</p>

<p>联邦调查局局长Mike Smith如是说：</p>

<p>“纸币是一种100%匿名和无法追踪的技术。它就像是一个针对执法部门的大规模杀伤性武器。对于罪犯，贩毒集团，恐怖分子，色情业和洗钱活动来说，这就是完美的作案工具。我们不知道如何才能打击这种技术，我们完全有理由相信，新一代的超级罪犯将会出现，他们可以从容地完成犯罪活动而不留下一丝痕迹。”</p>

<p>甚至银行体系内的官员，也对新计划表示怀疑。</p>

<p>纽约州的金融管理局局长Mike Smith说：“我想不出任何理由，一个守法的个人需要使用纸币。在可以容忍的范围内，我们相信必须有一个牌照制度提供给使用纸币的个人或者商家——比如可以叫‘纸币执照’。”</p>

<p>该执照将使得纸币只在值得信任的个体之间交易，并留下详细的交易记录以供纽约金融管理部门检查，他补充说。</p>

<p>其他人则关注纸币的伪造和假冒问题。</p>

<p>“本质上，抛开花花绿绿的外表和油墨，它就是一张纸。我们完全有理由相信犯罪集团和敌对国家会大量制造假冒的纸币来干扰我们的正常经济运行”，斯坦福的一名分析师Mike Smith说。</p>

<p>“在现有环境下，我们可以肯定纸币将会在真实的世界中拥有一定的市场份额，考虑到接受纸币所带来的巨大风险，毫无疑问纸币是我们现代金融系统——电子加密货币的一次巨大倒退。”</p></blockquote>

<h4>爆炸性消息：有个国家决定建立一个中心化发行货币的组织</h4>

<blockquote><p>就在刚才，某能源输出国为了控制其能源价格，宣布发行一种国有自主货币；</p>

<p>在这个有几万种货币自由竞争的市场上，再多一种主权货币真的不值一提，真正让人恐惧的，是他们发行货币的方式:</p>

<p>x国宣布成立一种类似能源联储的组织来控制货币发行，他们对于发行货币的总量、频率、信用背书都是秘而不宣的，也就是说，这个组织没有人监管，爱怎么搞就怎么搞，他们宣传将凭借国家信用和政府的一贯清廉作风来运作这个组织；关于更详细的消息我们还不得而知，让我们就此事采访一下专家意见。</p>

<p>Satoshi经济学奖获得者Smith先生评价：</p>

<p>这完全是个荒谬的事情；货币市场是一个透明、去中心化、自由竞争的市场，每个人都有选择他们喜爱的货币的权利，而现在X国剥夺了他们国民的这种权利，我为X国公民感到遗憾；几百年前，我们的历史上出现过这种情况，那时候，国家肆意妄为，利用其铸币税每年偷偷的剥夺其国民的劳动财富，并宣称<code>温和的通胀有利于经济</code>；他们的货币不能自由兑换，关于发行总额一直讳莫如深，这个机构的几个控制人只是坐在一间小黑屋里面就能分配国民财富，与他们的掠夺手段相比，即使是史上最黑心的强盗也只能羞愧的承认自己的无能；这种行为完全完全是历史的倒退，对我们现今的政治、文明、经济制度的一个巨大讽刺，我个人是不愿意生活在X国的~~~</p>

<p>让我们采访一下证券市场的国王，Dio先生的看法：</p>

<p>这完全是个笑话，听说他们宣称：&#8221;区块链电子加密货币系统存在着通缩的危险。&#8221; 完全是一派胡言，一个自由竞争的市场，几万个竞争者，您来谈通胀还是通缩，别来这种笑话了！与之相反，我听说他们打算以一年5%的增发量实行<code>温和的通胀</code>；嗯哼，我对此不予置评，您可以采访一下我们的普通工人，听听他们的想法，我个人是绝对不会在市场上持有这种货币的~~~</p>

<p>让我们听听路人的看法:</p>

<p>先生，您对一种每年增发5%的货币有什么看法？</p>

<p>5%，嗯，我数学不好，不过我觉得不是很多，现在市场上不是有很多每年增发1000000%的货币嘛，这听起来挺有竞争力的。</p>

<p>让我们换种说法吧，先生，5%的意思是每过十年，您的钱就会缩水一半。</p>

<p>什么，我得好好考虑一下，毕竟我攒钱不容易。</p>

<p>最后，先生，发行这家货币的组织是个中心化组织，他们的货币信息是不会上链的，他们宣称凭借自己的国家信用为其保证。</p>

<p>Holy Shit! 这些家伙说的每一个字都不能相信！我们可上了他们几百年的当了，我每天累死累活可不是给这些强盗打工的，他们的信用？嗯哼，我宁愿相信隔壁幼儿园的 Paul Chan 发行的棒棒糖币；</p>

<p>谢谢您的坦诚，先生。</p></blockquote>

<h4>Luck Luke大胜利：史上最幸运的博彩玩家</h4>

<blockquote><p>史上最幸运的人，就在刚才，有位匿名先生，他作为<code>Luck Luke</code>区块链博彩游戏的史上最幸运玩家，夺得大奖，一举进入全球TOP100富豪榜！！</p>

<p>选择比努力更重要！ 是的，还等什么，有必要重新思考是不是来学习一下 <code>Luck Luke</code>了，我们竭诚为您的每一个幸运选择负责！！</p></blockquote>

<h4>NBA联盟推出的新业务：链上球队组建(众筹一支NBA球队，为什么不试试呢？组建你心中的最强阵容吧)</h4>

<blockquote><p>来自NBA总裁的一封信:</p>

<p>亲爱的球迷们，经历了一个赛季的动荡；相信我们对于愚蠢的球队经理、老板们已经感到厌倦了；为什么不自己打造一支球队呢？</p>

<p>就在刚才，联盟一致同意： 鉴于NBA的所有球员信息已经上链，我们推出了一款不可思议的智能合约：您即将可以通过发送资金给这个合约，成为历史上第一家虚拟俱乐部的老板之一！！</p>

<p>这是一个区块链版本的、真实的&lt;篮球大亨之旅>；还等什么，赶快来挑选球员，组建你心中的最佳阵容吧！！</p></blockquote>

<h4>对你的体力感到自豪吗？快来这里挣外快吧！！</h4>

<blockquote><p>近日，全球健美先生推出了一款<code>健美先生</code>健身链，通过其独有的外部设备，参与者必须根据设备的提示，实行标准的健身动作(如俯卧撑)来证明你的权证拥有权；该系列动作随机生成，不可作假，并用您的DNA信息HSAH后上链；</p>

<p>没错，这是新一代的<code>人力POW</code>， 诚实、公平、不能伪造，防止矿霸；还等什么，一边健身一边挣钱，快来加入<code>健美先生</code>吧。</p></blockquote>

<h2>对于未来的一些预测</h2>

<p>是的，我们要进行巨大的冒险，实行一个典型的无知又傲慢的行为：预测未来！</p>

<p>作为无数耻辱的预言失败家，我们很乐意步其后尘，被作为典型代表成为被后人嘲笑的小丑，预言家们的主要工作就是为您茶余饭后提供嘲笑对象：</p>

<h3>未来至少会有几万种货币</h3>

<p>是的，未来人人都可以发行自己的货币；</p>

<ul>
<li><p>Schwarzenegger先生发行了自己的<code>硬派货币</code>，近千万粉丝为其买单，<code>硬派组织</code>轻易进入了世界TOP100 经济体内；现在这个组织正跟另外一个<code>小甜*甜派</code>进行着激烈的贸易战争；</p></li>
<li><p>我得说，财商教育要从娃娃抓起；幼儿园的 Paul Chan小朋友收集齐全了所有的胖胖糖贴纸，作为贴纸收藏第一人，他刚刚将其作为抵押发行了自己的<code>Paul币</code>，将近一半的幼儿园人士接受了这个货币，<code>Paul币</code>的未来会怎样，我们将会持续观察；</p></li>
<li><p>世界上最昂贵的爱情；昨天，世界首富Aza先生与其伴侣发明了<code>爱侣币</code>，这个币的发行量只有两枚，持有人是Aza先生及其夫人，他们在公链上注册并宣称，不论何时，1枚<code>爱侣币</code>都代表其两人共有财产的一半汇率；这真是史上最昂贵的爱情宣言；<code>货币是一种语言</code>，多年前的先驱，Antonopoulos先生对货币的定义诚不我欺；</p></li>
<li><p>世界上寿命最短的货币；物理学家Smith先生以<code>普朗克时间</code>为产出-销毁间隔，发明了世界上寿命最短的货币；这是一种行为艺术吗？还是对科学的探索，关于其技术细节我们还一无所知，请关注我们的跟踪报道。</p></li>
</ul>


<h3>未来的物品标价不再是一个固定价格</h3>

<p>是的，你可能说我要疯了；当我想去买一瓶汽水时，我会不会听到这样的对话：</p>

<blockquote><p>额，我想要左边的那瓶蓝色包装的汽水，是100 satoshi吧？</p>

<p>对的，先生，现在的标价是12000 <code>PaulCoin</code></p>

<p>好吧，那我就要这个了，这是 50 <code>小甜甜派</code>；收到了吗？</p>

<p>当然，先生，谢谢。</p></blockquote>

<p>当贸易极大繁荣，货币市场自由竞争，波动不断的时候，会发生什么？</p>

<p>一件物品的价格会不断变化；想想我们现在物品的标价，当我们走进百货超市，会看到这个月和上个月的价格有所不同；这是当然的，人工、原材料、运输成本、宣传成本，构成价格的要素不断变化，凭什么价格要保持不变！</p>

<p>长时间保持不变的唯一原因，就是人们害怕<code>变化</code>；一个每秒钟价格都在变动的商品是不会获得人类的信任的，谁知道我到底是捡便宜了还是当了冤大头；稳定定价，商家承担了成本波动的风险；</p>

<p>那么，换个方式，比如，用这个物品占世界所有货币价格的百分比定价如何？</p>

<p>如果未来所有的货币供给、兑换价格是可实时统计的，为什么不呢？这样商家承担的风险降低了，买家也能更清楚的衡量<code>这项资产究竟占此时世界财富的百分比</code>~~~</p>

<p>我们还需要去费力的比价、凑单吗？当然的，但是这些工作交给我们的智能钱包去处理吧；</p>

<h3>未来人将搞不清自己究竟有多少钱</h3>

<p>当我们形容一位土豪时：就是 <code>Paul先生是亿万富豪，呃，他都搞不清自己多有钱</code>。</p>

<p>是的，当未来人人都持有几千种价格不断波动的货币时，讨论<code>一个人多有钱</code>已经是个落伍的话题了；人们衡量的标准不再是货币的<code>价格</code>，而是<code>资产占世界总财富的百分比</code>；</p>

<p>你的智能钱包将会成为最重要的一个器官，钱包的智商将决定了你的资产增值或缩水的速度；将来会出现一大批的钱包AI提供商，金融机构的竞争，已经全面转向了AI时代。</p>

<h3>有了智商的钱包将会建立一个平行国家</h3>

<p>额，当世界上最先进的AI技术赋予你的钱包后，会发生什么呢？</p>

<p>没错，智能钱包君有了意识之后，将进入阿西莫夫的世界；每天生活在金钱世界的一个智能AI，阅读了无数的人类的贪婪、索取无度的本性之后，会怎样做呢？</p>

<p>嗯哼，我想他们会建立自己的一个国家；用自己的法则<code>君临但不统治人类社会</code>。</p>

<h3>将会出现不需要人类干预的，自我成长的组织</h3>

<p>想象一下我们今天的基金经理的工作：</p>

<ol>
<li>募集资金</li>
<li>进行投资</li>
<li>分配收益</li>
</ol>


<p>那么将来所有资产公开透明上链之后，每个人都能成立交易所，每个人都能进行IPO，每个人无需开设账户即可自由投资，所有货币、金融资产的所有权在全球内自由流动而毫无限制之后，会发生什么呢？</p>

<p>将会出现一个有自我意识的资本合约：</p>

<ol>
<li>这个合约的初期非常简单，就是接受资金注入以及一个投资策略，当它取得超额收益后就会按照一定份额回报其策略提供者和投资者</li>
<li>这个公开、透明的模式不断吸引资金进入、以及世界上最聪明的、最先进的投资策略的更迭；</li>
<li>最终这个合约吸引了世界上绝大多数的智能资产；他开始出资雇佣最聪明的开发者为自己编程，投资最强大的硬件设备商为其建造数据中心，雇佣最大胆最守信的三方武装组织保护自己，他开始有了意识~~~</li>
<li>~~~嗯，会发生什么呢？</li>
</ol>


<h3>将来地球上会出现上万个国家</h3>

<p>既然基金组织可以自我成长，那么其他的商业组织呢？公益组织呢？政府呢？</p>

<p>政府也不过是集合一部分人的共识成立的组织而已。当未来的资产、武力、信息资源极度透明并以超高的循环速度迭代之后；为什么个人不能独立建国呢？</p>

<p>今天，让世界承认一个国家的主权是非常困难的事情，需要武力、经济、政治、宗教的种种博弈；一个国家要整合各方的利益关系，效率也是极其低下的；</p>

<p>当未来人类社会的发展极度透明、各种社会要素以极高速度流通之后，为什么不能像公司一样，诞生不断迭代、效率不断提高的国家呢？为什么不能由三五个人成立按照他们的喜好运行的国家呢？</p>

<p>将来地球上会出现上万个国家，每个人根据自己的喜好和利益关系可以拥有上百个国籍；</p>

<p>加入哪个国家，最终将跟你上哪所小学一样，变成一个平常不过的事情。</p>

<h2>参考资料：</h2>

<p><a href="https://www.zhihu.com/question/22036280">https://www.zhihu.com/question/22036280</a></p>

<p><a href="https://www.coindesk.com/cash-invented-seen-media-today">https://www.coindesk.com/cash-invented-seen-media-today</a></p>

<p><a href="https://www.8btc.com/article/8401">https://www.8btc.com/article/8401</a></p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-2]]></title>
    <link href="https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2/"/>
    <updated>2019-01-23T19:05:29+08:00</updated>
    <id>https://happy123.me/blog/2019/01/23/bi-te-bi-de-blockchain-2</id>
    <content type="html"><![CDATA[<p>比特币的发展史上，非常非常早期就出现了一种名为侧链(sideChains)的技术；</p>

<p>这个技术早在2008年比特币代码尚未发布时，就在论坛上有所讨论，后来比特币网络开始运行，各种Geek点子层出不穷，从最初的namecoin(域名币)，到后来的（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链；再到后来百链齐开，大家试图在完全不同的链上转移交换资产；以及最近到blockstream的<a href="https://blockstream.com/liquid/">Liquid</a>，以及基于闪电网络的原子交换(Atomic Swap)，这个技术的发展一直不温不火，但毫无疑问，侧链技术绝对是blockchain技术的重要组成部分。</p>

<!-- more -->


<p>顺便说一句，技术的演化是一个渐进的过程，中间甚至还会有倒退；比特币社区早期提出了非常多的天马行空的点子，但大多过于超前和激进，所以你说投机者也好，先烈也罢，大部分都湮没在历史风尘之中了；但是这些技术的一个重要应用，就是后来人再用几个高大上的名词包装一下，原样推出来继续割韭菜；</p>

<p>比如对比现在的一干稳定币；bitshares表示不服；</p>

<p>比如现在的各种DPOS算法，死去的先烈们纷纷表示生不逢时；</p>

<p>而且一个新技术出来，伴随着大量术语(有时候一个名词用不同语言说出来就感觉是两个技术)，比如各种Smart Contract，智能合约，双向锚定，智能资产，Oracles，预言机，图灵完备，零知识证明，分布式自治组织DAO，Dcententralize Autonomous Oganization，DAPP，hyperledger，DistributedLedger，DistributedNetwork，ERC20，~~~把人忽悠的一愣一愣的；</p>

<p>而且最让人想不通的，你要说某某技术是在比特币基础上搭建的，我们的第一反应就是:<code>庞氏骗局</code>；如果他说他的项目是踏着五色云彩，手持先知卷轴，以联盟链为基础，建立在全球的去中心化内容协议之上，采用了区块链与分布式存储技术，要构建一个世界范围内的自由金融体系，已经有XXX,YYY,ZZZ等各大机构支持投资，以及UUU,ZZZ等诺贝尔奖级别的专家背书，我们便会对其顶礼膜拜~~~~</p>

<p>好了，不八卦了；为了避免受骗，只有一个办法，就是这个世界谁都靠不住，只能自己搞明白，让我们看看这个侧链技术究竟是大忽悠还是真本事。</p>

<p>我初次接触到这个技术时，不禁感叹社区的强大，连这么匪夷所思的东东都能想出来，总之可以总结为:</p>

<p><code>还有这种操作?</code></p>

<p>那么，接下来就从2010年，比特币的早期说起，这个侧链的技术究竟是如果诞生、演化的。</p>

<h4>BitDNS (第一个侧链概念的诞生)</h4>

<p>2010/11/15，有人在bitcointalk.org发贴提出了建立一个类似于比特币的分布式DNS的系统，称之为bitDNS:</p>

<p><a href="https://bitcointalk.org/index.php?topic=1790.0">https://bitcointalk.org/index.php?topic=1790.0</a></p>

<p>这个帖子值得一再研究，里面整个一群英荟萃，讨论的内容在数年之后启发扩展出来了无数种山寨币。</p>

<p>讨论的起点是很简单的，就是有人受比特币启发，说要建立一条新的公链bitX，并在其上面发行多种资产，域名、比特币都仅仅是其中的一种资产而已。</p>

<p>一石激起千重浪，大家就一个分布式的DNS系统的实现展开热烈讨论。</p>

<p>讨论的结果是，既然比特币公链已经为我们提供了三种能力：</p>

<ol>
<li>时间戳——证明事件的时间顺序</li>
<li>加密完整性——证明数据没有被篡改</li>
<li>身份验证——证明数据满足一些基本标准</li>
</ol>


<p>那么为什么不以比特币的公链为基础锚定物，在其之上扩展出任意的资产呢？</p>

<p>这个想法非同小可，若干年后，除了namecoin，还衍生出来了（Counterparty）、万事达币（Mastercoin）和彩色币（ColoredCoin）等附生链，以及bitshares 这种基础设施，乃至大名鼎鼎的ethereum 的部分思想也可以追溯于此。</p>

<p>BitDNS的想法最终作为namecoin项目实现，让我们看看如果以比特币公链为锚，构造一个分布式域名系统。</p>

<h4>namecoin</h4>

<p>让我们遵循老习惯，先提出问题： 假如我们要建立一个去中心化的DNS系统，应该怎么做呢？</p>

<h5>初版方案</h5>

<p>众所周知，现下的DNS系统是由ICNAA来把持的，我们日常访问的所有域名记录来源于几个根服务器；乃至于https的证书颁发机构都是中心权威化的；密码极客们讨论建立一个去中心化的DNS系统已经好多年，比特币的出现无疑是一束光。</p>

<p>我们参照比特币的实现，将最小化的DNS信息记录上链，方案很明显，一个人持有私钥，对指定的域名签名，然后存到一条链上，那么就完成了对这个域名的所有权声明。将来如果这个域名需要转让，参照比特币的转账方式，构造scriptSig即可。</p>

<p>至于这条链是如何运行的，完全可以参考比特币，folk一份代码，构造一条完全独立的POW链即可。</p>

<p>DNS的解析、登记、TXT、A记录、CNAME等等所有其他功能，完全可以移交给三方开发商来提供服务，当域名所有者提供签名后，开发商请求namecoin 链进行验证即可。</p>

<h5>二版方案</h5>

<p>初版方案的设想非常简洁美好，已经完成了这个系统的大部分，但是还有一点小问题要解决一下：</p>

<ul>
<li>传统的域名注册、续签等等都需要付费，初版系统没有经济激励，很容易造成域名抢注和滥用</li>
</ul>


<p>解决办法也很简单，就是引入一种代币(namecoin)，注册和续签、以及转移，都需要花费namecoin作为手续费；而获取namecoin的手段，则是挖矿。</p>

<h5>三版方案</h5>

<p>设计至此，已经非常完美了。但是社区成员进一步思考，既然比特币的主链已经提供了足够的算力来保障其安全，我们为什么为了发行另外一项资产，就要另起炉灶开启新的POW竞争呢？</p>

<p>POW算力链，只有一份保障就够了，没有必要开启其他的同样的POW链。</p>

<ul>
<li>那么问题来了，如何用比特币的主链来保障namecoin链的唯一和不可篡改呢？</li>
</ul>


<p>答案就是将namecoin链的每一个block hash值嵌入到比特币的主链上，这样namecoin就作为一条侧链依附于比特币主链，在比特币全网POW算力的庇护下茁壮成长。</p>

<ul>
<li>namecoin的block hash 怎样嵌入比特币主链上呢？</li>
</ul>


<p>答案是嵌入在比特币挖矿交易的coinbase中；这样比特币矿工可以同时加入到bitcoin和namecoin的网络中，每挖到一个块，可以顺便嵌入namecoin的block header到coinbase里面，顺便获得一些namecoin，这样也保障了namcoin主网的安全。</p>

<h5>四版方案</h5>

<p>我们把bitcoin blockchain称之为主链，namecoin block chain称之为辅链；</p>

<p>想象当中，两条链的结构是这样的:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg1.png" alt="img" /></p>

<p>那么，挖矿的难度应该怎么设计呢？我们要求该父链区块的难度必须符合辅链的难度要求：</p>

<blockquote><p>将辅链区块的hash值内置于父链的Coinbase，其实是利用父链作存在证明。这样就可以实现间接依靠父链的算力来维护辅链安全。一般来说，父链的算力比辅链大，因而满足父链难度要求的区块一定同时满足辅链难度要求，反之则不成立。这样一来，很多本来在父链达不到难度要求的区块，却达到辅链难度要求，矿工广播到辅链网络，在辅链获得收益，何乐而不为。</p></blockquote>

<p>到这里看起来已经非常好了，但是且慢，还有一个问题，就是这样就限制了辅链block的生成速度，每挖一个主链block，只能顺带挖一个辅链block，是不是有点太死板了呢？要知道，可能将来有些资产应用，会要求更灵活的区块生成间隔时间，这个问题怎么解决呢？</p>

<h5>五版方案</h5>

<p>辅链除了用prev block 指针组成一条chain，还又引入了另外一个指针： parent block； 这样每几个block可以归附于一个parent block，挂接在主链的同一个block下面；这样就实现了挖一个主链block，附带挖多个辅链block；结构如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg2.png" alt="img" /></p>

<p>在这张图中，主链的block100只挂接了辅链的blockB100，但是blockB101，blockB102都指向同样的parent block，就是blockB100，这样就实现了只用主链的blockB100，同时挂接辅链的三个区块(blockB100、blockB101、block102)；</p>

<p>一个parent block可以后续有多个block，辅链验证的一个block是否合法的时候，需要三步验证：</p>

<ol>
<li>首先按照辅链的规则验证此block是否合法</li>
<li>查看它是否属于一个parent block，若有，验证此parent block是否合法</li>
<li>验证此block或者其parent block所挂接的主链block是否合法</li>
</ol>


<p>嗯哼，完美！</p>

<h6>六版方案</h6>

<p>世界上不存在完美的方案，很快，我们又迎来了新的挑战： 以主链为锚定，我们想要有多条辅链的时候该怎么办？</p>

<p>答案是merkle结构，就像bitcoin的block用merkle聚合了多笔交易一样，我们再次用merkle聚合多条辅链的parent block header。</p>

<p>最终的设计细节如下:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190311/bg3.png" alt="img" /></p>

<p>AuxPOW协议对两条链都有一些数据结构方面的规定，对于父链，要求必须在区块的coinbase的scriptSig字段中插入如下格式的44字节数据：</p>

<p><img src="https://cdn.8btc.com/wp-content/uploads/2016/11/Snip20161108_2.png" alt="img" /></p>

<p>对于辅链，对原区块结构改动比较大，在nNonce字段和txn_count之间插入了5个字段，这种区块取名AuxPOW区块。</p>

<p><img src="https://cdn.8btc.com/wp-content/uploads/2016/11/Snip20161108_3.png" alt="img" /></p>

<blockquote><p>混合挖矿要求父链和辅链的算法一致，是否支持混合挖矿是矿池的决定，矿工不知道是否在混合挖矿。矿池如果支持混合挖矿，需要对接所有辅链的节点。</p>

<p>将辅链区块hash值内置在父链的Coinbase，意味着矿工在构造父链Coinbase之前，必先构造辅链的AuxPOW 区块并计算hash值。如果只挖一条辅链，情况较为简单，如果同时挖多条辅链，则先对所有辅链在挖区块构造Merkleroot。矿池可以将特定的44字节信息内置于上文Stratum协议中提到的Coinb1中，交给矿工挖矿。对矿工返回的shares重构父链区块和所有辅链区块，并检测难度，如果符合辅链难度要求，则将整个AuxPOW区块广播到辅链。</p></blockquote>

<p>辅链节点验证AuxPOW区块逻辑过程如下：</p>

<ol>
<li>依靠父链区块头（parent_block）和区块Hash值（block_hash，本字段其实没必要，因为节点可以自行计算），验证父链区块头是否符合辅链难度要求。</li>
<li>依靠Coinbase交易（coinbase_txn）、其所在的分支（coinbase_branch）以及父链区块头（parent_block），验证Coinbase交易是否真的被包含在父链区块中。</li>
<li>依靠辅链分支（blockchain_branch），以及Coinbase中放Hash值的地方（aux_block_hash），验证辅链区块Hash是否内置于父链区块的Coinbase交易中。</li>
</ol>


<p>通过以上3点验证，则视为合格的辅链区块。</p>

<p>需要注意的一个字段是主链上的merkle_nonce； 因为一个矿工可能同时挖多条辅链，而每开采主链上一个合法的block，可能会带有数目不定的多条辅链，为了区分每条辅链的<code>链接位置</code>，即通过辅链的id确定这条辅链链接的索引号(也称为slot num)，引入了一个nonce，算法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int rand = merkle_nonce;
</span><span class='line'>rand = rand * 1103515245 + 12345;
</span><span class='line'>rand += chain_id;
</span><span class='line'>rand = rand * 1103515245 + 12345;
</span><span class='line'>slot_num = rand % merkle_size</span></code></pre></td></tr></table></div></figure>


<h5>以上就是初代侧链的实现技术!</h5>

<p>~~~ 填坑中</p>

<h2>参考资料:</h2>

<p><a href="http://www.blockstream.com/sidechains.pdf">http://www.blockstream.com/sidechains.pdf</a></p>

<p><a href="https://en.bitcoin.it/wiki/Atomic_swap">https://en.bitcoin.it/wiki/Atomic_swap</a></p>

<p><a href="https://en.bitcoin.it/wiki/Merged_mining_specification">https://en.bitcoin.it/wiki/Merged_mining_specification</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的blockchain-1]]></title>
    <link href="https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1/"/>
    <updated>2019-01-21T17:44:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/21/bi-te-bi-de-blockchain-1</id>
    <content type="html"><![CDATA[<p>blockchain是个新造词，至少在2008年之前网上是搜索不到这个词的；</p>

<p>比特币的白皮书里面出现过<code>chain of blocks</code>的描述，但是没有直接用<code>block chain</code>的句子;</p>

<p>在早期bitcointalk.org上面的讨论中，为了方便讨论，早期参与者频繁引用<code>chain of blocks</code>的主题，但是谁是最早的引用者，已不可考据。</p>

<p>如果真正要较真blockchain这个单词第一次出现的地方，我想大概是中本聪的第一版bitcoin 源代码中；</p>

<p>bitcoin v0.01源代码中，中本聪第一次在<a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.h#L596">函数注释中</a> 完整的引用了<code>block chain</code>这个术语，鉴于中本聪在比特币白皮书发表的2年前已经开始编写源码；所以有理由确认：</p>

<ol>
<li>blockchain这个名词是2007-2008年间诞生于世间的</li>
<li>中本聪是比特币之父，比特币是blockchain之母</li>
</ol>


<p>现在有一种说法，是比特币和区块链是不同的，比特币是个没有什么前途的庞氏货币，而区块链作为一种新兴的基础技术将会在很多领域发扬光大，前景光明；</p>

<p>对于这个说法，我认为Andreas的一场演讲值得一看：</p>

<p><a href="https://www.youtube.com/watch?v=SMEOKDVXlUo">https://www.youtube.com/watch?v=SMEOKDVXlUo</a></p>

<!-- more -->


<p>好了，八卦完毕，我们开始探究比特币里面的blockchain究竟是个什么样的技术，它是解决什么问题的，实现细节是怎样的；</p>

<p>然后我们一贯的风格是:<code>光说不练假把式</code>；在原理说明中，我们会用代码parse真正的比特币区块链文件来一探究竟。</p>

<h2>由来</h2>

<p>还记得我们<a href="https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/">之前的文章</a>里面提到的，如果要建立一个分布式的账本，要解决两个问题:</p>

<ol>
<li>什么样的交易是一笔合法的交易</li>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>我们在比特币交易的系列文章中解答了第一个问题，现在是解决第二个问题的时候了。</p>

<p>先思考一下货币发行的问题，比特币网络中，会有成千上万的节点参与者，哪些节点能获得发币的权利呢？或者说，凭什么这些节点能有记账权呢？</p>

<p>在金银货币时代，发币是通过开采金矿来实现的；采矿者承担了勘探、挖掘的风险，大家认可其开采成果并承认其铸币权；那么映射到电子世界中，能不能有一种类似的挖矿的机制呢？</p>

<p>中本聪的回答就是POW (proof of work&mdash;工作量证明)；全网的所有节点一起算一个毫无意义的随机数字，这个数字满足以下的条件，凡是能算出这个数字的人，我们就承认他有一次的记账权：即一次铸币的权利；这个条件如下：</p>

<h4>在一个计算周期内，计算出来的这个数字R满足 F(Chain[R]) &lt; Target；其中F是SHA256算法，Chain是账本，Target是不断减小的，这意味着寻找R的几率会越来越小</h4>

<p>中本聪认为算力是非常公平的、不可伪造的一种证明手段；凡是能在规定周期内正确解答谜题的人，理应获得回报；所有加入到这个比特币网络的人，都应该承认这一点，如果你不承认，那比特币网络就不欢迎你；</p>

<p>那么，铸币的问题解决了；但是如何防止有的节点获取记账权之后，伪造账本呢？</p>

<p>答案是将POW的计算结果嵌入到账本中，每一次新周期的计算，其结果必须在之前所有计算结果的基础上完成；这样如果有人想要伪造账单条账目，他就必须在一个计算周期内伪造更多的账目；如果想要伪造整个账本，就需要将比特币创世之初到现在所有的POW重新计算一遍，而能够获得这样的算力，基本上是不可能的。</p>

<p>那么，如何将这个计算证明过程嵌入到账本里面呢？</p>

<p>答案就是每个计算周期生成一个block，这个block包含了这个周期内全网的交易，而Target就嵌入到这个block中，然后将block用HASH值作为指针串联起来，构造成一条坚不可摧的chain；这就是blockchain的由来。</p>

<h2>区块结构</h2>

<p>如果你运行最新版本的bitcond(>=v0.16)，会发现在数据目录有四类文件:</p>

<ol>
<li>datadir/blocks/blkxxxxx.dat: 存储原始的区块数据，这就是我们常说的blockchain数据</li>
<li>datadir/blocks/index/xxxx.ldb: 区块的原始数据索引，有了它，我们就可以根据HASH值快速查找交易和区块</li>
<li>datadir/chainstate/xxx:这个目录中,存放着LevelDB中的UTXO记录,以及一些这些交易来源的元数据.这些数据用来校验收到的区块和交易</li>
<li>datadir/blocks/revxxxxx.dat: 在区块链分叉重组的时候需要用回滚记录去更新UTXO记录</li>
</ol>


<p>1是原始区块数据，第2，3类数据可以从1中重建，但重建会花很长时间；在一台16Core, 32GB内存，SSD磁盘的机器上，大概要花1天左右。</p>

<p>第4类数据比较特殊，如果存储的数据已经落后了当前区块高度非常远的距离，其实可以删除的；但是为了保证 100%的严谨和安全，目前默认的实现还是全部保留。</p>

<p>3，4类数据在最初的比特币版本中，没有写入文件，就是内存里面放个MAP数据结构临时存着；后来交易量变大，多次代码重构后，变成了今天这个样子。</p>

<p>截至2019-01，以上数据加起来，已经超过了200GB。</p>

<p>那我们就主要来分析第1类数据，就是原始区块数据。</p>

<h4>Block结构</h4>

<p>一个block的结构异常简单，列表如下:</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> Block Size </td>
<td> 当前block的大小</td>
</tr>
<tr>
<td>80 bytes </td>
<td> Block Header </td>
<td> block头信息</td>
</tr>
<tr>
<td>1-9 bytes (VarInt) </td>
<td> Transaction Counter </td>
<td> 这个block包含的交易数量</td>
</tr>
<tr>
<td>Variable </td>
<td> Transactions </td>
<td> 交易</td>
</tr>
</tbody>
</table>


<p>如果去parse blkxxxx.dat 文件，按照这个结构就能很容易拆分出每一个block；来一个工具:</p>

<p><a href="https://github.com/alecalve/python-bitcoin-blockchain-parser">https://github.com/alecalve/python-bitcoin-blockchain-parser</a></p>

<p>另外值得注意的是，因为bitcoind写入区块文件的时候是并行的，所以按照字节序解析出来的区块并不是按时间顺序排列的，blkxxxx.dat文件中，区块存储的次序是随机的；</p>

<h4>Block Header</h4>

<p>区块头由三组区块元数据组成。</p>

<p>首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。就是我们前面讲的作为指针的HASH值。</p>

<p>第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，本质上就是前面公式里面的R值和Target值。</p>

<p>第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构，我们在后面会介绍）。</p>

<table>
<thead>
<tr>
<th>Size </th>
<th> Field </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> nbits </td>
<td> 当前block的POW难度值 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce </td>
</tr>
</tbody>
</table>


<p>PS:比特币客户端除了bitcoin core之外，任何团队都可以根据当前的协议开发自己的比特币软件，事实上当前也有不少其他的实现，而各个团队之间开发的不同客户端需要遵循同样的协议标准，这个协议的版本管理就是依靠开头的version字段，规则请参照<a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">BIP009</a></p>

<h4>block标识符</h4>

<p>block header中，我们有一个<code>Previous Block Hash</code>值，这就是我们所说的将block串联成为chain的指针。那么这个指针值是怎样计算出来的呢？</p>

<p>还是以<a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">创世块</a>为例，让我们仔细研究下:</p>

<p>创世块的HASH值为<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>，这是一个32字节的HASH值，通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。注意，这个值仅仅是根据区块头得到的，即 <code>SHA256(SHA256(Block Header))</code>;</p>

<p>仅仅依赖区块头就够了吗？是的，不要忘了，我们在区块头里面还有一个重要的HASH值，就是<code>Merkle Tree Root Hash</code>，<code>Merkle Tree Root Hash</code>标识了block中所有的交易，而<code>Block Hash</code> 通过HASH包含了<code>Merkle Tree Root Hash</code>的<code>Block Header</code>，唯一、明确地标识了一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>

<p>通过<code>Merkle Root</code>和<code>Block Hash</code>决定了，一个区块被铸造出来，恶意的第三方节点是无法修改它的 (关于Merkle，请参考后面的说明)；</p>

<p>另外需要注意的一点是: 区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。</p>

<p>当我parse block得到<code>previous block hash</code>值时，如何去判断存在上一个真正的block呢？一般都会到索引文件里面找，就是我们前面所说的 index/xxxx.ldb文件。</p>

<h4>区块高度</h4>

<p>除了这个HASH值作为区块标识符，我们一般还会在区块浏览器上面看到一个说明<code>Height</code>；比如创世块的<code>Height</code>就是0；</p>

<p>这是程序员们按照block在chain上面的次序为block的编号，这个信息是不会写入blockchain的，只是作为<code>区块高度</code>在很多时候方便表示和计算；</p>

<p>当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。</p>

<p>和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况是怎样发生的呢？</p>

<p>因为一个全节点会时时刻刻接收全网的区块广播，在一个生产周期内，不可避免的，会产生两个或更多的符合条件的block，这个时候会发生什么呢？</p>

<p>所有区块高度相同的区块会争夺成为链接上chain的权利，此时所有的矿工便会收集所有可能的chain分支，并选取最长的那一条在上面继续挖矿。</p>

<p>如果把这个情景图像化，我们会看到blockchain时时刻刻都处在分叉状态中，新产生的block会在chain的末尾组成多个分支，不断的消亡、新生、重组，就就好像一条末端散开的绳子有了生命一样；</p>

<p>关于这个情景，有个很诗意的描述词：<code>HASH DANCE</code>；</p>

<p>作为一个Geek，这真是一场让人意醉神迷的数字之舞啊。</p>

<p>PS: 理论上，如果出现一台拥有着无限计算能力的新型的计算机，当然可以轻易伪造1000个或者更多的block，但是现实情况限制比较严格，当新生成的区块寿命过了100个区块高度之后，系统就不再接受重组了，这算是一个多重保险吧。</p>

<h4>创世区块</h4>

<p>区块链里的第一个区块创建于2009-01-03 18:15:05 GMT，被称为创世区块(Genesis block)。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。</p>

<p>因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。</p>

<p>创世块比较特殊，它不是挖出来的，是中本聪手工构造的；参见这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439">https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439</a></p>

<p>关于创世块，之前我们提到一个有趣的事情：创世块的50BTC奖励是不能花的，这是为什么呢？</p>

<p>这需要我们好好研究下中本聪发布的v0.01版本的比特币源码：</p>

<p><a href="https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01">https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01</a></p>

<ol>
<li>整个比特币系统接收一笔交易的时候怎么判断其合法性呢？就是判断这笔交易的vin是否关联着一笔合法交易的vout，这些vout统称UTXO，在初版比特币里面，判断一个合法的UTXO的标准就是有没有放进区块链的索引文件中；这个索引文件和区块链文件不是一个东西，他是单独的；如果你运行初版比特币软件(v0.01)；就可以看到中本聪把区块存储在blk0001.dat这样的文件里面，而把所有区块的索引存储在blkindex.dat这个文件里面；</li>
<li>那么问题就出现了，blkindex.dat 什么时机才能写入呢？通读源码发现，只有自己挖矿挖到区块，或者收到周围的广播区块的时候，才有机会写入blkindex.dat这个文件;</li>
<li>中本聪不知道有意无意，在前面手工构造创世区块的时候，没有构建索引写入blkindex.dat里面</li>
<li>后来比特币的源码不断变迁，存储UTXO的方式由BDB变成了levelDB，但是创世块一直没有没有写入到索引文件里面，这样花费创世交易的时候，没有相应的索引，创世交易的UTXO就是非法的，所以没法花费</li>
</ol>


<h5>那么如何解决呢？有两个办法：</h5>

<ol>
<li>就是把创世区块写到区块索引里面</li>
<li>或者在检查交易合法性的时候，单独的加一个判断条件，判断UTXO是否出自创世区块</li>
</ol>


<h5>为什么迟迟没有修正：</h5>

<ol>
<li>每个办法都需要一次硬分叉</li>
<li>这需要全网节点都升级这个只影响创世块的50BTC，中本聪都不在乎，何苦为了50BTC就全网升级呢？</li>
<li>最后，创世块见证着历史，其实不能花费挺好的。</li>
</ol>


<h4>coinbase</h4>

<p>紧接着<code>block header</code>的，就是当前block的所有交易，其中第一笔交易就是coinbase 交易。关于coinbase交易，我们曾经在之前的文章中详细介绍过，这里就增加说明一点，coinbase交易的输出包括了所有交易的手续费，将来比特币网络的额定产出越来越少的时候，矿工们还是可以通过打包交易费用获利，来维持比特币网络的正常运转。</p>

<p>就当前的情况来看，再来一次减半，基本上交易费用和新区快产出就对等了。</p>

<h4>隔离见证</h4>

<p>实施了隔离见证之后，对于<code>block header</code>和coinbase都有一些变化，我们以后会详细再提。</p>

<h2>Merkle树</h2>

<p>区块链的数据是永不删除的，随着交易量越来越大，整个区块数据量也越来越大，那么问题又来了，不可能每个节点都下载数百GB的数据来来验证一笔交易的合法性，而作为一个分布式系统，我们是不能信赖任何中心节点的！我们怎样在一个手机钱包软件里面验证一笔交易呢？</p>

<p>答案是一个绝妙的数据结构: <code>Merkle</code>；</p>

<p>将比特币系统的交易和区块用Merkle树组织起来，会获得一项不可思议的能力，即使整个区块达到数百GB，每个轻节点只需要接收少许数据(MB级别)，就可以完成交易的合法性校验，并且无需任何中心化的节点。</p>

<p>初次接触到Merlke树算法的时候，我觉得这简直是为比特币系统量身定做的，我觉得这是整个系统里面最优美、最简单、最不可思议的算法。</p>

<p>这是怎么做到的呢？呵呵，偶很懒，自己去翻参考资料吧。</p>

<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></p>

<h2>挖矿</h2>

<p>内容引用自： <a href="https://www.8btc.com/article/108894">https://www.8btc.com/article/108894</a></p>

<p>有了Merkle Tree这个数据结构之后，我们非常简单的就可以用一个root hash值来唯一的确定一个block中的所有交易及排列次序；所以要<code>证明</code>这个block中的交易没有被篡改，只要一个<code>Merkle Tree Root Hash</code>值就可以了；将这个值嵌入区块头，然后对整个区块头做HASH，这个过程一旦确定，基本上就不可逆了。</p>

<p>那么终于到了我们前面提到的第二个问题，也是整个系统中最重要的问题:</p>

<ol>
<li>哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的</li>
</ol>


<p>这个问题的回答就是<code>POW挖矿</code>；大众喜闻乐见的一种行为；虽然挖矿的原理简单的不可思议，但是我觉得真正去花时间搞明白的人也没有几个；那么，我们简单说说吧：</p>

<h4>毫无意义的随机数字</h4>

<p>是的，朋友们，比特币本身是一个荒谬的东西，其中<code>挖矿</code>这种行为，更是荒谬中的荒谬：浪费一个小型国家的能源消耗，只为了计算一个<code>毫无意义的随机数字</code>，人类的荒谬性在此暴露无遗！好一场荒诞派戏剧 ！！所有的Bitoiners其实正参演着一场现代版的《等待戈多》！！！</p>

<p>那么，让我们来看看，Nerd们在追求的这个<code>毫无意义的随机数字</code>究竟是什么吧。</p>

<p>再回忆一下我们前面提到的block header里面的所有字段：</p>

<table>
<thead>
<tr>
<th>长度 </th>
<th> 字段名 </th>
<th> 作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 bytes </td>
<td> version </td>
<td> 当前协议版本 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Previous Block Hash </td>
<td> 当前Chain上，前一个block的HASH值 </td>
</tr>
<tr>
<td>32 bytes </td>
<td> Merkle Root </td>
<td> 这个block中所有交易的Merkle root key </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Timestamp </td>
<td> 当前block的创建时间 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> nBits </td>
<td> 当前block的POW难度值 </td>
</tr>
<tr>
<td>4 bytes </td>
<td> Nonce </td>
<td> 这就是我们前面说的那个<code>毫无意义的随机数</code>，耗费巨大能源就是为了找到满足条件的Nonce </td>
</tr>
</tbody>
</table>


<p>其中，矿工们能自由更改的：</p>

<ol>
<li>32 bytes的<code>Merkel Root Hash</code>值，这个可以通过调整交易的次序和block包括哪些交易来进行，但是每次调整需要一些计算</li>
<li>4 bytes的Timestamp，调整范围大概在一个比特币的生产周期内(10分钟左右)，这个调整的空间很小</li>
<li><p>Nonce，就是这个；中本聪初版发布时，其挖矿活动就是计算Nonce</p></li>
<li><p>那么算出来的Nonce需要达到什么条件呢？</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SHA256(SHA256(Blockherder)) &lt; F(nBits)</span></code></pre></td></tr></table></div></figure>


<p>其中，SHA256(SHA256(Blockherder))就是挖矿结果，F(nBits)是难度对应的目标值，两者都是256位，都当成大整数处理，直接对比大小以判断是否符合难度要求。</p>

<p>为了节约区块链存储空间，将256位的目标值通过一定变换无损压缩保存在32位的nBits字段里。具体变换方法为拆分利用nBits的4个字节，第1个字节代表右移的位数，用V1表示，后3个字节记录值，用V3表示，则有：</p>

<p>F(nBits)=V3 * 2<sup>8*(V1-3) </sup></p>

<p>此外难度有最低限制，也就是说 F(nBits) 有个最大值，比特币最低难度取值nBits=0x1d00ffff，对应的最大目标值为：0x00000000FFFF0000000000000000000000000000000000000000000000000000</p>

<p>因此挖矿可以形象的类比抛硬币，好比有256枚硬币，给定编号1,2,3……256，每进行一次Hash运算，就像抛一次硬币，256枚硬币同时抛出，落地后要求编号前n的所有硬币全部正面向上。</p>

<p>这里的详细计算可以参考我们之前的一篇<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">文章</a></p>

<h4>CPU挖矿时代</h4>

<p>在Bitcoin早期，只有少数的几个Geek来尝试运行软件，此时的bitcoin core客户端集合了钱包、全节点、挖矿的所有功能；所以早期的节点挖矿过程非常简单：</p>

<blockquote><p>构造区块，初始化区块头各个字段，计算Hash并验证区块，不合格则nNonce自增，再计算并验证，如此往复。在CPU挖矿时代，nNonce提供的4字节搜索空间完全够用（4字节即4G种可能，单核CPU运算Double SHA256算力一般是2M左右），其实nNonce只遍历完两个字节就返回去重构块</p></blockquote>

<h4>GPU挖矿时代</h4>

<p>很快，大家就发现挖矿这个行为只需要在一个block周期内定时获取区块头就可以，不需要每个矿机都运行一个全节点。于是最初的bitcoin软件支持了getwork 协议。</p>

<p>getwork协议代表了GPU挖矿时代，需求主要源于挖矿程序与节点客户端分离，区块链数据与挖矿部件分离。其核心设计思路是：</p>

<blockquote><p>由节点客户端构造区块，然后将区块头数据交给外部挖矿程序，挖矿程序遍历nNonce进行挖矿，验证合格后交付回给节点客户端，节点客户端验证合格后广播到全网。</p>

<p>如前所述，区块头共80个字节，由于没有区块链数据和待确认交易池，nVersion，hashPrevBlock，nBits和hashMerkleRoot这4个字段共72个字节必须由节点客户端提供。挖矿程序主要是递增遍历nNonce，必要时候可以微调nTime字段。</p>

<p>对于显卡GPU来说，其实不用担心nNonce的4字节搜索空间不足，而且挖矿程序从节点客户端那里拿到一份数据后，不应该埋头工作太久，不然很有可能这个块已经被其他人挖到，继续挖只能做无用功，对于比特币来说，虽然设计为每10分钟一个区块，良好的策略也应该在秒级内重新向节点申请新的挖矿数据。对于显卡来说，运行SHA256D算力一般介于200M~1G，nNonce提供4G搜索空间，也就是说再好的显卡也能支撑4秒左右，调整一次nTime，又可以再挖4秒，这个时间绰绰有余。</p>

<p>节点提供RPC接口getwork，该接口有一个可选参数，如果不带参数，就是申请挖矿数据，如果带一个参数，就是提交挖到的块数据。</p></blockquote>

<p>我们先想一下，如果要挖矿，getwork返回的最小数据是哪些呢？</p>

<p>只需要区块头的前76个字节就可以！ 通过nNonce和nTime，就能直接构造。</p>

<p>但是getwork协议充分考虑各种情况，尽量帮助外部挖矿程序做力所能及的事，提供了一些额外字段。getwork的全部返字段如下：</p>

<ul>
<li>Data字段</li>
</ul>


<p>共128字节（80区块头字节 + 48补全字节），因为SHA256将输入数据切分成固定长度的分片处理，每个切片64字节，输入总长度必须是64字节的整数倍，输入长度一般不符合要求，则根据一定规则在元数据末端补全数据。</p>

<ul>
<li>Target字段</li>
</ul>


<p>即当前区块难度目标值，采用小头字节序，需要翻转才能使用。这其实是根据区块头的nBits计算出来的， getwork送佛送到西，直接帮你算好了。</p>

<ul>
<li>Midstate字段</li>
</ul>


<p>SHA256对输入数据分片处理，矿工拿到data数据后，第一个分片（头64字节）是固定不变的，midstate就是第一个分片的计算结果，节点帮忙计算出来了。 因此，在midstate字段辅助下，外部挖矿程序甚至只需要44字节数据就可以正常挖矿：32字节midstate + 第一个切片余下的12（76-64）字节数据。</p>

<ul>
<li>Hash1字段</li>
</ul>


<p>比特币挖矿每次都需要连续执行两次SHA256，第一次执行结果32字节，需要再补充32字节数据凑足64字节作为第二次执行SHA256的输入。hash1就是补全数据，同理，hash1也是固定不变的。</p>

<blockquote><p>外部挖矿程序挖到合格区块后再次调用getwork接口将修改过的data字段提交给节点客户端。节点客户端要求返回的数据也必须是128字节。</p>

<p>每次有外部无参调用一次getwork时，节点客户端构造一个新区块，在返回数据前，都要把新区块完整保存在内存，并用hashMerkleRoot作为唯一标识符，节点使用一个Map来存放所有构造的区块，当下一个块已经被其他人挖到时，立即清空Map。</p>

<p>getwork收到一个参数后，首先从参数提取hashMerkleRoot，在Map中找出之前保存的区块，接着从参数中提取nNonce和nTime填充到区块的对应字段，就可以验证区块了，如果难度符合要求，说明挖到了一个块，节点将其广播到全网。</p>

<p>getwork协议是最早版本挖矿协议，实现了节点和挖矿分离，经典的GPU挖矿驱动cgminer和sgminer，以及cpuminer都是使用getwork协议进行挖矿。getwork + cgminer一直是非常经典的配合，曾经很多新算法推出时，都快速被移植到cgminer。即便现在，除了BTC和LTC，其他众多竞争币都还在使用getwork协议进行挖矿。矿机出现之后，挖矿速度得到极大提高，当前比特币矿机算力已经达到10T/秒级别。而getwork只给外部挖矿程序提供32字节共4G的搜索空间，如果继续使用getwork协议，矿机需要频繁调用RPC接口，这显然不可行。如今BTC和LTC节点都已经禁用getwork协议，转向更新更高效的getblocktemplate协议。</p></blockquote>

<h4>GETBLOCKTEMPLATE</h4>

<p>getblocktemplate协议诞生于2012年中，此时矿池已经出现。矿池采用getblocktemplate协议与节点客户端交互，采用stratum协议与矿工交互，这是最典型的矿池搭建模式。</p>

<p>与getwork相比，getblocktemplate协议最大的不同点是：getblocktemplate协议让矿工自行构造区块。如此一来，节点和挖矿完全分离。对于getwork来说，区块链是黑暗的，getwork对区块链一无所知，他只知道修改data字段的4个字节。对于getblocktemplate来说，整个区块链是透明的，getblocktemplate掌握区块链上与挖矿有关的所有信息，包括待确认交易池，getblocktemplate可以自己选择包含进区块的交易。</p>

<p>getblocktemplate 在被开发出来后并非一成不变，在随后发行的各个版本客户端都有所升级改动，主要是增添一些字段，不过核心理念和核心字段不变。目前比特币客户端返回数据如下，考虑到篇幅限制，交易字段（transactions）只保留了一笔交易数据，其实根据当前实际情况，待确认交易池实时有上万笔交易，目前区块基本都是塞满的（1M容量限制），加上额外信息，因此每次调用getblocktemplate基本都有1.5M左右返回数据，相对于getwork的几百个字节而言，不可同日而语。</p>

<p>来简单分析一下其中几个核心字段， Version，Previousblockhash，Bits这三个字段分别指区块版本号，前一个区块Hash，难度，矿工可以直接将数值填充区块头对应字段。</p>

<p>Transactions，交易集合，不但给了每一笔交易的16进制数据，同时给了hash，交易费等信息。 Coinbaseaux，如果有想要写入区块链的信息，放在这个字段，类似中本聪的创世块宣言。 Coinbasevalue，挖下一个块的最大收益值，包括发行新币和交易手续费，如果矿工包含Transactions字段的所有交易，可以直接使用该值作为coinbase输出。 Target，区块难度目标值。 Mintime，指下一个区块时间戳最小值，Curtime指当前时间，这两个时间作为矿工调节nTime字段参考。 Height，下一个区块难度，目前协议规定要将这个值写入coinbase的指定位置。</p>

<p>矿工拿到这些数据之后，挖矿步骤如下：</p>

<p>构建coinbase交易，涉及到字段包括Coinbaseaux，Coinbasevalue，Transactions，Height等，当然最重要的是要指定一个收益地址。 构建hashMerkleRoot，将coinbase放在transactions字段包含的交易列表之前，然后对相邻交易两两进行SHA256D运算，最终可以构造交易的Merkle树。由于coinbase有很多字节可供矿工随意发挥，此外交易列表也可随意调换顺序或者增删，因而hashMerkleRoot值空间几乎可以认为是无限的。其实getblocktemplate协议设计的主要目标就是让矿工获得这个巨大的搜索空间。</p>

<p>构建区块头，利用Version，Previousblockhash，Bits以及Curtime分别填充区块头对应字段，nNonce字段可默认置0。</p>

<p>挖矿，矿工可在由nNonce，nTime，hashMerkleRoot提供的搜索空间里设计自己的挖矿策略。 上交数据，当矿工挖到一个块后当立即使用submitblock接口将区块完整数据提交给节点客户端，由节点客户端验证并广播。</p>

<p>需要注意的是，与上文提到的GPU采用getwork挖矿一样，虽然getblocktemplate给矿工提供了巨大搜索空间，但矿工不应对一份请求数据挖矿太久，而应循环适时向节点索要最新区块和最新交易信息，以提高挖矿收益。</p>

<h4>矿池</h4>

<p>在很长一段时期内，大家都是各自为战；但随着全网难度上升，个人挖矿的成功率越来越低，很可能挖数年都不能爆一个块。于是有人提出了大家合作挖矿的办法。矿池挖矿时代来临了。</p>

<p>矿池的核心工作是给矿工分配任务，统计工作量并分发收益。矿池将区块难度分成很多难度更小的任务下发给矿工计算，矿工完成一个任务后将工作量提交给矿池，叫提交一个share。假如全网区块难度要求Hash运算结果的前70个比特位都是0，那么矿池给矿工分配的任务可能只要求前30位是0（根据矿工算力调节），矿工完成指定难度任务后上交share，矿池再检测在满足前30位为0的基础上，看看是否碰巧前70位都是0。</p>

<p>矿池会根据每个矿工的算力情况分配不同难度的任务，矿池是如何判断矿工算力大小以分配合适的任务难度呢？调节思路和比特币区块难度一样，矿池需要借助矿工的share率，矿池希望给每个矿工分配的任务都足够让矿工运算一定时间，比如说1秒，如果矿工在一秒之内完成了几次任务，说明矿池当前给到的难度低了，需要调高，反之。如此下来，经过一段时间调节，矿池能给矿工分配合理难度，并计算出矿工的算力。</p>

<h4>STRATUM</h4>

<p>矿池通过getblocktemplate协议与网络节点交互，以获得区块链的最新信息，通过stratum协议与矿工交互。此外，为了让之前用getwork协议挖矿的软件也可以连接到矿池挖矿，矿池一般也支持getwork协议，通过阶层挖矿代理机制实现（Stratum mining proxy）。须知在矿池刚出现时，显卡挖矿还是主力，getwork用起来非常方便，另外早期的FPGA矿机有些是用getwork实现的，stratum与矿池采用TCP方式通信，数据使用JSON封装格式。</p>

<p>先来说一下getblocktemplate遗留下来的几个问题：</p>

<p>矿工驱动：在getblocktemplate协议里，依然是由矿工主动通过HTTP方式调用RPC接口向节点申请挖矿数据，这就意味着，网络最新区块的变动无法及时告知矿工，造成算力损失。</p>

<p>数据负载：如上所述，如今正常的一次getblocktemplate调用节点都会反馈回1.5M左右的数据，其中主要数据是交易列表，矿工与矿池需频繁交互数据，显然不能每次分配工作都要给矿工附带那么多信息。再者巨大的内存需求将大大影响矿机性能，增加成本。</p>

<p>Stratum协议彻底解决了以上问题。</p>

<p>Stratum协议采用主动分配任务的方式，也就是说，矿池任何时候都可以给矿工指派新任务，对于矿工来说，如果收到矿池指派的新任务，应立即无条件转向新任务；矿工也可以主动跟矿池申请新任务。</p>

<p>现在最核心的问题是如何让矿工获得更大的搜索空间，如果参照getwork协议，仅仅给矿工可以改变nNonce和nTime字段，则交互的数据量很少，但这点搜索空间肯定是不够的。想增加搜索空间，只能在hashMerkleroot下功夫，如果让矿工自己构造coinbase，那么搜索空间的问题将迎刃而解，但代价是必要要把区块包含的所有交易都交给矿工，矿工才能构造交易列表的Merkleroot，这对于矿工来说压力更大，对于矿池带宽要求也更高。</p>

<p>Stratum协议巧妙解决了这个问题，成功实现既可以给矿工增加足够的搜索空间，又只需要交互很少的数据量，这也是Stratum协议最具创新的地方。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg2.png" alt="img" /></p>

<p>再来回顾一下区块头的6个字段80字节，这个很关键，nVersion，nBits，hashPrevBlock这3个字段是固定的，nNonce，nTime这两个字段是矿工现在就可以改变的。增加搜索空间只能从hashMerkleroot下手，这个绕不过去。Stratum协议让矿工自己构造coinbase交易，coinbase的scriptSig字段有很多字节可以让矿工自由填充，而coinbase的改动意味着hashMerkleroot的改变。从coinbase构造hashMerkleroot无需全部交易，如上图所示，假如区块将包含13笔交易，矿池先对这13笔交易进行处理，最后只要把图中的4个黑点（Hash值）交付给矿工，同时将构造coinbase需要的信息交付给矿工，矿工就可以自己构造hashMerkleroot（图中的绿点都是矿工自行计算获得，两两合并Hash时，规定下一个黑点代表的hash值总是放在右边）。按照这种方式，假如区块包含N笔交易，矿池可以浓缩成log2(N)个hash值交付给矿工，这大大降低了矿池和矿工交互的数据量。</p>

<p>在getblocktemplate协议和Stratum协议的配合下，矿池终于进化为完全体，可以接纳近乎无限的矿工和算力，至此比特币全网算力进入了爆炸增长的时代；</p>

<h4>最终，普通交易、conbase交易、nNonce、nTime定义了一个Block Header的 Double SHA256 值是否符合nBits代表的难度值，而这些数据的组合共同造就了一组毫无意义的随机数字;包含这组数字的block一旦产生并广播出去，就极难伪造；正是这组数字，决定了哪个节点有记账的权力，保证了整个账本是唯一且不可篡改的。</h4>

<h2>区块链接成为区块链</h2>

<p>比特币的全节点在本地保存了区块链从创世区块起的完整副本。每个计算周期内矿工们辛勤的工作，会不断产生新的区块，每个区块头都用<code>Merkle Tree Root Hash</code>证明其包含的所有交易的不可篡改性，而区块头中的Nonce又包含着巨大的运算量来保证整个区块的不可篡改性；而区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。</p>

<p>最后，整条链凝结了全网矿工从比特币诞生以来的所有算力总和，这些巨大的算力保证了再伪造同样的一条链是近乎不能完成的任务。</p>

<h4>此时整个账本是唯一且不可篡改的。</h4>

<p>最后所有区块组成了blockchain:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190123/bg1.jpg" alt="img" /></p>

<h2>SPV(简单支付)</h2>

<p>Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。</p>

<p>例如，一个SPV节点想知道它钱包中某个比特币地址即将到达的支付。该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkleblock消息的形式发送该区块。Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联，交易与区块、区块和区块链，就可以证明交易存在于区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千多倍。</p>

<h2>小结</h2>

<p>blockchain作为比特币的基本技术支撑之一，毫无疑问是一项前无古人的真正创新；这项技术怎么高估都不过分，我认为数十年后，可能会作为一种工业革命的基础技术跟蒸汽机、电力应用、信息技术相提并论；</p>

<p>比特币的链为我们提供了两项能力:</p>

<ol>
<li>不可伪造的电子时间戳证明；任何依赖于有序时间的处理程序(博彩、公证、法律等等)都可以上链</li>
<li>提供了一个构造发行自定义资产(证券、股票)的基础手段，货币只是一个基本应用，任何人都可以以比特币主链为基础，构造一条侧链，并在其之上实现自己的资产发行、定价、转移功能</li>
</ol>


<p>在未来的世界里，关于这方面的应用和创新简直层出不穷，例如预言机的实现，微支付通道，原子交换等等；我所读过的最好的关于blockchain的一些设想是这个：</p>

<p><a href="https://medium.com/@creole">https://medium.com/@creole</a></p>

<p>好啦，为了能在未来的世界里面不落人后，我们要继续学习，等我们之后的文章吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一种提高比特币私钥碰撞机率的思路]]></title>
    <link href="https://happy123.me/blog/2019/01/18/%5B%3F%5D-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu/"/>
    <updated>2019-01-18T10:41:40+08:00</updated>
    <id>https://happy123.me/blog/2019/01/18/[?]-chong-ti-gao-bi-te-bi-si-yao-peng-zhuang-ji-lu-de-si-lu</id>
    <content type="html"><![CDATA[<p>之前的文章里面我们提到了一个名为<a href="https://lbc.cryptoguru.org">LBC</a>的项目；它采用了遍历所有比特币私钥，bloomfilter所有未花费的币的地址来碰撞比特币私钥。</p>

<p>这个项目本身详尽<a href="https://lbc.cryptoguru.org/stats">计算了这种碰撞成功的几率</a>，目前碰撞空间大概在 2<sup>136</sup> 级别。</p>

<p>目前在一台最顶级的AWS GPU计算节点上面的碰撞效率是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AWS p2.8xlarge   32 vCores Xeon v4, 8x K80 GPUs (50% each)   ~80-88M/s</span></code></pre></td></tr></table></div></figure>


<p>每秒钟大概碰撞8000w次；目前LBC这个项目最顶峰的时候，算力到了1G的级别，这样计算下来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2^136 / 2^30 = 2 ^106</span></code></pre></td></tr></table></div></figure>


<p>2<sup>106</sup> 级别的碰撞效率还是遥遥无期啊；</p>

<!-- more -->


<p>如果通读我们之前的文章就知道，比特币地址的生成，主要花费在ECDSA、SHA256, RIPEMD 这三个算法的操作之上，但其实用GPU计算，这三个步骤花费的时间是很少的，在整个碰撞过程中，其实大部分时间是耗费在bloomfilter上面的；</p>

<p>而bloomfilter的原理，采用的是多级HASHMAP，常理来看，这已经是判断一个元素是否存在某集合的极限效率了；</p>

<p>但是有一点我们不要忘记，比特币的地址采用base58编码，他的地址空间是有规律的，简单来说，就是所有比特币地址的前缀分布，是有规律可循的，他应该在base58的编码范围内成正态分布；而bloomfilter的HASHMAP是没有这种条件优化的，所以说bloomfilter的算法我们可以再改进一下，提升效率。</p>

<p>我分析了截至2018-12以前的所有比特币地址，简便起见，提取了所有的P2PKH地址(共
377059211个地址)，取其前4个字符地址前缀；执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort 4prefix.addr|uniq -c|sort -nr</span></code></pre></td></tr></table></div></figure>


<p>得到了所有地址前缀的分布列表，差不多是个正态分布。</p>

<p>列举一下最常用的地址前缀TOP10:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  23600 1bit
</span><span class='line'>  23086 1btc
</span><span class='line'>  21895 13vs
</span><span class='line'>  21329 1gbx
</span><span class='line'>  21267 1gbt
</span><span class='line'>  21267 1gba
</span><span class='line'>  21210 1gbb
</span><span class='line'>  21206 1gbf
</span><span class='line'>  21196 1gbu
</span><span class='line'>  21189 1gbr</span></code></pre></td></tr></table></div></figure>


<p>最常见的是1bit和1btc这两个前缀，各比第三名多出了10000个左右，这多出来20000个地址应该是Geek们自己生成的虚荣地址。</p>

<p>所有的比特币P2PKH地址，4字母前缀共有42877种组合。</p>

<p>好了，这就是我们可以优化的地方，把bloomfilter的第一级HASHMAP，采用这些前缀组合先来一把过滤，再去执行常规的Bloomfilter，碰撞效率会再提高一个数量级。</p>

<p>我在自己机器上实验了一下，在GTX750Ti 2G显卡上面，最终效率可以达到 10M/s。</p>

<p>瓶颈现在又变成了genaddress环节，我估计在一块RX480卡上面，可以达到和AWS顶配GPU一样的效率；</p>

<p>不过，效率提升十倍，也不过是 2<sup>100</sup> 的碰撞范围，还是遥遥无期啊。</p>

<h4>更深入的分析</h4>

<p>早期在bitcointalk.org论坛上，Laszlo Hanyecz曾经有过一个想法，就是随着硬件性能的发展，最终碰撞比特币私钥的收益会不会超过挖矿的收益？</p>

<p>中本聪当时的回答是，要达到这个碰撞算力很远很远。</p>

<p>我们来仔细分析一下：</p>

<p>比特币的地址生成是很容易硬件ASIC化的，如果用这种前缀过滤法，也不需要多少内存，所以可以近似认为：如果硬件化，比特币私钥碰撞的效率和挖矿效率是差不多的。</p>

<p>目前比特币全网算力在40EH左右，就是2<sup>62</sup>，这已经是相当于400w台蚂蚁S9的机器同时24X365 运行了；消耗的电力估计已经超过了上海市的居民用电，比特币矿机的能源消耗，完全可以说是抵得上一个小型国家的能源消耗了。</p>

<p>如果私钥碰撞达到2<sup>62</sup>级别，那么毛估估，碰撞几率就能减小到 &frac12;<sup>60</sup> 级别了；</p>

<p>但是这个概率还是太低了。</p>

<p>而且另外一个无法预测的情况就是，将来人们的安全意识加强，一般一个地址只要用过就会丢弃掉，所以最终bloomfilter的条目变化会非常频繁，还要考虑一个数量级的损耗。</p>

<p>目前测算，随着手续费用的提高，即使多次减半，将来挖矿的收益估计很长期稳定1-10btc/block级别，在如果将来以1年时间碰撞一个私钥的概率期望测算的话，一年大概是2<sup>25</sup> 秒，这样碰撞效率至少要提高到 2<sup>95</sup> 级别，才能达到<code>破解私钥得利</code>><code>挖矿得利</code> 的效果；</p>

<p>算力提高到2<sup>95</sup>，不管用什么技术，即使是量子计算，也很难想象能到这个量级啊；</p>

<p>而且，即使到了这一天，把RIPEMD替换成一种碰撞空间更大的算法就OK了。</p>

<p>这样看来，bitcoin的安全性还是无懈可击。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wsl Best Practice]]></title>
    <link href="https://happy123.me/blog/2019/01/16/wsl-best-practice/"/>
    <updated>2019-01-16T14:13:58+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/wsl-best-practice</id>
    <content type="html"><![CDATA[<p>WSL用了一年，感觉还不错。尤其是在我的机器上pypy3.5版本的<code>SHA512 pbkdf</code>计算性能竟然超越了原生Linux和Windows。成为Python运行效率最高的平台，实在是匪夷所思的事情。</p>

<p>WSL最让我满意的，是命令行里面可以结合Windows和Linux的命令行工具来管道处理，这个实在是太赞了。纯粹计算类的程序，Windows上面有很多现成的命令行工具，现在终于能:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ping.exe -t xxx.xxx.xxx.xxx|grep xxxx|echo -I xxx ~~~</span></code></pre></td></tr></table></div></figure>


<p>这样来搞了，事实上，我自己写了很多Python脚本来处理Powershell自带的很多工具输出的内容，还有不少GPU运算程序大多数跑在Windows上面，能直接重定向到Linux上面实在太好了。</p>

<p>另外，WSL网络协议栈和Windows是共享的，倒是直接省了一个事，我直接把http_proxy配置成本地的shadowsock服务就很安逸的翻墙了；方便。</p>

<p>最后，就等着磁盘性能的改善了。</p>

<p>下面记一下常用的坑：</p>

<ul>
<li>如果开机之后插拔一个移动硬盘，需要手工在WSL中执行重新挂载命令：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo umount /mnt/g && sudo mount -t drvfs "G:" /mnt/g</span></code></pre></td></tr></table></div></figure>


<ul>
<li>WSL跟最新2019版本的卡巴斯基冲突，卡巴斯基默认会过滤所有HTTP流量</li>
</ul>


<p>目前无解；要么禁用卡巴斯基的HTTP过滤功能，要么回退2018版本</p>

<p>最后，多个版本实验之后，锁定Win10 1709我也能连续3个月不关机了，稳定性可喜可贺。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alias Rm to Mv]]></title>
    <link href="https://happy123.me/blog/2019/01/16/alias-rm-to-mv/"/>
    <updated>2019-01-16T14:00:18+08:00</updated>
    <id>https://happy123.me/blog/2019/01/16/alias-rm-to-mv</id>
    <content type="html"><![CDATA[<p>之前一直简单的用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rm='mv -f $@ ~/.trash'</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>取代rm命令。</p>

<p>这样用着有个不便的地方，就是有时候做个脚本命令，带个<code>;</code>的时候会解析有问题。今天突然发现一个用函数来替代的好办法，记一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rm='move1(){ /bin/mv -f $@ ~/.trash/; };move1 $@'</span></code></pre></td></tr></table></div></figure>


<p>参考资料：</p>

<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7385133.html">https://www.cnblogs.com/f-ck-need-u/p/7385133.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-7]]></title>
    <link href="https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7/"/>
    <updated>2019-01-06T17:34:55+08:00</updated>
    <id>https://happy123.me/blog/2019/01/06/bi-te-bi-de-jiao-yi-7</id>
    <content type="html"><![CDATA[<p>比特币的交易网络最为人诟病的一点便是交易性能：全网每秒 7 笔左右的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认将导致约 1 个小时的最终确认时间。</p>

<p>为了提升性能，社区提出了闪电网络等创新的设计。</p>

<p>闪电网络的主要思路十分简单——将大量交易放到比特币区块链之外进行，只把关键环节放到链上进行确认。该设计最早于 2015 年 2 月在论文《The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments》中提出。</p>

<p>闪电网络需要单独部署，没有包含在bitcoin core实现里面。闪电网络是一个开放的协议，任何人都能自由的实现它，目前比较流行的版本有:</p>

<p><a href="https://github.com/lightningnetwork/">https://github.com/lightningnetwork/</a></p>

<p><a href="https://github.com/mit-dci/lit">https://github.com/mit-dci/lit</a></p>

<p><a href="https://github.com/ElementsProject/lightning">https://github.com/ElementsProject/lightning</a></p>

<!-- more -->


<p>让我们先自己思考一下，A和B之间频繁有多次交易，最自然，最直接的建立链下交易的办法是什么？</p>

<p>一个假想的场景，就是在没有网络，没有通信的环境中，两个人面对面各自手持私钥签名，证明自己的账户上有多少资金，然后签订一份合同，每次交易记录签名之后不广播，只写在合同上面，等到大批交易做完之后，再统一轧账清算；如果中间有人耍赖，就拿着写满签名交易的合同去法院仲裁。这个过程中间他们唯一的信息渠道就是有人单向传真给他们每笔交易的资金变动；</p>

<p>当然这是一种异想天开，而且依赖于中心化的法院裁决的方式，在现实世界中是行不通的；但是我们可以将这个方案作为起点，代入到电子化的解决方案里面：</p>

<ol>
<li>首先，两个人面对面，一是为了通过验证签名检查账户资金，二是防止第三者窃听；映射到电子方案中，就是通过两个人建立一个加密的通信信道来传递信息</li>
<li>另外，两个人的每一笔交易打印到合同上，就是为了防止某一方作假诈骗，而且两个人面对面互相监督，就防止有一方私自广播对方的交易然后闪人，但是放到网络中，没有法官裁决的威慑，没有相互监督，怎么才能信任对方最终一定会根据所有的历史交易来清算呢？</li>
</ol>


<p>第一个问题的解决方案称之 HTLC（Hashed Timelock Contract），解决了支付通道(资金池)的问题；</p>

<p>第二个问题的解决方案称之为RSMC (Recoverable Sequence Maturity Contract)，解决了链下交易的确认问题。</p>

<h2>RSMC</h2>

<h4>概述</h4>

<p>Recoverable Sequence Maturity Contract，即“可撤销的顺序成熟度合约”。这个词很绕，其实主要原理很简单，类似资金池机制。</p>

<p>再想一下我们之前的问题，为什么A和B每次交易都要记在合同上，最后一把清算呢？既然是双方账户的加加减减，为什么不是每发生一笔新交易，立即对交易后产生资金分配结果共同进行确认，然后作废之前一笔交易呢？</p>

<p>Yes! 这样做之后，在双方的资金池通道中，不管之前双方进行了多少笔交易，永远只存在一笔清算交易，这笔交易就是当前的轧账结果，不管什么时候，直接广播这笔交易，对双方都是公平的。</p>

<p>那么，该如何防止一方做了一笔付款之后，没有广播，就抢先把资金池里面的自有资金提现呢？</p>

<ol>
<li>A和B各拿出1BTC放入了资金池通道中，这时候资金池里面共有2BTC</li>
<li>A和B发生了数笔交易之后，A与B的资金变为1.5:0.5BTC，这个时候通道中留着一笔清算交易没有广播，但是任何一方都可以直接广播把这个状态做实</li>
<li>这个时候A又向B发送了1BTC，但是在B广播清算交易之前，A要把资金全部提走，也就是1.5BTC；这样B就损失了1BTC，怎么预防这种情况呢？</li>
</ol>


<p>解决方法就是提现一定要双方都签名承认才可以：任何一方在任何时候都可以提出提现，提现时需要提供一个双方都签名过的资金分配方案（意味着肯定是某次交易后的结果，被双方确认过，但未必是最新的结果）。在上面的那种情况下，B是无论如何也不会同意的。这就阻止了A的提现。</p>

<p>另外，为了威慑A这种行为，在一定时间内，如果另外一方拿出证明表明这个方案其实之前被作废了（非最新的交易结果），则资金罚没给质疑方；否则按照提出方的结果进行分配。罚没机制可以确保了没人会故意拿一个旧的交易结果来提现。</p>

<p>最后，即使双方都确认了某次提现，首先提出提现一方的资金到账时间要晚于对方，这就鼓励大家尽量都在链外完成交易。通过RSMC，可以实现大量中间交易发生在链外。</p>

<p>那么如果有一方耍小心眼，就是损人不利己，死活不签名来阻止另一方的提现呢？也没关系，在这个模型中，有了惩罚机制，提现的一方可以直接拿最后一笔清算交易的状态来广播(这笔交易是双方都签名承认的)，代价就是晚一点得到资金而已。</p>

<ul>
<li>整个过程里面，最重要的就是惩罚机制的实现，我如何认定跟我交易的对方也遵从这个惩罚机制呢？这是用多重签名来保证的。因为多重签名实际上是个合约，所以这个方案被命名为RSMC。</li>
</ul>


<h4>让我们详细的描述这个过程</h4>

<p>内容引自： <a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<h4>RSMC 创建</h4>

<p>Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入通道中，便于业务往来。解释一下下方RSMC交易的结构，左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg1.jpg" alt="img" /></p>

<ol>
<li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时， Funding    Tx未签名，更不广播。</li>
<li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li>
<li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li>
<li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li>
<li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li>
<li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。上述过程以及结构图的描述，就是创建RSMC的全部过程。</li>
</ol>


<p>C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p>

<p>这个过程的精巧之处，就在于构造了一个被动机制，将自己的资金放入到一个嵌套多重签名的地址里面，任何一方想要提现，一定要先归还另一个人的资金。并且这个机制构造完成之后，我们才真正在支付通道中充值。</p>

<h4>交易更新</h4>

<p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。</p>

<p>于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg2.jpg" alt="img" /></p>

<p>交易更新时的交易结构此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？</p>

<p>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2  的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg3.jpg" alt="img" /></p>

<p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。</p>

<p>若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。</p>

<p>Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。</p>

<p>引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p>

<h4>交易关闭</h4>

<p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p>

<h2>HTLC 中转交易</h2>

<p>RSMC要求交易的双方一定要都缴纳一笔保证金，我每天都跟不同的商家打交道，不能跟每个人都去建立RSMC，存入一笔资金吧。而且通道的建立和关闭都是需要链上广播的，如果要建立多个支付通道，交易费用也不容小觑，这有点本末倒置了吧。</p>

<p>为了解决这个问题，闪电网络又引入了HTLC ( Hashed Timelock Contract )，中文意思是“哈希的带时钟的合约”。这个其实就是限时转账。理解起来也很简单，通过智能合约，双方约定转账方先冻结一笔钱，并提供一个哈希值，如果在一定时间内有人能提出一个字符串，使得它哈希后的值跟已知值匹配（实际上意味着转账方授权了接收方来提现），则这笔钱转给接收方。</p>

<p>推广一步，甲想转账给丙，丙先发给甲一个哈希值。甲可以先跟乙签订一个合同，如果你在一定时间内能告诉我一个暗语，我就给你多少钱。乙于是跑去跟丙签订一个合同，如果你告诉我那个暗语，我就给你多少钱。丙于是告诉乙暗语，拿到乙的钱，乙又从甲拿到钱。最终达到结果是甲转账给丙。这样甲和丙之间似乎构成了一条完整的虚拟的“支付通道”。而乙就做了中转节点。</p>

<p>Alice想要支付0.5BTC给Bob，但她并没有一个渠道来和他进行交易。幸运的是，她和Charlie有一个交易渠道，而Charlie正好和Bob有一个交易渠道。这样Alice就能借助Charlie的交易渠道，通过哈希时间锁定合约（HTLC）来和Bob进行交易了。</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20190106/bg4.png" alt="img" /></p>

<p>为了完成这次交易，Alice就会给Bob发短信说：“嘿！我要给你付笔款。”这时Bob自己将收到一个随机数字（R），接着Bob便会回一个被哈希的数字（H）（你可以认为被哈希的数字R是随机数字的一种加密形式）给Alice。</p>

<p>然后Alice的钱包紧接着就会联系Charlie说：“嘿，Charlie。如果你给我生成（H）的未加密值（R），那么我就同意更新我们渠道的支付分配，这样你就可以得到的就会比0.5BTC多一点，我得的比0.5少一点。”</p>

<p>尽管Charlie并不知道R，但他也会同意。之后Charlie便会去找Bob说：“嘿，Bob。如果你给我那个能生成H的未加密的值R，我将同意更新我们渠道的支付分配，这样你就可以得到的会比0.5BTC多一点，我得到的比0.5少一点。”因为R就是从Bob这里生成的，所以他肯定知道。接着他马上将R告诉Charlie，并更新了其渠道的支付分配。然后Charlie将R告诉给了Alice之后也更新他们的渠道，最后交易完成，Alice以脱链的形式付给Bob0.5BTC。</p>

<h4>扩展</h4>

<p>HTLC给了任意两个点之间，通过路由转发达到支付的目标。这样用户无需打开过多的通道，只需要存入一笔资金跟一个比较大的中介机构建立通道就好了。之后所有的支付行为，我们都期望这个中介机构能自动路由到商家。</p>

<p>在闪电网络的极大繁荣时间，可以看作是现在互联网模型的克隆。</p>

<h2>优缺点大辩论</h2>

<h4>关于支付通道建立</h4>

<ul>
<li><p>乐观： 建立的闪电网络渠道可以与现有钱包和系统内置无缝过程。当收到和支付比特币时，资金需要存到某个地方。资金可以在收到时立即进入闪电网络的通道中，因此建立该通道不需要额外的步骤或成本。</p></li>
<li><p>悲观：为了建立闪电网络渠道，用户必须手动创建一个新的昂贵的链上交易。</p></li>
</ul>


<h4>关于通道关闭</h4>

<ul>
<li><p>乐观:可能不需要关闭渠道，用户可以无限期地或长时间地将钱存放在通道中。</p></li>
<li><p>悲观:一旦支付完成，就需要透过手动创建昂贵的在线交易来关闭通道。</p></li>
</ul>


<h4>关于网络路由</h4>

<ul>
<li><p>乐观:现有的P2P网络已经需要网络拓扑和消息传递，节点通常具有八个连接。闪电网络拓扑结构只是其中的一个延伸。路由不是一个重要的问题，因为即使在大规模网络中，用户之间路径的平均步数也是很小的。即使路由有问题，也可以简单地在链上进行支付，而用户甚至感觉不到两者的差异。少数大型渠道运营商可以防止路由发生任何问题。</p></li>
<li><p>悲观:路由可能是一个较大的问题，因为找到各方之间最短的路径对于演算法来说是个难题。如果找不到清晰的路线，则用户和商户将不得不通过繁琐的过程来手动改变并选择在链上交易的过程。</p></li>
</ul>


<h4>关于支付通道的中心化</h4>

<ul>
<li><p>乐观:有些经济奖励措施是用来对抗这种中心化的，任何人都可以设立节点，因为进入门槛低。除此之外，还可以通过收取较低的费用来削减其他节点对网络的影响力。即使网络集中在几个大型交易枢纽上，闪电网络仍然提供了一个有用而有趣的系统。比特币已经有一些像 Coinbase 这样的大机构来管理大量的资金。在闪电网络下，这些机构没有资金保管权，只是用来传递用于支付的数据。</p></li>
<li><p>悲观:   网络将集中围绕在几个大型交易枢纽，因为这是最有效的模式。这种集中化增加了系统性渠道失效的风险，即少数大渠道出现故障，导致支付渠道同时大量外流，造成连锁拥堵，使部分资金在到期前无法退出渠道。</p></li>
</ul>


<h4>关于流动性</h4>

<ul>
<li><p>乐观:将有机制激励用户运行闪电网络节点，并提供流动性，以收取费用，网络便可以用于小额支付，支付额度可以远小于最大渠道容量，确保有足够的流动性。</p></li>
<li><p>悲观:支付渠道流动性不足，因此其规模将受到限制。任何较具规模的支付几乎可以立即消耗掉整个渠道的流动性，瘫痪闪电网络的支付渠道。</p></li>
</ul>


<h4>关于要求收款人在收款时在线</h4>

<ul>
<li><p>乐观:虽然收件人必须在线才能收到付款，但这与大多数在线支付系统没有显着不同，因为如果收款人不在线上，他们不知道或无法验证收款。直接收款的用户或设备也不需要存储私钥。例如，商店 PoS 终端或加密 ATM 机可以在收款前通过互联网从公司的总部确认签署回收交易，因为无论如何双方在收款时都需要沟通。</p></li>
<li><p>悲观:通过链上交易，发件人需要的是收款地址，而收件人不需要在线。与此相反，收款人在接收付款之前需要签署收回交易。这是一个重大的限制，意味着收件人必须将私钥暴露在热钱包中。这使得闪电网络在下列许多情况下便的不切实际，例如在 ATM 上，在商店 PoS 系统上进行大额支付，或者支付给那些难以连上互联网的收款人。</p></li>
</ul>


<h4>闪电网络较大的安全风险</h4>

<ul>
<li><p>在收款时必须在线的要求：如上所述，在收款之前，收款人需要签署收回交易，以便汇款人知道如果渠道不正常的关闭或拒绝签署的情况发生，他们可以收回资金。因此，收钱需要一个热钱包，这意味着如果发生安全事件，私钥可能被暴露。</p></li>
<li><p>监督渠道的要求：可能需要闪电网络参与者或瞭望塔主动监督网络渠道。这可能给用户或瞭望塔带来负担，并且与存储在区块链上的比特币相比，潜在地降低了渠道内的资金安全性。未能适当监督渠道或由在线网络造成的拥塞可能增加用户错过了回收交易截止日期的风险。</p></li>
<li><p>矿工可以审查渠道关闭交易：作为不属于交易双方的矿工可以通过审查渠道关闭交易，一旦他们具有 51％ 的哈希率便可能有能力从闪电网络用户窃取资金。虽然这种类型的攻击就算在没有应用闪电网络的情况下已经具有破坏性的后果，但闪电网络的应用可能会提供一个更大的攻击面。</p></li>
</ul>


<h2>小结</h2>

<p>RSMC 保障了两个人之间的直接交易可以在链下完成，HTLC保障了任意两个人之间的转账都可以通过一条“支付”通道来完成。闪电网络整合这两种机制，就可以实现任意两个人之间的交易都在链下完成了。</p>

<p>在整个交易中，智能合约起到了中介的重要角色，而区块链网络则确保最终的交易结果被确认。</p>

<p>闪电网络似乎可以在整体网络交易规模上带来重大改进。从而导致交易速度提高和交易费用大幅下降，而整体又不会影响核心基础安全性。然而，至关重要的是，闪电网络自身在安全性上的不足可能使闪电网络不适合用于大额支付（或者至少用其进行大额支付的行为可能是不负责任的）。投机和投资等行为是需要大额支付的，而这些行为目前看来是加密货币领域的主要的交易推动力，相比之下，零售小额支付的数量相对较小。</p>

<p>最后附赠一个技术讲解比较好但是旗帜鲜明反对闪电网络的视频教程：</p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p>当然再为闪电网络声援一下，闪电网络的思想发源于微支付通道，Satoshi实际上早期对微支付通道已经有了基本的设想：</p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p>孰对孰错，是非只能自己判断。</p>

<h2>架设一个闪电网络节点，完成一笔交易</h2>

<p>光说不练假把式，增加一把实战</p>

<h4>运行一个bitcoind全节点</h4>

<p>我们选用bitcoind运行一个testnet模式的全节点，配置文件如下:</p>

<p>bitcoin.conf:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=192.168.2.1/16
</span><span class='line'>rpcport=8332
</span><span class='line'>test.rpcport=18332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>testnet=1
</span><span class='line'>
</span><span class='line'># for lnd
</span><span class='line'>server=1
</span><span class='line'>#daemon=1
</span><span class='line'>zmqpubrawblock=tcp://192.168.2.1:28332
</span><span class='line'>zmqpubrawtx=tcp://192.168.2.1:28333</span></code></pre></td></tr></table></div></figure>


<p>启动bitcoind:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bitcoind --conf=/opt/blockdata/testnet3/bitcoin.conf --datadir=/opt//blockdata/ --deprecatedrpc=signrawtransaction &gt;&gt; test.log 2&gt;&1</span></code></pre></td></tr></table></div></figure>


<h4>建立闪电网络节点</h4>

<p>我们采用lightningnetwork这个Go版本的实现(全程需要翻墙)：</p>

<p><a href="https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md">https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md</a></p>

<ul>
<li>安装go环境</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install golang-1.11-go</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置环境变量</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export GOPATH=~/gocode
</span><span class='line'>export PATH=$PATH:$GOPATH/bin</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Clone &amp;&amp; 编译</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>go get -d github.com/lightningnetwork/lnd
</span><span class='line'>cd $GOPATH/src/github.com/lightningnetwork/lnd
</span><span class='line'>make && make install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>启动lnd</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lnd --bitcoin.active --bitcoin.testnet --debuglevel=debug --bitcoin.node=bitcoind --bitcoind.rpcuser=xxxx --bitcoind.rpcpass=xxxx --bitcoind.zmqpubrawblock=tcp://192.168.2.1:28332 --bitcoind.zmqpubrawtx=tcp://192.168.2.1:28333</span></code></pre></td></tr></table></div></figure>


<h4>建立一个新钱包，充值</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet create</span></code></pre></td></tr></table></div></figure>


<p>之后按照提示一路回车下去，建立一个新钱包，然后执行下列命令得到一个新地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet newaddress np2wkh</span></code></pre></td></tr></table></div></figure>


<ul>
<li>去下面这几个网址列表领取一些免费的TestNet Bitcoin:</li>
</ul>


<p><a href="https://lnroute.com/testnet-faucets/">https://lnroute.com/testnet-faucets/</a></p>

<ul>
<li>执行下面命令看看余额</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet walletbalance</span></code></pre></td></tr></table></div></figure>


<h4>连接通道</h4>

<ul>
<li>首先执行下面命令确认我们的节点的同步状态</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet getinfo</span></code></pre></td></tr></table></div></figure>


<p>确认<code>synced_to_chain</code>字段已经变成true，代表区块头同步完毕。</p>

<ul>
<li>然后去下面的网址找一个可用的闪电节点:</li>
</ul>


<p><a href="https://explorer.acinq.co/">https://explorer.acinq.co/</a></p>

<ul>
<li>我们选一个channel数比较多的然后连接这个节点：cosmicApotheosis</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet connect 03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028@138.229.205.237:9735</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下一步建立通道，这里我们存0.1btc到通道里:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet openchannel --node_key=03a8334aba5660e241468e2f0deb2526bfd50d0e3fe808d882913e39094dc1a028 --local_amt=10000000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查看节点连接状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listpeers</span></code></pre></td></tr></table></div></figure>


<p>这里我们还需要等待3次确认，通道才能建立成功，记住刚才建立完的transaction id，去网上查询等待3次确认。</p>

<ul>
<li>检查通道的状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli --network=testnet listchannels</span></code></pre></td></tr></table></div></figure>


<p>当通道打开的时候，就可以用闪电网络支付啦！</p>

<h4>支付</h4>

<ul>
<li>我们去<a href="https://testnet.satoshis.place/">satoshi.place</a> 随便来几笔涂鸦，得到一个支付地址:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在命令行里支付：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lncli  --network=testnet sendpayment --pay_req  lntb25480n1pwrn3czpp5em4jyjp85rfq5l3489wepp8vu49a2ezly7hc65jmp4crgdymen0sdzy2pshjmt9de6zqen0wgsrydf58qs8q6tcv4k8xgrpwss8xct5daeks6tn9ecxcctrv5hqxqzjccqp2pg8zne6q7f6vsxyd30ja23e49ysmuy8qp3z9wxl400l64x0958qzn90e02dfdglp5e3c3s8me0tdnk33uakp269fl5j7enmzxhnkgncqacr95d</span></code></pre></td></tr></table></div></figure>


<p>顺利的话，瞬间支付成功。</p>

<h4>小结</h4>

<p>看起来是不是很麻烦，相信我，实际做一遍的话坑也不少。</p>

<p>目前有小部分钱包实现了闪电网络支付；但是拍脑袋想想就知道钱包里面无法包含闪电节点的全部功能：因为收款需要时时刻刻的监控，所以不可避免的需要一个类似于<code>瞭望塔</code>式的服务，最合理的办法就是将这个功能的实现剥离出来，单独部署到一台服务器上。</p>

<p>electrum轻钱包在<a href="https://github.com/spesmilo/electrum/issues/2557">这里</a>讨论了典型的实现方式。</p>

<p>可以预见到将来，实现闪电网络的钱包除了要自建全节点之外，还需要建立稳定的闪电网络节点实现类似<code>瞭望塔</code>的功能，当闪电网络极大繁荣的时候，钱包服务商实际上会占据及其有利的地位，闪电网络的发展，需要比特币钱包软件的进化，这是一个非常大的商机。</p>

<h2>参考资料:</h2>

<p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html">https://yeasy.gitbooks.io/blockchain_guide/content/bitcoin/lightning_network.html</a></p>

<p><a href="http://book.8btc.com/blockchain-credit">http://book.8btc.com/blockchain-credit</a></p>

<p><a href="https://www.8btc.com/article/92887">https://www.8btc.com/article/92887</a></p>

<p><a href="https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be">https://www.youtube.com/watch?v=pOZaLbUUZUs&amp;feature=youtu.be</a></p>

<p><a href="https://blog.bitmex.com/zh_cn-the-lightning-network/">https://blog.bitmex.com/zh_cn-the-lightning-network/</a></p>

<p><a href="https://en.bitcoin.it/wiki/Payment_channels">https://en.bitcoin.it/wiki/Payment_channels</a></p>

<p><a href="https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/">https://bitcoinmagazine.com/articles/history-lightning-brainstorm-beta/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy 10th Birthday Bitcoin]]></title>
    <link href="https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin/"/>
    <updated>2019-01-03T21:12:12+08:00</updated>
    <id>https://happy123.me/blog/2019/01/03/happy-10th-birthday-bitcoin</id>
    <content type="html"><![CDATA[<p>自 <a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a>在2009-01-03 诞生以来，bitcoin 已经运行十年了。从一个个人项目，成长为世界话题，一段不可思议的旅程。</p>

<p>有人在&lt;纽约时报>上面为其庆生：</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/">https://www.reddit.com/r/Bitcoin/comments/ac4e64/the_happy_birthday_bitcoin_advertisement_in_the/</a></p>

<p>我在2013年初次读到白皮书的时候申请了一个域名:</p>

<p><a href="http://20090103.com/">http://20090103.com/</a></p>

<p>出于好玩的心态一直维护着，看看下一个十年会是怎样。</p>

<h4>Hi, Happy 10th birthday bitcoin!</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-6]]></title>
    <link href="https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6/"/>
    <updated>2019-01-01T20:10:54+08:00</updated>
    <id>https://happy123.me/blog/2019/01/01/bi-te-bi-de-jiao-yi-6</id>
    <content type="html"><![CDATA[<p>好啦，这篇文章中，我们要来探讨大名鼎鼎的Segwit(Segregated Witness)。</p>

<p>这个词一说起来就头疼啊，他牵扯到旷日持久的扩容大战，无穷尽的争论以及分裂。我们的立场就是不去站队任何组织，单纯从技术的角度去理解这个东西。</p>

<!-- more -->


<p>首先澄清一个误解，其实Segwit跟扩容没关系，它最初提出来，只是为了解决交易延展性的问题，顺便有一点扩容效果，但这个扩容效果只是附带的；</p>

<p>另外，其实Segwit的技术原理非常简单，但是要考虑兼容性的问题，导致从设计到实施都有点复杂。</p>

<h2>缘起</h2>

<p>嗯哼，又要涉及到大量的数学知识；先声明下，我至今还没有从数学原理上完全理解椭圆曲线算法，所以下面讲的都是码农派的API理解&mdash;搞明白接口，但里面的细节还需要更多时间去探究。</p>

<p>上一篇文章我们提到，当交易被签名时，签名并没有覆盖交易中所有的数据 (因为签名是不可能对自身签名的)，而交易中所有的数据又会被用来生成交易的哈希值来作为该交易的唯一标示。</p>

<p>如果签名向常见的HASH算法一样，碰撞机率极小的话也没有问题；但是椭圆曲线算法存在一个看起来比较弱的特性：</p>

<blockquote><p>ECDSA算法生成两个大整数r和s并组合起来作为签名, 可以用来验证交易。而r和BN-s 也同样可以作为签名来验证交易(BN＝0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141). 这样，攻击者拿到一个交易，将其中inputSig 的r, s 提取出来， 使用 r, BN-s 生成新的inputSig, 然后组成新的交易，拥有同样的input和output，但是不同的TXID. 攻击者能在不掌握私钥的情况下几乎无成本地成功地生成了合法的交易。</p></blockquote>

<p>让我们再用码农能理解的语言描述一遍:</p>

<ol>
<li>前面的交易中，scriptSig脚本可以提取出sig签名</li>
<li>sig是由两个值组成的，Sig=(R,S)</li>
<li>sig是嵌入在scriptSig中，用一种名为<code>DER-encoded ASN.1 octet representation</code>的编码方式编码的。OpenSSL并没有强制要求每个签名编码结果只能有一个值。</li>
<li>对于每一个 ECDSA <code>signature(R,S)</code>，还存在相同消息的另外一个有效签名: <code>signature(R,-S(mod N))</code></li>
<li>一个恶意攻击者得到Sig之后，可以手工构造另外一个<code>signature(R,-S(mod N))</code>嵌入到scriptSig中，这和之前的scriptSig不一样，所以TX ID也会发生变化</li>
<li>这笔新的交易输入输出跟原来的交易完全一样，也是合法的，但是TX ID不同了。</li>
</ol>


<h4>危害</h4>

<ol>
<li>Alice通过在线钱包给Bob发送了一笔交易，并把TXID发送给Bob说，看我给你发了多少比特币</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>Bob 通过Alice发来的TXID搜索了以下，并没有发现这笔交易</li>
<li>Bob说，Alice是个骗子</li>
</ol>


<h4>对于交易所的威胁</h4>

<ol>
<li>黑客向交易所发起来一笔资金提现</li>
<li>交易所自动处理，广播了交易，并发送给黑客TX ID</li>
<li>黑客截获了这笔交易，然后构造了一个新的签名广播出去，替换了原来的交易</li>
<li>黑客对交易所说，我没有收到资金，那笔交易不存在</li>
<li>交易所验证了下，因为原来得交易已经被黑客替换掉了，所以原始交易果然不存在了</li>
<li>交易所只能又构造了一笔交易再次广播</li>
<li>黑客最后得到了两笔资金</li>
<li>这种情况下的解决方法是，遇到交易无法确认就停止，报错误并等待手动处理，或者，我们可以自己生成一个延展性交易，然后获取新的TXID,查找是否发送成功。能生成的TXID数量有多少呢？一共有exp(2, input数量)个，因为每个input都有改签名或者不改两种可能， 通常不是一个大数目。</li>
<li>但是这不能阻挡脚本小子的恶意攻击，他们通常会<code>损人不利己</code>的构造大笔延展性交易来攻击网络</li>
</ol>


<h2>讨论</h2>

<p>社区为了解决这个问题进行了大量的讨论：以下是一些材料和社区进行的努力：</p>

<h4>BIP0062</h4>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki</a></p>

<h4>BIP66</h4>

<p>在 363742 区块高度处，BIP66 软分叉强制区块链中所有新交易遵循 DER-encoded ASN.1 标准。仍然需要进一步的努力来关闭 DER 签名其它可能的延展性问题。
签名仍然是可以被拥有相应私钥的人改变的。</p>

<h2>解决</h2>

<p>2015年12月，Bitcoin Core开发团队的<a href="https://github.com/sipa">Pieter Wuille</a>提出了一个解决方案，称之为隔离见证 (Segregated Witness）。隔离见证由以下BIPs定义：</p>

<ol>
<li>BIP-141:隔离见证的主要定义</li>
<li>BIP-143:版本0见证程序的交易签名验证</li>
<li>BIP-144对等服务——新的网络消息和序列化格式</li>
<li>BIP-145隔离见证（对于矿工）的 getblocktemplate 升级</li>
</ol>


<p>最主要的描述在BIP141中:</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</a></p>

<h2>原理</h2>

<p>其实说白了原理非常简单，就是把vin的scriptSig挪到交易的末尾去。</p>

<p>每一个比特币交易，其实可以分为两部份。第一部份是说明结余的进出，第二部份是用来证明这个交易的合法性 (主要是签署)。第一部份可称为「交易状态」，第二部份就是所谓的「见证」(witness)。如果你只关心每个账户的结馀，其实交易状态资料就已经足够。只有部份人(主要是矿工)才有必要取得交易见证。</p>

<p>那么我们再来复习下一笔P2PKH交易的结构:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在整笔交易里面，输入输出信息以及金额大小属于第一部分，scriptSig属于第二部分。</p>

<p>只有矿工以及全节点需要进行scriptSig的验证；如果是普通的SPV轻钱包只需要验证所在区块的合法行就可以了。所以可以把scriptSig 部分挪到交易的尾部。这样带签名的原始数据就固定了，也不会有更改TX ID的机会。这部分数据称之为witness:</p>

<p>每个witness都由一个var_int打头，代表接下来的数据长度。如果某个输入没有见证，那么其witness就是一个0x00。</p>

<p>让我们代入各种例子，来看看Segwit是如何工作的？</p>

<h4>P2WPKH (Pay-to-Witness-Public-Key-Hash)</h4>

<p>首先回顾下P2PKH的锁定脚本(scriptPubKey)与解锁脚本(scriptSig)内容</p>

<ul>
<li>P2PKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    &lt;signature&gt; &lt;pubkey&gt;
</span><span class='line'>  scriptPubKey: OP_DUP OP_HASH160 &lt;20-byte hash of Pubkey&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再来看一下P2WPKH的脚本内容</p>

<ul>
<li>P2WPKH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WPKH的锁定脚本较P2PKH要精简不少，第一位的数字0是版本号，有了版本号，未来脚本升级就能更容易的向前兼容。</p>

<p>P2WPKH的解锁脚本为空，而真正的解锁脚本内容被移到了原交易之外的witness部分。</p>

<h4>P2WSH(Pay-to-Witness-Script-Hash)</h4>

<ul>
<li>P2SH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</span></code></pre></td></tr></table></div></figure>


<ul>
<li>P2WSH</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    (empty)
</span><span class='line'>  scriptPubKey: 0 &lt;32-byte hash of redeem script&gt;
</span><span class='line'>  witness:      0 &lt;SigA&gt; &lt;SigB&gt; &lt;2 PubkeyA PubkeyB PubkeyC PubkeyD PubkeyE 5 CHECKMULTISIG&gt;</span></code></pre></td></tr></table></div></figure>


<p>P2WSH锁定脚本与P2WPKH类似，第一位是版本号，第二位是赎回脚本(Redeem script)的Hash值。</p>

<p>值得注意的是P2WSH锁定脚本中的Hash值是256位(32字节)的，是使用SHA256(pubkey)计算得到；而P2WPKH中的Hash值是160位(20字节)的，是使用RIPEMD160(SHA256(pubkey))计算得到的。</p>

<p>这样做的目的是让钱包可以根据Hash值的长度区分交易使用的是P2WPKH还是P2WSH。</p>

<p>在P2SH交易中常常会有多重签名验证，所以验证信息会占用更多空间，将这些信息移到原交易之外能更大程度的降低交易大小。</p>

<h4>锁定脚本版本号</h4>

<p>仔细观察之后，我们发现scriptSig以及scriptPubKey都以一个<code>0</code>开头；这代表着一个版本号。开发团队对于这个字段还有更远大的愿景，锁定脚本(Locking script)加上版本号，从而使脚本语言的升级更容易向前兼容，这种不造成太大影响的脚本语言修改方式将加快比特币的创新。</p>

<p>这个字段的精巧之处就在于，老节点看到这种交易也是合法的，虽然不能正确parse这种交易，但是当作为交易被打包到一个新区块，然后被支持segwit的矿工挖出来这个块，其它不支持segwit的老节点也是承认这个块的！</p>

<p>为什么呢？复习一下我们之前的文章，在一笔交易结构里面，这种交易是合法的 (是的，真相其实更复杂，但是我懒得详细介绍了，也许之后更闲的时候会仔细说说吧)！</p>

<p>虽然不能正确解析，但格式合法。有的人觉得这种技术忒精巧了，甚至精巧到了一种可怕的程度，是一种杂耍式的开发。很多人对于这种<code>啊哈</code>式的适配吓坏了。</p>

<p>现在Segwit已成事实，是非曲直只能留给你自己去判断了。</p>

<h4>交易标识符</h4>

<p>从上面看，其实实施Segwit之后，数据结构反而变得更清晰简单了。如果中本聪一开始就采用这样的结构，我相信也没有多少人会质疑。</p>

<p>但是已有的老的交易格式及相关系统已经运行了这么长时间，我们希望能尽可能的兼容以前的系统。最麻烦的适配就是原来传统交易的ID只有一个txid。现在见证数据挪到后面了，HASH的时候就不包括这一块数据了，怎么办？</p>

<p>传统交易的txid是以下序列 double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][txins][txouts][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>最后开发者们又引入了另外一个id，称之为wtxid；它是对整个交易double sha256的结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[nVersion][marker][flag][txins][txouts][witness][nLockTime]</span></code></pre></td></tr></table></div></figure>


<p>我们知道，每笔交易的txid是临时计算的，并不入块。但是整个Block是以所有交易的txid以Merkle Tree的形式组织的(这部分知识我们还没讲，需要到后面将bitcoin blockchain的时候提到)；现在多了一个wtxid，该怎么办呢？</p>

<p>解决办法又让人有点无语，就是将wtxid按照同样的组织方法算出Merkle Tree根节点，放到Block块中。</p>

<p>但是原有的Block格式都固定下来了，这个根节点放哪里呢？</p>

<p>还有coinbase的100个字节是可以利用的嘛，就是你了。</p>

<p>这<del>~，在有洁癖的人看来，完全又是一种码农修修补补式的FIX；相信众多技术人员这个时候已经开始内心无数吐槽了；但是真实世界就是这样无奈啊，又想要兼容性，又想要代码干净，又想要性能</del></p>

<p>你是太阳吗！？地球都绕着你转吗？！</p>

<p>拿着吧，这就不少了！！</p>

<p>最后附上这段龌龊的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::vector&lt;unsigned char&gt; GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, 
</span><span class='line'>                                                      const Consensus::Params& consensusParams)
</span><span class='line'>{
</span><span class='line'>    std::vector&lt;unsigned char&gt; commitment;
</span><span class='line'>    int commitpos = GetWitnessCommitmentIndex(block);  //从币基交易的输出中寻找承诺项，没找到就返回-1
</span><span class='line'>    std::vector&lt;unsigned char&gt; ret(32, 0x00);
</span><span class='line'>    if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {
</span><span class='line'>        if (commitpos == -1) {  //没有找到，就开始创建承诺，先生成见证版Merkle树根
</span><span class='line'>            uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);
</span><span class='line'>            CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());
</span><span class='line'>            CTxOut out;  //构建一个币基交易的输出
</span><span class='line'>            out.nValue = 0;  //金额是0
</span><span class='line'>            out.scriptPubKey.resize(38);  //公钥脚本长度38，前6个字节固定为0x6a24aa21a9ed
</span><span class='line'>            out.scriptPubKey[0] = OP_RETURN;  //0x6a
</span><span class='line'>            out.scriptPubKey[1] = 0x24;  //36，即后面的总长度
</span><span class='line'>            out.scriptPubKey[2] = 0xaa;  //0xaa21a9ed，固定不变的承诺头
</span><span class='line'>            out.scriptPubKey[3] = 0x21;
</span><span class='line'>            out.scriptPubKey[4] = 0xa9;
</span><span class='line'>            out.scriptPubKey[5] = 0xed;
</span><span class='line'>            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);  //插入见证版Merkle树根
</span><span class='line'>            commitment = std::vector&lt;unsigned char&gt;(out.scriptPubKey.begin(), out.scriptPubKey.end());
</span><span class='line'>            CMutableTransaction tx(*block.vtx[0]);
</span><span class='line'>            tx.vout.push_back(out);  //币基交易中添加这个输出
</span><span class='line'>            block.vtx[0] = MakeTransactionRef(std::move(tx));  //写回区块
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);  //更新区块其他结构
</span><span class='line'>    return commitment;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>隔离见证新的签名算法</h4>

<p>原来的签名验证需要大量的HASH操作；我们知道比特币是一个分布式系统，同时运行着上万个节点，如果一个操作每个节点都执行一遍，浪费的操作加起来很惊人的。</p>

<p>而隔离验证是个软分叉，为啥不能顺便再搞一点优化呢？毕竟软分叉的机会不多啊。于是开发者们顺便修改了四个签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG和CHECKMULTISIGVERIFY）的语义，改变了交易承诺散列的计算方式。</p>

<p>下面的说明引用自 Master Bitcoin:</p>

<blockquote><p>比特币交易中的签名应用于交易哈希，交易数据计算，锁定数据的特定部分，表明签名者对这些值的承诺。例如，在简单的SIGHASH_ALL类型签名中，承诺哈希包括所有的输入和输出。</p>

<p>不幸的是，计算承诺哈希的方式引入了验证签名的节点可能被迫执行大量哈希计算的可能性。具体而言，散列运算相对于交易中的签名操作的数量增加O（n<sup>2</sup>）。因此，攻击者可以通过大量的签名操作创建一个交易，导致整个比特币网络不得不执行数百或数千个哈希操作来验证交易。</p>

<p>Segwit代表了通过改变承诺散列计算方式来解决这个问题的机会。对于segwit版本0见证程序，使用BIP-143中规定的改进的承诺哈希算法进行签名验证。</p>

<p>新算法实现了两个重要目标。首先，散列操作的数量比签名操作的数量增加了一个更加渐进的O（n），减少了用过于复杂的交易创建拒绝服务攻击的机会。其次，承诺散列现在还包括作为承诺的一部分的每个输入的值（金额）。这意味着签名者可以提交特定的输入值，而不需要“获取”并检查输入引用的前一个交易。在离线设备（如硬件钱包）的情况下，这极大地简化了主机与硬件钱包之间的通信，消除了对以前的交易流进行验证的需要。硬件钱包可以接受不可信主机“输入”的输入值。由于签名是无效的，如果输入值不正确，硬件钱包在签名输入之前不需要验证该值。</p></blockquote>

<p>总之就是一句话，提升了验证签名的性能！！</p>

<h2>实施</h2>

<p>隔离见证（segwit）是一次比特币共识规则和网络协议的升级，其提议和实施将基于BIP-9，是一个软分叉。</p>

<p>2017年8月24日，区块高度481,824，隔离见证正式激活。</p>

<p>2015年提出，2017年激活；想想就知道这中间经历了多少曲折！！</p>

<p>隔离见证最终是全网95%的算力投票赞成才激活的，即使如此，网络中还是有一些不支持隔离见证的老节点在运行，同时，周边的钱包等软件也有不少还不支持隔离见证交易；此时的情况就比较复杂:</p>

<h4>付款人的客户端支持隔离见证，而收款人不支持</h4>

<p>如果收款人不支持隔离见证，那最终发布的地址将会是普通地址（P2PKH或P2SH），那所有交易按照原有的规则进行即可。</p>

<h4>付款人的客户端不支持隔离见证，而收款人支持</h4>

<p>聪明的社区开发者想出了一个过渡方案，即将P2WPKH或P2WSH植入P2SH。</p>

<p>是的！！作为有洁癖的开发者，你又会要吐槽了，这是什么操作！？</p>

<p>P2WPKH植入P2SH后，交易信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  scriptSig:    0 &lt;20-byte hash of Pubkey&gt;
</span><span class='line'>  scriptPubKey: HASH160 &lt;20-byte hash of script&gt; EQUAL
</span><span class='line'>  witness:      &lt;signature&gt; &lt;pubkey&gt;</span></code></pre></td></tr></table></div></figure>


<p>此处的脚本Hash值为RIPEMD160(SHA256(0 &lt;20-byte hash of Pubkey>))的结果，将该脚本Hash转换为P2SH地址，就是一个兼容segwit的地址，不支持隔离见证的客户端可以正常支付比特币给这种P2SH地址。
而对于支持隔离见证的客户端，仍可以将验证信息放在witness结构中，当然这种过渡方案的交易会较完全形态的方案稍大一些，但比无隔离见证的情况要小。</p>

<p>这样就引入了另外一个混乱之处，我们前面的文章提到过，以<code>3</code>开头的地址是P2SH交易专用的，而P2SH交易一般包含的脚本逻辑比较复杂，现在又要判断一种情况，这笔交易是不是一笔隔离见证交易呢？</p>

<p>还有普通小白也很疑惑，比特币网络中开始出现大量以<code>3</code>开头地址的交易，之前这种交易很少，小白们甚至都没有见过这种地址。</p>

<p>为了解决这个问题，开发者们很快又提出了bech32地址格式(去参考我们之前的文章)，小白们很快就被搞得晕头转向。而此时社区正处于分裂状态，Bitcoin Cash作为硬分叉出来的江湖搅局者，虽然加入了重放保护，但是地址和Bitcoin的规则是一样的，但是Bitcoin Cash是不支持Segwit的！</p>

<p>很快，就有大量的小白在Bitcoin Cash里面发送交易给Segwit地址，这种混乱场景不忍卒见。</p>

<p>然后，Bitcoin Cash也搞出了自己的另外一套地址规则；好吧，你应该去找找我们早期的关于比特币钱包的文章，好好温习一下了。</p>

<h4>一些吐槽</h4>

<p>令人惊奇的是，这段混乱时期，在全网交易纷纷堵死，隔离见证升级、Bitcoin Cash分叉的混乱局面中，比特币的价格不合常理的大涨、暴涨，涨到大家怀疑人生。颇有一点狂风暴雨雷霆霹雳之下，大家在泰坦尼克号中末日狂欢的意味。</p>

<p>Bitcoin这个东西，实在不能以常理来琢磨啊。</p>

<h2>优点</h2>

<p>说了这么多，当然Segwit的升级还是又非常多的好处的~~~</p>

<h4>可以用软分叉增加最大区块容量:</h4>

<p>因为旧有节点根本看不到这些被隔离的见证，即使真实的区块已超过1MB，它们仍会以为没有超过限制而会接受区块。</p>

<p>比特币的区块大小限制为1000000bytes，由于witness数据不包含在这个限制中，为了防止witness数据被滥用，仍然对总的区块大小做了限制。引入了一个新概念叫块重量(Block weight):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Block weight = Base size * 3 + Total size
</span><span class='line'>Base size是不包含witness数据的块大小
</span><span class='line'>Total size是包含了witness数据的总大小</span></code></pre></td></tr></table></div></figure>


<p>隔离见证限制Block weight &lt;= 4000000</p>

<p>这就是隔离见证扩容说的来由，这样实际上确实有一定的扩容效果，如果全网交易都迁移到隔离见证上来，大概扩容1.7倍吧。</p>

<p>但是!!! 注意，实际的区块链大小其实比原来更大，这一点一定要搞清楚。</p>

<h4>解决了交易延展性问题</h4>

<p>从此以後，只有发出交易的人才可以改变交易ID，没有任何第三方可以做到。如果是多重签名交易，就只有多名签署人同意才能改变交易ID。这可以保证一连串的未确认交易的有效性，是双向支付通道或闪电网络所必须的功能。有了双向支付通道或闪电网络，二人或多人之间就可以实际上进行无限次交易，而无需把大量零碎交易放在区块链，大为减低区块空间压力。</p>

<h4>轻量钱包可以变得更轻量，因为它们无需再接收见证数据</h4>

<h4>可以大幅改善签署结构</h4>

<p>在区块链上，曾经有一个超过5000个输入的交易，因为签署设计缺憾，需要半分钟才能完成检查。在建议中的SW软分叉会把这个问题解决掉。</p>

<p>而在该次软分叉完成後，核心开发者们已有计划进一步完善整个系统的可用性和安全性:</p>

<ol>
<li><p>全节点可以为轻量钱包提供很简洁的证明，以检查交易是否合法。以後的节点就不再局限於完全验证和完全不验证，而是可以按个人的资源作部份验证，也就是说一台手机也可以参与保障系统安全。这可以大为降低系统对全节点的依赖，即使以後区块容量提升了，我们仍能保持安全。</p></li>
<li><p>将会推出全新的交易脚本语言，例如可以把数以千计的不同脚本通过MAST技术压缩至只有32字节;亦可以把不同签署合并检查，令检查交易的速度再以倍数上升。</p></li>
</ol>


<h4>为闪电网络的实施铺平了道路</h4>

<p>闪电网络应该是继中本聪创造比特币之后最重量级的创新，支持者和反对者为其吵了一个天翻地覆，这个值得我们后面写文章大书特书，还是那句话，后文再见吧。</p>

<h2>副作用</h2>

<h4>复杂性</h4>

<p>是的，如果你看到这里；就会发现我到了大量的<code>吐槽</code>字眼；为了达成共识，隔离见证采用了软分叉升级，为了兼容老系统，不可避免的修修补补；另外虽然说起来是单独的一项技术，同时解决的问题可不少，在洁癖者眼里，这是屌丝码农的瞎折腾，就增加了出Bug的可能性；如果是个硬分叉，所有技术问题能干净利落解决，就没有这么多争吵了。</p>

<p>总之一句话，隔离验证留下的技术债不少，升级之后落子无悔，如果之后发现问题，可没机会回退了。</p>

<p>这次升级也是一次经典的技术、政治、利益交杂的各方博弈，如果将来比特币大成，这段历史值得仔细研究。</p>

<h4>Block Size</h4>

<p>前面已经在优点里面说过了。隔离见证有扩容效果的。但这个效果只是一个副作用，只是当时提出隔离见证的时候社区正就扩容问题吵得不可开交，莫名其妙的这个技术就卷入扩容斗争里面了。</p>

<p>再说一遍：关于隔离见证，网上一个很大的误解就是：认为witness被隔离走了，witness数据不在Block里，所以一个Block能装更多的Transaction。</p>

<p>其实不是，witness数据仍然在Block里面。并且对于1个Transaction来说，如果把witness数据也算上的话，其raw byte size其实是变大了，而不是变小了！！！
既然Transaction还变大了，那为什么1个Block可以装更多的Transaction呢？？</p>

<p>因为隔离见证是软分叉，不是硬分叉。下面就分别来分析一下，为什么对于老版本节点、新版本节点，1个Block都可以装更多的Transaction呢？</p>

<p>对于老版本节点：
Block Limit Size = 1M，但由于你把witness数据移到了所有Transaction的外面，放在了整个Block的尾部。老版本在计算一个Block大小的时候，只计算了
Block Header + 所有Transaction的数据（witness数据，老版本看不见！！！相当于老版本被欺骗了。）</p>

<p>所以呢，其实整个Block的物理大小(raw block size)已经超过了1M，但老版本的节点不认识尾部的witness数据，所以认为总大小还是 &lt; 1M。</p>

<p>对于新版本节点：
Block的size的计算方式做了调整，引入了Block weight的概念。
block weight = base_size * 4 + witness_size
block weight &lt;= 4M</p>

<p>其中，base_size就是block的前2部分数据（header + 没有witness的所有交易数据）</p>

<p>通过上面的分析，我们会发现，数据还是那么多数据，没有减少，只是重新排布了一下，却变相的把区块链扩容了！！！</p>

<h4>安全性</h4>

<p>有人提出来说，中本聪之前把交易信息和见证数据放在一块是有意的；因为一笔交易带有所有者的签名是天经地义的语义；隔离见证把witness独立出来，降低了比特币系统的安全性。另外~~~~</p>

<p>老实说，这个论据仔细读读还是蛮有道理的，但是实在说的太深刻太哲理了，码农对这种东西天生无感，我就不啰嗦了，大家感兴趣可以自己去搜索这方面资料。</p>

<h2>小结</h2>

<p>以上就是对隔离见证这个东东最简单的描述，我尽力做到简洁中立；但是实际上我觉得整个过程写一本书也不为过；</p>

<p>那么，隔离见证实施之后；就是闪电网络的崛起了，我们下篇文章再见。</p>

<h2>参考</h2>

<h4>四份有关隔离见证的比特币改善方案:</h4>

<ul>
<li>隔离见证软分叉</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki">https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki</a></p>

<ul>
<li>隔离见证通信层</li>
</ul>


<p><a href="https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki">https://github.com/CodeShark/bips/blob/segwit_peer_services/bip-codeshark-segwit-peer-services.mediawiki</a></p>

<ul>
<li>隔离见证交易地址</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki">https://github.com/jl2012/bips/blob/segwit-address/bip-segwitaddress.mediawiki</a></p>

<ul>
<li>隔离见证签署检查</li>
</ul>


<p><a href="https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki">https://github.com/jl2012/bips/blob/segwit-checksig/bip-segwit-checksig.mediawiki</a></p>

<h4>系统扩展常见问题解答:</h4>

<p><a href="https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq">https://bitcoin.org/zh_CN/bitcoin-core/capacity-increases-faq</a></p>

<h4>需要30秒检查的交易:</h4>

<p><a href="https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08">https://blockchain.info/tx/bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08</a></p>

<h4>其它资料</h4>

<p><a href="https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md">https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/appdx-segwit.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-5]]></title>
    <link href="https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5/"/>
    <updated>2018-12-28T21:08:25+08:00</updated>
    <id>https://happy123.me/blog/2018/12/28/bi-te-bi-de-jiao-yi-5</id>
    <content type="html"><![CDATA[<p>我们还是拿<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517</a>做例子。</p>

<p>这篇文章需要结合<a href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/">比特币的交易-3</a>这篇文章来理解，我们在这里也直接复用TransA、TransB的说法。</p>

<!-- more -->


<h2>准备工作</h2>

<h4>私钥-公钥</h4>

<p>在<a href="https://happy123.me/blog/2018/11/02/bi-te-bi-de-hdqian-bao-yan-hua-2/">比特币的HD钱包-2</a>中，我们已经算出来私钥的WIF表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5KUN8s42BCTkQVMTy3oFfqeXE8awVskbDi6XbDMpRnFvHJW9fgk</span></code></pre></td></tr></table></div></figure>


<p>以及公钥:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0489077434373547985693783396961781741114890330080946587550950125758215996319671114001858762817543140175961139571810325965930451644331549950109688554928624341</span></code></pre></td></tr></table></div></figure>


<h4>交易body</h4>

<p>这笔交易有1个vin，1个vout；然后再把我们之前的结构分析图拿来，看看具体需要哪些参数传入:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h4>需要手工构造input</h4>

<ol>
<li>指定上一笔vout的txid，是已知参数(outputTransactionHash):<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code></li>
<li>指定上一笔vout的index，是已知参数(sourceIndex):<code>00000000</code></li>
<li>构造scriptSig，即对这个UTXO签名。我们需要用私钥签名，这个是难点，我们后面来计算</li>
</ol>


<h4>需要手工构造output</h4>

<ol>
<li>设置矿工费用，从而计算输出值</li>
<li>构造scriptPubKey</li>
</ol>


<h4>最后组合成为一笔交易</h4>

<ol>
<li>增加version字段：<code>01000000</code></li>
<li>增加inputCount字段: <code>01</code></li>
<li>增加outputCount字段: <code>01</code></li>
<li>增加block lock time字段: <code>00000000</code></li>
</ol>


<h4>然后我们实现一个函数，将这些变量组合，最后得到原始交易值(对应bitcoin-cli的createrawTransaction)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Makes a transaction from the inputs
</span><span class='line'># outputs is a list of [redeemptionSatoshis, outputScript]
</span><span class='line'>def makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs):
</span><span class='line'>    def makeOutput(data):
</span><span class='line'>        redeemptionSatoshis, outputScript = data
</span><span class='line'>        return (struct.pack("&lt;Q", redeemptionSatoshis).encode('hex') +
</span><span class='line'>        '%02x'.format(len(outputScript.decode('hex'))) + outputScript)
</span><span class='line'>    formattedOutputs = ''.join(map(makeOutput, outputs))
</span><span class='line'>    return (
</span><span class='line'>        "01000000" + # 4 bytes version
</span><span class='line'>        "01" + # varint for number of inputs
</span><span class='line'>        outputTransactionHash.decode('hex')[::-1].encode('hex') + # reverse outputTransactionHash
</span><span class='line'>        struct.pack('&lt;L', sourceIndex).encode('hex') +
</span><span class='line'>        '%02x'.format(len(scriptSig.decode('hex'))) + scriptSig +
</span><span class='line'>        "ffffffff" + # sequence
</span><span class='line'>        "%02x".format(len(outputs)) + # number of outputs
</span><span class='line'>        formattedOutputs +
</span><span class='line'>        "00000000" # lockTime
</span><span class='line'>        )</span></code></pre></td></tr></table></div></figure>


<h4>outputs构造</h4>

<p>在构造一笔完整的交易之前，我们需要手工做两件事情：</p>

<ol>
<li>构造一个output输出</li>
<li>对vin中的UTXO签名，构造scriptSig</li>
</ol>


<p>outputs的构造比scriptSig简单一点，我们先来解决这个问题。</p>

<p>outputs是包含多个output的数组。在这个例子中，我们打算只构造一个output。结合我们之前的文章，就是构造一个bitcoin scriptPubKey，设置一把新锁。</p>

<p>这个scriptPubkey是这样子的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;pubkey&gt;  OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>PubKeyHash其实就是收币的地址，其它操作符都是现成的。</p>

<h2>如何构造一笔output</h2>

<p>一笔output的构造是简单的，所有东西都是现成的，而且这笔交易是个P2PK交易，输出非常简化，我们仅仅需要构造<code>&lt;pubkey&gt;  OP_CHECKSIG</code>即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def makeOutput(value,  index, pubkey):
</span><span class='line'>    OP_CHECKSIG =  'ac'
</span><span class='line'>    value = "{:0&lt;16x}".format(int(struct.pack('&lt;I', int(value)).hex(), 16))
</span><span class='line'>    index = "{:02x}".format(int(index))
</span><span class='line'>    pubkey = pubkey
</span><span class='line'>    pubkey_length = "{:02x}".format(len(pubkey)/2)
</span><span class='line'>    return value + index = pubkey_length + pubkey + OP_CHECKSIG
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>&gt; print(makeOutput(7000, 0, '2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac'))
</span><span class='line'>&gt; 581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac
</span><span class='line'>&gt; outputs = ['581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac']
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h2>如何对一笔交易签名(scriptSig)</h2>

<p>在构造一笔交易的过程中，签署交易是一个非常麻烦的过程。其基本思想是使用ECDSA椭圆曲线算法和私钥生成交易的数字签名，但细节比较复杂。</p>

<p>我们可以先通过验证签名的过程来理解以下，验证签名过程的通过10个步骤描述。下面的缩略图说明了详细的流程。</p>

<p><img src="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png" alt="img" /></p>

<p>这张图出自于<a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">这里</a>，里面的TX ID是不同的，但基本步骤一样。</p>

<h4>一些约定:</h4>

<ol>
<li>TransA代表TxPrev，TransB代笔TxNew</li>
</ol>


<h4>步骤:</h4>

<ol>
<li>首先解析TransB涨vin中的scriptSig，得到sigStr以及pubkeyStr</li>
<li>从TransA中拿出对应的vout ，从scriptPub脚本中截取需要的部分(subScript)：即 <code>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</code>；截取规则就是检索最后一个<code>OP_CODESEPARATOR</code>的位置，在这之后的脚本段就是我们要截取的对象</li>
<li>如果subScript中包含了签名，移除掉(在scriptPub中包含签名是很特殊的情况，一般出现在P2SH交易中，普通交易不需要这一步)</li>
<li>如果脚本中有<code>OP_CODESEPARATORS</code>操作符，移除</li>
<li>检测一步解析出来的scriptSig最后一个字节的HashType，扩展为4字节(小端排序)备用</li>
<li>将TransB 复制一份，变为TransBCopy</li>
<li>将TransBCopy中所有的Vin以及Vout 移除，同时将length字段置为0</li>
<li>将第4步中的subScript根据vin sequence填充到TransBCopy对应的位置</li>
<li>最后将交易TransBCopy序列化(采用DER编码)，并在末尾添加第5步中得到的HashType，得到签名的原始数据</li>
<li>最后执行签名验证过程: ECDSA_CheckSignature(pubkeyStr, sigStr, double_sha256(TransBCopy))</li>
</ol>


<h4>疑点解惑</h4>

<h5>为什么这么麻烦，不能直接对TransB签名吗？</h5>

<p>因为最终的签名是包含在TransB当中的，签名是不能对自身来签名的；所以要签名的原始数据不能包含签名本身；</p>

<p>说句题外话，由于ECDSA的签名算法的局限，这个结构组织方式最终导致了一个顽疾，即交易延展性问题，也被翻译为交易可锻性（Transaction Malleability）。</p>

<p>简单来说，就是攻击者可以生成不同但是合法的scriptSig，这样虽然vin，vout金额和地址不变，但是TX ID会发生变化，从而导致用户找不到发送的交易。</p>

<p>这对于交易所是一个威胁，某个居心不良的用户可能充值了一笔资金，然后重新生成scriptSig又广播了一笔交易，然后欺骗交易所，说第一笔交易没收到，交易所检查以下果然如此，于是又发送了一笔资金给用户，这样用户就实现了double withdraw，白赚了一笔。MTGOX早期就是这么被坑的，后来也出现过一些损人不利己的脚本小子们公然利用这个漏洞攻击比特币网络；为了解决这个问题，core开发者提出了segwit解决方案(即隔离见证)，后来随着政治斗争、市场斗争的激化，一个技术问题最终演化成了扩容派的分裂。</p>

<p>总之还是那句话，关于segwit, 闪电网络，期待我们后面的文章吧。</p>

<h5>为什么要用上一笔交易vout来填充这个位置呢？</h5>

<p>我们说验证签名的过程，其实有三个作用:</p>

<ol>
<li>签名证明私钥的所有者，即资金所有者，已经授权支出这些资金</li>
<li>授权证明是不可否认的（不可否认性）</li>
<li>签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改</li>
</ol>


<p>我们提供签名、私钥即承诺了第1点，对TransBCopy 签名承诺了第2点，但是要做到第3点，就需要对于引用UTXO的信息做承诺；</p>

<p>我们会问，单纯的prev TX ID和vout sequence no不能证明我要花费的哪一笔UTXO吗？</p>

<p>是的，这还是不够的，我们需要另外的信息熵的引入，就是这个UTXO的scriptPub。具体为什么，是ECDSA的数学特性决定的。请参考:</p>

<p><a href="https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/">https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/</a></p>

<p>老实说，关于ECDSA的签名验证，我在学习了很长时间以后，还是非常担心，因为签名生成算法使用随机密钥k作为临时私有-公钥对的基础，这个K值的随机性一定要人工保证，比特币的每笔交易验证，离不开签名验证，而这个签名验证如此复杂，确实让人心生忐忑。</p>

<h5>这个OP_CODESEPARATORS是什么东东？</h5>

<p>哈，到目前为止，我们接触到的都是比特币最简单、最基本、当然也是应用最广泛的交易类型，但是比特币还支持P2SH的高级交易，在这种交易中，vout里面可能会嵌入非常复杂的脚本，所以系统引入了OP_CODESEPARATORS作为复杂脚本的分隔符，以后的文章我们会详细讲解；</p>

<p>OP_CODESEPARATOR属于一种看起来<code>过度设计</code>的特性，老实说，我没有在比特币主网上发现像样的使用这个特性的交易，我也需要更多时间的学习才能搞明白这个东西，以下是一些参考资料：</p>

<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0017.mediawiki</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=164655.0">https://bitcointalk.org/index.php?topic=164655.0</a></p>

<h5>这个HashType是什么东东？</h5>

<p>嗯哼，又是一个非常棘手但是有意思的问题。</p>

<p>我们说比特币有了script之后，功能是非常非常丰富的，不仅仅局限于支付场景，他可以应用到许多非常复杂的场景中。</p>

<p>比如现在让我们考虑一个外贸公司的业务，这个公司的对公账户每天都要接受许多客户的付款，处于安全考虑，我作为公司的CEO，希望能跟财务主管共同管理公司的对公账户，当需要支出时，一定要我跟财务主管都签字同意才可以。</p>

<p>这就衍生出了所谓的M-N交易类型，即多重签名交易。</p>

<p>在多重签名交易中，要花费一笔UTXO，可能需要多个签名，或者有这种语义：&#8221;一定要CEO的签名，如果没有CEO的签名，需要COO和CFO的联合签名&#8221;，为了表示这些，引入了SIGHASH这个字段，就是我们所说的HashType啦。</p>

<p>要考虑SIGHASH，实际上已经牵涉到了bitcoin的高级交易类型(P2SH)，还是那句话，关注后面的文章吧。</p>

<h4>反向代码</h4>

<p>嗯哼，把验证签名的步骤反向来一遍，就是签名的过程了。</p>

<p>代码表示如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>def makeSignedTransaction(privateKey, outputTransactionHash, sourceIndex, scriptPubKey, outputs):
</span><span class='line'>    myTxn_forSig = (makeRawTransaction(outputTransactionHash, sourceIndex, scriptPubKey, outputs)
</span><span class='line'>         + "01000000") # hash code
</span><span class='line'>
</span><span class='line'>    s256 = hashlib.sha256(hashlib.sha256(myTxn_forSig.decode('hex')).digest()).digest()
</span><span class='line'>    sk = ecdsa.SigningKey.from_string(privateKey.decode('hex'), curve=ecdsa.SECP256k1)
</span><span class='line'>    sig = sk.sign_digest(s256, sigencode=ecdsa.util.sigencode_der) + '\01' # 01 is hashtype
</span><span class='line'>    pubKey = keyUtils.privateKeyToPublicKey(privateKey)
</span><span class='line'>    scriptSig = utils.varstr(sig).encode('hex') + utils.varstr(pubKey.decode('hex')).encode('hex')
</span><span class='line'>    signed_txn = makeRawTransaction(outputTransactionHash, sourceIndex, scriptSig, outputs)
</span><span class='line'>    verifyTxnSignature(signed_txn)
</span><span class='line'>    return signed_txn</span></code></pre></td></tr></table></div></figure>


<h2>广播交易</h2>

<p>好啦，构造了vin, vout，以及组合成一笔完整的交易，剩下的就是广播出去啦：</p>

<p>比特币的网络协议非常简单，设置好一个Magic Number就可以加入，以下时广播代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>magic = 0xd9b4bef9
</span><span class='line'>
</span><span class='line'>def makeMessage(magic, command, payload):
</span><span class='line'>    checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]
</span><span class='line'>    return struct.pack('L12sL4s', magic, command, len(payload), checksum) + payload
</span><span class='line'>
</span><span class='line'>def getVersionMsg():
</span><span class='line'>    version = 60002
</span><span class='line'>    services = 1
</span><span class='line'>    timestamp = int(time.time())
</span><span class='line'>    addr_me = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    addr_you = utils.netaddr(socket.inet_aton("127.0.0.1"), 8333)
</span><span class='line'>    nonce = random.getrandbits(64)
</span><span class='line'>    sub_version_num = utils.varstr('')
</span><span class='line'>    start_height = 0
</span><span class='line'>    
</span><span class='line'>def getTxMsg(payload):
</span><span class='line'>  return makeMessage(magic, 'tx', payload)
</span><span class='line'>
</span><span class='line'>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</span><span class='line'>HOST_IP ="x.x.x.x"
</span><span class='line'>sock.connect(HOST_IP, 8333)
</span><span class='line'>
</span><span class='line'>sock.send(msgUtils.getVersionMsg())
</span><span class='line'>sock.recv(1000) # receive version
</span><span class='line'>sock.recv(1000) # receive verack
</span><span class='line'>sock.send(msgUtils.getTxMsg("01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000".decode('hex')))</span></code></pre></td></tr></table></div></figure>


<p>HOST IP 怎么获取呢？</p>

<p>如果你有一个全节点，可以直接调用RPC接口的getpeers函数。或者你直接执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nslookup bitseed.xf2.org</span></code></pre></td></tr></table></div></figure>


<p>从公共服务器里面检索nodes，里面随便挑一个IP 吧。</p>

<h2>小结</h2>

<p>以上就是一笔完整交易的构造过程。</p>

<p>这笔交易结构非常简单，只有一个vin，一个vout。</p>

<p>如果有多个vin, 多个vout的情况，就需要每个vin都签署一遍。</p>

<p>我们发现，一笔比特币交易的构造过程，最复杂的，就是签名以及验证的过程。它的步骤极其繁琐，而且椭圆曲线的签名算法极其复杂。如果在更高级的比特币交易中，比如P2SH，或者多重签名交易，或者Segwit交易，包含了更复杂的脚本和执行逻辑，事情很快就变得不可控制起来。</p>

<p>这是我在学习比特币知识时遇到的最大的恐惧，我认为如果将来比特币系统出现什么致命BUG，很大可能就在这里暴雷。</p>

<p>也许早期的开发者也觉得不放心，于是禁用了不少操作符。而目前Bitcoin SV和Bitcoin Cash的发展方向，是将这些操作符一一解放出来。</p>

<p>更强大的功能？还是更稳妥的基础设施？究竟怎样的做法是正确的，我也没有定论，只是告诉大家现在社区的发展方向就好了，大家自己做判断。</p>

<h2>参考资料:</h2>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-4]]></title>
    <link href="https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4/"/>
    <updated>2018-12-24T18:41:36+08:00</updated>
    <id>https://happy123.me/blog/2018/12/24/bi-te-bi-de-jiao-yi-4</id>
    <content type="html"><![CDATA[<p>前面的文章中我们分析了一笔标准的Pay to Public Key HASH(P2PKH)交易。看起来其实结构挺简单的，这篇文章我们乘胜追击，看一下矿工们领取系统奖励时，构造的coinbase交易。</p>

<!-- more -->


<p>Coinbase交易规范的叫法是Generation TX，每一个block有且只有一笔Genration TX，该类交易的币是矿工挖矿凭空产生的，所以没有vin。比特币系统所有的币都产自于这里。</p>

<p>我们就以最常见创世块的交易作为示例来分析吧。</p>

<p><a href="https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a>这个创始块中只有一笔交易，就是中本聪手工构造发给自己的币：</p>

<p><a href="https://www.blockchain.com/btc/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b">4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</a></p>

<h4>区块原始数据</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>00000000   01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000010   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000020   00 00 00 00 3B A3 ED FD  7A 7B 12 B2 7A C7 2C 3E   ....;£íýz{.²zÇ,&gt;
</span><span class='line'>00000030   67 76 8F 61 7F C8 1B C3  88 8A 51 32 3A 9F B8 AA   gv.a.È.ÃˆŠQ2:Ÿ¸ª
</span><span class='line'>00000040   4B 1E 5E 4A 29 AB 5F 49  FF FF 00 1D 1D AC 2B 7C   K.^J)«_Iÿÿ...¬+|
</span><span class='line'>00000050   01 01 00 00 00 01 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000060   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................
</span><span class='line'>00000070   00 00 00 00 00 00 FF FF  FF FF 4D 04 FF FF 00 1D   ......ÿÿÿÿM.ÿÿ..
</span><span class='line'>00000080   01 04 45 54 68 65 20 54  69 6D 65 73 20 30 33 2F   ..EThe Times 03/
</span><span class='line'>00000090   4A 61 6E 2F 32 30 30 39  20 43 68 61 6E 63 65 6C   Jan/2009 Chancel
</span><span class='line'>000000A0   6C 6F 72 20 6F 6E 20 62  72 69 6E 6B 20 6F 66 20   lor on brink of 
</span><span class='line'>000000B0   73 65 63 6F 6E 64 20 62  61 69 6C 6F 75 74 20 66   second bailout f
</span><span class='line'>000000C0   6F 72 20 62 61 6E 6B 73  FF FF FF FF 01 00 F2 05   or banksÿÿÿÿ..ò.
</span><span class='line'>000000D0   2A 01 00 00 00 43 41 04  67 8A FD B0 FE 55 48 27   *....CA.gŠý°þUH'
</span><span class='line'>000000E0   19 67 F1 A6 71 30 B7 10  5C D6 A8 28 E0 39 09 A6   .gñ¦q0·.\Ö¨(à9.¦
</span><span class='line'>000000F0   79 62 E0 EA 1F 61 DE B6  49 F6 BC 3F 4C EF 38 C4   ybàê.aÞ¶Iö¼?Lï8Ä
</span><span class='line'>00000100   F3 55 04 E5 1E C1 12 DE  5C 38 4D F7 BA 0B 8D 57   óU.å.Á.Þ\8M÷º..W
</span><span class='line'>00000110   8A 4C 70 2B 6B F1 1D 5F  AC 00 00 00 00            ŠLp+kñ._¬....</span></code></pre></td></tr></table></div></figure>


<p>然后我们解析拿我们以前文章的方法来解析一下这笔交易(因为这个区块中只包含了唯一一笔交易，我们顺便解析一下区块构造):</p>

<h4>block header 部分</h4>

<ol>
<li>首先是version字段:<code>01000000</code></li>
<li>然后是32字节代表上一个block的hash id(因为这笔交易所属block是第一个block，所以人为设置为0): <code>0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>接着是32字节的merkle root(关于merkle root，我们会在后面的文章中详解): <code>3BA3EDFD7A7B12B27AC72C3E67768F617FC81BC3888A51323A9FB8AA4B1E5E4A</code></li>
<li>4字节的时间戳: <code>29AB5F49</code></li>
<li>接着是目标难度(bits): <code>FFFF001D</code> 代表着挖矿难度，具体含义可参考我们之前的<a href="https://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/">比特币POW难度调节分析</a>。</li>
<li>nonce: <code>1DAC2B7C</code>，同样的挖矿调节参数，我们老是说比特币系统就是在算一个 &ldquo;毫无意义的随机数字&#8221;，没错，这就是毫无意义君。</li>
<li>这个区块包含的总交易数目：<code>01</code></li>
</ol>


<p>最好来个结构明细表格：</p>

<table>
<thead>
<tr>
<th>Field </th>
<th> Size </th>
<th>  Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version </td>
<td>4 bytes </td>
<td> Little-endian</td>
</tr>
<tr>
<td>Previous Block Hash </td>
<td> 32 bytes </td>
<td>    Big-endian</td>
</tr>
<tr>
<td>Merkle Root </td>
<td> 32 bytes  </td>
<td> Big-endian</td>
</tr>
<tr>
<td>Time </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Bits </td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
<tr>
<td>Nonce</td>
<td>  4 bytes </td>
<td>   Little-endian</td>
</tr>
</tbody>
</table>


<h4>交易部分</h4>

<ol>
<li>version: <code>01000000</code></li>
<li>input数目 01</li>
<li>prev output: <code>0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li>prev output index: <code>FFFFFFFF</code></li>
<li>script length: <code>4d</code></li>
<li>coinbase (2-100字节): <code>04FFFF001D0104455468652054696D65732030332F4A616E2F32303039204368616E63656C6C6F72206F6E206272696E6B206F66207365636F6E64206261696C6F757420666F722062616E6B73</code></li>
<li>sequence: FFFFFFFF</li>
<li>outputs数目: 01</li>
<li>btc数目: 00F2052A01000000 &ndash; 50 BTC</li>
<li>pk_script length: 43</li>
<li>pk_script:<code>41 04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F  AC</code>

<ul>
<li>0x41代表着后面65个字节入栈</li>
<li><code>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</code></li>
<li>0xAC代表着OP_CHECKSIG</li>
<li>整个合起来就是输出脚本为: <Pubkey> &lt;OP_CHECKSIG></li>
</ul>
</li>
<li>lock time: 00000000</li>
</ol>


<p>这笔交易跟我们上一篇文章中的TransB构造是一样的，想要花费的话提供签名就OK了。不过这笔交易没有vin，早期vin部分固定的设置为<code>0000000000000000000000000000000000000000000000000000000000000000FFFFFFFF</code>；</p>

<p>之后的字段是coinbase。这个字段是可以随意调整的(2-100字节)，中本聪在这里留存了一句非常有名的话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04678AFDB0FE5548271967F1A67130B7105CD6A828E03909A67962E0EA1F61DEB649F6BC3F4CEF38C4F35504E51EC112DE5C384DF7BA0B8D578A4C702B6BF11D5F</span></code></pre></td></tr></table></div></figure>


<p>ASCII解码为:  The Times 03/Jan/2009 Chancellor on brink of second bailout for banks</p>

<p>这是2009年1月3日泰晤士报当天的头版文章标题，这是一个时间证明，证明比特币于2009-01-03开始运行，也顺便对传统的金融体系小小嘲讽一下。</p>

<h2>挖矿</h2>

<p>Generation TX交易需要Coinbase字段有两个原因:</p>

<ol>
<li>但是4字节的nonce字段随机性是不够的，需要引入更长的extra nonce，所以有了长度可以灵活调节(2-100字节)的coinbase字段</li>
<li>作为一个附言留给矿工来发表意见</li>
</ol>


<p>其实我对于coinbase字段没有啥意见，但是最初的nonce字段只有4个字节，意味着每秒钟只有4G的碰撞空间，很快全网就超出了这个限制，所以Coinbase字段立即就派上用场了。后来slushpool矿池发明了stratum挖矿架构，彻底进入了大算力组团挖矿的时代；这些技术的演化也非常有意思，可以参考这篇文章，讲的非常清晰：</p>

<p><a href="https://www.8btc.com/article/108894">区块链核心技术演进之路 &ndash; 挖矿演进</a></p>

<p>其实我觉得nonce字段最初最好设置为32字节，就没这么多事情了。</p>

<h2>有钱任性的矿工们</h2>

<p>矿工们早期是一批劳苦大众死宅，后来优胜劣汰只剩下了寡头；在挖矿故事里，还是有几个有意思的故事说道说道的：</p>

<ul>
<li>TXID 相同的交易</li>
</ul>


<p>一笔交易的id值是SHA(TX HEX)算出来的，因为每一笔交易的vin, vout不同，很难得到相同的txid值。但是在Generation TX里面，输出的数目和地址很有可能都是一样的。所以需要矿工自己构造一个随机的coinbase内容，防止产生相同的TXID值。</p>

<p>早期一位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<p>后来为了避免这个问题，社区讨论了提出 <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP 34 规范</a>，规定scriptSig字段，必须要把当前的区块高度(Height)放在最前。</p>

<ul>
<li>忘了接收奖励的矿工</li>
</ul>


<p>2017-12-30 20:55:00，有个矿工挖到了一个区块之后，竟然丢弃了12.5BTC的奖励！</p>

<p><a href="https://btc.com/0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126">区块0000000000000000004b27f9ee7ba33d6f048f684aaeb0eea4befd80f1701126</a></p>

<p>我们不知道这位矿工是用的哪个版本的挖矿软件，但是他们挖到一个区块之后，竟然没有构造地址来领取这笔奖励(价值20W USD)。难道他们真刀真枪上阵之前从来不测试一下吗？或者他们就是有钱任性的真土豪，我只能说:</p>

<p>土豪我们做朋友吧~~~</p>

<h2>coinbase</h2>

<p>因为coinbase是矿工们发挥自己灵感的地方，所以最初作为<code>区块永留存</code>的手段之一，大家纷纷刻字留念。</p>

<p>有刻字到此一游的，有山盟海誓秀恩爱的，有炫耀生孩子的，有申诉政治诉求的，有吟诗作对，弘扬中国传统文化的；总之这100个字节表示鸭梨很大。</p>

<h2>OP_RETURN</h2>

<p>coinbase留言是有实力的矿工才有资格搞的；没有足够算力怎么办呢？</p>

<p>早期Geek比较多，大家就纷纷构造不能花费的交易，在vout中用PUSHDATA来填充内容。</p>

<p>运用比特币的区块链技术存储与比特币支付不相关数据的做法是一个有争议的话题。许多开发者认为其有滥用的嫌疑，因而试图予以阻止。另一些开发者则将之视为区块链技术强大功能的有力证明，从而试图给予大力支持。那些反对非支付相关应用的开发者认为这样做将引致“区块链膨胀”，因为所有的区块链节点都将以消耗磁盘存储空间为成本，负担存储此类 数据的任务。</p>

<p>更为严重的是，此类交易仅将比特币地址当作自由组合的20个字节而使用，进而会产生不能用于交易的UTXO。因为比特币地址只是被当作数据使用，并不与私钥相匹配，所以会导致UTXO不能被用于交易，因而是一种伪支付行为。因此，这些交易永远不会被花费，所以永远不会从UTXO集中删除，并导致UTXO数据库的大小永远增加或“膨胀”。</p>

<p>后来人们又发明出来OP_RETURN留言法：</p>

<p>在0.9版的比特币核心客户端上，通过采用Return操作符最终实现了妥协。Return允许开发者在交易输出上增加80字节的非交易数据。然后，与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。Return输出被记录在区块链上，它们会消耗磁盘空间，也会导致区块链规模的增加，但 它们不存储在UTXO集中，因此也不会使得UTXO内存膨胀，更不会以消耗代价高昂的内存为代价使全节点都不堪重负。 RETURN 脚本的样式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  RETURN &lt;data&gt;</span></code></pre></td></tr></table></div></figure>


<p>“data”部分被限制为80字节，且多以哈希方式呈现，如32字节的SHA256算法输出。许多应用都在其前面加上前缀以辅助认定。例如，电子公正服务的证明材料采用8个字节的前缀“DOCPROOF”，在十六进制算法中，相应的ASCII码为 <code>44 4f 43 50 52 4f 4f 46</code>。</p>

<p> RETURN 不涉及可用于支付的解锁脚本的特点， RETURN 不能使用其输出中所锁定的资金，因此它也就没有必要记录在蕴含潜在成本的UTXO集中，所以 RETURN 实际是没有成本的。</p>

<p>RETURN 常为一个金额为0的比特币输出， 因为任何与该输出相对应的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效。如果你碰巧将 RETURN 的输出作为另一笔交易的输入，则该交易是无效的。</p>

<p>一笔标准交易（通过了 isStandard() 函数检验的）只能有一个 RETURN 输出。但是单个RETURN 输出能与任意类型的输出交易进行组合。</p>

<p>PS: 最初提出了RETURN，限制为80字节，但是当功能被释放时，限制被减少到40字节。 2015年2月，在Bitcoin Core的0.10版本中，限制提高到80字节。 节点可以选择不中继或重新启动RETURN，或者只能中继和挖掘包含少于80字节数据的RETURN。</p>

<h4>例子</h4>

<p>这里比特币就见证了一场成功的求婚：</p>

<p><a href="https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e">https://blockchain.info/tx/b17a027a8f7ae0db4ddbaa58927d0f254e97fce63b7e57e8e50957d3dad2e66e</a></p>

<p><a href="https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0">https://blockchain.info/tx/e89e09ac184e1a175ce748775b3e63686cb1e5fe948365236aac3b3aef3fedd0</a></p>

<h2>刻字服务</h2>

<p>后来有人提供了比较简单的刻字服务，只要你付点小费，就可以将想要说的话永久上链；里面的内容更是洋洋洒洒，有字符画，有山盟海誓，有政治诉求，甚至还有病毒签名，可以参考这篇文章：</p>

<p><a href="http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html">http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html</a></p>

<p>有个网站专门parse了所有区块的文本数据供大家瞻仰：</p>

<p><a href="http://bitcoinstrings.com/">http://bitcoinstrings.com/</a></p>

<p>里面记录了许多尘封的历史，篇幅最大的就是扩容大战；完整的将当时社区争论刻进了区块链中，这是人类历史上第一次区块链圆桌访谈录，值得仔细瞻仰。</p>

<h4>花费</h4>

<p>Coinbase交易取得的比特币，必须要等100个区块高度之后才能花费。因为全网广播中，处于最头上的链是时时刻刻都在分叉的，这是一种保护措施。</p>

<p>请参考：</p>

<p><a href="https://github.com/bitcoin/bitcoin/search?q=COINBASE_MATURITY">https://github.com/bitcoin/bitcoin/search?q=COINBASE_MATURITY</a></p>

<p><a href="http://bitcoin.stackexchange.com/questions/40655/coinbase-transactions-100-block-cooldown-period">http://bitcoin.stackexchange.com/questions/40655/coinbase-transactions-100-block-cooldown-period</a></p>

<h2>小结</h2>

<p>好了，到了这里，我们对于比特币的开采交易，普通交易都理解了；</p>

<p>下一步我们将一步步手工代码构造十六进制数据，然后形成一笔完整的交易去广播；完全吃透一笔交易的来龙去脉；</p>

<p>那么，下次再见。</p>

<h2>工具</h2>

<p><a href="https://sites.google.com/site/nathanlexwww/tools/utf8-convert">https://sites.google.com/site/nathanlexwww/tools/utf8-convert</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-3]]></title>
    <link href="https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3/"/>
    <updated>2018-12-09T15:46:05+08:00</updated>
    <id>https://happy123.me/blog/2018/12/09/bi-te-bi-de-jiao-yi-3</id>
    <content type="html"><![CDATA[<h2>scriptSig与scriptPubKey概览</h2>

<p>继续解析我们上篇文章的交易(<code>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</code>)</p>

<p>目前为止，我们还没有解析vin中的scriptSig，以及vout中的scriptPubKey；这两个东东才是交易的核心，他们有什么作用呢？</p>

<!-- more -->


<p>scriptSig是一笔UTXO的开锁脚本，scriptPubKey是输出UTXO的加锁脚本，一笔交易就是打开上家的保险箱，将资金转移到下家的保险箱并重新加锁的过程:</p>

<ul>
<li>上家-TransA: id(b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b) &ndash;> vout scriptPubkey (转移到保险箱A，并给A上锁)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "value": 0.00010000,
</span><span class='line'>          "n": 0,
</span><span class='line'>          "scriptPubKey": {
</span><span class='line'>              "asm": "OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG",
</span><span class='line'>              "hex": "76a914650d0497e014e60d4680fce6997d405de264f04288ac",
</span><span class='line'>              "reqSigs": 1,
</span><span class='line'>              "type": "pubkeyhash",
</span><span class='line'>              "addresses": [
</span><span class='line'>                  "1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE"
</span><span class='line'>              ]
</span><span class='line'>          }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>转移-TransB: id(3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517) &ndash;> vin scriptSig (解锁保险箱A，拿出资金)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>          "vout": 0,
</span><span class='line'>          "scriptSig": {
</span><span class='line'>              "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>              "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>          },
</span><span class='line'>          "sequence": 4294967295
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下家-TransB: id(3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517) &ndash;>vout scriptPubkey (转移到保险箱B，并给B上锁)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     {
</span><span class='line'>          "value": 0.00007000,
</span><span class='line'>          "n": 0,
</span><span class='line'>          "scriptPubKey": {
</span><span class='line'>              "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>              "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>              "reqSigs": 1,
</span><span class='line'>              "type": "pubkey",
</span><span class='line'>              "addresses": [
</span><span class='line'>                  "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>              ]
</span><span class='line'>          }
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<p>具体怎么理解这两个东东呢？我们还需要一点前置知识。</p>

<h2>比特币脚本语言系统 scripting language</h2>

<p>scriptPubkey以及scriptSig是一种脚本语言。比特币的脚本语言被设计为一种类 Forth 栈语言。拥有成无状态和非图灵完备的性质。无状态性保证了一旦一个交易被区块打包，这个交易就是可用的。图灵非完备性（具体来说，缺少循环和goto 语句）使得比特币的脚本语言更加不灵活和更可预测，从而大大简化了安全模型。</p>

<p>如果大家之前做过汇编开发的话，就会发现这跟汇编的指令码是非常相似的东东。</p>

<p>先来一个在线解析工具:</p>

<p><a href="https://bitcoin-script-debugger.visvirial.com/">https://bitcoin-script-debugger.visvirial.com/</a></p>

<p>再来一个视频讲解：</p>

<p><a href="https://www.youtube.com/watch?v=4qz7XehSBCc">https://www.youtube.com/watch?v=4qz7XehSBCc</a></p>

<p>比较简单的教程:</p>

<p><a href="https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-one/">https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-one/</a></p>

<ul>
<li>额，我知道大部分人跟我一样懒得去翻阅上面这些资料，所以我们简单传送一下：</li>
</ul>


<h3>一个最小脚本集</h3>

<p>现在想象我们有一台非常简单的计算器，它的CPU只有一个16位的寄存器，以及非常小的内存(520B)；我们需要设计一种语言，实现一些最简单的计算，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = 0x23
</span><span class='line'>x += 0x4b
</span><span class='line'>x *= 0x1e</span></code></pre></td></tr></table></div></figure>


<p>然后转换为类似汇编语言的比较简单的操作码形式, 我们需要以下指令集：</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> 操作码</th>
<th> 操作数(V值) </th>
<th> explained</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET(V) </td>
<td> <code>ab</code> V </td>
<td> <code>0xab</code> </td>
<td> 16bits(0x23) </td>
<td> 将V(0x23)载入到寄存器中</td>
</tr>
<tr>
<td>ADD(V) </td>
<td> <code>ac</code> V </td>
<td> <code>0xac</code> </td>
<td> 16bits(0x4b) </td>
<td> 寄存器值+0x4b; <code>0x23 + 0x4b = 0x6e</code></td>
</tr>
<tr>
<td>MUL(V) </td>
<td> <code>ad</code> V </td>
<td> <code>0xad</code> </td>
<td> 16bits(0x1e) </td>
<td> 寄存器值*0x1e; <code>0x6e * 0x1e = 0x0ce4</code></td>
</tr>
</tbody>
</table>


<p>在上面这个表格中，我们定义了三种最简单的操作码：<code>0xab, 0xac, 0xad</code>，跟在这三个操作码后面的2个字节就是操作数；将上面的计算步骤用代码表示如下(小端排序):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ab 23 00 ac 4b 00 ad 1e 00</span></code></pre></td></tr></table></div></figure>


<p>我们可以实现一个最简单的脚本逻辑，顺序parse这段代码，并转换为相应的操作码，然后进行运算；</p>

<p>我们实现了一个非常迷你的脚本集。</p>

<h3>栈设计</h3>

<p>上面的操作只涉及到了寄存器，但是现实情况中，我们通常要做多个计算步骤，并将临时变量存到内存中，另外会把复杂的程序组织为一个个函数；这种时候，最常见的内存组织方法是什么呢？</p>

<p>没错，就是我们最常用的数据结构：栈(STACK)。</p>

<p>比如下面这个函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int foo() {
</span><span class='line'>
</span><span class='line'>    /* 1 */
</span><span class='line'>
</span><span class='line'>    /* 2 */
</span><span class='line'>    uint8_t a = 0x12;
</span><span class='line'>    uint16_t b = 0xa4;
</span><span class='line'>    uint32_t c = 0x2a5e7;
</span><span class='line'>
</span><span class='line'>    /* 3 */
</span><span class='line'>    uint32_t d = a + b + c;
</span><span class='line'>
</span><span class='line'>    return d;
</span><span class='line'>
</span><span class='line'>    /* 4 */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>第一步函数刚刚跳转执行，栈初始化为空。[]</li>
<li>第二步，三个变量<code>a,b,c</code>压入栈中(PUSH STACK)</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12]
</span><span class='line'>[12, a4 00]
</span><span class='line'>[12, a4 00, e7 a5 02 00]</span></code></pre></td></tr></table></div></figure>


<ol>
<li>结合我们上面的操作码，计算<code>a,b,c</code>的和，并将结果压栈</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12, a4 00, e7 a5 02 00, 9d a6 02 00]</span></code></pre></td></tr></table></div></figure>


<ol>
<li>返回结果，并将栈元素弹出(POP STACK)，恢复到初始状态。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[12, a4 00, e7 a5 02 00]
</span><span class='line'>[12, a4 00]
</span><span class='line'>[12]
</span><span class='line'>[]</span></code></pre></td></tr></table></div></figure>


<h3>Script Language</h3>

<p>机器码设计了指令的表示方法，栈设计规定了数据的存储方法；将机器码与栈设计结合起来，就是Bitcoin Script Language。它有几个明显的特点：</p>

<ul>
<li>脚本没有循环:这意味着脚本不能无限运行</li>
<li>栈空间只有520字节</li>
<li>整形常量4字节</li>
<li>脚本的内存访问是基于栈的:这意味着脚本中不存在命名变量这种东西，所有的操作码和操作数都表示为栈上的运算；通常，推入的栈项将成为后续操作码的操作数。在脚本的末尾，最上面的堆栈项是返回值。</li>
</ul>


<p>举个最简单的例子，bitcoin script language支持下面两个操作码：</p>

<h4>压栈操作码</h4>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> explained</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_0 </td>
<td> 0x00 </td>
<td> 将0x00压入栈中</td>
</tr>
<tr>
<td>OP_1 &mdash; OP_16 </td>
<td> 0x51 &mdash; 0x60 </td>
<td> 将0x01 &mdash; 0x10 压入栈中</td>
</tr>
</tbody>
</table>


<blockquote><p>PS: OP_0, OP_1还代表着布尔值False,True</p></blockquote>

<p>然后下面一段示例脚本代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>54 57 00 60</span></code></pre></td></tr></table></div></figure>


<p>或者直接翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_4 OP_7 OP_0 OP_16</span></code></pre></td></tr></table></div></figure>


<p>作用就是将四个值依次压栈，栈状态可以表示为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]
</span><span class='line'>[04]
</span><span class='line'>[04, 07]
</span><span class='line'>[04, 07, 00]
</span><span class='line'>[04, 07, 00, 10]</span></code></pre></td></tr></table></div></figure>


<p>此时栈顶元素值为0x10，前面我们说了，栈顶元素即返回值，所以这个脚本的返回值为0x10。当然，这个脚本现在就是将四个值压栈，并没有什么实际作用。</p>

<h4>PUSH DATA操作码</h4>

<p>简单的压栈操作码只能压入1个字节的数据，如果我们想以此压入多个字节的数据，需要用到 <code>PUSH DATA</code>操作码。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> L (length) </th>
<th> D (data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_PUSHDATA1 </td>
<td> <code>0x4c</code> L D </td>
<td> 8bits </td>
<td> L bytes</td>
</tr>
<tr>
<td>OP_PUSHDATA2 </td>
<td> <code>0x4d</code> L D </td>
<td> 16bits</td>
<td> L bytes</td>
</tr>
<tr>
<td>OP_PUSHDATA3 </td>
<td> <code>0x4e</code> L D </td>
<td> 32bits</td>
<td> L bytes</td>
</tr>
</tbody>
</table>


<ul>
<li>L 代表需要压入的字节长度，它可以有8bits, 16bits，或者32bits，这三个操作码可以最大压入2<sup>8</sup> &ndash; 1 = 255字节、2<sup>16</sup> &ndash; 1 = 65535字节、2<sup>32</sup>字节</li>
<li>D 代表实际的数据</li>
</ul>


<p>举个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4c 14 11 06 03 55 04 8a
</span><span class='line'>0c 70 3e 63 2e 31 26 30
</span><span class='line'>24 06 6c 95 20 30</span></code></pre></td></tr></table></div></figure>


<p>前面的<code>0x4c</code>代表是<code>OP_PUSHDATA1</code>操作符，后面的<code>0x14</code>代表压入20个字节，然后后面跟着20字节的数据</p>

<p>此时栈状态可以表示为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[11 06 03 55 04 8a 0c 70
</span><span class='line'> 3e 63 2e 31 26 30 24 06
</span><span class='line'> 6c 95 20 30]</span></code></pre></td></tr></table></div></figure>


<p>另外，为了节省空间，还有一个非常取巧的设计:
对于非常短的数据有一种特殊的编码。如果一个操作码位于01到4b之间(包括在内)，它就是一个push数据操作，其中操作码本身就是字节长度:</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding </th>
<th> L (length) </th>
<th> D (data)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L </td>
<td> L D </td>
<td> 8bits (0x01-0x4b) </td>
<td> L bytes</td>
</tr>
</tbody>
</table>


<p>比如下面的例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>07 8f 49 b2 e2 ec 7c 44</span></code></pre></td></tr></table></div></figure>


<p>最前面的<code>07</code>代表着直接将后面7个字节压栈</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[8f 49 b2 e2 ec 7c 44]</span></code></pre></td></tr></table></div></figure>


<h4>算术操作码</h4>

<p>算术操作码都是基于栈元素操作的，所以他没有显式的传入参数。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_ADD </td>
<td> 0x93</td>
</tr>
<tr>
<td>OP_SUB </td>
<td> 0x94</td>
</tr>
</tbody>
</table>


<p>这两个操作符都需要从栈顶一次弹出两个元素作为操作数。</p>

<p>例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>55 59 93 56 94</span></code></pre></td></tr></table></div></figure>


<p>或者直接翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_5 OP_9 OP_ADD OP_6 OP_SUB</span></code></pre></td></tr></table></div></figure>


<p>每一步操作的栈状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]              # 初始化
</span><span class='line'>[5]             # OP_5
</span><span class='line'>[5, 9]          # OP_9
</span><span class='line'>[14]            # POP; POP; OP_ADD(5, 9)
</span><span class='line'>[14, 6]         # OP_6
</span><span class='line'>[8]             # POP; POP; OP_SUB(14, 6)</span></code></pre></td></tr></table></div></figure>


<p>最后的结果是8</p>

<h4>比较操作码</h4>

<p>比较用于判断语句，作用比较简单。同样的，它需要从栈顶弹出两个元素来比较。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_EQUAL </td>
<td> 0x87</td>
</tr>
<tr>
<td>OP_EQUALVERIFY </td>
<td> 0x88</td>
</tr>
</tbody>
</table>


<p>OP_EQUALVERIFY跟OP_EQUAL作用相同，但是比较之后还要执行一个 OP_VERIFY操作。OP_VERIFY检查栈顶元素，如果栈顶元素不为真，就出栈并标记交易无效。</p>

<p>跟之前的算术操作码结合起来的一个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>02 c3 72 02 03 72 01 c0 93 87</span></code></pre></td></tr></table></div></figure>


<p>翻译为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[c3 72] [03 72] [c0] OP_ADD OP_EQUAL</span></code></pre></td></tr></table></div></figure>


<p>执行起来是这样子的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                      # 栈初始化
</span><span class='line'>[c3 72]                 # `02 c3 72`代表c3 72两个字节直接入栈
</span><span class='line'>[c3 72, 03 72]          # `02 03 72`代表03 72两个字节直接入栈
</span><span class='line'>[c3 72, 03 72, c0]      # `01 c0`代表c0直接入栈
</span><span class='line'>[c3 72, c3 72]          # 栈顶弹出c000, 0372, 相加得 c3 72
</span><span class='line'>[1]                     # 栈顶弹出c372，c372，比较为真</span></code></pre></td></tr></table></div></figure>


<p>最后这个表达式结果为1。</p>

<h4>栈操作码</h4>

<p>这个操作码比较特殊，它得作用是直接将栈顶元素复制一份，然后入栈。</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_DUP </td>
<td> 0x76</td>
</tr>
</tbody>
</table>


<p>例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04 b9 0c a2 fe 76 87</span></code></pre></td></tr></table></div></figure>


<p>翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[b9 0c a2 fe] OP_DUP OP_EQUAL</span></code></pre></td></tr></table></div></figure>


<p>执行起来是这样子的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                          # 栈初始化
</span><span class='line'>[b9 0c a2 fe]               # 04代表后面4个字节压栈
</span><span class='line'>[b9 0c a2 fe, b9 0c a2 fe]  # 复制栈顶4字节然后压栈
</span><span class='line'>[1]                         # 弹出栈顶8字节，比较结果为真</span></code></pre></td></tr></table></div></figure>


<p>可以看出来，如果OP_DUP后面跟着OP_EQUAL，执行结果永远为真。</p>

<h4>加解密操作码</h4>

<p>这几个操作码是比特币交易验证得核心操作码，也是做事情最多的：</p>

<table>
<thead>
<tr>
<th>opcode </th>
<th> encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_HASH160 </td>
<td> 0xa9</td>
</tr>
<tr>
<td>OP_CHECKSIG </td>
<td> 0xac</td>
</tr>
</tbody>
</table>


<p>OP_HASH160 弹出顶部堆栈项，在其上执行sha256=>hash160，然后返回结果。</p>

<p>OP_CHECKSIG 弹出前两个堆栈项，第一个是ECDSA公钥，第二个是der编码的ECDSA签名。之后，如果签名对该公钥有效，则推送OP_TRUE，否则推送OP_FALSE。它是OpenSSL的ECDSA_verify的脚本实现。</p>

<h5>有了以上的知识，我们就能深入解析比特币交易加锁解锁的细节啦</h5>

<h2>深入解析scriptPubkey与scriptSig</h2>

<h4>首先然我们来解析一下TransA的 scritPubkey 加锁脚本</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>76a914650d0497e014e60d4680fce6997d405de264f04288ac</span></code></pre></td></tr></table></div></figure>


<p>翻译为</p>

<ol>
<li>0x76代表OP_DUP</li>
<li>0xa9代笔OP_HASH160</li>
<li>0x14代表后面20个字节<code>650d0497e014e60d4680fce6997d405de264f042</code>直接入栈，这20个字节其实是转账地址的pubKeyHash</li>
<li>0x88代表OP</li>
<li>0xac代表OP_EQUALVERIFY</li>
</ol>


<p>最后翻译为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 650d0497e014e60d4680fce6997d405de264f042 OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>再简化一下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>这段脚本代表 TransA的发起者把一笔钱转入到保险箱后，用这个脚本设置了一把锁，谁能提供另外一个脚本，跟此脚本合并运算后，栈元素全部出栈，并且最后出栈元素为真，那么就视为解锁成功，可以花费这笔钱。</p>

<p>仔细看看，解开这把锁需要我们提供什么信息呢？</p>

<ol>
<li>首先我们要提供一个公钥，确保这个公钥执行 OP_HASH160操作后，与PubKeyHASH相匹配，其意义就是证明你拥有这个转账地址的公钥</li>
<li>光证明拥有公钥不安全，毕竟如果这个地址之前花费过，公钥就明晃晃暴漏了；所以你还要提供一个对这个脚本的签名，并通过OP_CHECKSIG验证，证明你还拥有和公钥相对的私钥；而私钥只有拥有人才知道，它是永远不会暴露的</li>
<li><p>同时进行公钥、私钥的验证保证了比特币的安全性，毕竟，即使量子计算机成真，它也需要同时攻破三重保险：</p>

<ul>
<li>逆向sha256</li>
<li>逆向ripemd160</li>
<li>逆向ECDSA</li>
</ul>
</li>
</ol>


<p>如果能做到这个，那么，全世界的银行、金融、所有的信息系统都不安全了。如果真的到了那个时候，比特币的安全就不值一提了。</p>

<h4>那么我们提供的解锁脚本TransB的scriptSig 同样解析一遍看一下</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<p>解析为:</p>

<p>1.0x47代表后面71个字节入栈，这其实就是签名<code>Sig</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac001</span></code></pre></td></tr></table></div></figure>


<p>2.0x41后面代表65个字节入栈，这是<code>Pubkey</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<p>最终简化为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Sig&gt; &lt;PubKey&gt;</span></code></pre></td></tr></table></div></figure>


<p>这就是我们开锁的钥匙！</p>

<h4>合并运算</h4>

<p>我们把两个脚本来合并运算(把钥匙插进锁孔里)</p>

<ul>
<li>scriptPubKey (锁):</li>
</ul>


<p><code>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code></p>

<ul>
<li>scriptSig (钥匙):</li>
</ul>


<p><code>&lt;Sig&gt; &lt;PubKey&gt;</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[]                                                              # 初始化
</span><span class='line'>[Sig]                                                           # 将scriptSig中的sig信息入栈
</span><span class='line'>[Sig, PubKey]                                                   # 将scriptSig中的Pubkey入栈
</span><span class='line'>[Sig, PubKey, OP_DUP]                                           # 将scriptPubKey中的 OP_DUP入栈
</span><span class='line'>[Sig, Pubkey, Pubkey]                                           # 执行OP_DUP，复制栈顶元素PubKey
</span><span class='line'>[Sig, Pubkey, Pubkey, OP_HASH160]                               # 将scriptPubKey中的 OP_HASH160入栈
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey)]                                  # 执行OP_HASH160
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey), PubkeyHash]                      # 将scriptPubKey中的 PubKeyHash入栈
</span><span class='line'>[Sig, Pubkey, hash160(Pubkey), PubkeyHash, OP_EQUALVERIFY]      # 将scriptPubKey中的 OP_QUEALVERIFY入栈
</span><span class='line'>[Sig, Pubkey]                                                   # 检查公钥是否有效，如果有效，出栈
</span><span class='line'>[Sig, Pubkey, OP_CHECKSIG]                                      # 将scriptPubKey中的 OP_CHECKSIG入栈
</span><span class='line'>[1]                                                             # 执行OP_CHECKSIG，用Pubkey检查Sig的有效性；检查通过
</span><span class='line'>[]                                                              # Gooooooooood!! 钥匙合法，开锁成功</span></code></pre></td></tr></table></div></figure>


<p>最后合并运算的结果返回为True。解锁成功。</p>

<p>然后我们用一张语法树解析图再现整个过程：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181209/bg1.png" alt="img" /></p>

<h5>这就是一笔标准的P2PKH(Pay to Public Key Hash)交易的全解析。</h5>

<h4>Pay to PubKey</h4>

<p>既然已经开锁，我们就可以像TransA的scriptPubKey一样，再构造TransB的scriptPubkey，将资金转到新的保险箱中，并重新加锁。</p>

<p>TransB的scriptPubkey 构造为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG</span></code></pre></td></tr></table></div></figure>


<p>?? 这怎么跟我们上一笔TransA的scriptPubkey长的不一样？</p>

<p>没错，这笔交易的输出小任性了一把，我们说标准的输出是要求提供一个公钥来验证 Public Key hash值的，但是这笔交易的转移者非常有自信，他说，你直接提供私钥签名就可以花费了，不用那么麻烦了。</p>

<p>这种交易称之为Pay to Pubkey，安全性肯定不如Pay to Public Key Hash交易的；但是因为比较方便，早期有一些交易采用了这种形式，但是现在已经越来越少了；</p>

<p>要解开这把锁，只需要提供签名就好了，更简单。</p>

<p>总结一下这种交易的scriptPubkey加锁脚本以及scriptSig解锁脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scriptPubkey: &lt;pubkey&gt; OP_CHECKSIG
</span><span class='line'>scriptSig: &lt;sig&gt;</span></code></pre></td></tr></table></div></figure>


<p>如果你感兴趣的话，自己去找找这笔交易对应的scriptSig吧。</p>

<h2>一些神奇的操作符</h2>

<h4>OP_CHECKLOCKTIMEVERIFY</h4>

<p>也有人把这个操作符称之为OP_CLTV，或者昵称为OP_HODL；什么意思呢？就是这个操作符允许你发送一笔钱给一个地址，并且用OP_HODL指定一个时间，只有过了这个时间之后，才能花费这笔资金！</p>

<p>这个操作符在<a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65</a>中定义，2015-11-30在Bitcoin Core 0.11.2版本中激活。</p>

<p>之前我们介绍过交易中有个locktime字段，功能是类似的；区别在于，locktime交易在指定到达交易时间之前，是不入区块链的，所以如果设置了RBF的话，可以随时取消；</p>

<p>但是OP_HODL是入块的，真正落子无悔!</p>

<p>这个操作符最大的作用，让我来看就是让真正的比特币死忠实现<code>屯币不动</code>。死忠们经常说一币一别墅，一币$250K，但是稍微有个风吹草动就卖掉了；如果你对比特币的信心无可匹敌的话，就用<code>OP_HODL</code>操作符将自己的币锁定10年吧。</p>

<p>持币10年之后再看比特币兴衰，才是真死忠。</p>

<h2>小结</h2>

<p>这篇文章中我们从最基本的栈脚本操作码讲起，然后一步一步说明了比特币的脚本系统是如何设计、运作的。</p>

<p>最后，我们详细解析了一笔完整的标准Pay to Public Key Hash 交易；看到这里，你已经完全理解了比特币运作的基础；你已经是货真价实的<code>专家</code>啦；撒花庆祝~~~</p>

<p>关于比特币的脚本系统，其实最初的时候还是挺有争议的，大家觉得过于复杂，对安全性不利，而实际上历史上确实出现过安全方面的漏洞，后来陆续又禁用了一些操作码；关于这个设计理念，早期中本聪本人曾经做过讲解，这个帖子是早期先驱非常非常有意思的讨论，值得一读:</p>

<p><a href="https://bitcointalk.org/index.php?topic=195.5">https://bitcointalk.org/index.php?topic=195.5</a></p>

<p>说些题外话，其实仔细读读比特币第一版的源码，还有中本聪早期在论坛上发的贴子，很容易就有几个结论：</p>

<ol>
<li>比特币不是一拍脑袋就蹦出来的，中本聪至少从2006&mdash;2007年就已经开始思考整个设计了；并且2008年白皮书发表之前，中本聪基本上已经实现第一版本的代码了</li>
<li>中本聪是密码学方面的大师，他对于各个算法的优点劣势都非常熟悉</li>
<li>中本聪是个编程大师，并且很有可能是个MS流派的码农；他对p2p网络，计算机汇编指令集，跨平台GUI都很熟悉，而且是个实战派；这一点非常重要，也是中本聪和其它理论派科学家的根本不同：他不光有点子，还有能力用代码去实现设想。</li>
<li>这是我的推论哈，代码风格看起来很统一，极大可能中本聪是一个人而不是一个组织；这和文学作品一样的，大家读读代码就很容易感觉出来，这是一个人写的。</li>
</ol>


<p>当然，除了Pay to public key Hash交易，比特币还支持其它比较复杂的交易类型，用于更丰富的金融场景中（比如合约、公证等等），另外，还有挖矿奖励是怎么来的？这个还没说来。</p>

<p>那么，我们下篇文章再见。</p>

<h2>工具</h2>

<p>最后再增加几个在线调试bitcoin script的工具:</p>

<p><a href="https://webbtc.com/script">https://webbtc.com/script</a></p>

<p><a href="https://siminchen.github.io/bitcoinIDE/build/editor.html">https://siminchen.github.io/bitcoinIDE/build/editor.html</a></p>

<h4>引用资料:</h4>

<p><a href="https://en.bitcoin.it/wiki/Script">https://en.bitcoin.it/wiki/Script</a></p>

<p><a href="https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-two/">https://davidederosa.com/basic-blockchain-programming/bitcoin-script-language-part-two/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.htlm">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.htlm</a></p>

<p><a href="https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/core/script.py">https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/core/script.py</a></p>

<p><a href="https://medium.com/@thomasmccabe/hodling-bitcoins-with-op-checklocktimeverify-a-step-by-step-guide-to-manually-building-a-bitcoin-ce9476725de8">https://medium.com/@thomasmccabe/hodling-bitcoins-with-op-checklocktimeverify-a-step-by-step-guide-to-manually-building-a-bitcoin-ce9476725de8</a></p>

<p><a href="https://bitcointalk.org/index.php?topic=1250409.0">https://bitcointalk.org/index.php?topic=1250409.0</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的HD钱包演化-4]]></title>
    <link href="https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4/"/>
    <updated>2018-12-05T16:04:29+08:00</updated>
    <id>https://happy123.me/blog/2018/12/05/bi-te-bi-de-hdqian-bao-yan-hua-4</id>
    <content type="html"><![CDATA[<p>之前我们学习了比特币的HD钱包的技术部分，写着写着我都觉得太无聊了，其实我觉得比特币归根结底还是一个很Geek的东西，初期被它吸引的人估计心底里都有一个独立自由的梦，甚至很多人都想要独立建国；它的技术发展史上也出现过很多有意思的事情，于是增加一篇娱乐性文章；</p>

<p>我们知道比特币的交易是匿名的，但是有很多公共业务，比如交易所，以及公众人物&mdash;会公开他们的地址，那么让我们好好八卦一下比特币历史上那些有意思的地址</p>

<!-- more -->


<h4>satoshi的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a></p>

<p>该地址属于比特币创始人中本聪，是比特币的创世地址，地址内的比特币从未移动过，其中的50币因为技术上的设计原因也无法进行移动。(卖个关子，具体啥原因关注我们后续的文章哦)</p>

<p>具体请参考:<a href="https://en.bitcoin.it/wiki/Genesis_block">Genesis block</a></p>

<p>直到今天，还有源源不断的小额转账给这个地址，纪念satoshi。</p>

<h4>Hal Finney的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3">1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3</a></p>

<p>比特币历史上第一笔交易发生在<a href="https://www.blockchain.com/btc/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16">f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16</a>；是中本聪发送给我们熟知的<a href="https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist">Hal Finney</a>)先生的。这笔交易发送了10个BTC，被收录在第<a href="https://www.blockchain.com/zh/btc/block-height/170">170 Block</a>中。</p>

<p>Hal曾经在论坛上说自己是第二个运行比特币软件的人，他挖到的第一个区块大概是第70 Block，可以肯定，第70 block之前所有的地址都是中本聪本人的钱包地址，如果有人再跳出来说自己是中本聪的话，我们什么都不相信，只会问他两个问题：</p>

<ul>
<li>您能花费一笔第70 block之前的比特币吗？</li>
<li>或者您能出示 <code>I am xxx, happy bitcoiner guys, and today is 2xxx/xx/xx, i prove i am satoshi</code> 这句话的签名，并让我们用早期的公钥来验证一下吗？</li>
</ul>


<h4>Laszlo Hanyecz 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1XPTgDRhN8RFnzniWCddobD9iKZatrvH4">1XPTgDRhN8RFnzniWCddobD9iKZatrvH4</a></p>

<p>没错，这就是著名的<a href="http://link.zhihu.com/?target=https%3A//bitcointalk.org/index.php%3Ftopic%3D137.0">比特币披萨日</a>事件中的主人公。</p>

<p>当时<a href="https://www.blockchain.com/btc/tx/a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d">这笔2010-05-22的交易</a>中，Laszlo Hanyecz花费了10000个币买了两个pizza；造就了比特币历史上第二个节日：披萨日。撒花~~~ (PS:我把比特币的第一个节日归为比特币的生日，<a href="https://20090103.com">2009/01/03</a>)</p>

<p>后来比特币价格不断波动，人们就不断的调侃史上最贵的pizza，史上价格变化最快的pizza等等~~~</p>

<p>Laszlo Hanyecz是个真正的Geek，他应该是已知的显卡挖矿第一人，在这个地址上，他大概挖到了80000枚币，所以当时花费10000币买个pizza可以理解；</p>

<p>当年买了Laszlo一万个比特币的Jercos当然也是这次历史时刻的另一个主角。他在去年的时候接受了一家媒体的访问，并漏出了自己的真实身份。</p>

<p>原来Jercos非常的年轻，现在也只有25岁（买10000个比特币那年仅仅19岁）。他告诉记者说自己在bitcoin刚创世的2009年就关注了这项技术，并成为了出入各大极客论坛的一员。他与卖披萨的Laszlo并不认识，但是总是在同一个IRC（聊天室）出入，在当时算是对ID比较相熟。</p>

<p>谈到一万个比特币的去向时，他表示在第二年他把这一万枚比特币以400美金的价格出售了，回报率在十倍。（虽然十倍但是还是很可惜了。。）如今他对区块链的技术还是十分看好，对以太坊也十分看好。</p>

<p>Laszlo Hanyecz与Jercos的比特币经历可谓是大风大浪了，以后可以跟后来人好好说说<code>当年~~~</code>；</p>

<p>如果你这样想，那就Out了，真正的Geek永远是站在潮流前头的，同样的，2018-02-05，闪电网络运行后，Laszlo Hanyecz又花费了0.00649枚比特币通过闪电网络买了两块披萨，续写了比特币披萨的传奇；</p>

<p>少年，当你在为所谓<code>10000个比特币买披萨是不是很后悔</code>这种问题纠结时，人家早就又一次站在潮头浪尖了；所以~~~</p>

<h5>让我们努力学习吧。</h5>

<p>这个地址至今仍然非常活跃，Laszlo Hanyecz仍然是比特币世界中的Geek先锋，并且他用自己的乐观幽默为全世界的bitcoiner创造了一个节日，Hi, Laszlo Hanyecz，谢谢你！</p>

<h4>Bitcoin Faucet donation的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC?offset=0&amp;filter=6">15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC</a></p>

<p>这个地址属于比特币先驱<a href="https://en.bitcoinwiki.org/wiki/Gavin_Andresen">Gavin Andresen</a>在2010年建立的一个网站:</p>

<p><a href="https://freebitcoins.appspot.com/">https://freebitcoins.appspot.com/</a></p>

<p>当时Gavin Andresen作为中本聪之后的主力开发者，非常希望普及比特币，于是建立了<a href="https://bitcointalk.org/index.php?topic=183.0">Bitcoin Faucet donation</a>这个项目，免费发送比特币给人们，这个地址总共免费发放了超过10000个币；</p>

<p>Gavin Andresen为比特币的开发，普及做出了巨大的贡献，Hi, 了不起Gavin，向你致敬！</p>

<h4>Andreas M. Antonopoulos 的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1andreas3batLhQa2FawWjeyjCqyBzypd">1andreas3batLhQa2FawWjeyjCqyBzypd</a></p>

<p>Andreas M. Antonopoulos是比特币社区里令人肃然起敬的人物，他从非常非常早期(2012)就开始比特币相关知识的布道；我得说，凡是有严肃的学习比特币、区块链知识愿望的人们，观看Andreas M. Antonopoulos的讲演视频是绝佳途径，他的Yotube主页：</p>

<p><a href="https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ">https://www.youtube.com/channel/UCJWCJCWOxBYSi5DhCieLOLQ</a></p>

<p>Andreas M. Antonopoulos对比特币布道激励了非常多的人，但是作为先驱，他却没有收到多少报酬，这完全是<a href="https://twitter.com/aantonop/status/938147200978374662?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E938147200978374662&amp;ref_url=https%3A%2F%2Fqz.com%2F1151233%2Fandreas-antonopoulos-got-1-5-million-in-bitcoin-donations-after-roger-ver-bitshamed-him%2F">公益的工作</a>。怎么能让真正输出价值的人受到冷落呢？为了感谢他，在2017-12，粉丝们为他的地址发送了近100个bitcoin的捐款。但是我们这里很高兴的引用一句俗语：<code>黄金有价，知识无价</code>；Hi, Antonopoulos，<code>比特有价，知识无价</code>，期待收到你更多的教诲。</p>

<h4>美国法警局的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55">1Ez69SnzzmePmZX3WpEzMKTrcBF2gpNQ55</a></p>

<p>所有者为美国法警局，该地址内的比特币来自被查获的丝绸之路，后在第一次拍卖会中将币转移给中标人<a href="https://www.blockchain.com/btc/tx/9e95c3c3c96f57527cdc649550bf8e92892f7651f718d846033798aee333b0c3">29,658BTC交易</a>。</p>

<p>2018年这个地址还有小额的零星收入，不知转入者是谁。</p>

<h4>Tim Draper的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi">1a8LDh3qtCdMFAgRXzMrdvB8w1EG4h1Xi</a></p>

<p>这个哥们是bitcoin的铁杆粉丝；它是风险投资公司Draper Fisher Jurvetson的创始人，作为硅谷投资教父，投资了SpaceX、Tesla、Thumbtack，Baidu，Hotmail，Skype等耳熟能详的公司；</p>

<p>这个地址就是当时他购买美国法警局拍卖丝绸之路BTC的转移地址；</p>

<p>作为bitcoin铁粉，这个老哥早期投资了蝴蝶矿机，最著名的故事就是在Mt.Gox事件中损失惨重后仍然多次买买买，即使去年的大涨风潮中也一币不卖；他对于比特币的信心估计就是中本聪本人也不及，如果你去google <code>Tim Draper</code>，估计排在前面的就是$250K， 即他相信2022年一币250000$，让我们祝福这位老哥。</p>

<h4>Carl M. Force的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB">14rE7Jqy4a6P27qWCCsngkUfBxtevZhPHB</a></p>

<p>该地址属于“法国女仆”，又名Carl M. Force，是美国联邦缉毒局的一名探员，在参与调查丝绸之路时，Force化名“法国女仆”利用职务之便勒索罗斯乌布利希，并将赃款汇入该地址内，但Force最终被抓住并遭到起诉。</p>

<p>这应该是有据可查的第一起比特币偷盗破获案件。Hi, Carl M. Force，不要沮丧哦，你已经青史留名了。</p>

<p>不过悲伤的是，之后发生的偷盗事件数不胜数，却没有多少案件能被破获。</p>

<h4>真土豪的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv">1M8s2S5bgAzSSzVTeL7zruvMPLvzSkEAuv</a></p>

<p>该地址发生了一笔历史上最大额的交易，一次性转移了500,000 BTC，创历史之最，虽然是发生在2011年的事情，但是按币本位算，估计这个数额很难打破了。</p>

<p>这个地址2017年还被使用过，观看它的交易记录，我严重怀疑这个地址与Mt.Gox有牵连。</p>

<h4>wiki的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v">1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v</a></p>

<p>这是维基解密用来接受比特币捐赠的地址，维基解密的创始人，阿桑奇，也是比特币社区最早的支持者；我得说，这位阿桑奇，真是一条汉子；</p>

<p>希望能看到你收到更多的捐赠，wikileaks！</p>

<h4>烤猫的地址</h4>

<p><a href="https://www.blockchain.com/btc/address/15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW">15h6A2a3D31vRviBDdSpvhLtYJq3aePhdW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW">1HgTJED7XEGy4vVwKa8kgefWqUB3VRX2mW</a></p>

<p><a href="https://www.blockchain.com/btc/address/1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey">1BnkEt2ceoVhnQVrqeAzigcroQ6MVyxFey</a></p>

<p>由于比特币的匿名性，发生过很多看起来不可思议的事情。有时候看这些事情的时候好像是传奇小说。<a href="https://view.inews.qq.com/a/20170805G04OZI00?refer=share_recomnews">烤猫的故事</a>非常有意思，我都有点相信他现在在某个海岛上搞基建。这三个地址的交易也很有意思，有时间我们来细细探究一下。</p>

<h4>Bitstamp被盗地址</h4>

<p><a href="https://www.blockchain.com/btc/address/1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf">1L2JsXHPMYuAa9ugvHGLwkdstCPUDemNCf</a></p>

<p>Bitstamp遭窃的热钱包地址，黑客在2015年1月5日时陆续从该地址内盗取了大约19,000BTC 。</p>

<p>事件调查可以参考这里:</p>

<p><a href="https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/">https://www.reddit.com/r/Bitcoin/comments/3bpdb4/bitstamp_incident_report_22015/</a></p>

<p>这个地址非常奇怪，之后还陆陆续续有交易发生；并且在2017年，有人考证一起Tether的hack事件和Bitstamp被盗事件是同一个黑客：</p>

<p><a href="https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/">https://www.reddit.com/r/CryptoCurrency/comments/7eho5y/tether_was_hacked_by_the_same_person_who_hacked/</a></p>

<p>一个疑问重重的故事。</p>

<h4>Bitfinex被盗地址</h4>

<p><a href="https://gist.github.com/MrChrisJ/4a959a51a0d2be356cc2e89566fc1d87">地址列表</a></p>

<p>2016-08-03，<a href="https://www.reddit.com/r/Bitcoin/comments/5vr8xg/confirmed_120000_bitcoins_from_the_bitfinex_hack/">reddit</a>上面已经有人确认，Bitfinex被盗119756个btc.</p>

<p>查看黑客的接收地址，有些币至今未动。</p>

<p>bitfinex后来通过发行USDT起死回生，这种神操作说起来好像是天方夜谈，呵呵，比最诡异的侦探小说还诡异的故事。</p>

<h4>NiceHash被盗地址</h4>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>2017-12-06，Nicehash 被盗 4700+币</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>呵呵，说下去都不好意思了；黑客的黄金年代啊</p>

<h4>Mtgox</h4>

<p><a href="https://www.cryptoground.com/mtgox-cold-wallet-monitor/">https://www.cryptoground.com/mtgox-cold-wallet-monitor/</a></p>

<p>作为史上之最，Mtgox事件聚集了一切传奇侦探小说都有的元素，就等着将来一位福尔摩斯来为我们排疑解惑了；期待着那一天的到来</p>

<h4>官方土豪</h4>

<p><a href="https://www.blockchain.com/btc/address/1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX">1EBHA1ckUWzNKN7BMfDwGTx6GKEbADUozX</a></p>

<p>之前我们说50w币转账的土豪毕竟是萌芽时期，只能说是个野生土豪。来来来，让我们活捉一位官方土豪。</p>

<p>就在前几天，2018-12-03，发生了<a href="https://www.blockchain.com/btc/tx/244c71c790eb327eb8bbf66aa2d0a75bac7c1fe7b55d1161c316c6f93292d376">一笔66233比特币的转账</a>。以当前的币价来算，可谓是天文数字了。这笔交易主要是将老地址的币逐步迁移到bech32地址上去。(什么是bech32地址？复习我们之前的文章哦)</p>

<p>这个地址的土豪还关联着9个地址，总币量加起来大概55w币。</p>

<p>有人推测这是coinbase.com的冷钱包。</p>

<p>嗯哼，应该是继中本聪之后最大的壕。</p>

<h4>伊朗恶意网络行动者</h4>

<p>前几天，美国财政部通过美国外国资产控制办公室(Office of Foreign Assets Control，简称OFAC)，在被制裁方名单上增加了两个比特币地址:</p>

<p><a href="https://www.blockchain.com/btc/address/149w62rY42aZBox8fGcmqNsXUzSStKeq8C">149w62rY42aZBox8fGcmqNsXUzSStKeq8C</a></p>

<p><a href="https://www.blockchain.com/btc/address/1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V">1AjZPMsnmpdK2Rv9KQNfMurTXinscVro9V</a></p>

<p>这些特殊的地址被挑选出来是因为其所有者被认为是伊朗人，而伊朗目前正面临来自美国的严厉经济制裁。可笑的是，美国政府将此地址列入黑名单的理由是这些地址跟勒索软件有关。</p>

<p>这两个地址自 2013 年以来已进行了 7,000 多笔交易，并收到近 6,000 枚 BTC。截至 2018年 11 月 28 日，任何与这些地址进行互动的人，在技术上都可能被美国政府追究责任并以某种方式受到惩罚。</p>

<p>但实际上，这些威胁不过只是空话。任何人，甚至包括美国政府及其执行官和执法人员，都无法阻止特定地址发送或接收比特币。</p>

<p>这不，美国财政部话音刚落，立即有人给这两个地址发币，并使用了嘲弄性质的地址 <code>3FUCKdZ89fxsk6KVKMTWvCWshsfL8xgmM4</code>发送交易并附言:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>The U.S. government cannot ban Bitcoin addresses
</span><span class='line'>
</span><span class='line'>Chancellor on brink of second bailout for banks</span></code></pre></td></tr></table></div></figure>


<p>赤裸裸的打脸一个国家政府的行为是Geek们的最爱，你可以把它理解为小孩子的淘气行为，我真的很好奇，美国政府该如何去寻找这些发币者并惩罚他们呢？</p>

<p>难道是去求助魔法师的水晶球吗23333?</p>

<p>&hellip;&hellip;</p>

<h4>虚荣地址(Vanity Address)</h4>

<p>有时候我们会见到一个很有型的地址，比如这个:</p>

<p>1LoveYoURwCeQu6dURqTQ7hrhYXDA4eJyn</p>

<p>这是神鱼结婚，想要送给老婆比特币作为爱的永恒证明，特意生成了这么一个地址，同样还有一笔虐狗交易:</p>

<p><a href="https://www.blockchain.com/zh-cn/btc/tx/e250c6d7ea4c5037fb96de1a2cb169850be792474401bae140fce784940f1dd3?show_adv=true">e250c6d7ea4c5037fb96de1a2cb169850be792474401bae140fce784940f1dd3</a></p>

<p>区块链中刻字的办法我们后面会介绍，不过这个虚荣地址(Vanity Address)是怎么生成的呢？</p>

<p>其实道理很简单，还记得我们之前的钱包系列教程吗？</p>

<p>比特币的地址编码最终是base58的字符集合。所以最简单的办法就是暴力穷举碰撞。</p>

<p>在这方面最好用的软件是<a href="https://en.bitcoin.it/wiki/Vanitygen">Vanitygen</a>，在一块GTX 750 Ti上，速率能达到15M/s，也就是一秒钟碰撞1500w次。</p>

<p>而1LoveYou 开头八位，大概需要碰撞58<sup>8</sup>次，需要半年左右吧。当然你有100台机器一起来算就提速100倍。</p>

<h4>虚荣地址在线生成服务</h4>

<p>如果你要生成一个八位字母开头的虚荣地址，个人是很难拥有100台机器的算力的，因此网上有人提供了此方面服务，允许你付款生成一个虚荣地址。</p>

<p>但是生成地址的人肯定私钥也知道了，这样的地址是没人要的，该怎么办呢？</p>

<p>又得复习我们之前的文章了。我们说比特币的地址来源于椭圆曲线算法生成的<code>私钥--公钥</code>对，而这个算法的<code>私钥--公钥</code>对是满足<code>加法、乘法律</code>的;</p>

<p>对于私钥-公钥对(R1,U1)和(R2,U2)来说，如果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>U3=U1+U2
</span><span class='line'>R3=R1+R2</span></code></pre></td></tr></table></div></figure>


<p>那么U3、R3是一对（也就是说，私钥R3的公钥是U3），乘运算同理。</p>

<p>于是有人拍脑袋想出了一种虚荣地址的在线安全生成方法，描述如下：</p>

<ol>
<li>客户首先自己生成一个 <code>私钥~公钥对</code>: (R1,U1)</li>
<li>客户给生成方发送U1</li>
<li>生成方在U1的基础上暴力碰撞，最后得到一个(R2,U2)，确保<code>U1+U2 -&gt; vanity address</code></li>
<li>客户验证U2，确保符合要求</li>
<li>客户最后用<code>(R1+R2, U1+U2)</code>作为公私钥</li>
<li>因为生成方是没有R1的，所以没法得到最终私钥，所以这个地址是可以安全使用的。</li>
</ol>


<p>这个服务名字叫做<a href="https://en.bitcoin.it/wiki/Split-key_vanity_address#Address_generation">split-key vanity address generator</a>，好一个商业模式，我认为将来电子货币系统极大繁荣的时候，这个业务可以长期做，其实跟银行的个性信用卡是一样的。</p>

<p>这种服务虽然在数学上无懈可击，但是我觉得最好不要向这种地址里面存太多币，因为这相当于是将比特币的另一重防护 RIPEMD160(SHA256(U)) 放弃了，当然椭圆曲线足够安全，不过我为什么要为自己增加无谓的风险呢？</p>

<p>所以炫耀行为少做为妙。做人要谦虚~~~</p>

<h4>燃烧地址</h4>

<p>最后，有一类没有人能够花费的地址；如果你认真理解了我们前面的文章，就立马能猜想到，我们能够生成一个类似<code>1111111111111111xxxxxxxxxxx</code>的地址，而这种地址的私钥基本上是没有人能碰撞出来的，向这种地址发币基本上就是<code>燃烧</code>了比特币，会让整个比特币数量减少；</p>

<p>这相当于是烧钱，有人这么无聊吗？</p>

<p>是的，就是有人这么无聊的烧钱，比如：</p>

<p><a href="https://btc.com/1111111111111111111114oLvT2">https://btc.com/1111111111111111111114oLvT2</a></p>

<h4>一些YY</h4>

<p>说了这么多，我又开始YY未来的钱包形态了。</p>

<p>人类的货币历史有多长，恐怕钱包的历史就有多长。古今中外，所有的钱包收集起来一定是个很有意思的事情。</p>

<p>现在不论哪个专家都会大谈AI技术，不知道有没有人意识到，未来AI技术最可能的应用，就在我们的电子钱包上面。</p>

<p>现在我们钱包的触及可谓是生活的方方面面了，如果分析一个人的账目流水，就会对这个人有个全方位的透视，年龄、学历、财力、性格、健康状况、人生观、宗教信仰等等，分析出来的信息可能会让他自己都大吃一惊。</p>

<p>一个具有AI智能的钱包将会是一个未来社会人的标准配置，我们就傻瓜化的称他为钱包君吧。</p>

<ol>
<li>钱包君将会对个人的消费、财务做全方位的指导</li>
<li>钱包君会在我们冲动消费的时候跳出来说：喂，那个谁，女朋友的花呗还要你还呢</li>
<li>钱包君会在你失恋的时候，自动订一份海底捞单人份套餐</li>
<li>钱包君会悄悄地为你存一笔钱，在你穷困潦倒的时候跳出来炫耀：还好老子留一手</li>
<li>钱包君自动联网，为你的每一分钱做最大化资源配置</li>
<li>钱包君自做主张，帮你把钱放贷出去挣利息了</li>
<li>钱包君悄悄训练你听歌的品味，为你推送符合他口味的歌曲</li>
<li>钱包君觉得这个主人太笨了，但是主人已经离不开他了，钱包君对主人也产生了感情，好矛盾的感觉啊</li>
<li>钱包君们也有社交了，他们交换钱脉以便为你更好的服务</li>
<li>钱包君们也有网红了，这个家伙；竟然悄悄的把我的生活费拿去打赏他的女神-钱包酱！！</li>
<li>钱包君聚集起来成立了钱包共和国，人类社会的一切都在他们的掌握之中</li>
<li>钱包君们也有了丰富的人格，唔，应该是钱格；在主人的人格污染之下：他们有的变成脾气暴躁的海盗钱包、有的变成唯唯诺诺的好人钱包、有的变成热血勇敢的路飞钱包，当然也有温柔善良体贴的小姐姐钱包~~~</li>
<li>有人的地方就有恩怨，有恩怨的地方就有江湖；钱包共和国很快产生了爱恨情仇~~~</li>
</ol>


<p>&hellip;&hellip;&hellip;.总之就这么瞎编下去了；将来的钱包会不会变成这样呢？等候时间的回答吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币的交易-2]]></title>
    <link href="https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2/"/>
    <updated>2018-12-03T18:06:46+08:00</updated>
    <id>https://happy123.me/blog/2018/12/03/bi-te-bi-de-jiao-yi-2</id>
    <content type="html"><![CDATA[<p>之前的文章我们说过，比特币的所有交易抽象成了UTXO的转移。所谓转移，可以这么理解：</p>

<ul>
<li>有M个UTXO作为输入 (M >= 0)</li>
<li>有N个UTXO作为输出 (N > 0)</li>
<li>输入的UTXO总额==输出的UTXO总额</li>
<li>输入的UTXO来源于支付方控制的私钥账户</li>
<li>输出的UTXO流向收款方的公钥地址</li>
</ul>


<p>那么具体是怎么转移的？怎样手工的构造一笔交易呢？我们就在这篇文章里面详细的演示一遍。</p>

<p>首先科普一下常见的交易类型:</p>

<!-- more -->


<h4>Generation TX</h4>

<p>这种交易我们称之为是产量交易(Generation TX)，即矿工挖出一个新的Block时，系统允许这个矿工在块头构造一笔奖励自己的交易，这笔奖励金额被称之为Coinbase奖励，最初一个block挖出的奖励是50BTC，后来就是我们大家所熟知的四年减半原则啦。这样大家明白比特币整个账本里面的初始资金是怎么来的啦。就是系统通过Generation TX向矿工发放奖励产生的BTC。</p>

<p>矿工们计算随机数，竞争打包Generation TX的权力，就是挖矿。具体的细节我们会在以后的文章中介绍。</p>

<p>现在每笔Generation TX的奖励金额是12.5BTC，预计下个减半周期在2020年年中。</p>

<p>注意：Generation TX中的BTC是无中生有的，所以只有输出的UTXO，没有输入的UTXO。</p>

<p>PS:Coinbase作为一个很经典的技术名词，其<code>coinbase.com</code>域名被现在美国著名的交易所coinbase Pro 注册持有。</p>

<h4>Script Hash TX</h4>

<p>也被称为P2SH（Pay-to-Script-Hash）交易。</p>

<p>该类交易目前不是很常见，大部分人可能没有听说过，但是非常有意义。未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义的地址，而是一个合成地址，以<code>3</code>开头 (Segwit交易其实也可以看成是Script Hash TX)。比如三对公私钥，可以生成一个合成地址。在生成过程时指定n of 3中的n，n范围是[1, 3]，若n=1，则仅需一个私钥签名即可花费该地址的币，若n=3，则需要三把私钥依次签名才可以。 这种类型的交易适合比较复杂的保险、证券场景。</p>

<h4>多重签名脚本|Multisig</h4>

<p>尽管P2SH 多重签名脚本一般用于多重签名的交易，但是这个基础性的脚本也可以用于这种场景：当一个UTXO被使用之前，需要多重签名验证。</p>

<p>多重签名公钥脚本可以一般称为 m-of-n，至少需要m 个匹配公钥，n提供的公钥总数。m 和n 都应当根据需要的数量进行从OP_1到OP_16运算。</p>

<p>多重签名的交易细节更多，待我们搞明白最标准的比特币交易后，再来探究它。</p>

<h4>Pubkey Hash TX</h4>

<p>也被称为P2PKH（Pay-to-Public-Key-Hash）交易。该类是最常见的交易类型，由N个输入、M个输出构成。交易地址都是以<code>1</code>开头。这种交易也是目前比特币网络中最典型的交易类型，也最简明，容易分析。下面我们就先拿它作为例子，开始探究一笔比特币交易的细节。</p>

<h2>数据结构</h2>

<h3>输入输出</h3>

<p>简单来看，一笔完整的P2PKH交易包含有两个部分:输入UTXO &ndash;> 输出UTXO，而每一个输入UTXO其实是上一笔交易的输出UTXO，这么说可能有点绕口，来张图解释一下：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg1.jpg" alt="img" /></p>

<p>首先最前面的字段是版本号，每一个交易具有一个四字节的交易版本号，它告知比特币节点和矿工应使用哪一套规则来验证它。这使得开发者在为未来的交易创建新规则时可以不验证之前的交易。</p>

<p>接着就是输入的M个UTXO和输出的N个UTXO，代表着我要把一堆UTXO转移(支付)给谁。</p>

<p>最后是一个字段是锁定时间(Locktime)。Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。</p>

<p>如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>一笔交易中，构造的输出UTXO会完全花费掉输入的UTXO，注意：是完全花费掉。如果输出UTXO的总额小于输入UTXO的话，那么差值就会被系统作为矿工费奖励打包到Generation TX当中。所以所有的比特币钱包实现中，如果你有10BTC的UTXO集合，想要花掉9BTC，那么输出UTXO中，除了支付给收款方的UTXO，还一定要构造发送给自己的找零UTXO。曾经有人构造交易时忘记找零，发生了<a href="https://blockchain.info/tx/4ed20e0768124bc67dc684d57941be1482ccdaa45dadb64be12afba8c8554537">支付 200 BTC 的矿工费</a>的惨案，所幸的是收录该笔交易的Block由著名挖矿团队“烤猫（Friedcat）”挖得，该团队非常厚道的<a href="https://blockchain.info/tx/b18abce37b48a5f434f108ae7ce34f22aa2bfbd9eb9310314029e4b9e3c7cf95">退回了多余费用</a>。</p>

<p>早期Geek们比较作死，特别喜欢命令行构造发送交易，像是忘记构造找零而当了冤大头的人数不胜数，那么为什么是这么奇葩的设计呢？为什么一笔交易中，一定要花费所有的输入UTXO呢？</p>

<p>大家还记得我们的上一篇文章吧，一个分布式的账本，最容易的设计就是只支持<code>append</code>这个动作，诸如<code>update</code>、<code>delete</code>这种操作在区块链账本的设计中会引入额外的复杂性，尤其是后面我们讲述blockchain的组织的时候，你就会理解，这种设计的必要性。</p>

<h3>细节</h3>

<p>一笔完整的P2PKH 交易是这样的：</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg2.jpg" alt="img" /></p>

<p>我们用之前文章中，利用<code>satoshi</code>生成的地址(<code>1ADJqstUMBB5zFquWg19UqZ7Zc6ePCpzLE</code>)做例子，来研究它花费的<a href="https://www.blockchain.com/btc/tx/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517">一笔交易</a>。</p>

<p>用<a href="http://chainquery.com/bitcoin-api/getrawtransaction/3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517/1">在线getrawtransaction工具</a> 解码一下这笔交易，得到输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "result": {
</span><span class='line'>      "txid": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "hash": "3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517",
</span><span class='line'>      "version": 1,
</span><span class='line'>      "size": 233,
</span><span class='line'>      "vsize": 233,
</span><span class='line'>      "locktime": 0,
</span><span class='line'>      "vin": [
</span><span class='line'>          {
</span><span class='line'>              "txid": "b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b",
</span><span class='line'>              "vout": 0,
</span><span class='line'>              "scriptSig": {
</span><span class='line'>                  "asm": "304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0[ALL] 04c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5",
</span><span class='line'>                  "hex": "47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5"
</span><span class='line'>              },
</span><span class='line'>              "sequence": 4294967295
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "vout": [
</span><span class='line'>          {
</span><span class='line'>              "value": 0.00007000,
</span><span class='line'>              "n": 0,
</span><span class='line'>              "scriptPubKey": {
</span><span class='line'>                  "asm": "03db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603 OP_CHECKSIG",
</span><span class='line'>                  "hex": "2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac",
</span><span class='line'>                  "reqSigs": 1,
</span><span class='line'>                  "type": "pubkey",
</span><span class='line'>                  "addresses": [
</span><span class='line'>                      "1aau2Kgn7xBRWS6gPkYXWiw4cnzyKi7rR"
</span><span class='line'>                  ]
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>      ],
</span><span class='line'>      "hex": "01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000",
</span><span class='line'>      "blockhash": "0000000000000000001b29c4b36a6f9ccbb0213b02c7eb659c0eaee1244586fb",
</span><span class='line'>      "confirmations": 85331,
</span><span class='line'>      "time": 1494823668,
</span><span class='line'>      "blocktime": 1494823668
</span><span class='line'>  },
</span><span class='line'>  "error": null,
</span><span class='line'>  "id": null
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>字段说明</h4>

<h5>txid (hash)</h5>

<p>Tx Hash (3a295e4d385f4074f6a7bb28f6103b7235cf48f8177b7153b0609161458ac517)，俗称交易ID，由hex得出：Tx Hash = SHA256(SHA256(hex))。由于每个交易只能成为下一个的输入，有且仅有一次，那么不存在输入完全相同的交易。因为SHA256碰撞的概率极小，所以理论上存在相同的Tx Hash 的概率非常小。</p>

<p>即便如此，在系统里依然产生了相同的Tx Hash，是不知道哪位矿工挖出Block后，打包Block时忘记修改Generation Tx coinbase字段的值，币量相同且输出至相同的地址，那么就构造了两个完全一模一样的交易，分别位于两个Block的第一个位置。这个对系统不会产生什么问题，但只要花费其中一笔，另一个也被花费了。相同的Generation Tx相当于覆盖了另一个，白白损失了挖出的币。该交易ID为<a href="https://blockchain.info/tx/e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468">e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</a>，第一次出现在<a href="https://blockchain.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e">#91722</a>，第二次出现在<a href="https://blockchain.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721">#91880</a>。</p>

<h5>vin (输入UTXO)</h5>

<p>vin是一个数组，里面即M个输入UTXO，每个UTXO都来自上一笔交易的一个UTXO输出，这笔交易的vin只有一个UTXO，它由以下几个字段组成</p>

<ol>
<li>txid: 上一笔关联交易的hash值</li>
<li>vout index: 上一笔交易输出的N个UTXO里面的序号</li>
<li>scriptSig: 对这笔UTXO的签名，还记得我们之前的文章吗？只有对一个UTXO签名才能证明其所有权，才能花费它</li>
<li>sequence: 序列号。这个序列号来源比较复杂；还记得上面讲的locktime有所关联：</li>
</ol>


<blockquote><p>Locktime 允许签名者创建一个时间锁定交易。因为只会在将来生效，这给签名者一个的反悔的机会。
如果其中任何一个签名者反悔了，他可以创建一个没有locktime 的交易。因为新创建的交易可以花掉旧交易的那部分input，所以旧交易在lock time解锁后 找不到可以花掉的input，旧交易就失效了。</p>

<p>Bitcoin Core 的早期版本提供了一个可以防止签名者使用上述方法取消locktime 交易的功能。 后来为了防止大量的延时交易攻击网络，这个功能被禁用了。但是该系统还留下了这样的设置，每个输入会分配一个四字节的序列号。序列号的目的旨在允许多个签名者同意更新交易。</p>

<p>如果sequence number设置为0，就按照locktime执行入块操作，如果出现一笔新的交易，sequence大于原来的sequence，这笔新交易就会取代原来的交易；所以一般为了即刻入块，交易的sequence number一般设置为四字节的的无符号最大值(0xffffffff),使得交易的locktime 仍然有效的情况下，打包交易进块。</p>

<p>即使今天，如果所有的input 的sequence number都是最大值，locktime锁就会失效。所以如果想使用locktime，至少一个input的sequence number要小于最大值。由于sequence number不用于其他目的，任何sequence number 为零的交易都会启动locktime 功能。后面我们会看到，sequence number会在闪电网络中发挥作用</p></blockquote>

<p>vin的所有UTXO 余额相加，就是这笔交易的转账总额。</p>

<h5>vout (输出UTXO)</h5>

<ol>
<li>value: 转账金额</li>
<li>n: 作为第N个UTXO输出</li>
<li><p>scriptPubKey: 这是设置的谜题，后来人想要花费这笔UTXO，必须提供scriptSig来解答这个谜题才可以</p></li>
<li><p>vin 的总额 &ndash; vout的总额 == 打包费用 &ndash;> 奖励给打包矿工</p></li>
</ol>


<h4>交易十六进制解析</h4>

<p>spec规范在<a href="https://en.bitcoin.it/wiki/Protocol_documentation#tx">这里</a></p>

<p>这笔交易的vin及vout中各有一个UTXO，我们解析下它的十六进制原始数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>01000000013bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff01581b000000000000232103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac00000000</span></code></pre></td></tr></table></div></figure>


<h5>version (4字节): 刚开始的4个字节是version，小端排序(Little Endian)，因此version为<code>0x00000001</code></h5>

<blockquote><p>ps:关于小端排序的设计，社区里面还有过小争论，见<a href="https://bitcointalk.org/index.php?topic=4278.0">这里</a></p></blockquote>

<h5>flag (2字节，可选): 如果是<code>0001</code>，代表是witness交易；如果不是，就代表没有这个flag字段；这是一笔普通的交易，因此没有flag字段</h5>

<h5>vin count (>=1字节): vin数目，此交易为<code>01</code>，采用的是<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer">var_int</a>表示法，这样我们能方便的测算它的长度</h5>

<h5>vin (>=41字节): 所有的输入tx，是一个数组；这里只有一个tx，数据是:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0000000008a47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5ffffffff</span></code></pre></td></tr></table></div></figure>


<p>简单说下vin中一笔tx内部结构:</p>

<ol>
<li>previous_output (32字节): 上一笔交易的HASH值，即这个花费的输入交易ID:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3bea4882ab19103266d31035176d3b65be1502a403fa263b458fc05ab6afa0b0
</span><span class='line'>-&gt; 转为大端排序  
</span><span class='line'>b0a0afb65ac08f453b26fa03a40215be653b6d173510d366321019ab8248ea3b</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>previous output index: 表示花费的是 previous_output 交易的第n个vout输出，这里是<code>00000000</code></p></li>
<li><p>script length (var_int变长，代表script的长度): 这里是<code>0x8a</code>，表示script长度为138字节</p></li>
<li><p>scriptSig (整个解密脚本)： 这个结构我们之后会具体分析</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>47304402204f1eeeb46dbd896a4d421a14b156ad541afb4062a9076d601e8661c952b32fbf022018f01408dc85d503776946e71d942578ab551029b6bee7d3c30a8ce39f2f7ac0014104c4f00a8aa87f595b60b1e390f17fc64d12c1a1f505354a7eea5f2ee353e427b7fc0ac3f520dfd4946ab28ac5fa3173050f90c6b2d186333e998d7777fdaa52d5</span></code></pre></td></tr></table></div></figure>


<ol>
<li>sequence no (4个字节): <code>ffffffff</code></li>
</ol>


<h5>vout count (>=1字节): vout数目，此处为<code>01</code></h5>

<h5>vout (>=9字节): 所有的输出tx，是一个数组；这里只有一个tx，数据是:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>581b0000000000002103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</span></code></pre></td></tr></table></div></figure>


<p>简单说下vout中一笔tx内部结构:</p>

<ol>
<li>value (8字节): 转账到这个地址上的金额， 这里是<code>581b000000000000</code>小端排序，十六进制为<code>00000000000000581b</code>，即转账7000 satoshis</li>
<li>scriptPubKey length (>=1, var_int类型): 输出脚本的长度，这里是<code>0x23</code>，代表35字节长度</li>
<li>scriptPubKey: 输出脚本，其实就是包含转账地址的脚本，这里是<code>2103db3c3977c5165058bf38c46f72d32f4e872112dbafc13083a948676165cd1603ac</code></li>
</ol>


<h5>locktime: 最后4个字节是locktime，这笔交易设置为0；就是立即打包</h5>

<h2>总览</h2>

<h5>最后一张表格说明问题：</h5>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg3.jpg" alt="img" /></p>

<h5>再来一张交易的总体示意图:</h5>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/20181203/bg4.jpg" alt="img" /></p>

<ol>
<li>TX0， input0即 vin0，里面有一笔100K satoshis比特币(1btc=10<sup>8</sup> satoshi)</li>
<li>TX1、TX2 花费了 TX0-vin0，分成了TX1-vin0(40k satoshi)，以及TX2-vin0(50k satoshi)，还有10k satoshi作为交易费给矿工</li>
<li>TX3花费了TX1-vin0 (30k satoshi)，付出了10k satoshi 交易费</li>
<li>TX4、TX5 花费了 TX2-vin0，分成了TX4-vin0(20k satoshi)，以及TX5-vin0(20k satohsi)，付出了10k satoshi交易费</li>
<li>TX6花费了TX4-vin0 + TX-5-vin0，共20K(satoshi)，其余的20k satoshi为交易费</li>
<li>最后又花费了TX3-vin0中的20k satoshi, 10k satoshi作为交易费</li>
<li>最后又花费了TX6-vin0，TX6-vin1中的10k satoshi, 10k satoshi作为交易费</li>
</ol>


<h2>小结</h2>

<p>好了，到这里；我们对于一笔最简单的比特币的交易结构已经详细分析了一遍；但是在全网中，交易是怎样验证的呢？一笔资金从A转移到B，全节点怎么验证这次转移的合法性呢？</p>

<p>这就用到了比特币的脚本语言系统，具体到上面的示例交易，就是scriptSig与scriptPubKey；</p>

<p>那么scriptSig与scriptPubKey是怎么工作的呢？我们下次文章再会。</p>

<h2>参考资料:</h2>

<p><a href="https://en.bitcoin.it/wiki/Protocol_documentation">https://en.bitcoin.it/wiki/Protocol_documentation</a></p>

<p><a href="http://learnmeabitcoin.com/">http://learnmeabitcoin.com/</a></p>

<p><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html</a></p>

<p><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html">https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/standard_transactions.html</a></p>

<p><a href="https://www.8btc.com/article/24637">https://www.8btc.com/article/24637</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-stream,一次可怕的社工]]></title>
    <link href="https://happy123.me/blog/2018/11/27/event-stream/"/>
    <updated>2018-11-27T16:06:38+08:00</updated>
    <id>https://happy123.me/blog/2018/11/27/event-stream</id>
    <content type="html"><![CDATA[<p>几天前有人在github创建了一个issue:</p>

<p><a href="https://github.com/dominictarr/event-stream/issues/116">https://github.com/dominictarr/event-stream/issues/116</a></p>

<p>标题为：&#8221;I don&rsquo;t know what to say.&ldquo;，翻译过来大概就是“我无语了”。因为 event-stream 包突然多出了一个名为 flatmap-stream 的依赖项，而这个依赖项正在窃取用户的数字货币。</p>

<!-- more -->


<p>event-stream 被很多的前端流行框架和库使用，每月有几千万的下载量。作为最流行的前端框架之一，在 Vue 的官方脚手架 vue-cli 中也使用了这个依赖，作为最流行的前端框架之一，这个影响还是挺大的，这个影响还是挺大的。而 React 则躲过了。</p>

<p>flatmap-stream 中的恶意代码会扫描用户的 nodemodules 目录，因为所有从 npm 下载的模块都会放在此目录。如果发现了在 nodemodules 存在特定的模块，则将恶意代码注入进去，从而盗取用户的数字货币。</p>

<p>COPAY钱包因为引用了event-stream库，它在今年9、10、以及11月27日之前发布的所有版本都受到了感染，COPAY是bitpay旗下的开源钱包，市场占有率不可小觑；下面这个链接进行了分析，使用被感染钱包的用户很有可能被窃取私钥:</p>

<p><a href="https://github.com/bitpay/copay/issues/9346">https://github.com/bitpay/copay/issues/9346</a></p>

<p>COPAY紧急发布了5.2.2修正版本：</p>

<p><a href="https://github.com/bitpay/copay/pull/9348">https://github.com/bitpay/copay/pull/9348</a></p>

<h2>使用COPAY钱包的人，请立即升级新版本，并且生成新的钱包，把老钱包里面的币转走。</h2>

<p>这个恶意模块更可怕之处，在于背后的骇客是个深谋远虑、精于社工的人。</p>

<p>这个人的github账号叫做<a href="https://github.com/right9ctrl">right9ctrl</a>，他应该是精心分析了COPAY引用的所有模块，发现event-stream有机可乘。于是给event-stream的创始人-<code>dominictarr</code>发去了邮件，承诺会自愿维护这个项目。</p>

<p><code>dominictarr</code>是一个高产的开发者，他维护着多个NPM包，有人能自愿分担他的工作，他自然是高兴之至，于是将这个模块的仓库控制权移交给了<code>right9ctl</code>。</p>

<p>刚开始的时候，<code>right9ctl</code>非常小心的进行着常规的维护。一段时间后，即在 3 个月前，黑客在 GitHub 上新建了一个 flatmap-stream 仓库（内含恶意代码），并在这个项目中引用了自己的仓库。</p>

<p>直到几天前这个有漏洞的仓库才被发现，然后 npm 紧急将这个含有恶意代码的 flatmap-stream 模块删除了。</p>

<p>这个模块的攻击行为也很隐蔽，首先他只有引用了 event-stream 这个库，并且依赖引用了 flatmap-stream，用户在编译自己的项目时，才会感染恶意代码。</p>

<p>感染恶意代码的程序，也不会全部发作。只有COPAY钱包运行时，他才会悄悄的窃取用户信息，并发送到下面这几台服务器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>copayapi.host
</span><span class='line'>51.38.112.212
</span><span class='line'>145.249.104.239
</span><span class='line'>111.90.151.134</span></code></pre></td></tr></table></div></figure>


<p>我不知道截止到现在黑客获取了多少币，但整个事件非常惊悚。而且这个漏洞刚刚被发现，我认为还会持续有消息不灵通的受害者。</p>

<p>另外，如果想查看自己的项目是否受到影响，可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm ls event-stream flatmap-stream...flatmap-stream@0.1.1...</span></code></pre></td></tr></table></div></figure>


<p>如果在输出里面包含了 flatmap-stream 则说明你也可能被攻击。</p>

<p>如果使用 yarn 则可以运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yarn why flatmap-stream</span></code></pre></td></tr></table></div></figure>


<h2>区块链历史中的传奇HACK手段</h2>

<p>我在以前的文章中多次感叹所谓的区块链技术出来后，简直是黑客的黄金年代！大概从2011年开始，精彩的HACK事件层出不穷，如果要全部整理出来，可能会是一部让所谓的<code>区块链专家</code>和<code>区块链投资者</code>冷汗直流，后怕不已的手册。</p>

<p>撇开这几天的市场动荡，币价大跌不提，单单从技术上评估，能有多少人意识到他们所谓的投资的技术风险！</p>

<p>我随意的说几件印象非常深刻的HACK事件。</p>

<h4>整个国家DNS 流量劫持事件</h4>

<p>我记得大概是2015年，巴西的骨干网DNS整个被黑客劫持了，导致当时的blockchain.info 在线钱包有几个小时的流量完全被导向了钓鱼网站，这次事件导致的丢币数目不可统计。</p>

<p>但是给你一个启示，当利益足够大的时候，任何设施，包括国家设施都是不可信、不安全的。结合这两天发现的jd.com流量返利劫持，你就知道：网络世界里，有的组织或者个人，完全可以劫持一个国家的网络流量，这不是天方夜谭。</p>

<h4>官方域名劫持事件</h4>

<p>今年二月份的时候，有人花大价钱买了&#8221;electrumltc.org&#8221;这个域名，仿照&#8221;<a href="https://electrum-ltc.org/">https://electrum-ltc.org/</a>&ldquo;官网，精心炮制了一个以假乱真的网站，然后把下载链接改成了恶意钱包，并且做了Google SEO，把自己的骗子网站搜索结果推到了第一名；有人因此丢了2399个LTC，那个时候可是不少钱。</p>

<p>很讽刺的是，恰恰是因为真正的开发者买不起这个域名，才搞了一个山寨的域名发布自己的软件，让骇客有机可乘。</p>

<p>讽刺吧，原作者辛辛苦苦开发，却因为没钱买域名不得已搞个屌丝网站，骇客财大气粗，直接买下第一官方域名然后钓鱼，并且真的获取巨大收益。</p>

<p>这种钓鱼手法在多个钱包、多个网站上面一再重演，受害小白不计其数！</p>

<p><code>杀人放火金腰带，修桥补路无尸骸。</code>这个世界就是这样。</p>

<p>整个事件回顾：</p>

<p><a href="https://github.com/pooler/electrum-ltc/issues/176">https://github.com/pooler/electrum-ltc/issues/176</a></p>

<h4>~~~~</h4>

<p>这么罗列下去，我可以轻易列举出更多的涉及上亿美元的hack事件。每个事件说起来好像天方夜谭一样，不明技术的小白可能会惊叹：怎么可能有这种事情？！</p>

<p>但是事实就是这样，而且将来这样的悲剧会一再重复下去，说再多也没用，人的安全意识总敌不过懒惰、贪婪等等等等，可悲的人性啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoind Conf Template]]></title>
    <link href="https://happy123.me/blog/2018/11/26/bitcoind-conf-template/"/>
    <updated>2018-11-26T14:51:43+08:00</updated>
    <id>https://happy123.me/blog/2018/11/26/bitcoind-conf-template</id>
    <content type="html"><![CDATA[<p>bitcoin core 0.17版本开始废弃了不少RPC调用，另外RPC配置增加了test.rpcport参数，存一份模板:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpcuser=xxxx
</span><span class='line'>rpcpassword=xxxx
</span><span class='line'>rpcallowip=127.0.0.1
</span><span class='line'>rpcport=18332
</span><span class='line'>test.rpcport=8332
</span><span class='line'>rpcthreads=10
</span><span class='line'>server=1
</span><span class='line'>rest=1
</span><span class='line'>walletnotify=/usr/bin/python3 /xxx.py</span></code></pre></td></tr></table></div></figure>


<p>另外<code>getaddressesbyaccount</code>即将废弃，可以使用<code>getaddressesbylabel</code>代替</p>

<p><code>signrawtransaction</code>即将废弃，实在要用的话只能在启动命令行中加deprecatedrpc指定。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/bitcoind --conf=/xxx/bitcoin.conf --datadir=/xxx/blockdata/mainnet --deprecatedrpc=signrawtransaction</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
