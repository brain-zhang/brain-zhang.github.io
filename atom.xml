<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Living a Simple Life is a Happy Life]]></title>
  <link href="http://happy123.me/atom.xml" rel="self"/>
  <link href="http://happy123.me/"/>
  <updated>2018-02-12T21:41:26+08:00</updated>
  <id>http://happy123.me/</id>
  <author>
    <name><![CDATA[memoryboxes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[比特币POW难度调节分析]]></title>
    <link href="http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi/"/>
    <updated>2018-02-12T20:50:34+08:00</updated>
    <id>http://happy123.me/blog/2018/02/12/bi-te-bi-pownan-du-diao-jie-fen-xi</id>
    <content type="html"><![CDATA[<p>比特币白皮书在工作量证明章节中解释了工作量证明（PoW）的方式：</p>

<blockquote><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p></blockquote>

<p>那这个随机数难度值是怎么产生的呢？</p>

<!-- more -->


<p>原理是简单的，但是细节总是需要穷根究底。</p>

<h2>比特币难度值Difficulty</h2>

<p>难度值在区块中并不记录，仅仅是为了人类直观感受解题难度而演变出的一个浮点数。难度每2016个区块改变一次，公式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diffculty = difficulty_1_target / currentTarget</span></code></pre></td></tr></table></div></figure>


<p>此处的 difficulty_1_target 为一个常数，非常大的一个数字。表示矿池挖矿最大难度。目标值越小，区块生成难度越大。区块中存储的是这个名为target的值。</p>

<h2>难度值如何存储在区块中的</h2>

<p>在区块中存储的是Target，但是将Target经类似于浮点数的一种压缩表示法，字段为nbits。例如，如果区块bits记录为0x1b0404cb，那么他表示的十六进制的Target值为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000</span></code></pre></td></tr></table></div></figure>


<h3>在计算时，后面3个字节0x0404cb作为底，前面1字节0x1b表示次方数。具体压缩过程如下：</h3>

<ul>
<li><p>将数字转换为256进制数</p></li>
<li><p>如果第一位数字大于127(0x7f),则前面添加0</p></li>
<li><p>压缩结果中的第一位存放该256进制数的位数</p></li>
<li><p>后面三个数存放该256进制数的前三位，如果不足三位，则后面补零</p></li>
</ul>


<h4>例如，将数字1000压缩，先转换为256进制数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1000 = 0x03 * 256 + 0xe8 * 1</span></code></pre></td></tr></table></div></figure>


<p>那么是由两个数字构成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>03   e8</span></code></pre></td></tr></table></div></figure>


<p>第一个数未超过0x7f,则不需填0，但长度两位低于三位，在后面补零，最终表示为：0x0203e800</p>

<h3>等等，我有点晕了，为什么要采取这种绕弯的存储方式呢?</h3>

<ol>
<li>比特币的工作量证明本质是计算一个256bits的hash值，并保证这个值小于target，表示为公式如下:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SHA256(SHA256(区块头)) &lt; Target</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>初始Target(即difficulty_1_target)设置为0x00000000FFFF0000000000000000000000000000000000000000000000000000，此时难度为1</p></li>
<li><p>Target是一个256位的很大的数，对这个数进行乘除运算需要特殊的库来处理，所以中本聪考虑用一个32位的数来近似表示Target</p></li>
<li><p>256 / 32 = 8, 2<sup>8</sup> = 256，因此我们需要用256进制来表示Target，256进制的运算规则如上所述</p></li>
<li><p>那么初始Target其实可以表示为0x1d00FFFFFF，解压验证一下:</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00ffff *256** (0x1d - 3)  = ff ff 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></code></pre></td></tr></table></div></figure>


<ol>
<li>0x1d00FFFFFF 这个值可以称为nbits，就是存储在区块中的原始值，通过nbits可以推算当前Target，通过当前Target及初始Target可以推算当前难度</li>
</ol>


<h2>难度如何调节</h2>

<p>目标值计算公式如下，但在实际计算时有些特别处理，将目标值控制在一定范围内。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>新目标值= 当前目标值 * 实际2016个区块出块时间 / 理论2016个区块出块时间(2周)。 </span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>判断是否需要更新目标值( 2016的整数倍)，如果不是则继续使用最后一个区块的目标值</p></li>
<li><p>计算前2016个区块出块用时</p></li>
<li><p>如果用时低于半周，则按半周计算。防止难度增加4倍以上。</p></li>
<li><p>如果用时高于8周，则按8周计算。防止难度降低到4倍以下。</p></li>
<li><p>用时乘以当前难度, 再除以2周</p></li>
<li><p>如果超过最大难度限制，则按最大难度处理</p></li>
</ol>


<p>代码参考这里:</p>

<p><a href="https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857">https://github.com/memoryboxes/bitcoin/blob/a1c3d8f14dca6a86fa103d86ef125e95372f860c/src/main.cpp#L857</a></p>

<h2>知道nbits，如何推算全网算力</h2>

<ol>
<li>nbits为0x1b0404cb时，难度为：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFF0000000000000000000000000000000000000000000000000000 / 0x00000000000404CB000000000000000000000000000000000000000000000000 = 16307.420938523983</span></code></pre></td></tr></table></div></figure>


<ol>
<li>为了找到新区块，该区块的target值必须小于目标target值，实际上是一个在0到2<sup>256</sup>-1之间的随机数，难度1的偏移量是：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0xffff * 2^208</span></code></pre></td></tr></table></div></figure>


<ol>
<li>难度D的偏移量是</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(0xffff * 2^208)/D</span></code></pre></td></tr></table></div></figure>


<ol>
<li>在难度D下，为了找到新区块，我们预期要计算的HASH数量是</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>D * 2^256 / (0xffff * 2^208)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>难度的设定，是为了以每10分钟一个区块的产生速度产生2016个区块，因而我们在600秒内计算 (D * 2<sup>48</sup> / 0xffff) 个HASH，这就意味着产生2016个区块的网络HASH速率(算力)是</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>D * 2^48 / 0xffff / 600</span></code></pre></td></tr></table></div></figure>


<p>可以进一步简化为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>D * 2^32 / 600</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>2018-02-12 21:00:00(UTC+8), 难度值D为2,874,674,234,415; 此时全网算力为20.75EH</p></li>
<li><p>如果我有一台蚂蚁S9，算力13T，那么一个区块周期(10分钟)的期望收益为12.5 * 13T / 20.75EH BTC</p></li>
</ol>


<h2>一点小TIP</h2>

<ul>
<li>难度为1时，目标target在比特币客户端中表示为</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFF0000000000000000000000000000000000000000000000000000</span></code></pre></td></tr></table></div></figure>


<p>但是在绝大部分矿池里面表示为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></code></pre></td></tr></table></div></figure>


<p>这样挖矿的时候，挖矿软件显示的难度和比特币客户端api调用算出来的难度有微小差别，可以忽略。这个其实时早期矿池实现的时候找方便造成的不统一，因为比特币客户端判断HASH合法性的时候用的时nbits来判断，所以不影响最终计算结果</p>

<ul>
<li>现有的算法中，难度值每2016个区块调整一次，但新的难度值不需要与难度“1”进行比较运算，而是根据前2015个块的出块时间来计算，所以严谨的计算公式为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>difficulty = [prev_target] * 【前2015个区块生成所用的时间】 / 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数）</span></code></pre></td></tr></table></div></figure>


<p>为啥？就是中本聪早期的代码比较糙，他在循环的时候因为还有一个genius block要处理，可能为了代码干净起见就不去特殊处理了，其实也没啥影响</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[央行抵押补充贷款PSL浅析]]></title>
    <link href="http://happy123.me/blog/2018/02/02/yang-xing-di-ya-bu-chong-dai-kuan-pslqian-xi/"/>
    <updated>2018-02-02T22:38:15+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/yang-xing-di-ya-bu-chong-dai-kuan-pslqian-xi</id>
    <content type="html"><![CDATA[<p>看到一则新闻，山东取消了货币化安置奖励，美其名曰控制房价，其实想想就明白是政府余粮不足了，房价飞涨，补贴不能。</p>

<p>老家这里的棚户改造轰轰烈烈搞了两年了，货币化安置的效果非常显著，周边的房价一个劲往上涨。我就有点纳闷了，这个货币化安置的钱是从哪儿来的呢？</p>

<!-- more -->


<p>央行在2014年推出的PSL（抵押补充贷款）创新性政策工具，部分解决了棚改货币化安置的资金问题。央行通过PSL向国开行发放贷款，国开行通过棚改专项贷款向地方政府发放贷款，地方政府通过货币化安置向棚户区居民发放补偿款，地方政府拆迁卖地后偿还国开行贷款，国开行偿还央行贷款，形成资金流的闭环。</p>

<p>我查了一下资料，问题来了:</p>

<ul>
<li><p>开行是把什么抵押给央行了？是只能抵押棚改专项贷款，还是国债、开行债、扶贫贷款、小微企业贷款之类的都可以?</p></li>
<li><p>PSL利率怎么设定？央行指定还是市场化？</p></li>
<li><p>如何监控PSL的投向，并防止利差套利。</p></li>
<li><p>开行用什么方式来偿还PSL贷款？</p></li>
</ul>


<h2>最重要的是，这是不是放水？</h2>

<p>又学习了一下基本金融知识，发现一个比较权威的解释:</p>

<p>国信证券宏观经济分析师钟正生认为，这一工具最大突破在于，将商业银行贷款纳入用于基础货币投放的合格抵押品框架，从而摆脱再贷款的信用风险问题，打造一个常规的基础货币投放渠道。央行投放基础货币需要同时扩张资产方和负债方，而为了保证央行资产的安全性，央行一般会要求交易对手提供抵押品并进行风险评估。而合格抵押品意味着受到央行认可的，可在货币政策工具中用于抵押给央行的资产，例如我国正逆回购以及SLO、SLF操作中，一般使用国债和政策性金融债作为合格抵押品。我们在之前报告中提及，外汇占款趋势下滑，央票自然到期萎缩背景下，央行需要重启再贷款作为弥补基础货币缺口的手段。其主要原因在于，央行缺乏合适的抵押品，用于大规模基础货币的投放。而再贷款是信用贷款，不需要抵押。但吊诡的是，无需抵押既是再贷款的突出优点，也是再贷款的局限所在。无抵押会带来信用风险问题，央行资产有可能会遭受损失，历史上由于再贷款在央行账目上产生坏账的案例并不鲜见。因此，我们一直认为，短期内再贷款可以充当提供基础货币的过渡职能，但长期来看仍需完善央行的合格抵押品框架。现在看起来，PSL可能正是在央行在完善合格抵押品框架上作出的重要推进。</p>

<p>然后我又脑补为通俗版:</p>

<ul>
<li><p>央行采用外汇占款发行人民币的老路子越来越难了，美国加息，外汇流出压力大啊。</p></li>
<li><p>现在我要以国内资产来定价发行货币了</p></li>
</ul>


<h4>好吧，看起来这不是放水，顶多可以称之为定向宽松。那么是不是就不用紧张通胀了呢？</h4>

<p>完全不是！</p>

<p>类比一下，这其实是股市里面的一种对敲手法。</p>

<p>央行最终收下的抵押品不外乎还是地方财政的资产，那地方财政最大的抵押资产是什么呢？还是土地。</p>

<p>发出去的货币标的其实就是不断推升的地价。</p>

<p>这下好了，其实是央行和地方政府联手对敲，把地价炒高了，还多出来一种发行货币的手段，顺便把高杠杆风险转给平头百姓，一箭三雕啊。</p>

<p>兴，百姓苦；亡，百姓苦</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coincheck被盗5亿个XEM]]></title>
    <link href="http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem/"/>
    <updated>2018-02-02T21:16:43+08:00</updated>
    <id>http://happy123.me/blog/2018/02/02/coincheck-bei-dao-5-yi-ge-xem</id>
    <content type="html"><![CDATA[<p>2018-01-26,Coincheck 被盗 5 亿个 XEM, 这个数目估计是史上最大了，hacker 的账户地址是这里:</p>

<p><a href="http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG">http://explorer.ournem.com/#/s_account?account=NC4C6PSUW5CLTDT5SXAGJDQJGZNESKFK5MCN77OG</a></p>

<p>按照 coinmarketcap 的市场价来算，现在 5 亿个 XEM 价值大概 4 亿美元</p>

<p>另外可能是 coincheck 自己的防护，他们的 Ripple 钱包也有一笔大额的转账:</p>

<p><a href="https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8">https://xrpcharts.ripple.com/#/transactions/FC32DBF1C0CE6780A669349FEDF7BD9EC18033EB79B3DC8F1ADBAE9B5EAD3EF8</a></p>

<p>有将近 1 亿个 xrp 转账到了一个地址，这个地址貌似有 30 亿个 xrp.</p>

<p>这笔转账可能是 coincheck 正在审计，不是 hack 行为。</p>

<p>除去 MTGOX 那次，Coincheck 的这次悲剧不论数量还是市场价格估计都是史上最强了</p>

<p>2018-01-28, Coincheck公布了补偿措施</p>

<p><a href="http://corporate.coincheck.com/2018/01/28/30.html">http://corporate.coincheck.com/2018/01/28/30.html</a></p>

<p>共损失 52300,0000 个 XEM，按照被偷时的币值返还，每个币 88 日元</p>

<p>额，貌似总额超过 25 亿人民币了</p>

<p>最奇怪的是，直到2018-02-01，市场才起了反应，开始下跌。</p>

<p>这个赌博的场子越来越让人看不懂了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block Chain White Papers]]></title>
    <link href="http://happy123.me/blog/2018/01/09/block-chain-white-papers/"/>
    <updated>2018-01-09T16:42:45+08:00</updated>
    <id>http://happy123.me/blog/2018/01/09/block-chain-white-papers</id>
    <content type="html"><![CDATA[<h2>比特币白皮书</h2>

<h4>中文版</h4>

<p><a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a></p>

<h4>英文版</h4>

<p><a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></p>

<h2>以太坊白皮书</h2>

<h4>中文版</h4>

<p><a href="http://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6">http://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6</a></p>

<h4>英文版</h4>

<p><a href="https://github.com/ethereum/wiki/blob/master/drafts/%5Benglish%5D-old-ethereum-whitepaper.md">https://github.com/ethereum/wiki/blob/master/drafts/%5Benglish%5D-old-ethereum-whitepaper.md</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NiceHash被盗]]></title>
    <link href="http://happy123.me/blog/2017/12/07/nicehashbei-dao/"/>
    <updated>2017-12-07T13:13:52+08:00</updated>
    <id>http://happy123.me/blog/2017/12/07/nicehashbei-dao</id>
    <content type="html"><![CDATA[<p>Nicehash 被盗 4700+币</p>

<p>比 bitfinex 要幸运一点，这次发现的比较早，但是按照现在的币价大涨来算，损失也超过了 6000w USD，上次 bitfinex 11w 币不过折合 7000w USD 而已。</p>

<p><a href="https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/">https://www.reddit.com/r/NiceHash/comments/7i0s6o/official_press_release_statement_by_nicehash/</a></p>

<p>这个是 hacker 的转入地址:</p>

<p><a href="https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq">https://btc.com/1EnJHhq8Jq8vDuZA5ahVh6H4t6jh1mB4rq</a></p>

<p>最早的一笔交易发生在 2017-12-06 13:17:12(UTC+8)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrate Firewalld to Iptables on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/12/06/migrate-firewalld-to-iptables-on-centos7/"/>
    <updated>2017-12-06T16:23:22+08:00</updated>
    <id>http://happy123.me/blog/2017/12/06/migrate-firewalld-to-iptables-on-centos7</id>
    <content type="html"><![CDATA[<h2>关闭 FireWall</h2>

<pre><code>systemctl stop firewalld.service #停止firewall
systemctl disable firewalld.service #禁止firewall开机启动
</code></pre>

<h2>安装 iptables</h2>

<pre><code>yum install iptables-services
</code></pre>

<!-- more -->


<h2>配置 iptables</h2>

<pre><code>#!/bin/bash

IF="eth0"

#清除规则
/sbin/iptables -F
/sbin/iptables -X
/sbin/iptables -Z

# 预定义策略
/sbin/iptables -A INPUT -s 127.0.0.1 -j ACCEPT  # 允许回环接口可以被访问
/sbin/iptables -P INPUT   DROP # 默认是拒绝访问
/sbin/iptables -P OUTPUT  ACCEPT  # 允许本机访问其他机器，无限制
/sbin/iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
/sbin/iptables -A INPUT -p icmp -j ACCEPT # 允许ping


#允许的本机服务
/sbin/iptables -A INPUT -p TCP -i $IF --dport 22 -j ACCEPT        # SSH
# /sbin/iptables -A INPUT -p TCP -i $IF --dport  3306 -j ACCEPT        # mysql
/sbin/iptables -A INPUT -p TCP -i $IF --dport  80 -j ACCEPT        # web
/sbin/iptables -A INPUT -p TCP -i $IF --dport  8888 -j ACCEPT        # web

# 黑名单
#/sbin/iptables -A INPUT -s 1.1.1.0/24 -j DROP
#/sbin/iptables -A INPUT -s 1.1.1.0 -j DROP

# 信任的网络和IP
/sbin/iptables -A INPUT -s 1.1.1.1/24 -j ACCEPT # 信任的网络

# 保存配置
/usr/libexec/iptables/iptables.init save
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Penetrate GFW With ShadowSocks Docker Container on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/12/04/how-to-penetrate-gfw-with-shadowsocks-docker-container-on-centos7/"/>
    <updated>2017-12-04T20:23:40+08:00</updated>
    <id>http://happy123.me/blog/2017/12/04/how-to-penetrate-gfw-with-shadowsocks-docker-container-on-centos7</id>
    <content type="html"><![CDATA[<p>The quickest way to Penetrate GFW With ShadowSocks(Docker Container) On Centos7.</p>

<h2>Install Docker CE</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo yum install -y yum-utils   device-mapper-persistent-data  lvm2
</span><span class='line'>$ sudo yum-config-manager    --add-repo     https://download.docker.com/linux/centos/docker-ce.repo
</span><span class='line'>$ sudo yum install docker-ce</span></code></pre></td></tr></table></div></figure>


<h2>start  docker</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo systemctl start docker</span></code></pre></td></tr></table></div></figure>


<h2>pull shadowsocks container</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker pull oddrationale/docker-shadowsocks</span></code></pre></td></tr></table></div></figure>


<h2>start shadowsocks service</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -d -p 1984:1984 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1984 -k $SSPASSWORD -m aes-256-cfb</span></code></pre></td></tr></table></div></figure>


<p>You can configure the service to run on a port of your choice. Just make sure the port number given to Docker is the same as the one given to shadowsocks. Also, it is highly recommended that you store the shadowsocks password in an environment variable as shown above. This way the password will not show in plain text when you run docker ps.</p>

<p>For more command line options, refer to the <a href="https://github.com/shadowsocks/shadowsocks/tree/master">shadowsocks documentation</a></p>

<h2>windows Client</h2>

<p>Client is the machine you want to bypass the GFW.</p>

<p>Download the client package <a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Shadowsocks-win-latest-release</a>, extract it, and run.</p>

<p>You can check its “System Proxy” option, which is convenient for all browsers and terminal.</p>

<h2>now enjoy it</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Game Theory]]></title>
    <link href="http://happy123.me/blog/2017/12/04/game-theory/"/>
    <updated>2017-12-04T17:39:24+08:00</updated>
    <id>http://happy123.me/blog/2017/12/04/game-theory</id>
    <content type="html"><![CDATA[<p>看网易公开课的博弈论，很有意思，记下笔记:</p>

<h2>导论-五个入门结论</h2>

<ol>
<li><p>don’t play a strictly dominated strategy</p></li>
<li><p>rational choice in case lead to outcomes suck</p></li>
<li><p>you can’t get what you want ,till you know what you want</p></li>
<li><p>put yourself in others’ shoes and try to figure out what they will do</p></li>
<li><p>most people are evil</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Config Samba Config With No Password Share]]></title>
    <link href="http://happy123.me/blog/2017/12/03/how-to-config-samba-config-with-no-password-share/"/>
    <updated>2017-12-03T09:49:15+08:00</updated>
    <id>http://happy123.me/blog/2017/12/03/how-to-config-samba-config-with-no-password-share</id>
    <content type="html"><![CDATA[<p>年老记忆力下降，做了N+1遍了，还是忘。</p>

<h2>卸载干净</h2>

<pre><code>apt-get purge samba
rm -rf /etc/samba /etc/default/samba
</code></pre>

<h2>重装</h2>

<pre><code>apt-get install samba
</code></pre>

<h2>配置</h2>

<pre><code>vim /etc/samba/smb.conf


[share_name]
public = yes
browseable = yes
path = /home
guest ok = yes
read only = no
writeable = yes
create mask = 0644
directory mask = 2777
</code></pre>

<h2>重启</h2>

<pre><code>systemctl restart smbd
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Http Referer 的盗链与反盗链]]></title>
    <link href="http://happy123.me/blog/2017/10/31/http-referer-de-dao-lian-yu-fan-dao-lian/"/>
    <updated>2017-10-31T21:47:27+08:00</updated>
    <id>http://happy123.me/blog/2017/10/31/http-referer-de-dao-lian-yu-fan-dao-lian</id>
    <content type="html"><![CDATA[<p>HTTP的图片防盗链技术基本上人民群众喜闻乐见了。 今天突然发现一种比较通用的隐藏referer来反盗链的hack手段，记录之。</p>

<p>简单来说，Referer是HTTP协议中的一个请求报头，用于告知服务器用户的来源页面。比如说你从Google搜索结果中点击进入了某个页面，那么该次HTTP请求中的Referer就是Google搜索结果页面的地址。</p>

<p>一般Referer主要用于统计，像CNZZ、百度统计等可以通过Referer统计访问流量的来源和搜索的关键词（包含在URL中）等等，方便站长们有针性对的进行推广和SEO什么的~</p>

<p>当然Referer另一个用处就是防盗链了，主要是图片和网盘服务器使用的较多。盗链的危害不言而喻，侵犯了版权不说，增加了服务器的负荷，却没有给真正的服务提供者带来实际利益（广告点击什么的）</p>

<p>另外要注意的是，Referer是由浏览器自动为我们加上的，以下情况是不带Referer的</p>

<ul>
<li><p>直接输入网址或通过浏览器书签访问</p></li>
<li><p>使用JavaScript的Location.href或者是Location.replace()</p></li>
<li><p>HTTPS等加密协议</p></li>
</ul>


<p>很多网站挟持脚本一般是注入https链接来隐藏referer，这样固然好用，但是一定要一个域名，有点不方便。前人实践发现只要在iframe里面的src属性填上 <code>javascript: &lt;html&gt;....</code>的内容就可以隐藏referer了。一试果然如此。</p>

<p>比如大家常见的微信公众号文章，如果引用过来，一般就是防盗链了，这个时候可以用下面的通用代码解决：</p>

<ul>
<li>需要引用jquery和 <a href="https://github.com/jpgerek/referrer-killer">ReferrerKiller.js</a> 这两个库:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   jQuery(function() {
</span><span class='line'>       //遍历所有的img元素，凡是QQ和微信引用的统统放到iframe里面
</span><span class='line'>       jQuery("div").find("img").each(function() {
</span><span class='line'>           var img = jQuery(this);
</span><span class='line'>           var img_src = img.attr("src");
</span><span class='line'>           if (img_src != undefined && img_src != '') {
</span><span class='line'>               img_src = decodeURI(img_src);
</span><span class='line'>               img_src = img_src.split("?")[0];
</span><span class='line'>               if (img_src.indexOf("qpic.cn") &gt; 0 || img_src.indexOf("qlogo.cn") &gt; 0 || img_src.indexOf("qq.com") &gt; 0) {
</span><span class='line'>                   var frameid = 'frameimg' + Math.random();
</span><span class='line'>                   img.parent().append('&lt;span id="' + frameid + '"&gt;&lt;/span&gt;')
</span><span class='line'>                   img.remove();
</span><span class='line'>                   document.getElementById(frameid).innerHTML = ReferrerKiller.imageHtml(img_src);
</span><span class='line'>               }
</span><span class='line'>           }
</span><span class='line'>       })
</span><span class='line'>   })</span></code></pre></td></tr></table></div></figure>


<p>这样看出来的效果就是原来引用微信的图片:</p>

<pre><code>&lt;img src="http://mmbiz.qpic.cn/mmbiz/cfxQzmUp8b0E12wMVv6SzROhSAgmxENxKPSQibVNhXAx8vr3BQW1lnlakR8wDVLc38QSZwnRfiaDtPZ0d3PhBMtQ/640?"/&gt;
</code></pre>

<p>就会被替换到iframe里面，同时iframe的src属性包括了完整的html内容，这样浏览器请求图片的时候，就不会带referrer了，微信的盗链就被绕过。</p>

<p>不知道微信啥时候堵上这个洞呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Btc UAHF]]></title>
    <link href="http://happy123.me/blog/2017/08/01/btc-uahf/"/>
    <updated>2017-08-01T22:11:54+08:00</updated>
    <id>http://happy123.me/blog/2017/08/01/btc-uahf</id>
    <content type="html"><![CDATA[<p>UTC时间 2017-08-01 18:12，UAHF<a href="https://blockchair.com/bitcoin-cash/block/478559">第一个大于1MB的块</a>被挖出，虽然现在算力占比很小，但值得关注，UAHF是否能存活下去，算力来决定吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Local Repo by Iso]]></title>
    <link href="http://happy123.me/blog/2017/06/06/set-local-repo-by-iso/"/>
    <updated>2017-06-06T22:15:22+08:00</updated>
    <id>http://happy123.me/blog/2017/06/06/set-local-repo-by-iso</id>
    <content type="html"><![CDATA[<p>想要挂载一个iso安装镜像作为本地repo</p>

<h2>mount iso</h2>

<pre><code>mkdir -p /mnt/cdrom
mount -t iso9660 -o loop /home/Centosxxxx.iso /mnt/cdrom
</code></pre>

<h2>set local repo</h2>

<pre><code>vi /etc/yum.repos.d/local.repo

[localrepo]
name=Unixmen Repository
baseurl=file:///mnt/cdrom
gpgcheck=0
enabled=1
</code></pre>

<h2>set up</h2>

<pre><code>yum clean all
yum repolist
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy Local Ntp Server on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/06/06/deploy-local-ntp-server-on-centos7/"/>
    <updated>2017-06-06T21:20:35+08:00</updated>
    <id>http://happy123.me/blog/2017/06/06/deploy-local-ntp-server-on-centos7</id>
    <content type="html"><![CDATA[<p>有时候需要内网环境搭建一个ntp服务器同步内网的几台机器。</p>

<p>四步走:</p>

<h2>安装ntpd</h2>

<pre><code>yum -y install ntp ntpdate
</code></pre>

<h2>修改/etc/ntpd.conf</h2>

<pre><code># line 18: add the network range you allow to receive requests
restrict 10.0.0.0 mask 255.255.255.0 nomodify notrap

# local clock
server 127.127.1.0
fudge  127.127.1.0 stratum 10
</code></pre>

<h2>重启</h2>

<pre><code>systemctl start ntpd
systemctl enable ntpd
firewall-cmd --add-service=ntp --permanent
firewall-cmd --reload
</code></pre>

<h2>瞄一眼</h2>

<pre><code>watch ntpq -p
</code></pre>

<p>注意reach这个值，在启动ntp server服务后，这个值就从0开始不断增加，当增加到17的时候，从0到17是5次的变更，每一次是poll的值的秒数，是64秒*5=320秒的时间。</p>

<p>如果之后从ntp客户端同步ntp server还失败的话，用ntpdate –d来查询详细错误信息，再做判断。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Update to gcc4.9.x on Centos7]]></title>
    <link href="http://happy123.me/blog/2017/04/15/how-to-update-to-gcc4-dot-9-x-on-centos7/"/>
    <updated>2017-04-15T15:50:53+08:00</updated>
    <id>http://happy123.me/blog/2017/04/15/how-to-update-to-gcc4-dot-9-x-on-centos7</id>
    <content type="html"><![CDATA[<p>现在很多软件包默认编译要求GLIBCXX >=3.4.20，碰到这种事redhat系又哭了，目前Centos7.x默认仓库里的gcc还是4.8.5的，所以需要一个办法升级gcc相关组件>=4.9.1。</p>

<p>CentOS下升级gcc版本有两个途径，一个是添加其他源进行自动升级，一个是手动编译升级，这里先顺便讲下自动升级的两个办法：</p>

<h3>添加Fedora源</h3>

<p>在 /etc/yum.repos.d 目录中添加文件 FedoraRepo.repo ，并输入以下内容:</p>

<pre><code>[warning:fedora]
name=fedora
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch
enabled=1
gpgcheck=1
gpgkey=https://getfedora.org/static/34EC9CBA.txt
</code></pre>

<p>然后执行</p>

<pre><code>yum update gcc gcc-c++
</code></pre>

<h3>使用Devtoolset-4升级</h3>

<pre><code>yum install centos-release-scl
yum install devtoolset-4-gcc*
scl enable devtoolset-4 bash
which gcc
gcc --version
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migarate Duoshuo to Disqus]]></title>
    <link href="http://happy123.me/blog/2017/03/26/migarate-duoshuo-to-disqus/"/>
    <updated>2017-03-26T15:27:11+08:00</updated>
    <id>http://happy123.me/blog/2017/03/26/migarate-duoshuo-to-disqus</id>
    <content type="html"><![CDATA[<p>没有盈利前景的产品死掉了，话说disqus是怎么活的?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ant Pool Support Bitcoin Ulimited]]></title>
    <link href="http://happy123.me/blog/2017/03/07/ant-pool-support-bitcoin-ulimited/"/>
    <updated>2017-03-07T21:58:17+08:00</updated>
    <id>http://happy123.me/blog/2017/03/07/ant-pool-support-bitcoin-ulimited</id>
    <content type="html"><![CDATA[<p>比特币诞生8年来最大波澜即将到来，大家拭目以待。
{:.info}</p>

<p>北京时间2017年3月7日凌晨2点半左右，当前比特币全网算力排名第一的矿池蚁池（AntPool）的某个节点通过替代版比特币软件Bitcoin Unlimited（BU）挖到了一个<a href="https://btc.com/00000000000000000204cd2c9840023f1434f3dcdd7f471e4b8c8638d14d7006">新区块</a>，这标志着蚁池正式向Bitcoin Unlimited（BU）开放投票。</p>

<p>目前蚁池的算力占全网算力的13%左右，加上已有的支持BU的算力，BU支持率达到30%以上。</p>

<p>也许未来一个月很快就会发生一些有趣的事情，这是Bitcoin系统运行8年来的最大波澜。</p>

<p>大家拭目以待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Pyinstaller打包python脚本适配windows]]></title>
    <link href="http://happy123.me/blog/2017/02/14/yong-pyinstallerda-bao-pythonjiao-ben-gua-pei-windows/"/>
    <updated>2017-02-14T16:13:52+08:00</updated>
    <id>http://happy123.me/blog/2017/02/14/yong-pyinstallerda-bao-pythonjiao-ben-gua-pei-windows</id>
    <content type="html"><![CDATA[<p>一行命令的事，纯python脚本打包出来一般5Mb左右，大小还可以接收。</p>

<p>首先在脚本同目录下加入一个pyinstaller.py:</p>

<pre><code>#!/usr/bin/env python
from PyInstaller.__main__ import run
run()
</code></pre>

<p>然后执行:</p>

<pre><code>python pyinstaller.py -c -F &lt;xxxx.py&gt; -p &lt;sdk&gt;
</code></pre>

<ul>
<li>&lt;xxxx.py> 为脚本名称</li>
<li><sdk> 为三方包目录</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python在windows CMD中输出中文]]></title>
    <link href="http://happy123.me/blog/2017/02/14/pythonzai-windows-cmdzhong-shu-chu-zhong-wen/"/>
    <updated>2017-02-14T16:06:12+08:00</updated>
    <id>http://happy123.me/blog/2017/02/14/pythonzai-windows-cmdzhong-shu-chu-zhong-wen</id>
    <content type="html"><![CDATA[<p>在windows CMD中输出中文是比较烦的事情，最简单的就是增加一个windows.py，用的时候import一下:</p>

<pre><code>#!/usr/bin/env python
#  -*- coding: utf-8 -*-
import sys

class UnicodeStreamFilter:
    def __init__(self, target):
        self.target = target
        self.encoding = 'utf-8'
        self.errors = 'replace'
        self.encode_to = self.target.encoding
    def write(self, s):
        if type(s) == str:
            s = s.decode("utf-8")
        s = s.encode(self.encode_to, self.errors).decode(self.encode_to)
        self.target.write(s)

if sys.stdout.encoding == 'cp936':
    sys.stdout = UnicodeStreamFilter(sys.stdout)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[加密技术发展]]></title>
    <link href="http://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan/"/>
    <updated>2016-12-25T16:54:47+08:00</updated>
    <id>http://happy123.me/blog/2016/12/25/jia-mi-ji-zhu-fa-zhan</id>
    <content type="html"><![CDATA[<p>比特币是建立在区块链基础上的，区块链的基本技术支撑有三个:</p>

<ul>
<li><p>非对称加密</p></li>
<li><p>点对点网络技术</p></li>
<li><p>HASH现金</p></li>
</ul>


<p>其中非对称加密和HASH现金技术的历史发展颇有渊源，最近仔细学习了一下密码学科普知识，总结一下。</p>

<!-- more -->


<h2>历史回溯</h2>

<p>虽然加密和解秘是人类诞生以来一直上演的剧目，方法也是形形色色，但到现在为止，可以简单归纳为两个历史阶段:</p>

<h3>1976年之前</h3>

<p>1976年以前，所有的加密算法，模式是一样的:</p>

<ul>
<li><p>甲方选择某一种加密规则，对信息进行加密</p></li>
<li><p>乙方使用同一种规则，对信息进行解密</p></li>
</ul>


<p>这时候所有的加解密都是在规则上下文章，主要有两大流派，隐写术和密码术。</p>

<p>隐写术就是利用隐形墨水之类的秘密传递手段，缺点显而易见，比如在很多小说里描述的火烤显形的段子。</p>

<p>密码术相对比较主流，最基本的是&#8221;替换&#8221;和&#8221;移位&#8221;两种方法，</p>

<h4>替换法</h4>

<p>即用一个字母表来替换明码字母的方法，举例:</p>

<p>明码表: a b c d e f g h i j k l m n o p q r s t u v w x y z</p>

<p>密码表: D E F G H I J K L M N O P Q R S T U V W X Y Z A B C</p>

<p>明文:   v e n i, v i d i, v i c i</p>

<p>密文:   Y H Q L, Y L G L, Y L F L</p>

<p>上面这个简单的加密就来自于鼎鼎大名的凯撒加密。当然实际没这么简单，但原理就是这么回事。</p>

<h4>移位法</h4>

<p>即制定一系列规则，对明文进行移位交换获得密文， 举例:</p>

<p>相邻两个字符互换形成密文:</p>

<p>明文:   v e n i, v i d i, v i c i</p>

<p>密文:   e v i n, i v i d, i v i c</p>

<p>在1976年之前，大家用的最多的就是这两种方法交替多次加密，比如有多个密码表多次映射，多个移位变换规则进行多次变换等等</p>

<p>大家熟知的<a href="https://zh.wikipedia.org/zh-hans/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">DES加密算法</a>就是此类古典加密算法的顶峰，当然，现在已经由于安全问题不被推荐了。</p>

<p>上千年间，大家围绕这些基础手段斗智斗力，但始终有个缺陷无法解决：</p>

<h4>如何把加密规则和密码表安全的通知对方?</h4>

<p>用现代密码学里面的一个<a href="https://zh.wikipedia.org/wiki/%E6%84%9B%E9%BA%97%E7%B5%B2%E8%88%87%E9%AE%91%E4%BC%AF">经典譬喻</a>来描述一下:</p>

<ul>
<li><p>Alice和Bob是朋友，他们的住处离得比较远，Alice想要发送一则隐私消息给Bob</p></li>
<li><p>Eve想要窃听Alice和Bob的通信，Alice和Bob无法防止Eve的偷看</p></li>
<li><p>Alice把信放在一个盒子里，她上了锁，让邮差发给Bob，Eve没有钥匙，无法打开盒子，但是Bob也无法打开</p></li>
</ul>


<p>那么问题来了，Alice如何把钥匙发给Bob呢？</p>

<p>古典密码术的所有问题，在于密钥分发的问题，而且看起来这个问题和“先有蛋还是先有鸡”的问题一样，是无解的:</p>

<p>Alice要安全的给Bob钥匙，就得放在加锁的盒子里，但是要打开盒子，就需要钥匙。</p>

<h3>1976年之后</h3>

<p>当然，世上的无奈，除了马云不能灌篮这类事情外，大部分都是能解决的。</p>

<p>在我们想出解决办法之前，先放一张拽拽的图片镇楼:</p>

<p><img src="https://raw.githubusercontent.com/memoryboxes/memoryboxes.github.io/source/images/201612/bg1.jpg" alt="非对称加密发明人" /></p>

<p>左边的Whtfield Diffie是早期的Geek典范，看看他迷离的眼神，拽拽的发型，不羁的络腮胡&hellip;.等等等等，最让人生气的是他还有个善解人意的爱人~ ~</p>

<p>好，让我们再回到Alice和bob的情书问题上来，咳咳，不知道为什么变成Alice给Bob情书了~ ~ ~</p>

<p>现在设想这样一种解决手段:</p>

<ul>
<li><p>Alice把情书放到铁盒子里，上锁，发给Bob</p></li>
<li><p>Bob收到盒子，没有去想办法打开它，而是又加上了自己的一把锁，发回给Alice</p></li>
<li><p>Alice打开自己加的锁，发回给Bob</p></li>
<li><p>Bob打开自己的锁</p></li>
<li><p>可恶的Eve只能干生气了，好可怜啊</p></li>
</ul>


<p>哈，这证明了在我们的小譬喻里，分发密钥这个事情是可以安全解决的。1976年之前的人好笨啊，为什么不能这么搞呢？</p>

<p>少年，图样图僧破，在密码世界里，有一个重要的屏障：先进先出原则，就是先上锁的那个人，必须先打开锁。</p>

<p>???</p>

<p>你问我为什么会有这个屏障呢，我也说不明白啊，这是数学家们呕心沥血好多年也没解决的问题，嗯，少年，我看好你哦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GPU运算卡备存]]></title>
    <link href="http://happy123.me/blog/2016/12/18/gpuyun-suan-qia-bei-cun/"/>
    <updated>2016-12-18T15:38:18+08:00</updated>
    <id>http://happy123.me/blog/2016/12/18/gpuyun-suan-qia-bei-cun</id>
    <content type="html"><![CDATA[<p>科技产品的命名一很高冷，就是老发烧友，过了几年再来看新产品的名儿，仍有可能一头雾水。</p>

<p>这其中显卡命名尤甚，为了不把马良认成马超，留存一下。</p>

<p>从知乎上爬来一堆资料，先来备忘一下基础知识:</p>

<p>作者：老汤
链接：<a href="https://zhuanlan.zhihu.com/p/20585886">https://zhuanlan.zhihu.com/p/20585886</a></p>

<!-- more -->


<p>显卡有哪些？市面上的显卡又有哪些不同呢？</p>

<p>显卡由GPU和其他结构组成，那么不同的显卡的这两个部分固然是不同的。</p>

<h2>一、不同的显卡GPU有不同</h2>

<ol>
<li>GPU的品牌不同</li>
</ol>


<p>GPU是一种处理器，即一种超大规模的集成电路，其研发和设计非常复杂，反正不是每家公司都能干的。目前设计消费级GPU的三家企业为超微半导体（AMD）、英伟达（NVIDIA）和我们的老朋友英特尔（Intel）。AMD原本并不设计GPU，后来收购了冶天（ATI），才做起了GPU。</p>

<p>在国内，使用AMD GPU的显卡俗称A卡，使用NVIDIA GPU的就叫N卡，Intel GPU也可以叫做I卡，但由于Intel GPU全为核心显卡，这样叫的人比较少。</p>

<ol>
<li>GPU的性能不同</li>
</ol>


<p>GPU和CPU相似，是一种处理器，所以也有相似的常见参数如架构、制程、核心频率（单位为兆赫MHz，后面会详细讲）、功耗等。需要复习的同学请返回专栏首页或去我的公众号，点击关注，然后参考《DIY从入门到精通——CPU》中的有关内容！</p>

<p>GPU作为图形处理器，还有一些特殊的参数：</p>

<ul>
<li><p>显存类型：目前有SDDR3、DDR3、GDDR3和GDDR5四种，同容量的情况下性能依次增强；</p></li>
<li><p>显存位宽：GPU一个时钟周期内发送数据的位数，单位为bit，当然是越大越好的；</p></li>
<li><p>显存带宽：GPU的实际数据带宽，计算方法为显存带宽=显存频率*显存位宽/8；显存位宽是决定显卡性能的重要因素之一，越大越好；</p></li>
<li><p>3D API：是指与GPU对应的编程用应用程序，目前有DirectX和OpenGL，其中最重要的是显卡是否支持最新版本的DirectX。</p></li>
<li><p>辅助供电：主板的PCI-E 16x插槽可以为显卡提供电力，但有的GPU功耗较高，需要额外辅助供电。</p></li>
</ul>


<p>还有一堆越大越好的参数，比如晶体管数、流处理器数、纹理单元数、ROP单元数、N卡特有的CUDA Core数等等，这些参数都代表着GPU在不同方面的处理能力。</p>

<p>通过比较参数我们可以准确地判断一款GPU的性能。但为了方便，我们往往通过GPU的命名判断一款GPU的性能大概如何。下面就来简单无脑地说说GPU都是怎么命名的：</p>

<h3>AMD GPU</h3>

<p>分为HD系列和R系列。R系列于2013年底正式发布，取代HD系列。</p>

<h4>a. HD系列</h4>

<p>HD系列GPU姓HD，名为4位数字，可伴有后缀。</p>

<p>栗子：AMD HD 7970 x2</p>

<p>HD：HD系列；</p>

<p>第一位7：代数；这里为7代；代数的升级往往代表着架构和制程的升级，即一般情况下HD 7970相对HD6970有着较大的提升；</p>

<p>第二位9：定位；同一代下常分为7、8、9三级，分别指低、中、高端；这里的9即为高端；</p>

<p>第三位7：性能；同一定位下常分为3、5、7、9四挡，性能依次提升；这里的7即表示HD7970为HD79XX中性能第二强的GPU；</p>

<p>第四位0：基本无意义；</p>

<p>x2：后缀，这里代表双核心GPU，即一张显卡由两块GPU共同组成。若有后缀“M”表示为笔记本显卡。</p>

<p>于是我们可以判断任意一款HD系列的显卡究竟是哪个水平了，比如HD 8970M是HD系列8代高端显卡中性能最强（没有推出HD 8990M）的单核心笔记本GPU。</p>

<h4>b. R系列</h4>

<p>R系列GPU姓R加1位数字；名为3位数字，名前可伴有前缀，名后可伴有后缀；也有同姓R但名字特殊的型号，如R9 Fury、R9 Fury X、R9 Fury x2、R9 Nano等。</p>

<p>栗子：AMD R9 M290X</p>

<p>R：R系列；</p>

<p>加1位数字9：定位；共有5、7、9三级，分别指低、中、高端；这里R9表示R系列高端；</p>

<p>M：名前缀，表示笔记本GPU；</p>

<p>第一位2：代数，这里为2代。（注：R系列没有1代）</p>

<p>第二位9：性能；R5系列有3一档；R7系列分4、5、6三挡；R9系列有7、8、9三档，数字越大性能越强；这里9即为最强。</p>

<p>第三位0：基本无意义；有时代表性能，目前只有0、5两档，且仅存在于部分型号，如R9 295 x2。</p>

<p>X：名后缀，表示增强型号；若有后缀“x2”表示双核心。</p>

<p>至此我们可以判断几乎所有R系列的显卡是什么水平了，比如R7 340是R系列3代中端性能最弱（性能在3代中总排名倒数第2）的单核心台式机GPU。</p>

<h3>NVIDIA GPU</h3>

<p>NVIDIA GPU姓GT，姓后可紧接后缀；名为3位数字，名后可伴有后缀。也有姓GT但名字特殊的型号，多指Titan系列，如GTX Titan、GTX Titan X、GTX Titan Z、GTX Titan Black等。</p>

<p>栗子：NVIDIA GTX 980 TI</p>

<p>X：GT的后缀，代表性能更强；</p>

<p>9：代数；这里为9代；其中8代全线为笔记本GPU；</p>

<p>8：性能；分1到9共九档，这里的8代表第二强；</p>

<p>0：基本无意义；有时可代表性能，分为0、5两档，仅存在于部分型号如GTX 765M。</p>

<p>TI：后缀，表示增强型号；若后缀为“M”则为笔记本GPU。</p>

<p>我们一起来看看GTX 860M是啥玩意？没错，就是8代第6档性能的笔记本GPU。</p>

<h3>Intel GPU</h3>

<p>Intel GPU均为核心显卡，有HD和锐炬（Iris）两个系列。</p>

<h4>a. HD系列</h4>

<p>HD系列GPU姓HD，名为3位或4位数字，名前可伴有前缀。其中3位命名从Skylake开始沿用。另有最古老、性能最弱的一款为HD Graphics。</p>

<p>4位命名栗子：HD P4600</p>

<p>HD：HD系列；</p>

<p>P：前缀，表示企业版，性能上与民用版几乎无异；</p>

<p>4600：性能；基本上数字越大，性能越强，从2000到6000无规律分布。</p>

<p>三位命名栗子：HD 530</p>

<p>530：性能，与4位命名规律基本一致，但不能根据数字大小与4位命名的HD系列GPU直接比较。</p>

<p>由此可见HD 4400便是一款在HD系列中排名第七的民用版GPU。</p>

<h4>b. Iris系列</h4>

<p>Iris系列GPU姓Iris，姓后可伴有后缀；名为3位或4位数字。其中3位命名从Skylake开始沿用。</p>

<p>4位命名栗子：Iris Pro 5200</p>

<p>Iris：锐炬系列；</p>

<p>Pro：姓后缀，表示专业版，性能有所提升；若姓有后缀“P”则为企业版；</p>

<p>5200：性能，基本上数字越大，性能越强，从5100至6300无规律分布；</p>

<p>三位命名栗子：Iris 540</p>

<p>540：性能，与4位命名规律基本一致，但不能根据数字大小与4位命名的Iris系列GPU直接比较。</p>

<p>由此可见Iris P580为锐炬系列企业版的顶级GPU。</p>

<h4>Intel GPU的命名十分混乱把自己都搞混了，所以Intel把自家的GPU分为GT1、GT1.5、GT2、GT3、GT3e、GT4e共六个等级，性能依次提升，每个等级下有多种型号，以下是目前的分类：</h4>

<ul>
<li><p>GT1包含HD Graphics、HD 510；</p></li>
<li><p>GT1.5包含HD 515；</p></li>
<li><p>GT2包含HD 4200、HD 4400、HD 4600、HD P4600、HD 520、HD 530、HD P530；</p></li>
<li><p>GT3包含HD 5000、HD 5100、Iris 540、Iris 550；</p></li>
<li><p>GT3e包含HD 5200、HD 570；</p></li>
<li><p>GT4e包含HD 580、HD P580。</p></li>
</ul>


<h2>二、不同的显卡其他结构不同</h2>

<p>这里仅限独立显卡。A、N、I公司设计出GPU后，通过外包生产得到成品GPU，这些GPU会有三种用途：</p>

<p>AMD和Intel的部分GPU用作CPU的核心显卡。</p>

<p>AMD和NVIDIA的部分GPU用于生产公版显卡。</p>

<p>AMD和NVIDIA的部分GPU卖给显卡授权生产商，用于生产独立显卡；</p>

<p>公版显卡，是A、N公司为了宣传GPU而生产的，其实就是在告诉显卡授权生产商：“使用这款GPU做出来的显卡是这样的！”，一般公版显卡的性能、用料比较基础，只是用作示范。当然，粉丝们可以买来作纪念。</p>

<h2>买哪种卡组计算集群</h2>

<p>理论上说，同价位N卡的双精度计算能力是完爆A卡的。如果你是用于科学计算的话，参考下面这位仁兄的折腾经历:</p>

<p><a href="http://mli.github.io/gpu/2016/01/17/build-gpu-clusters/">http://mli.github.io/gpu/2016/01/17/build-gpu-clusters/</a></p>

<p>最近GTX1080已经开始展现王者性价比风范，如果你不是超土豪的话，可以考虑入手这个替代Titan X</p>

<p>但是，我要说但是，如果你是买来做某数字货币挖矿的话，A卡完爆N卡，具体的bentchmark，我希望将来有人就下面这几种算法，根据各种难度，出个列表:</p>

<ul>
<li><p>Scrypt算法</p></li>
<li><p>MAX算法</p></li>
<li><p>G算法</p></li>
<li><p>x11算法</p></li>
<li><p>HEFTY1算法</p></li>
</ul>


<p>好吧，折腾了一圈发现，某云号称要上A卡的云平台，难道是挖矿的春天来了？</p>

<p>太天真，某国外云立马做出回应，要开放FPGA云平台啦~~~~</p>

<p>嗯，我正在认真考虑重新投身微电子行业，确切的是打好本领，投身云挖矿行业&hellip;.</p>

<p>持续关注能耗比最小的hash算法手段~~~~</p>

<p>最后，附一个硬件天梯排行榜测评网站:</p>

<p><a href="http://www.passmark.com/">http://www.passmark.com/</a></p>
]]></content>
  </entry>
  
</feed>
