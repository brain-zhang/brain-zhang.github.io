---
layout: post
title: "吴恩达机器学习笔记-5"
date: 2019-09-22 18:01:34 +0800
comments: true
categories: develop ai
---

降维，异常检测，推荐系统，大规模机器学习
{:.info}

<!-- more -->

## 数据压缩

#### 降维问题

假设我们未知两个的特征： 𝑥1 :长度, 用厘米表示； 𝑥2：是用英寸表示同一物体的长度。

这给了我们高度冗余表示，也许不是两个分开的特征  𝑥1  和  𝑥2 ，这两个基本的长度度量，我们可以减少数据到一维。

假使我们有有关于许多不同国家的数据，每一个特征向量都有 50 个特征（如，GDP，人均GDP，平均寿命等）。如果要将这个 50 维的数据可视化是不可能的。使用降维的方法将其降至 2 维，我们便可以将其可视化了。

#### PCA 降维算法

在 PCA 中，我们要做的是找到一个方向向量（Vector direction），
当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。
方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。

主成分分析与线性回归是两种不同的算法。
主成分分析最小化的是投射误差（Projected Error），而线性回归尝试的是最小化预测误差。
线性回归的目的是预测结果，而主成分分析不作任何预测。

过程：

1. 均值归一化 (mean normalization)。计算出所有特征的均值，然后令 𝑥𝑗=𝑥𝑗−𝜇𝑗 。如果特征是在不同的数量级上，我们还需要将其除以标准差  𝜎2 。
2. 计算协方差矩阵（covariance matrix）Σ：
3. 是计算协方差矩阵 Σ 的特征向量（eigenvectors）: 可以利用奇异值分解（singular value decomposition 理解 SVD）来求解，[U, S, V]= svd(Σ)。

```
import numpy as np

def covariance_matrix(X):
    """
    Args:
        X (ndarray) (m, n)
    Return:
        cov_mat (ndarray) (n, n):
            covariance matrix of X
    """
    m = X.shape[0]

    return (X.T @ X) / m


def normalize(X):
    """
        for each column, X-mean / std
    """
    X_copy = X.copy()
    m, n = X_copy.shape

    for col in range(n):
        X_copy[:, col] = (X_copy[:, col] - X_copy[:, col].mean()) / X_copy[:, col].std()

    return X_copy

def pca(x, keep_dims=None):
    if not keep_dims:
        keep_dims = x.shape[1] - 1
    # 进行归一化
    normalize_x = normalize(x)
    # 求出协方差矩阵
    cov_x = covariance_matrix(x)
    # 奇异值分解
    U, S, V = np.linalg.svd(cov_x)  # U: principle components (n, n)
    # 选取前 keep_dims 维特征
    reduction = U[:, :keep_dims]
    # 得到降维的结果
    return np.matmul(x, reduction)

x = np.random.uniform(size=(10, 10))
pca(x).shape
```

## 异常检测

用途:

1. 识别欺骗。特征：用户多久登录一次，访问过的页面，在论坛发布的帖子数量，甚至是打字速度等。构建模型来识别那些不符合该模式的用户,

2. 数据中心。特征：内存使用情况，被访问的磁盘数量，CPU 的负载，网络的通信量等。构建模型来判断某些计算机是不是有可能出错了。

#### 高斯分布

如果变量 𝑥 符合高斯分布 𝑥 𝑁(𝜇,𝜎2) , 则其概率密度函数为：

$$
p(x,\mu, \sigma^2) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-\mu)^2}{2\sigma^2})
$$

#### 高斯分布的异常检测算法

对于每一个样本值，计算特征，并以此估算高斯分布中的𝜇 和𝜎2的估计值;

以此来绘制一个估计函数，在这个估计函数之外的值即异常值；

模型计算  𝑝(𝑥) :

$$
p(x)=\prod_{j=1}^n p(x_j;\mu_j,\sigma^2_j)=\prod_{j=1}^n \frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma^2_j})
$$

$$
p(x)=\prod_{j=1}^n p(x_j;\mu_j,\sigma^2_j)=\prod_{j=1}^n \frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma^2_j})
$$

当  𝑝(𝑥)<𝜀 时，为异常。

#### 开发和评价一个异常检测系统

1. 根据测试集数据，我们估计特征的平均值和方差并构建 𝑝(𝑥) 函数
2. 对交叉检验集，我们尝试使用不同的 𝜀 值作为阀值，并预测数据是否异常，根据F1值或者查准率与查全率的比例来选择 𝜀
3. 选出 𝜀 后，针对测试集进行预测，计算异常检验系统的 F1 值，或者查准率与查全率之比。


#### 特征选择

我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小），例如，在检测数据中心的计算机状况的例子中，我们可以用 CPU 负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。

#### 多元高斯分布

TODO...


## 推荐系统

#### 协同过滤

TODO....


## 大规模机器学习

#### 大型数据集的学习

我们应该怎样应对一个有 100 万条记录的训练集？

以线性回归模型为例，每一次梯度下降迭代，我们都需要计算训练集的误差的平方和，如果我们的学习算法需要有 20 次迭代，这便已经是非常大的计算代价。

首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用 1000 个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。

#### 随机梯度下降

随机梯度下降算法在每一次计算之后便更新参数 θ，而不需要首先将所有的训练集求和，在梯度下降算法还没有完成一次迭代时，随机梯度下降算法便已经走出了很远。但是这样的算法存在的问题是，不是每一步都是朝着”正确”的方向迈出的。因此算法虽然会逐渐走向全局最小值的位置，但是可能无法站到那个最小值的那一点，而是在最小值点附近徘徊。

#### 小批量梯度下降
小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数 b 次训练实例，便更新一次参数 θ。

通常我们会令 b 在 2-100 之间。这样做的好处在于，我们可以用向量化的方式来循环 b 个训练实例，如果我们用的线性代数函数库比较好，能够支持平行处理，那么算法的总体表现将不受影响（与随机梯度下降相同）。


#### Map Reduce 和 数据并行

Map Reduce和数据并行对于大规模机器学习问题而言是非常重要的概念。

之前提到，如果我们用批量梯度下降算法来求解大规模数据集的最优解，我们需要对整个训练集进行循环，计算偏导数和代价，再求和，计算代价非常大。如果我们能够将我们的数据集分配给多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计算的结果汇总然后再求和。这样的方法叫做Map Reduce。
